
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
	'use strict';

	/** @returns {void} */
	function noop() {}

	const identity = (x) => x;

	/**
	 * @template T
	 * @template S
	 * @param {T} tar
	 * @param {S} src
	 * @returns {T & S}
	 */
	function assign(tar, src) {
		// @ts-ignore
		for (const k in src) tar[k] = src[k];
		return /** @type {T & S} */ (tar);
	}

	/** @returns {void} */
	function add_location(element, file, line, column, char) {
		element.__svelte_meta = {
			loc: { file, line, column, char }
		};
	}

	function run(fn) {
		return fn();
	}

	function blank_object() {
		return Object.create(null);
	}

	/**
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function run_all(fns) {
		fns.forEach(run);
	}

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	/** @returns {boolean} */
	function safe_not_equal(a, b) {
		return a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';
	}

	let src_url_equal_anchor;

	/**
	 * @param {string} element_src
	 * @param {string} url
	 * @returns {boolean}
	 */
	function src_url_equal(element_src, url) {
		if (element_src === url) return true;
		if (!src_url_equal_anchor) {
			src_url_equal_anchor = document.createElement('a');
		}
		// This is actually faster than doing URL(..).href
		src_url_equal_anchor.href = url;
		return element_src === src_url_equal_anchor.href;
	}

	/** @returns {boolean} */
	function is_empty(obj) {
		return Object.keys(obj).length === 0;
	}

	function create_slot(definition, ctx, $$scope, fn) {
		if (definition) {
			const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
			return definition[0](slot_ctx);
		}
	}

	function get_slot_context(definition, ctx, $$scope, fn) {
		return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
	}

	function get_slot_changes(definition, $$scope, dirty, fn) {
		if (definition[2] && fn) {
			const lets = definition[2](fn(dirty));
			if ($$scope.dirty === undefined) {
				return lets;
			}
			if (typeof lets === 'object') {
				const merged = [];
				const len = Math.max($$scope.dirty.length, lets.length);
				for (let i = 0; i < len; i += 1) {
					merged[i] = $$scope.dirty[i] | lets[i];
				}
				return merged;
			}
			return $$scope.dirty | lets;
		}
		return $$scope.dirty;
	}

	/** @returns {void} */
	function update_slot_base(
		slot,
		slot_definition,
		ctx,
		$$scope,
		slot_changes,
		get_slot_context_fn
	) {
		if (slot_changes) {
			const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
			slot.p(slot_context, slot_changes);
		}
	}

	/** @returns {any[] | -1} */
	function get_all_dirty_from_scope($$scope) {
		if ($$scope.ctx.length > 32) {
			const dirty = [];
			const length = $$scope.ctx.length / 32;
			for (let i = 0; i < length; i++) {
				dirty[i] = -1;
			}
			return dirty;
		}
		return -1;
	}

	/** @returns {{}} */
	function exclude_internal_props(props) {
		const result = {};
		for (const k in props) if (k[0] !== '$') result[k] = props[k];
		return result;
	}

	/** @returns {{}} */
	function compute_rest_props(props, keys) {
		const rest = {};
		keys = new Set(keys);
		for (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];
		return rest;
	}

	function action_destroyer(action_result) {
		return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
	}

	const is_client = typeof window !== 'undefined';

	/** @type {() => number} */
	let now = is_client ? () => window.performance.now() : () => Date.now();

	let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;

	const tasks = new Set();

	/**
	 * @param {number} now
	 * @returns {void}
	 */
	function run_tasks(now) {
		tasks.forEach((task) => {
			if (!task.c(now)) {
				tasks.delete(task);
				task.f();
			}
		});
		if (tasks.size !== 0) raf(run_tasks);
	}

	/**
	 * Creates a new task that runs on each raf frame
	 * until it returns a falsy value or is aborted
	 * @param {import('./private.js').TaskCallback} callback
	 * @returns {import('./private.js').Task}
	 */
	function loop(callback) {
		/** @type {import('./private.js').TaskEntry} */
		let task;
		if (tasks.size === 0) raf(run_tasks);
		return {
			promise: new Promise((fulfill) => {
				tasks.add((task = { c: callback, f: fulfill }));
			}),
			abort() {
				tasks.delete(task);
			}
		};
	}

	/** @type {typeof globalThis} */
	const globals =
		typeof window !== 'undefined'
			? window
			: typeof globalThis !== 'undefined'
			? globalThis
			: // @ts-ignore Node typings have this
			  global;

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */
	function append$1(target, node) {
		target.appendChild(node);
	}

	/**
	 * @param {Node} node
	 * @returns {ShadowRoot | Document}
	 */
	function get_root_for_style(node) {
		if (!node) return document;
		const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
		if (root && /** @type {ShadowRoot} */ (root).host) {
			return /** @type {ShadowRoot} */ (root);
		}
		return node.ownerDocument;
	}

	/**
	 * @param {Node} node
	 * @returns {CSSStyleSheet}
	 */
	function append_empty_stylesheet(node) {
		const style_element = element$1('style');
		// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,
		// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.
		// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.
		// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.
		// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.
		style_element.textContent = '/* empty */';
		append_stylesheet(get_root_for_style(node), style_element);
		return style_element.sheet;
	}

	/**
	 * @param {ShadowRoot | Document} node
	 * @param {HTMLStyleElement} style
	 * @returns {CSSStyleSheet}
	 */
	function append_stylesheet(node, style) {
		append$1(/** @type {Document} */ (node).head || node, style);
		return style.sheet;
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */
	function insert(target, node, anchor) {
		target.insertBefore(node, anchor || null);
	}

	/**
	 * @param {Node} node
	 * @returns {void}
	 */
	function detach$1(node) {
		if (node.parentNode) {
			node.parentNode.removeChild(node);
		}
	}

	/**
	 * @template {keyof HTMLElementTagNameMap} K
	 * @param {K} name
	 * @returns {HTMLElementTagNameMap[K]}
	 */
	function element$1(name) {
		return document.createElement(name);
	}

	/**
	 * @param {string} data
	 * @returns {Text}
	 */
	function text(data) {
		return document.createTextNode(data);
	}

	/**
	 * @returns {Text} */
	function space() {
		return text(' ');
	}

	/**
	 * @returns {Text} */
	function empty() {
		return text('');
	}

	/**
	 * @param {EventTarget} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @returns {() => void}
	 */
	function listen(node, event, handler, options) {
		node.addEventListener(event, handler, options);
		return () => node.removeEventListener(event, handler, options);
	}

	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */
	function attr(node, attribute, value) {
		if (value == null) node.removeAttribute(attribute);
		else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
	}
	/**
	 * List of attributes that should always be set through the attr method,
	 * because updating them through the property setter doesn't work reliably.
	 * In the example of `width`/`height`, the problem is that the setter only
	 * accepts numeric values, but the attribute can also be set to a string like `50%`.
	 * If this list becomes too big, rethink this approach.
	 */
	const always_set_through_set_attribute = ['width', 'height'];

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {{ [x: string]: string }} attributes
	 * @returns {void}
	 */
	function set_attributes(node, attributes) {
		// @ts-ignore
		const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
		for (const key in attributes) {
			if (attributes[key] == null) {
				node.removeAttribute(key);
			} else if (key === 'style') {
				node.style.cssText = attributes[key];
			} else if (key === '__value') {
				/** @type {any} */ (node).value = node[key] = attributes[key];
			} else if (
				descriptors[key] &&
				descriptors[key].set &&
				always_set_through_set_attribute.indexOf(key) === -1
			) {
				node[key] = attributes[key];
			} else {
				attr(node, key, attributes[key]);
			}
		}
	}

	/**
	 * @param {Record<string, unknown>} data_map
	 * @returns {void}
	 */
	function set_custom_element_data_map(node, data_map) {
		Object.keys(data_map).forEach((key) => {
			set_custom_element_data(node, key, data_map[key]);
		});
	}

	/**
	 * @returns {void} */
	function set_custom_element_data(node, prop, value) {
		if (prop in node) {
			node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
		} else {
			attr(node, prop, value);
		}
	}

	/**
	 * @param {string} tag
	 */
	function set_dynamic_element_data(tag) {
		return /-/.test(tag) ? set_custom_element_data_map : set_attributes;
	}

	/**
	 * @param {Element} element
	 * @returns {ChildNode[]}
	 */
	function children(element) {
		return Array.from(element.childNodes);
	}

	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]
	 * @returns {CustomEvent<T>}
	 */
	function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
		return new CustomEvent(type, { detail, bubbles, cancelable });
	}

	/**
	 * @typedef {Node & {
	 * 	claim_order?: number;
	 * 	hydrate_init?: true;
	 * 	actual_end_child?: NodeEx;
	 * 	childNodes: NodeListOf<NodeEx>;
	 * }} NodeEx
	 */

	/** @typedef {ChildNode & NodeEx} ChildNodeEx */

	/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */

	/**
	 * @typedef {ChildNodeEx[] & {
	 * 	claim_info?: {
	 * 		last_index: number;
	 * 		total_claimed: number;
	 * 	};
	 * }} ChildNodeArray
	 */

	// we need to store the information for multiple documents because a Svelte application could also contain iframes
	// https://github.com/sveltejs/svelte/issues/3624
	/** @type {Map<Document | ShadowRoot, import('./private.d.ts').StyleInformation>} */
	const managed_styles = new Map();

	let active = 0;

	// https://github.com/darkskyapp/string-hash/blob/master/index.js
	/**
	 * @param {string} str
	 * @returns {number}
	 */
	function hash(str) {
		let hash = 5381;
		let i = str.length;
		while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
		return hash >>> 0;
	}

	/**
	 * @param {Document | ShadowRoot} doc
	 * @param {Element & ElementCSSInlineStyle} node
	 * @returns {{ stylesheet: any; rules: {}; }}
	 */
	function create_style_information(doc, node) {
		const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
		managed_styles.set(doc, info);
		return info;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {number} a
	 * @param {number} b
	 * @param {number} duration
	 * @param {number} delay
	 * @param {(t: number) => number} ease
	 * @param {(t: number, u: number) => string} fn
	 * @param {number} uid
	 * @returns {string}
	 */
	function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
		const step = 16.666 / duration;
		let keyframes = '{\n';
		for (let p = 0; p <= 1; p += step) {
			const t = a + (b - a) * ease(p);
			keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
		}
		const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
		const name = `__svelte_${hash(rule)}_${uid}`;
		const doc = get_root_for_style(node);
		const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
		if (!rules[name]) {
			rules[name] = true;
			stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
		}
		const animation = node.style.animation || '';
		node.style.animation = `${
		animation ? `${animation}, ` : ''
	}${name} ${duration}ms linear ${delay}ms 1 both`;
		active += 1;
		return name;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {string} [name]
	 * @returns {void}
	 */
	function delete_rule(node, name) {
		const previous = (node.style.animation || '').split(', ');
		const next = previous.filter(
			name
				? (anim) => anim.indexOf(name) < 0 // remove specific animation
				: (anim) => anim.indexOf('__svelte') === -1 // remove all Svelte animations
		);
		const deleted = previous.length - next.length;
		if (deleted) {
			node.style.animation = next.join(', ');
			active -= deleted;
			if (!active) clear_rules();
		}
	}

	/** @returns {void} */
	function clear_rules() {
		raf(() => {
			if (active) return;
			managed_styles.forEach((info) => {
				const { ownerNode } = info.stylesheet;
				// there is no ownerNode if it runs on jsdom.
				if (ownerNode) detach$1(ownerNode);
			});
			managed_styles.clear();
		});
	}

	let current_component;

	/** @returns {void} */
	function set_current_component(component) {
		current_component = component;
	}

	function get_current_component() {
		if (!current_component) throw new Error('Function called outside component initialization');
		return current_component;
	}

	/**
	 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
	 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
	 * it can be called from an external module).
	 *
	 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
	 *
	 * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
	 *
	 * https://svelte.dev/docs/svelte#onmount
	 * @template T
	 * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		get_current_component().$$.on_mount.push(fn);
	}

	/**
	 * Schedules a callback to run immediately after the component has been updated.
	 *
	 * The first time the callback runs will be after the initial `onMount`
	 *
	 * https://svelte.dev/docs/svelte#afterupdate
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function afterUpdate(fn) {
		get_current_component().$$.after_update.push(fn);
	}

	/**
	 * Associates an arbitrary `context` object with the current component and the specified `key`
	 * and returns that object. The context is then available to children of the component
	 * (including slotted content) with `getContext`.
	 *
	 * Like lifecycle functions, this must be called during component initialisation.
	 *
	 * https://svelte.dev/docs/svelte#setcontext
	 * @template T
	 * @param {any} key
	 * @param {T} context
	 * @returns {T}
	 */
	function setContext(key, context) {
		get_current_component().$$.context.set(key, context);
		return context;
	}

	// TODO figure out if we still want to support
	// shorthand events, or if we want to implement
	// a real bubbling mechanism
	/**
	 * @param component
	 * @param event
	 * @returns {void}
	 */
	function bubble(component, event) {
		const callbacks = component.$$.callbacks[event.type];
		if (callbacks) {
			// @ts-ignore
			callbacks.slice().forEach((fn) => fn.call(this, event));
		}
	}

	const dirty_components = [];
	const binding_callbacks = [];

	let render_callbacks = [];

	const flush_callbacks = [];

	const resolved_promise = /* @__PURE__ */ Promise.resolve();

	let update_scheduled = false;

	/** @returns {void} */
	function schedule_update() {
		if (!update_scheduled) {
			update_scheduled = true;
			resolved_promise.then(flush);
		}
	}

	/** @returns {void} */
	function add_render_callback(fn) {
		render_callbacks.push(fn);
	}

	// flush() calls callbacks in this order:
	// 1. All beforeUpdate callbacks, in order: parents before children
	// 2. All bind:this callbacks, in reverse order: children before parents.
	// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
	//    for afterUpdates called during the initial onMount, which are called in
	//    reverse order: children before parents.
	// Since callbacks might update component values, which could trigger another
	// call to flush(), the following steps guard against this:
	// 1. During beforeUpdate, any updated components will be added to the
	//    dirty_components array and will cause a reentrant call to flush(). Because
	//    the flush index is kept outside the function, the reentrant call will pick
	//    up where the earlier call left off and go through all dirty components. The
	//    current_component value is saved and restored so that the reentrant call will
	//    not interfere with the "parent" flush() call.
	// 2. bind:this callbacks cannot trigger new flush() calls.
	// 3. During afterUpdate, any updated components will NOT have their afterUpdate
	//    callback called a second time; the seen_callbacks set, outside the flush()
	//    function, guarantees this behavior.
	const seen_callbacks = new Set();

	let flushidx = 0; // Do *not* move this inside the flush() function

	/** @returns {void} */
	function flush() {
		// Do not reenter flush while dirty components are updated, as this can
		// result in an infinite loop. Instead, let the inner flush handle it.
		// Reentrancy is ok afterwards for bindings etc.
		if (flushidx !== 0) {
			return;
		}
		const saved_component = current_component;
		do {
			// first, call beforeUpdate functions
			// and update components
			try {
				while (flushidx < dirty_components.length) {
					const component = dirty_components[flushidx];
					flushidx++;
					set_current_component(component);
					update(component.$$);
				}
			} catch (e) {
				// reset dirty state to not end up in a deadlocked state and then rethrow
				dirty_components.length = 0;
				flushidx = 0;
				throw e;
			}
			set_current_component(null);
			dirty_components.length = 0;
			flushidx = 0;
			while (binding_callbacks.length) binding_callbacks.pop()();
			// then, once components are updated, call
			// afterUpdate functions. This may cause
			// subsequent updates...
			for (let i = 0; i < render_callbacks.length; i += 1) {
				const callback = render_callbacks[i];
				if (!seen_callbacks.has(callback)) {
					// ...so guard against infinite loops
					seen_callbacks.add(callback);
					callback();
				}
			}
			render_callbacks.length = 0;
		} while (dirty_components.length);
		while (flush_callbacks.length) {
			flush_callbacks.pop()();
		}
		update_scheduled = false;
		seen_callbacks.clear();
		set_current_component(saved_component);
	}

	/** @returns {void} */
	function update($$) {
		if ($$.fragment !== null) {
			$$.update();
			run_all($$.before_update);
			const dirty = $$.dirty;
			$$.dirty = [-1];
			$$.fragment && $$.fragment.p($$.ctx, dirty);
			$$.after_update.forEach(add_render_callback);
		}
	}

	/**
	 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function flush_render_callbacks(fns) {
		const filtered = [];
		const targets = [];
		render_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));
		targets.forEach((c) => c());
		render_callbacks = filtered;
	}

	/**
	 * @type {Promise<void> | null}
	 */
	let promise;

	/**
	 * @returns {Promise<void>}
	 */
	function wait() {
		if (!promise) {
			promise = Promise.resolve();
			promise.then(() => {
				promise = null;
			});
		}
		return promise;
	}

	/**
	 * @param {Element} node
	 * @param {INTRO | OUTRO | boolean} direction
	 * @param {'start' | 'end'} kind
	 * @returns {void}
	 */
	function dispatch(node, direction, kind) {
		node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
	}

	const outroing = new Set();

	/**
	 * @type {Outro}
	 */
	let outros;

	/**
	 * @returns {void} */
	function group_outros() {
		outros = {
			r: 0,
			c: [],
			p: outros // parent group
		};
	}

	/**
	 * @returns {void} */
	function check_outros() {
		if (!outros.r) {
			run_all(outros.c);
		}
		outros = outros.p;
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} [local]
	 * @returns {void}
	 */
	function transition_in(block, local) {
		if (block && block.i) {
			outroing.delete(block);
			block.i(local);
		}
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} local
	 * @param {0 | 1} [detach]
	 * @param {() => void} [callback]
	 * @returns {void}
	 */
	function transition_out(block, local, detach, callback) {
		if (block && block.o) {
			if (outroing.has(block)) return;
			outroing.add(block);
			outros.c.push(() => {
				outroing.delete(block);
				if (callback) {
					if (detach) block.d(1);
					callback();
				}
			});
			block.o(local);
		} else if (callback) {
			callback();
		}
	}

	/**
	 * @type {import('../transition/public.js').TransitionConfig}
	 */
	const null_transition = { duration: 0 };

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {TransitionFn} fn
	 * @param {any} params
	 * @param {boolean} intro
	 * @returns {{ run(b: 0 | 1): void; end(): void; }}
	 */
	function create_bidirectional_transition(node, fn, params, intro) {
		/**
		 * @type {TransitionOptions} */
		const options = { direction: 'both' };
		let config = fn(node, params, options);
		let t = intro ? 0 : 1;

		/**
		 * @type {Program | null} */
		let running_program = null;

		/**
		 * @type {PendingProgram | null} */
		let pending_program = null;
		let animation_name = null;

		/** @type {boolean} */
		let original_inert_value;

		/**
		 * @returns {void} */
		function clear_animation() {
			if (animation_name) delete_rule(node, animation_name);
		}

		/**
		 * @param {PendingProgram} program
		 * @param {number} duration
		 * @returns {Program}
		 */
		function init(program, duration) {
			const d = /** @type {Program['d']} */ (program.b - t);
			duration *= Math.abs(d);
			return {
				a: t,
				b: program.b,
				d,
				duration,
				start: program.start,
				end: program.start + duration,
				group: program.group
			};
		}

		/**
		 * @param {INTRO | OUTRO} b
		 * @returns {void}
		 */
		function go(b) {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick = noop,
				css
			} = config || null_transition;

			/**
			 * @type {PendingProgram} */
			const program = {
				start: now() + delay,
				b
			};

			if (!b) {
				// @ts-ignore todo: improve typings
				program.group = outros;
				outros.r += 1;
			}

			if ('inert' in node) {
				if (b) {
					if (original_inert_value !== undefined) {
						// aborted/reversed outro — restore previous inert value
						node.inert = original_inert_value;
					}
				} else {
					original_inert_value = /** @type {HTMLElement} */ (node).inert;
					node.inert = true;
				}
			}

			if (running_program || pending_program) {
				pending_program = program;
			} else {
				// if this is an intro, and there's a delay, we need to do
				// an initial tick and/or apply CSS animation immediately
				if (css) {
					clear_animation();
					animation_name = create_rule(node, t, b, duration, delay, easing, css);
				}
				if (b) tick(0, 1);
				running_program = init(program, duration);
				add_render_callback(() => dispatch(node, b, 'start'));
				loop((now) => {
					if (pending_program && now > pending_program.start) {
						running_program = init(pending_program, duration);
						pending_program = null;
						dispatch(node, running_program.b, 'start');
						if (css) {
							clear_animation();
							animation_name = create_rule(
								node,
								t,
								running_program.b,
								running_program.duration,
								0,
								easing,
								config.css
							);
						}
					}
					if (running_program) {
						if (now >= running_program.end) {
							tick((t = running_program.b), 1 - t);
							dispatch(node, running_program.b, 'end');
							if (!pending_program) {
								// we're done
								if (running_program.b) {
									// intro — we can tidy up immediately
									clear_animation();
								} else {
									// outro — needs to be coordinated
									if (!--running_program.group.r) run_all(running_program.group.c);
								}
							}
							running_program = null;
						} else if (now >= running_program.start) {
							const p = now - running_program.start;
							t = running_program.a + running_program.d * easing(p / running_program.duration);
							tick(t, 1 - t);
						}
					}
					return !!(running_program || pending_program);
				});
			}
		}
		return {
			run(b) {
				if (is_function(config)) {
					wait().then(() => {
						const opts = { direction: b ? 'in' : 'out' };
						// @ts-ignore
						config = config(opts);
						go(b);
					});
				} else {
					go(b);
				}
			},
			end() {
				clear_animation();
				running_program = pending_program = null;
			}
		};
	}

	/** @typedef {1} INTRO */
	/** @typedef {0} OUTRO */
	/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */
	/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */

	/**
	 * @typedef {Object} Outro
	 * @property {number} r
	 * @property {Function[]} c
	 * @property {Object} p
	 */

	/**
	 * @typedef {Object} PendingProgram
	 * @property {number} start
	 * @property {INTRO|OUTRO} b
	 * @property {Outro} [group]
	 */

	/**
	 * @typedef {Object} Program
	 * @property {number} a
	 * @property {INTRO|OUTRO} b
	 * @property {1|-1} d
	 * @property {number} duration
	 * @property {number} start
	 * @property {number} end
	 * @property {Outro} [group]
	 */

	/** @returns {{}} */
	function get_spread_update(levels, updates) {
		const update = {};
		const to_null_out = {};
		const accounted_for = { $$scope: 1 };
		let i = levels.length;
		while (i--) {
			const o = levels[i];
			const n = updates[i];
			if (n) {
				for (const key in o) {
					if (!(key in n)) to_null_out[key] = 1;
				}
				for (const key in n) {
					if (!accounted_for[key]) {
						update[key] = n[key];
						accounted_for[key] = 1;
					}
				}
				levels[i] = n;
			} else {
				for (const key in o) {
					accounted_for[key] = 1;
				}
			}
		}
		for (const key in to_null_out) {
			if (!(key in update)) update[key] = undefined;
		}
		return update;
	}

	function get_spread_object(spread_props) {
		return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
	}

	/** regex of all html void element names */
	const void_element_names =
		/^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;

	/**
	 * @param {string} name
	 * @returns {boolean}
	 */
	function is_void(name) {
		return void_element_names.test(name) || name.toLowerCase() === '!doctype';
	}

	/** @returns {void} */
	function create_component(block) {
		block && block.c();
	}

	/** @returns {void} */
	function mount_component(component, target, anchor) {
		const { fragment, after_update } = component.$$;
		fragment && fragment.m(target, anchor);
		// onMount happens before the initial afterUpdate
		add_render_callback(() => {
			const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
			// if the component was destroyed immediately
			// it will update the `$$.on_destroy` reference to `null`.
			// the destructured on_destroy may still reference to the old array
			if (component.$$.on_destroy) {
				component.$$.on_destroy.push(...new_on_destroy);
			} else {
				// Edge case - component was destroyed immediately,
				// most likely as a result of a binding initialising
				run_all(new_on_destroy);
			}
			component.$$.on_mount = [];
		});
		after_update.forEach(add_render_callback);
	}

	/** @returns {void} */
	function destroy_component(component, detaching) {
		const $$ = component.$$;
		if ($$.fragment !== null) {
			flush_render_callbacks($$.after_update);
			run_all($$.on_destroy);
			$$.fragment && $$.fragment.d(detaching);
			// TODO null out other refs, including component.$$ (but need to
			// preserve final state?)
			$$.on_destroy = $$.fragment = null;
			$$.ctx = [];
		}
	}

	/** @returns {void} */
	function make_dirty(component, i) {
		if (component.$$.dirty[0] === -1) {
			dirty_components.push(component);
			schedule_update();
			component.$$.dirty.fill(0);
		}
		component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
	}

	// TODO: Document the other params
	/**
	 * @param {SvelteComponent} component
	 * @param {import('./public.js').ComponentConstructorOptions} options
	 *
	 * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.
	 * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.
	 * This will be the `add_css` function from the compiled component.
	 *
	 * @returns {void}
	 */
	function init(
		component,
		options,
		instance,
		create_fragment,
		not_equal,
		props,
		append_styles = null,
		dirty = [-1]
	) {
		const parent_component = current_component;
		set_current_component(component);
		/** @type {import('./private.js').T$$} */
		const $$ = (component.$$ = {
			fragment: null,
			ctx: [],
			// state
			props,
			update: noop,
			not_equal,
			bound: blank_object(),
			// lifecycle
			on_mount: [],
			on_destroy: [],
			on_disconnect: [],
			before_update: [],
			after_update: [],
			context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
			// everything else
			callbacks: blank_object(),
			dirty,
			skip_bound: false,
			root: options.target || parent_component.$$.root
		});
		append_styles && append_styles($$.root);
		let ready = false;
		$$.ctx = instance
			? instance(component, options.props || {}, (i, ret, ...rest) => {
					const value = rest.length ? rest[0] : ret;
					if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
						if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
						if (ready) make_dirty(component, i);
					}
					return ret;
			  })
			: [];
		$$.update();
		ready = true;
		run_all($$.before_update);
		// `false` as a special case of no DOM component
		$$.fragment = create_fragment ? create_fragment($$.ctx) : false;
		if (options.target) {
			if (options.hydrate) {
				// TODO: what is the correct type here?
				// @ts-expect-error
				const nodes = children(options.target);
				$$.fragment && $$.fragment.l(nodes);
				nodes.forEach(detach$1);
			} else {
				// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
				$$.fragment && $$.fragment.c();
			}
			if (options.intro) transition_in(component.$$.fragment);
			mount_component(component, options.target, options.anchor);
			flush();
		}
		set_current_component(parent_component);
	}

	/**
	 * Base class for Svelte components. Used when dev=false.
	 *
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 */
	class SvelteComponent {
		/**
		 * ### PRIVATE API
		 *
		 * Do not use, may change at any time
		 *
		 * @type {any}
		 */
		$$ = undefined;
		/**
		 * ### PRIVATE API
		 *
		 * Do not use, may change at any time
		 *
		 * @type {any}
		 */
		$$set = undefined;

		/** @returns {void} */
		$destroy() {
			destroy_component(this, 1);
			this.$destroy = noop;
		}

		/**
		 * @template {Extract<keyof Events, string>} K
		 * @param {K} type
		 * @param {((e: Events[K]) => void) | null | undefined} callback
		 * @returns {() => void}
		 */
		$on(type, callback) {
			if (!is_function(callback)) {
				return noop;
			}
			const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
			callbacks.push(callback);
			return () => {
				const index = callbacks.indexOf(callback);
				if (index !== -1) callbacks.splice(index, 1);
			};
		}

		/**
		 * @param {Partial<Props>} props
		 * @returns {void}
		 */
		$set(props) {
			if (this.$$set && !is_empty(props)) {
				this.$$.skip_bound = true;
				this.$$set(props);
				this.$$.skip_bound = false;
			}
		}
	}

	/**
	 * @typedef {Object} CustomElementPropDefinition
	 * @property {string} [attribute]
	 * @property {boolean} [reflect]
	 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
	 */

	// generated during release, do not modify

	/**
	 * The current version, as set in package.json.
	 *
	 * https://svelte.dev/docs/svelte-compiler#svelte-version
	 * @type {string}
	 */
	const VERSION = '4.2.1';
	const PUBLIC_VERSION = '4';

	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @returns {void}
	 */
	function dispatch_dev(type, detail) {
		document.dispatchEvent(custom_event(type, { version: VERSION, ...detail }, { bubbles: true }));
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */
	function append_dev(target, node) {
		dispatch_dev('SvelteDOMInsert', { target, node });
		append$1(target, node);
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */
	function insert_dev(target, node, anchor) {
		dispatch_dev('SvelteDOMInsert', { target, node, anchor });
		insert(target, node, anchor);
	}

	/**
	 * @param {Node} node
	 * @returns {void}
	 */
	function detach_dev(node) {
		dispatch_dev('SvelteDOMRemove', { node });
		detach$1(node);
	}

	/**
	 * @param {Node} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @param {boolean} [has_prevent_default]
	 * @param {boolean} [has_stop_propagation]
	 * @param {boolean} [has_stop_immediate_propagation]
	 * @returns {() => void}
	 */
	function listen_dev(
		node,
		event,
		handler,
		options,
		has_prevent_default,
		has_stop_propagation,
		has_stop_immediate_propagation
	) {
		const modifiers =
			options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
		if (has_prevent_default) modifiers.push('preventDefault');
		if (has_stop_propagation) modifiers.push('stopPropagation');
		if (has_stop_immediate_propagation) modifiers.push('stopImmediatePropagation');
		dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
		const dispose = listen(node, event, handler, options);
		return () => {
			dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
			dispose();
		};
	}

	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */
	function attr_dev(node, attribute, value) {
		attr(node, attribute, value);
		if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
		else dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
	}

	/**
	 * @param {Text} text
	 * @param {unknown} data
	 * @returns {void}
	 */
	function set_data_dev(text, data) {
		data = '' + data;
		if (text.data === data) return;
		dispatch_dev('SvelteDOMSetData', { node: text, data });
		text.data = /** @type {string} */ (data);
	}

	/**
	 * @returns {void} */
	function validate_slots(name, slot, keys) {
		for (const slot_key of Object.keys(slot)) {
			if (!~keys.indexOf(slot_key)) {
				console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
			}
		}
	}

	/**
	 * @param {unknown} tag
	 * @returns {void}
	 */
	function validate_dynamic_element(tag) {
		const is_string = typeof tag === 'string';
		if (tag && !is_string) {
			throw new Error('<svelte:element> expects "this" attribute to be a string.');
		}
	}

	/**
	 * @param {undefined | string} tag
	 * @returns {void}
	 */
	function validate_void_dynamic_element(tag) {
		if (tag && is_void(tag)) {
			console.warn(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
		}
	}

	/**
	 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
	 *
	 * Can be used to create strongly typed Svelte components.
	 *
	 * #### Example:
	 *
	 * You have component library on npm called `component-library`, from which
	 * you export a component called `MyComponent`. For Svelte+TypeScript users,
	 * you want to provide typings. Therefore you create a `index.d.ts`:
	 * ```ts
	 * import { SvelteComponent } from "svelte";
	 * export class MyComponent extends SvelteComponent<{foo: string}> {}
	 * ```
	 * Typing this makes it possible for IDEs like VS Code with the Svelte extension
	 * to provide intellisense and to use the component like this in a Svelte file
	 * with TypeScript:
	 * ```svelte
	 * <script lang="ts">
	 * 	import { MyComponent } from "component-library";
	 * </script>
	 * <MyComponent foo={'bar'} />
	 * ```
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 * @template {Record<string, any>} [Slots=any]
	 * @extends {SvelteComponent<Props, Events>}
	 */
	class SvelteComponentDev extends SvelteComponent {
		/**
		 * For type checking capabilities only.
		 * Does not exist at runtime.
		 * ### DO NOT USE!
		 *
		 * @type {Props}
		 */
		$$prop_def;
		/**
		 * For type checking capabilities only.
		 * Does not exist at runtime.
		 * ### DO NOT USE!
		 *
		 * @type {Events}
		 */
		$$events_def;
		/**
		 * For type checking capabilities only.
		 * Does not exist at runtime.
		 * ### DO NOT USE!
		 *
		 * @type {Slots}
		 */
		$$slot_def;

		/** @param {import('./public.js').ComponentConstructorOptions<Props>} options */
		constructor(options) {
			if (!options || (!options.target && !options.$$inline)) {
				throw new Error("'target' is a required option");
			}
			super();
		}

		/** @returns {void} */
		$destroy() {
			super.$destroy();
			this.$destroy = () => {
				console.warn('Component was already destroyed'); // eslint-disable-line no-console
			};
		}

		/** @returns {void} */
		$capture_state() {}

		/** @returns {void} */
		$inject_state() {}
	}

	if (typeof window !== 'undefined')
		// @ts-ignore
		(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);

	var uid = 0;
	var isBlazorPlatform = false;
	/**
	 * Create Instance from constructor function with desired parameters.
	 *
	 * @param {Function} classFunction - Class function to which need to create instance
	 * @param {any[]} params - Parameters need to passed while creating instance
	 * @returns {any} ?
	 * @private
	 */
	// eslint-disable-next-line
	function createInstance(classFunction, params) {
	    var arrayParam = params;
	    arrayParam.unshift(undefined);
	    return new (Function.prototype.bind.apply(classFunction, arrayParam));
	}
	/**
	 * To run a callback function immediately after the browser has completed other operations.
	 *
	 * @param {Function} handler - callback function to be triggered.
	 * @returns {Function} ?
	 * @private
	 */
	function setImmediate(handler) {
	    var unbind;
	    // eslint-disable-next-line
	    var num = new Uint16Array(5);
	    var intCrypto = window.msCrypto || window.crypto;
	    intCrypto.getRandomValues(num);
	    var secret = 'ej2' + combineArray(num);
	    // eslint-disable-next-line
	    var messageHandler = function (event) {
	        if (event.source === window && typeof event.data === 'string' && event.data.length <= 32 && event.data === secret) {
	            handler();
	            unbind();
	        }
	    };
	    window.addEventListener('message', messageHandler, false);
	    window.postMessage(secret, '*');
	    return unbind = function () {
	        window.removeEventListener('message', messageHandler);
	        handler = messageHandler = secret = undefined;
	    };
	}
	/**
	 * To get nameSpace value from the desired object.
	 *
	 * @param {string} nameSpace - String value to the get the inner object
	 * @param {any} obj - Object to get the inner object value.
	 * @returns {any} ?
	 * @private
	 */
	// eslint-disable-next-line
	function getValue(nameSpace, obj) {
	    // eslint-disable-next-line
	    var value = obj;
	    var splits = nameSpace.replace(/\[/g, '.').replace(/\]/g, '').split('.');
	    for (var i = 0; i < splits.length && !isUndefined(value); i++) {
	        value = value[splits[parseInt(i.toString(), 10)]];
	    }
	    return value;
	}
	/**
	 * To set value for the nameSpace in desired object.
	 *
	 * @param {string} nameSpace - String value to the get the inner object
	 * @param {any} value - Value that you need to set.
	 * @param {any} obj - Object to get the inner object value.
	 * @returns {any} ?
	 * @private
	 */
	// eslint-disable-next-line
	function setValue(nameSpace, value, obj) {
	    var keys = nameSpace.replace(/\[/g, '.').replace(/\]/g, '').split('.');
	    // eslint-disable-next-line
	    var start = obj || {};
	    // eslint-disable-next-line
	    var fromObj = start;
	    var i;
	    var length = keys.length;
	    var key;
	    for (i = 0; i < length; i++) {
	        key = keys[parseInt(i.toString(), 10)];
	        if (i + 1 === length) {
	            fromObj["" + key] = value === undefined ? {} : value;
	        }
	        else if (isNullOrUndefined(fromObj["" + key])) {
	            fromObj["" + key] = {};
	        }
	        fromObj = fromObj["" + key];
	    }
	    return start;
	}
	/**
	 * Delete an item from Object
	 *
	 * @param {any} obj - Object in which we need to delete an item.
	 * @param {string} key - String value to the get the inner object
	 * @returns {void} ?
	 * @private
	 */
	// eslint-disable-next-line
	function deleteObject(obj, key) {
	    delete obj["" + key];
	}
	/**
	 *@private
	 */
	// eslint-disable-next-line
	var containerObject = typeof window !== 'undefined' ? window : {};
	/**
	 * Check weather the given argument is only object.
	 *
	 * @param {any} obj - Object which is need to check.
	 * @returns {boolean} ?
	 * @private
	 */
	// eslint-disable-next-line
	function isObject(obj) {
	    var objCon = {};
	    return (!isNullOrUndefined(obj) && obj.constructor === objCon.constructor);
	}
	/**
	 * Merge the source object into destination object.
	 *
	 * @param {any} source - source object which is going to merge with destination object
	 * @param {any} destination - object need to be merged
	 * @returns {void} ?
	 * @private
	 */
	function merge(source, destination) {
	    if (!isNullOrUndefined(destination)) {
	        var temrObj = source;
	        var tempProp = destination;
	        var keys = Object.keys(destination);
	        var deepmerge = 'deepMerge';
	        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
	            var key = keys_1[_i];
	            if (!isNullOrUndefined(temrObj["" + deepmerge]) && (temrObj["" + deepmerge].indexOf(key) !== -1) &&
	                (isObject(tempProp["" + key]) || Array.isArray(tempProp["" + key]))) {
	                extend(temrObj["" + key], temrObj["" + key], tempProp["" + key], true);
	            }
	            else {
	                temrObj["" + key] = tempProp["" + key];
	            }
	        }
	    }
	}
	/**
	 * Extend the two object with newer one.
	 *
	 * @param {any} copied - Resultant object after merged
	 * @param {Object} first - First object need to merge
	 * @param {Object} second - Second object need to merge
	 * @param {boolean} deep ?
	 * @returns {Object} ?
	 * @private
	 */
	function extend(copied, first, second, deep) {
	    var result = copied && typeof copied === 'object' ? copied : {};
	    var length = arguments.length;
	    if (deep) {
	        length = length - 1;
	    }
	    var _loop_1 = function (i) {
	        // eslint-disable-next-line
	        if (!arguments_1[i]) {
	            return "continue";
	        }
	        // eslint-disable-next-line
	        var obj1 = arguments_1[i];
	        Object.keys(obj1).forEach(function (key) {
	            var src = result["" + key];
	            var copy = obj1["" + key];
	            var clone;
	            Array.isArray(copy) && Array.isArray(src) && (copy.length !== src.length);
	            // eslint-disable-next-line
	            var blazorEventExtend = true;
	            if (deep && blazorEventExtend && (isObject(copy) || Array.isArray(copy))) {
	                if (isObject(copy)) {
	                    clone = src ? src : {};
	                    // eslint-disable-next-line
	                    if (Array.isArray(clone) && clone.hasOwnProperty('isComplexArray')) {
	                        extend(clone, {}, copy, deep);
	                    }
	                    else {
	                        result["" + key] = extend(clone, {}, copy, deep);
	                    }
	                }
	                else {
	                    /* istanbul ignore next */
	                    clone = src ? src : [];
	                    // eslint-disable-next-line
	                    result["" + key] = extend([], clone, copy, (clone && clone.length) || (copy && copy.length));
	                }
	            }
	            else {
	                result["" + key] = copy;
	            }
	        });
	    };
	    var arguments_1 = arguments;
	    for (var i = 1; i < length; i++) {
	        _loop_1(i);
	    }
	    return result;
	}
	/**
	 * To check whether the object is null or undefined.
	 *
	 * @param {Object} value - To check the object is null or undefined
	 * @returns {boolean} ?
	 * @private
	 */
	function isNullOrUndefined(value) {
	    return value === undefined || value === null;
	}
	/**
	 * To check whether the object is undefined.
	 *
	 * @param {Object} value - To check the object is undefined
	 * @returns {boolean} ?
	 * @private
	 */
	function isUndefined(value) {
	    return ('undefined' === typeof value);
	}
	/**
	 * To return the generated unique name
	 *
	 * @param {string} definedName - To concatenate the unique id to provided name
	 * @returns {string} ?
	 * @private
	 */
	function getUniqueID(definedName) {
	    return definedName + '_' + uid++;
	}
	/**
	 * It limits the rate at which a function can fire. The function will fire only once every provided second instead of as quickly.
	 *
	 * @param {Function} eventFunction - Specifies the function to run when the event occurs
	 * @param {number} delay - A number that specifies the milliseconds for function delay call option
	 * @returns {Function} ?
	 * @private
	 */
	function debounce(eventFunction, delay) {
	    // eslint-disable-next-line
	    var out;
	    return function () {
	        var _this = this;
	        // eslint-disable-next-line
	        var args = arguments;
	        var later = function () {
	            out = null;
	            return eventFunction.apply(_this, args);
	        };
	        clearTimeout(out);
	        out = setTimeout(later, delay);
	    };
	}
	/**
	 * To check whether the  child element is descendant to parent element or parent and child are same element.
	 *
	 * @param {Element} child - Specifies the child element to compare with parent.
	 * @param {Element} parent - Specifies the parent element.
	 * @returns {boolean} ?
	 * @private
	 */
	function compareElementParent(child, parent) {
	    var node = child;
	    if (node === parent) {
	        return true;
	    }
	    else if (node === document || !node) {
	        return false;
	    }
	    else {
	        return compareElementParent(node.parentNode, parent);
	    }
	}
	/**
	 * To throw custom error message.
	 *
	 * @param {string} message - Specifies the error message to be thrown.
	 * @returns {void} ?
	 * @private
	 */
	function throwError(message) {
	    try {
	        throw new Error(message);
	    }
	    catch (e) {
	        // eslint-disable-next-line
	        throw e.message + '\n' + e.stack;
	    }
	}
	/**
	 * This function is used to print given element
	 *
	 * @param {Element} element - Specifies the print content element.
	 * @param {Window} printWindow - Specifies the print window.
	 * @returns {Window} ?
	 * @private
	 */
	function print(element, printWindow) {
	    var div = document.createElement('div');
	    var links = [].slice.call(document.getElementsByTagName('head')[0].querySelectorAll('base, link, style'));
	    var blinks = [].slice.call(document.getElementsByTagName('body')[0].querySelectorAll('link, style'));
	    if (blinks.length) {
	        for (var l = 0, len = blinks.length; l < len; l++) {
	            links.push(blinks[parseInt(l.toString(), 10)]);
	        }
	    }
	    var reference = '';
	    if (isNullOrUndefined(printWindow)) {
	        printWindow = window.open('', 'print', 'height=452,width=1024,tabbar=no');
	    }
	    div.appendChild(element.cloneNode(true));
	    for (var i = 0, len = links.length; i < len; i++) {
	        reference += links[parseInt(i.toString(), 10)].outerHTML;
	    }
	    printWindow.document.write('<!DOCTYPE html> <html><head>' + reference + '</head><body>' + div.innerHTML +
	        '<script> (function() { window.ready = true; })(); </script>' + '</body></html>');
	    printWindow.document.close();
	    printWindow.focus();
	    // eslint-disable-next-line
	    var interval = setInterval(function () {
	        if (printWindow.ready) {
	            printWindow.print();
	            printWindow.close();
	            clearInterval(interval);
	        }
	    }, 500);
	    return printWindow;
	}
	/**
	 * Function to normalize the units applied to the element.
	 *
	 * @param {number|string} value ?
	 * @returns {string} result
	 * @private
	 */
	function formatUnit(value) {
	    var result = value + '';
	    if (result.match(/auto|cm|mm|in|px|pt|pc|%|em|ex|ch|rem|vw|vh|vmin|vmax/)) {
	        return result;
	    }
	    return result + 'px';
	}
	/**
	 * Function to check whether the platform is blazor or not.
	 *
	 * @returns {boolean} result
	 * @private
	 */
	function isBlazor() {
	    return isBlazorPlatform;
	}
	/**
	 * Function to generate the unique id.
	 *
	 * @returns {any} ?
	 * @private
	 */
	// eslint-disable-next-line
	function uniqueID() {
	    if ((typeof window) === 'undefined') {
	        return;
	    }
	    // eslint-disable-next-line
	    var num = new Uint16Array(5);
	    var intCrypto = window.msCrypto || window.crypto;
	    return intCrypto.getRandomValues(num);
	}
	/**
	 *
	 * @param {Int16Array} num ?
	 * @returns {string} ?
	 */
	function combineArray(num) {
	    var ret = '';
	    for (var i = 0; i < 5; i++) {
	        ret += (i ? ',' : '') + num[parseInt(i.toString(), 10)];
	    }
	    return ret;
	}

	/**
	 * Parser
	 */
	var defaultNumberingSystem = {
	    'latn': {
	        '_digits': '0123456789',
	        '_type': 'numeric'
	    }
	};
	var defaultNumberSymbols = {
	    'decimal': '.',
	    'group': ',',
	    'percentSign': '%',
	    'plusSign': '+',
	    'minusSign': '-',
	    'infinity': '∞',
	    'nan': 'NaN',
	    'exponential': 'E'
	};
	var latnNumberSystem = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
	/**
	 * Interface for parser base
	 *
	 * @private
	 */
	var ParserBase = /** @class */ (function () {
	    function ParserBase() {
	    }
	    /**
	     * Returns the cldr object for the culture specifies
	     *
	     * @param {Object} obj - Specifies the object from which culture object to be acquired.
	     * @param {string} cName - Specifies the culture name.
	     * @returns {Object} ?
	     */
	    ParserBase.getMainObject = function (obj, cName) {
	        var value = 'main.' + cName;
	        return getValue(value, obj);
	    };
	    /**
	     * Returns the numbering system object from given cldr data.
	     *
	     * @param {Object} obj - Specifies the object from which number system is acquired.
	     * @returns {Object} ?
	     */
	    ParserBase.getNumberingSystem = function (obj) {
	        return getValue('supplemental.numberingSystems', obj) || this.numberingSystems;
	    };
	    /**
	     * Returns the reverse of given object keys or keys specified.
	     *
	     * @param {Object} prop - Specifies the object to be reversed.
	     * @param {number[]} keys - Optional parameter specifies the custom keyList for reversal.
	     * @returns {Object} ?
	     */
	    ParserBase.reverseObject = function (prop, keys) {
	        var propKeys = keys || Object.keys(prop);
	        var res = {};
	        for (var _i = 0, propKeys_1 = propKeys; _i < propKeys_1.length; _i++) {
	            var key = propKeys_1[_i];
	            // eslint-disable-next-line
	            if (!res.hasOwnProperty(prop[key])) {
	                // eslint-disable-next-line
	                res[prop[key]] = key;
	            }
	        }
	        return res;
	    };
	    /**
	     * Returns the symbol regex by skipping the escape sequence.
	     *
	     * @param {string[]} props - Specifies the array values to be skipped.
	     * @returns {RegExp} ?
	     */
	    ParserBase.getSymbolRegex = function (props) {
	        var regexStr = props.map(function (str) {
	            return str.replace(/([.*+?^=!:${}()|[\]/\\])/g, '\\$1');
	        }).join('|');
	        var regExp = RegExp;
	        return new regExp(regexStr, 'g');
	    };
	    /**
	     *
	     * @param {Object} prop ?
	     * @returns {Object} ?
	     */
	    ParserBase.getSymbolMatch = function (prop) {
	        var matchKeys = Object.keys(defaultNumberSymbols);
	        var ret = {};
	        for (var _i = 0, matchKeys_1 = matchKeys; _i < matchKeys_1.length; _i++) {
	            var key = matchKeys_1[_i];
	            // eslint-disable-next-line
	            ret[prop[key]] = defaultNumberSymbols[key];
	        }
	        return ret;
	    };
	    /**
	     * Returns regex string for provided value
	     *
	     * @param {string} val ?
	     * @returns {string} ?
	     */
	    ParserBase.constructRegex = function (val) {
	        var len = val.length;
	        var ret = '';
	        for (var i = 0; i < len; i++) {
	            if (i !== len - 1) {
	                ret += val[parseInt(i.toString(), 10)] + '|';
	            }
	            else {
	                ret += val[parseInt(i.toString(), 10)];
	            }
	        }
	        return ret;
	    };
	    /**
	     * Returns the replaced value of matching regex and obj mapper.
	     *
	     * @param {string} value - Specifies the  values to be replaced.
	     * @param {RegExp} regex - Specifies the  regex to search.
	     * @param {Object} obj - Specifies the  object matcher to be replace value parts.
	     * @returns {string} ?
	     */
	    ParserBase.convertValueParts = function (value, regex, obj) {
	        return value.replace(regex, function (str) {
	            // eslint-disable-next-line
	            return obj[str];
	        });
	    };
	    /**
	     * Returns default numbering system object for formatting from cldr data
	     *
	     * @param {Object} obj ?
	     * @returns {NumericObject} ?
	     */
	    ParserBase.getDefaultNumberingSystem = function (obj) {
	        var ret = {};
	        ret.obj = getValue('numbers', obj);
	        ret.nSystem = getValue('defaultNumberingSystem', ret.obj);
	        return ret;
	    };
	    /**
	     * Returns the replaced value of matching regex and obj mapper.
	     *
	     * @param {Object} curObj ?
	     * @param {Object} numberSystem ?
	     * @param {boolean} needSymbols ?
	     * @param {boolean} blazorMode ?
	     * @returns {Object} ?
	     */
	    ParserBase.getCurrentNumericOptions = function (curObj, numberSystem, needSymbols, blazorMode) {
	        var ret = {};
	        var cur = this.getDefaultNumberingSystem(curObj);
	        if (!isUndefined(cur.nSystem) || blazorMode) {
	            var digits = blazorMode ? getValue('obj.mapperDigits', cur) : getValue(cur.nSystem + '._digits', numberSystem);
	            if (!isUndefined(digits)) {
	                ret.numericPair = this.reverseObject(digits, latnNumberSystem);
	                var regExp = RegExp;
	                ret.numberParseRegex = new regExp(this.constructRegex(digits), 'g');
	                ret.numericRegex = '[' + digits[0] + '-' + digits[9] + ']';
	                if (needSymbols) {
	                    ret.numericRegex = digits[0] + '-' + digits[9];
	                    ret.symbolNumberSystem = getValue(blazorMode ? 'numberSymbols' : 'symbols-numberSystem-' + cur.nSystem, cur.obj);
	                    ret.symbolMatch = this.getSymbolMatch(ret.symbolNumberSystem);
	                    ret.numberSystem = cur.nSystem;
	                }
	            }
	        }
	        return ret;
	    };
	    /**
	     * Returns number mapper object for the provided cldr data
	     *
	     * @param {Object} curObj ?
	     * @param {Object} numberSystem ?
	     * @param {boolean} isNumber ?
	     * @returns {NumberMapper} ?
	     */
	    // eslint-disable-next-line
	    ParserBase.getNumberMapper = function (curObj, numberSystem, isNumber) {
	        var ret = { mapper: {} };
	        var cur = this.getDefaultNumberingSystem(curObj);
	        if (!isUndefined(cur.nSystem)) {
	            ret.numberSystem = cur.nSystem;
	            ret.numberSymbols = getValue('symbols-numberSystem-' + cur.nSystem, cur.obj);
	            ret.timeSeparator = getValue('timeSeparator', ret.numberSymbols);
	            var digits = getValue(cur.nSystem + '._digits', numberSystem);
	            if (!isUndefined(digits)) {
	                for (var _i = 0, latnNumberSystem_1 = latnNumberSystem; _i < latnNumberSystem_1.length; _i++) {
	                    var i = latnNumberSystem_1[_i];
	                    // eslint-disable-next-line
	                    ret.mapper[i] = digits[i];
	                }
	            }
	        }
	        return ret;
	    };
	    ParserBase.nPair = 'numericPair';
	    ParserBase.nRegex = 'numericRegex';
	    ParserBase.numberingSystems = defaultNumberingSystem;
	    return ParserBase;
	}());
	/**
	 * @private
	 */
	var blazorCurrencyData = {
	    'DJF': 'Fdj',
	    'ERN': 'Nfk',
	    'ETB': 'Br',
	    'NAD': '$',
	    'ZAR': 'R',
	    'XAF': 'FCFA',
	    'GHS': 'GH₵',
	    'XDR': 'XDR',
	    'AED': 'د.إ.',
	    'BHD': 'د.ب.',
	    'DZD': 'د.ج.',
	    'EGP': 'ج.م.',
	    'ILS': '₪',
	    'IQD': 'د.ع.',
	    'JOD': 'د.ا.',
	    'KMF': 'CF',
	    'KWD': 'د.ك.',
	    'LBP': 'ل.ل.',
	    'LYD': 'د.ل.',
	    'MAD': 'د.م.',
	    'MRU': 'أ.م.',
	    'OMR': 'ر.ع.',
	    'QAR': 'ر.ق.',
	    'SAR': 'ر.س.',
	    'SDG': 'ج.س.',
	    'SOS': 'S',
	    'SSP': '£',
	    'SYP': 'ل.س.',
	    'TND': 'د.ت.',
	    'YER': 'ر.ي.',
	    'CLP': '$',
	    'INR': '₹',
	    'TZS': 'TSh',
	    'EUR': '€',
	    'AZN': '₼',
	    'RUB': '₽',
	    'BYN': 'Br',
	    'ZMW': 'K',
	    'BGN': 'лв.',
	    'NGN': '₦',
	    'XOF': 'CFA',
	    'BDT': '৳',
	    'CNY': '¥',
	    'BAM': 'КМ',
	    'UGX': 'USh',
	    'USD': '$',
	    'CZK': 'Kč',
	    'GBP': '£',
	    'DKK': 'kr.',
	    'KES': 'Ksh',
	    'CHF': 'CHF',
	    'MVR': 'ރ.',
	    'BTN': 'Nu.',
	    'XCD': 'EC$',
	    'AUD': '$',
	    'BBD': '$',
	    'BIF': 'FBu',
	    'BMD': '$',
	    'BSD': '$',
	    'BWP': 'P',
	    'BZD': '$',
	    'CAD': '$',
	    'NZD': '$',
	    'FJD': '$',
	    'FKP': '£',
	    'GIP': '£',
	    'GMD': 'D',
	    'GYD': '$',
	    'HKD': '$',
	    'IDR': 'Rp',
	    'JMD': '$',
	    'KYD': '$',
	    'LRD': '$',
	    'MGA': 'Ar',
	    'MOP': 'MOP$',
	    'MUR': 'Rs',
	    'MWK': 'MK',
	    'MYR': 'RM',
	    'PGK': 'K',
	    'PHP': '₱',
	    'PKR': 'Rs',
	    'RWF': 'RF',
	    'SBD': '$',
	    'SCR': 'SR',
	    'SEK': 'kr',
	    'SGD': '$',
	    'SHP': '£',
	    'SLL': 'Le',
	    'ANG': 'NAf.',
	    'SZL': 'E',
	    'TOP': 'T$',
	    'TTD': '$',
	    'VUV': 'VT',
	    'WST': 'WS$',
	    'ARS': '$',
	    'BOB': 'Bs',
	    'BRL': 'R$',
	    'COP': '$',
	    'CRC': '₡',
	    'CUP': '$',
	    'DOP': '$',
	    'GTQ': 'Q',
	    'HNL': 'L',
	    'MXN': '$',
	    'NIO': 'C$',
	    'PAB': 'B/.',
	    'PEN': 'S/',
	    'PYG': '₲',
	    'UYU': '$',
	    'VES': 'Bs.S',
	    'IRR': 'ريال',
	    'GNF': 'FG',
	    'CDF': 'FC',
	    'HTG': 'G',
	    'XPF': 'FCFP',
	    'HRK': 'kn',
	    'HUF': 'Ft',
	    'AMD': '֏',
	    'ISK': 'kr',
	    'JPY': '¥',
	    'GEL': '₾',
	    'CVE': '​',
	    'KZT': '₸',
	    'KHR': '៛',
	    'KPW': '₩',
	    'KRW': '₩',
	    'KGS': 'сом',
	    'AOA': 'Kz',
	    'LAK': '₭',
	    'MZN': 'MTn',
	    'MKD': 'ден',
	    'MNT': '₮',
	    'BND': '$',
	    'MMK': 'K',
	    'NOK': 'kr',
	    'NPR': 'रु',
	    'AWG': 'Afl.',
	    'SRD': '$',
	    'PLN': 'zł',
	    'AFN': '؋',
	    'STN': 'Db',
	    'MDL': 'L',
	    'RON': 'lei',
	    'UAH': '₴',
	    'LKR': 'රු.',
	    'ALL': 'Lekë',
	    'RSD': 'дин.',
	    'TJS': 'смн',
	    'THB': '฿',
	    'TMT': 'm.',
	    'TRY': '₺',
	    'UZS': 'сўм',
	    'VND': '₫',
	    'TWD': 'NT$'
	};
	/**
	 *
	 * @param {string} currencyCode ?
	 * @returns {string} ?
	 */
	function getBlazorCurrencySymbol(currencyCode) {
	    return getValue(currencyCode || '', blazorCurrencyData);
	}

	/***
	 * Hijri parser
	 */
	// eslint-disable-next-line
	var HijriParser;
	(function (HijriParser) {
	    var dateCorrection = [28607, 28636, 28665, 28695, 28724, 28754, 28783, 28813, 28843, 28872, 28901, 28931, 28960, 28990,
	        29019, 29049, 29078, 29108, 29137, 29167, 29196, 29226, 29255, 29285, 29315, 29345, 29375, 29404, 29434, 29463, 29492, 29522,
	        29551, 29580, 29610, 29640, 29669, 29699, 29729, 29759, 29788, 29818, 29847, 29876, 29906, 29935, 29964, 29994, 30023, 30053,
	        30082, 30112, 30141, 30171, 30200, 30230, 30259, 30289, 30318, 30348, 30378, 30408, 30437, 30467, 30496, 30526, 30555, 30585,
	        30614, 30644, 30673, 30703, 30732, 30762, 30791, 30821, 30850, 30880, 30909, 30939, 30968, 30998, 31027, 31057, 31086, 31116,
	        31145, 31175, 31204, 31234, 31263, 31293, 31322, 31352, 31381, 31411, 31441, 31471, 31500, 31530, 31559, 31589, 31618, 31648,
	        31676, 31706, 31736, 31766, 31795, 31825, 31854, 31884, 31913, 31943, 31972, 32002, 32031, 32061, 32090, 32120, 32150, 32180,
	        32209, 32239, 32268, 32298, 32327, 32357, 32386, 32416, 32445, 32475, 32504, 32534, 32563, 32593, 32622, 32652, 32681, 32711,
	        32740, 32770, 32799, 32829, 32858, 32888, 32917, 32947, 32976, 33006, 33035, 33065, 33094, 33124, 33153, 33183, 33213, 33243,
	        33272, 33302, 33331, 33361, 33390, 33420, 33450, 33479, 33509, 33539, 33568, 33598, 33627, 33657, 33686, 33716, 33745, 33775,
	        33804, 33834, 33863, 33893, 33922, 33952, 33981, 34011, 34040, 34069, 34099, 34128, 34158, 34187, 34217, 34247, 34277, 34306,
	        34336, 34365, 34395, 34424, 34454, 34483, 34512, 34542, 34571, 34601, 34631, 34660, 34690, 34719, 34749, 34778, 34808, 34837,
	        34867, 34896, 34926, 34955, 34985, 35015, 35044, 35074, 35103, 35133, 35162, 35192, 35222, 35251, 35280, 35310, 35340, 35370,
	        35399, 35429, 35458, 35488, 35517, 35547, 35576, 35605, 35635, 35665, 35694, 35723, 35753, 35782, 35811, 35841, 35871, 35901,
	        35930, 35960, 35989, 36019, 36048, 36078, 36107, 36136, 36166, 36195, 36225, 36254, 36284, 36314, 36343, 36373, 36403, 36433,
	        36462, 36492, 36521, 36551, 36580, 36610, 36639, 36669, 36698, 36728, 36757, 36786, 36816, 36845, 36875, 36904, 36934, 36963,
	        36993, 37022, 37052, 37081, 37111, 37141, 37170, 37200, 37229, 37259, 37288, 37318, 37347, 37377, 37406, 37436, 37465, 37495,
	        37524, 37554, 37584, 37613, 37643, 37672, 37701, 37731, 37760, 37790, 37819, 37849, 37878, 37908, 37938, 37967, 37997, 38027,
	        38056, 38085, 38115, 38144, 38174, 38203, 38233, 38262, 38292, 38322, 38351, 38381, 38410, 38440, 38469, 38499, 38528, 38558,
	        38587, 38617, 38646, 38676, 38705, 38735, 38764, 38794, 38823, 38853, 38882, 38912, 38941, 38971, 39001, 39030, 39059, 39089,
	        39118, 39148, 39178, 39208, 39237, 39267, 39297, 39326, 39355, 39385, 39414, 39444, 39473, 39503, 39532, 39562, 39592, 39621,
	        39650, 39680, 39709, 39739, 39768, 39798, 39827, 39857, 39886, 39916, 39946, 39975, 40005, 40035, 40064, 40094, 40123, 40153,
	        40182, 40212, 40241, 40271, 40300, 40330, 40359, 40389, 40418, 40448, 40477, 40507, 40536, 40566, 40595, 40625, 40655, 40685,
	        40714, 40744, 40773, 40803, 40832, 40862, 40892, 40921, 40951, 40980, 41009, 41039, 41068, 41098, 41127, 41157, 41186, 41216,
	        41245, 41275, 41304, 41334, 41364, 41393, 41422, 41452, 41481, 41511, 41540, 41570, 41599, 41629, 41658, 41688, 41718, 41748,
	        41777, 41807, 41836, 41865, 41894, 41924, 41953, 41983, 42012, 42042, 42072, 42102, 42131, 42161, 42190, 42220, 42249, 42279,
	        42308, 42337, 42367, 42397, 42426, 42456, 42485, 42515, 42545, 42574, 42604, 42633, 42662, 42692, 42721, 42751, 42780, 42810,
	        42839, 42869, 42899, 42929, 42958, 42988, 43017, 43046, 43076, 43105, 43135, 43164, 43194, 43223, 43253, 43283, 43312, 43342,
	        43371, 43401, 43430, 43460, 43489, 43519, 43548, 43578, 43607, 43637, 43666, 43696, 43726, 43755, 43785, 43814, 43844, 43873,
	        43903, 43932, 43962, 43991, 44021, 44050, 44080, 44109, 44139, 44169, 44198, 44228, 44258, 44287, 44317, 44346, 44375, 44405,
	        44434, 44464, 44493, 44523, 44553, 44582, 44612, 44641, 44671, 44700, 44730, 44759, 44788, 44818, 44847, 44877, 44906, 44936,
	        44966, 44996, 45025, 45055, 45084, 45114, 45143, 45172, 45202, 45231, 45261, 45290, 45320, 45350, 45380, 45409, 45439, 45468,
	        45498, 45527, 45556, 45586, 45615, 45644, 45674, 45704, 45733, 45763, 45793, 45823, 45852, 45882, 45911, 45940, 45970, 45999,
	        46028, 46058, 46088, 46117, 46147, 46177, 46206, 46236, 46265, 46295, 46324, 46354, 46383, 46413, 46442, 46472, 46501, 46531,
	        46560, 46590, 46620, 46649, 46679, 46708, 46738, 46767, 46797, 46826, 46856, 46885, 46915, 46944, 46974, 47003, 47033, 47063,
	        47092, 47122, 47151, 47181, 47210, 47240, 47269, 47298, 47328, 47357, 47387, 47417, 47446, 47476, 47506, 47535, 47565, 47594,
	        47624, 47653, 47682, 47712, 47741, 47771, 47800, 47830, 47860, 47890, 47919, 47949, 47978, 48008, 48037, 48066, 48096, 48125,
	        48155, 48184, 48214, 48244, 48273, 48303, 48333, 48362, 48392, 48421, 48450, 48480, 48509, 48538, 48568, 48598, 48627, 48657,
	        48687, 48717, 48746, 48776, 48805, 48834, 48864, 48893, 48922, 48952, 48982, 49011, 49041, 49071, 49100, 49130, 49160, 49189,
	        49218, 49248, 49277, 49306, 49336, 49365, 49395, 49425, 49455, 49484, 49514, 49543, 49573, 49602, 49632, 49661, 49690, 49720,
	        49749, 49779, 49809, 49838, 49868, 49898, 49927, 49957, 49986, 50016, 50045, 50075, 50104, 50133, 50163, 50192, 50222, 50252,
	        50281, 50311, 50340, 50370, 50400, 50429, 50459, 50488, 50518, 50547, 50576, 50606, 50635, 50665, 50694, 50724, 50754, 50784,
	        50813, 50843, 50872, 50902, 50931, 50960, 50990, 51019, 51049, 51078, 51108, 51138, 51167, 51197, 51227, 51256, 51286, 51315,
	        51345, 51374, 51403, 51433, 51462, 51492, 51522, 51552, 51582, 51611, 51641, 51670, 51699, 51729, 51758, 51787, 51816, 51846,
	        51876, 51906, 51936, 51965, 51995, 52025, 52054, 52083, 52113, 52142, 52171, 52200, 52230, 52260, 52290, 52319, 52349, 52379,
	        52408, 52438, 52467, 52497, 52526, 52555, 52585, 52614, 52644, 52673, 52703, 52733, 52762, 52792, 52822, 52851, 52881, 52910,
	        52939, 52969, 52998, 53028, 53057, 53087, 53116, 53146, 53176, 53205, 53235, 53264, 53294, 53324, 53353, 53383, 53412, 53441,
	        53471, 53500, 53530, 53559, 53589, 53619, 53648, 53678, 53708, 53737, 53767, 53796, 53825, 53855, 53884, 53913, 53943, 53973,
	        54003, 54032, 54062, 54092, 54121, 54151, 54180, 54209, 54239, 54268, 54297, 54327, 54357, 54387, 54416, 54446, 54476, 54505,
	        54535, 54564, 54593, 54623, 54652, 54681, 54711, 54741, 54770, 54800, 54830, 54859, 54889, 54919, 54948, 54977, 55007, 55036,
	        55066, 55095, 55125, 55154, 55184, 55213, 55243, 55273, 55302, 55332, 55361, 55391, 55420, 55450, 55479, 55508, 55538, 55567,
	        55597, 55627, 55657, 55686, 55716, 55745, 55775, 55804, 55834, 55863, 55892, 55922, 55951, 55981, 56011, 56040, 56070, 56100,
	        56129, 56159, 56188, 56218, 56247, 56276, 56306, 56335, 56365, 56394, 56424, 56454, 56483, 56513, 56543, 56572, 56601, 56631,
	        56660, 56690, 56719, 56749, 56778, 56808, 56837, 56867, 56897, 56926, 56956, 56985, 57015, 57044, 57074, 57103, 57133, 57162,
	        57192, 57221, 57251, 57280, 57310, 57340, 57369, 57399, 57429, 57458, 57487, 57517, 57546, 57576, 57605, 57634, 57664, 57694,
	        57723, 57753, 57783, 57813, 57842, 57871, 57901, 57930, 57959, 57989, 58018, 58048, 58077, 58107, 58137, 58167, 58196, 58226,
	        58255, 58285, 58314, 58343, 58373, 58402, 58432, 58461, 58491, 58521, 58551, 58580, 58610, 58639, 58669, 58698, 58727, 58757,
	        58786, 58816, 58845, 58875, 58905, 58934, 58964, 58994, 59023, 59053, 59082, 59111, 59141, 59170, 59200, 59229, 59259, 59288,
	        59318, 59348, 59377, 59407, 59436, 59466, 59495, 59525, 59554, 59584, 59613, 59643, 59672, 59702, 59731, 59761, 59791, 59820,
	        59850, 59879, 59909, 59939, 59968, 59997, 60027, 60056, 60086, 60115, 60145, 60174, 60204, 60234, 60264, 60293, 60323, 60352,
	        60381, 60411, 60440, 60469, 60499, 60528, 60558, 60588, 60618, 60648, 60677, 60707, 60736, 60765, 60795, 60824, 60853, 60883,
	        60912, 60942, 60972, 61002, 61031, 61061, 61090, 61120, 61149, 61179, 61208, 61237, 61267, 61296, 61326, 61356, 61385, 61415,
	        61445, 61474, 61504, 61533, 61563, 61592, 61621, 61651, 61680, 61710, 61739, 61769, 61799, 61828, 61858, 61888, 61917, 61947,
	        61976, 62006, 62035, 62064, 62094, 62123, 62153, 62182, 62212, 62242, 62271, 62301, 62331, 62360, 62390, 62419, 62448, 62478,
	        62507, 62537, 62566, 62596, 62625, 62655, 62685, 62715, 62744, 62774, 62803, 62832, 62862, 62891, 62921, 62950, 62980, 63009,
	        63039, 63069, 63099, 63128, 63157, 63187, 63216, 63246, 63275, 63305, 63334, 63363, 63393, 63423, 63453, 63482, 63512, 63541,
	        63571, 63600, 63630, 63659, 63689, 63718, 63747, 63777, 63807, 63836, 63866, 63895, 63925, 63955, 63984, 64014, 64043, 64073,
	        64102, 64131, 64161, 64190, 64220, 64249, 64279, 64309, 64339, 64368, 64398, 64427, 64457, 64486, 64515, 64545, 64574, 64603,
	        64633, 64663, 64692, 64722, 64752, 64782, 64811, 64841, 64870, 64899, 64929, 64958, 64987, 65017, 65047, 65076, 65106, 65136,
	        65166, 65195, 65225, 65254, 65283, 65313, 65342, 65371, 65401, 65431, 65460, 65490, 65520, 65549, 65579, 65608, 65638, 65667,
	        65697, 65726, 65755, 65785, 65815, 65844, 65874, 65903, 65933, 65963, 65992, 66022, 66051, 66081, 66110, 66140, 66169, 66199,
	        66228, 66258, 66287, 66317, 66346, 66376, 66405, 66435, 66465, 66494, 66524, 66553, 66583, 66612, 66641, 66671, 66700, 66730,
	        66760, 66789, 66819, 66849, 66878, 66908, 66937, 66967, 66996, 67025, 67055, 67084, 67114, 67143, 67173, 67203, 67233, 67262,
	        67292, 67321, 67351, 67380, 67409, 67439, 67468, 67497, 67527, 67557, 67587, 67617, 67646, 67676, 67705, 67735, 67764, 67793,
	        67823, 67852, 67882, 67911, 67941, 67971, 68000, 68030, 68060, 68089, 68119, 68148, 68177, 68207, 68236, 68266, 68295, 68325,
	        68354, 68384, 68414, 68443, 68473, 68502, 68532, 68561, 68591, 68620, 68650, 68679, 68708, 68738, 68768, 68797, 68827, 68857,
	        68886, 68916, 68946, 68975, 69004, 69034, 69063, 69092, 69122, 69152, 69181, 69211, 69240, 69270, 69300, 69330, 69359, 69388,
	        69418, 69447, 69476, 69506, 69535, 69565, 69595, 69624, 69654, 69684, 69713, 69743, 69772, 69802, 69831, 69861, 69890, 69919,
	        69949, 69978, 70008, 70038, 70067, 70097, 70126, 70156, 70186, 70215, 70245, 70274, 70303, 70333, 70362, 70392, 70421, 70451,
	        70481, 70510, 70540, 70570, 70599, 70629, 70658, 70687, 70717, 70746, 70776, 70805, 70835, 70864, 70894, 70924, 70954, 70983,
	        71013, 71042, 71071, 71101, 71130, 71159, 71189, 71218, 71248, 71278, 71308, 71337, 71367, 71397, 71426, 71455, 71485, 71514,
	        71543, 71573, 71602, 71632, 71662, 71691, 71721, 71751, 71781, 71810, 71839, 71869, 71898, 71927, 71957, 71986, 72016, 72046,
	        72075, 72105, 72135, 72164, 72194, 72223, 72253, 72282, 72311, 72341, 72370, 72400, 72429, 72459, 72489, 72518, 72548, 72577,
	        72607, 72637, 72666, 72695, 72725, 72754, 72784, 72813, 72843, 72872, 72902, 72931, 72961, 72991, 73020, 73050, 73080, 73109,
	        73139, 73168, 73197, 73227, 73256, 73286, 73315, 73345, 73375, 73404, 73434, 73464, 73493, 73523, 73552, 73581, 73611, 73640,
	        73669, 73699, 73729, 73758, 73788, 73818, 73848, 73877, 73907, 73936, 73965, 73995, 74024, 74053, 74083, 74113, 74142, 74172,
	        74202, 74231, 74261, 74291, 74320, 74349, 74379, 74408, 74437, 74467, 74497, 74526, 74556, 74586, 74615, 74645, 74675, 74704,
	        74733, 74763, 74792, 74822, 74851, 74881, 74910, 74940, 74969, 74999, 75029, 75058, 75088, 75117, 75147, 75176, 75206, 75235,
	        75264, 75294, 75323, 75353, 75383, 75412, 75442, 75472, 75501, 75531, 75560, 75590, 75619, 75648, 75678, 75707, 75737, 75766,
	        75796, 75826, 75856, 75885, 75915, 75944, 75974, 76003, 76032, 76062, 76091, 76121, 76150, 76180, 76210, 76239, 76269, 76299,
	        76328, 76358, 76387, 76416, 76446, 76475, 76505, 76534, 76564, 76593, 76623, 76653, 76682, 76712, 76741, 76771, 76801, 76830,
	        76859, 76889, 76918, 76948, 76977, 77007, 77036, 77066, 77096, 77125, 77155, 77185, 77214, 77243, 77273, 77302, 77332, 77361,
	        77390, 77420, 77450, 77479, 77509, 77539, 77569, 77598, 77627, 77657, 77686, 77715, 77745, 77774, 77804, 77833, 77863, 77893,
	        77923, 77952, 77982, 78011, 78041, 78070, 78099, 78129, 78158, 78188, 78217, 78247, 78277, 78307, 78336, 78366, 78395, 78425,
	        78454, 78483, 78513, 78542, 78572, 78601, 78631, 78661, 78690, 78720, 78750, 78779, 78808, 78838, 78867, 78897, 78926, 78956,
	        78985, 79015, 79044, 79074, 79104, 79133, 79163, 79192, 79222, 79251, 79281, 79310, 79340, 79369, 79399, 79428, 79458, 79487,
	        79517, 79546, 79576, 79606, 79635, 79665, 79695, 79724, 79753, 79783, 79812, 79841, 79871, 79900, 79930, 79960, 79990
	    ];
	    /**
	     *
	     * @param {Date} gDate ?
	     * @returns {Object} ?
	     */
	    function getHijriDate(gDate) {
	        var day = gDate.getDate();
	        var month = gDate.getMonth();
	        var year = gDate.getFullYear();
	        var tMonth = month + 1;
	        var tYear = year;
	        if (tMonth < 3) {
	            tYear -= 1;
	            tMonth += 12;
	        }
	        var yPrefix = Math.floor(tYear / 100.);
	        var julilanOffset = yPrefix - Math.floor(yPrefix / 4.) - 2;
	        var julianNumber = Math.floor(365.25 * (tYear + 4716)) + Math.floor(30.6001 * (tMonth + 1)) + day - julilanOffset - 1524;
	        yPrefix = Math.floor((julianNumber - 1867216.25) / 36524.25);
	        julilanOffset = yPrefix - Math.floor(yPrefix / 4.) + 1;
	        var b = julianNumber + julilanOffset + 1524;
	        var c = Math.floor((b - 122.1) / 365.25);
	        var d = Math.floor(365.25 * c);
	        var tempMonth = Math.floor((b - d) / 30.6001);
	        day = (b - d) - Math.floor(30.6001 * tempMonth);
	        month = Math.floor((b - d) / 20.6001);
	        if (month > 13) {
	            c += 1;
	            month -= 12;
	        }
	        month -= 1;
	        year = c - 4716;
	        var modifiedJulianDate = julianNumber - 2400000;
	        // date calculation for year after 2077
	        var iyear = 10631. / 30.;
	        var z = julianNumber - 1948084;
	        var cyc = Math.floor(z / 10631.);
	        z = z - 10631 * cyc;
	        var j = Math.floor((z - 0.1335) / iyear);
	        var iy = 30 * cyc + j;
	        z = z - Math.floor(j * iyear + 0.1335);
	        var im = Math.floor((z + 28.5001) / 29.5);
	        /* istanbul ignore next */
	        if (im === 13) {
	            im = 12;
	        }
	        var tempDay = z - Math.floor(29.5001 * im - 29);
	        var i = 0;
	        for (; i < dateCorrection.length; i++) {
	            if (dateCorrection[parseInt(i.toString(), 10)] > modifiedJulianDate) {
	                break;
	            }
	        }
	        var iln = i + 16260;
	        var ii = Math.floor((iln - 1) / 12);
	        var hYear = ii + 1;
	        var hmonth = iln - 12 * ii;
	        var hDate = modifiedJulianDate - dateCorrection[i - 1] + 1;
	        if ((hDate + '').length > 2) {
	            hDate = tempDay;
	            hmonth = im;
	            hYear = iy;
	        }
	        return { year: hYear, month: hmonth, date: hDate };
	    }
	    HijriParser.getHijriDate = getHijriDate;
	    /**
	     *
	     * @param {number} year ?
	     * @param {number} month ?
	     * @param {number} day ?
	     * @returns {Date} ?
	     */
	    function toGregorian(year, month, day) {
	        var iy = year;
	        var im = month;
	        var id = day;
	        var ii = iy - 1;
	        var iln = (ii * 12) + 1 + (im - 1);
	        var i = iln - 16260;
	        var mcjdn = id + dateCorrection[i - 1] - 1;
	        var julianDate = mcjdn + 2400000;
	        var z = Math.floor(julianDate + 0.5);
	        var a = Math.floor((z - 1867216.25) / 36524.25);
	        a = z + 1 + a - Math.floor(a / 4);
	        var b = a + 1524;
	        var c = Math.floor((b - 122.1) / 365.25);
	        var d = Math.floor(365.25 * c);
	        var e = Math.floor((b - d) / 30.6001);
	        var gDay = b - d - Math.floor(e * 30.6001);
	        var gMonth = e - (e > 13.5 ? 13 : 1);
	        var gYear = c - (gMonth > 2.5 ? 4716 : 4715);
	        /* istanbul ignore next */
	        if (gYear <= 0) {
	            gMonth--;
	        } // No year zero
	        return new Date(gYear + '/' + (gMonth) + '/' + gDay);
	    }
	    HijriParser.toGregorian = toGregorian;
	})(HijriParser || (HijriParser = {}));

	var abbreviateRegexGlobal = /\/MMMMM|MMMM|MMM|a|LLLL|LLL|EEEEE|EEEE|E|K|cccc|ccc|WW|W|G+|z+/gi;
	var standalone$1 = 'stand-alone';
	var weekdayKey = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
	var timeSetter$1 = {
	    m: 'getMinutes',
	    h: 'getHours',
	    H: 'getHours',
	    s: 'getSeconds',
	    d: 'getDate',
	    f: 'getMilliseconds'
	};
	var datePartMatcher = {
	    'M': 'month',
	    'd': 'day',
	    'E': 'weekday',
	    'c': 'weekday',
	    'y': 'year',
	    'm': 'minute',
	    'h': 'hour',
	    'H': 'hour',
	    's': 'second',
	    'L': 'month',
	    'a': 'designator',
	    'z': 'timeZone',
	    'Z': 'timeZone',
	    'G': 'era',
	    'f': 'milliseconds'
	};
	var timeSeparator = 'timeSeparator';
	/* tslint:disable no-any */
	/**
	 * Date Format is a framework provides support for date formatting.
	 *
	 * @private
	 */
	var DateFormat = /** @class */ (function () {
	    function DateFormat() {
	    }
	    /**
	     * Returns the formatter function for given skeleton.
	     *
	     * @param {string} culture -  Specifies the culture name to be which formatting.
	     * @param {DateFormatOptions} option - Specific the format in which date  will format.
	     * @param {Object} cldr - Specifies the global cldr data collection.
	     * @returns {Function} ?
	     */
	    DateFormat.dateFormat = function (culture, option, cldr) {
	        var _this = this;
	        var dependable = IntlBase.getDependables(cldr, culture, option.calendar);
	        getValue('parserObject.numbers', dependable);
	        var dateObject = dependable.dateObject;
	        var formatOptions = { isIslamic: IntlBase.islamicRegex.test(option.calendar) };
	        var resPattern = option.format ||
	            IntlBase.getResultantPattern(option.skeleton, dependable.dateObject, option.type, false, '');
	        formatOptions.dateSeperator = IntlBase.getDateSeparator(dependable.dateObject);
	        if (isUndefined(resPattern)) {
	            throwError('Format options or type given must be invalid');
	        }
	        else {
	            resPattern = IntlBase.ConvertDateToWeekFormat(resPattern);
	            formatOptions.pattern = resPattern;
	            formatOptions.numMapper = ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr));
	            var patternMatch = resPattern.match(abbreviateRegexGlobal) || [];
	            for (var _i = 0, patternMatch_1 = patternMatch; _i < patternMatch_1.length; _i++) {
	                var str = patternMatch_1[_i];
	                var len = str.length;
	                var char = str[0];
	                if (char === 'K') {
	                    char = 'h';
	                }
	                switch (char) {
	                    case 'E':
	                    case 'c':
	                        {
	                            // eslint-disable-next-line
	                            formatOptions.weekday = dependable.dateObject[IntlBase.days][standalone$1][IntlBase.monthIndex[len]];
	                        }
	                        break;
	                    case 'M':
	                    case 'L':
	                        {
	                            // eslint-disable-next-line
	                            formatOptions.month = dependable.dateObject[IntlBase.month][standalone$1][IntlBase.monthIndex[len]];
	                        }
	                        break;
	                    case 'a':
	                        formatOptions.designator = getValue('dayPeriods.format.wide', dateObject);
	                        break;
	                    case 'G':
	                        // eslint-disable-next-line
	                        var eText = (len <= 3) ? 'eraAbbr' : (len === 4) ? 'eraNames' : 'eraNarrow';
	                        formatOptions.era = getValue('eras.' + eText, dependable.dateObject);
	                        break;
	                    case 'z':
	                        formatOptions.timeZone = getValue('dates.timeZoneNames', dependable.parserObject);
	                        break;
	                }
	            }
	        }
	        return function (value) {
	            if (isNaN(value.getDate())) {
	                return null;
	            }
	            return _this.intDateFormatter(value, formatOptions);
	        };
	    };
	    /**
	     * Returns formatted date string based on options passed.
	     *
	     * @param {Date} value ?
	     * @param {FormatOptions} options ?
	     * @returns {string} ?
	     */
	    DateFormat.intDateFormatter = function (value, options) {
	        var pattern = options.pattern;
	        var ret = '';
	        var matches = pattern.match(IntlBase.dateParseRegex);
	        var dObject = this.getCurrentDateValue(value, options.isIslamic);
	        for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {
	            var match = matches_1[_i];
	            var length_1 = match.length;
	            var char = match[0];
	            if (char === 'K') {
	                char = 'h';
	            }
	            var curval = void 0;
	            var curvalstr = '';
	            var isNumber = void 0;
	            var processNumber = void 0;
	            var curstr = '';
	            switch (char) {
	                case 'M':
	                case 'L':
	                    curval = dObject.month;
	                    if (length_1 > 2) {
	                        // eslint-disable-next-line
	                        ret += options.month[curval];
	                    }
	                    else {
	                        isNumber = true;
	                    }
	                    break;
	                case 'E':
	                case 'c':
	                    // eslint-disable-next-line
	                    ret += options.weekday[weekdayKey[value.getDay()]];
	                    break;
	                case 'H':
	                case 'h':
	                case 'm':
	                case 's':
	                case 'd':
	                case 'f':
	                    isNumber = true;
	                    if (char === 'd') {
	                        curval = dObject.date;
	                    }
	                    else if (char === 'f') {
	                        isNumber = false;
	                        processNumber = true;
	                        // eslint-disable-next-line
	                        curvalstr = value[timeSetter$1[char]]().toString();
	                        curvalstr = curvalstr.substring(0, length_1);
	                        var curlength = curvalstr.length;
	                        if (length_1 !== curlength) {
	                            if (length_1 > 3) {
	                                continue;
	                            }
	                            for (var i = 0; i < length_1 - curlength; i++) {
	                                curvalstr = '0' + curvalstr.toString();
	                            }
	                        }
	                        curstr += curvalstr;
	                    }
	                    else {
	                        // eslint-disable-next-line
	                        curval = value[timeSetter$1[char]]();
	                    }
	                    if (char === 'h') {
	                        curval = curval % 12 || 12;
	                    }
	                    break;
	                case 'y':
	                    processNumber = true;
	                    curstr += dObject.year;
	                    if (length_1 === 2) {
	                        curstr = curstr.substr(curstr.length - 2);
	                    }
	                    break;
	                case 'a':
	                    // eslint-disable-next-line
	                    var desig = value.getHours() < 12 ? 'am' : 'pm';
	                    // eslint-disable-next-line
	                    ret += options.designator[desig];
	                    break;
	                case 'G':
	                    // eslint-disable-next-line
	                    var dec = value.getFullYear() < 0 ? 0 : 1;
	                    // eslint-disable-next-line
	                    var retu = options.era[dec];
	                    if (isNullOrUndefined(retu)) {
	                        // eslint-disable-next-line
	                        retu = options.era[dec ? 0 : 1];
	                    }
	                    ret += retu || '';
	                    break;
	                case '\'':
	                    ret += (match === '\'\'') ? '\'' : match.replace(/'/g, '');
	                    break;
	                case 'z':
	                    // eslint-disable-next-line
	                    var timezone = value.getTimezoneOffset();
	                    // eslint-disable-next-line
	                    var pattern_1 = (length_1 < 4) ? '+H;-H' : options.timeZone.hourFormat;
	                    pattern_1 = pattern_1.replace(/:/g, options.numMapper.timeSeparator);
	                    if (timezone === 0) {
	                        ret += options.timeZone.gmtZeroFormat;
	                    }
	                    else {
	                        processNumber = true;
	                        curstr = this.getTimeZoneValue(timezone, pattern_1);
	                    }
	                    curstr = options.timeZone.gmtFormat.replace(/\{0\}/, curstr);
	                    break;
	                case ':':
	                    // eslint-disable-next-line
	                    ret += options.numMapper.numberSymbols[timeSeparator];
	                    break;
	                case '/':
	                    ret += options.dateSeperator;
	                    break;
	                case 'W':
	                    isNumber = true;
	                    curval = IntlBase.getWeekOfYear(value);
	                    break;
	                default:
	                    ret += match;
	            }
	            if (isNumber) {
	                processNumber = true;
	                curstr = this.checkTwodigitNumber(curval, length_1);
	            }
	            if (processNumber) {
	                ret += ParserBase.convertValueParts(curstr, IntlBase.latnParseRegex, options.numMapper.mapper);
	            }
	        }
	        return ret;
	    };
	    DateFormat.getCurrentDateValue = function (value, isIslamic) {
	        if (isIslamic) {
	            return HijriParser.getHijriDate(value);
	        }
	        return { year: value.getFullYear(), month: value.getMonth() + 1, date: value.getDate() };
	    };
	    /**
	     * Returns two digit numbers for given value and length
	     *
	     * @param {number} val ?
	     * @param {number} len ?
	     * @returns {string} ?
	     */
	    DateFormat.checkTwodigitNumber = function (val, len) {
	        var ret = val + '';
	        if (len === 2 && ret.length !== 2) {
	            return '0' + ret;
	        }
	        return ret;
	    };
	    /**
	     * Returns the value of the Time Zone.
	     *
	     * @param {number} tVal ?
	     * @param {string} pattern ?
	     * @returns {string} ?
	     * @private
	     */
	    DateFormat.getTimeZoneValue = function (tVal, pattern) {
	        var _this = this;
	        var splt = pattern.split(';');
	        var curPattern = splt[tVal > 0 ? 1 : 0];
	        var no = Math.abs(tVal);
	        return curPattern = curPattern.replace(/HH?|mm/g, function (str) {
	            var len = str.length;
	            var ishour = str.indexOf('H') !== -1;
	            return _this.checkTwodigitNumber(Math.floor(ishour ? (no / 60) : (no % 60)), len);
	        });
	    };
	    return DateFormat;
	}());

	var errorText = {
	    'ms': 'minimumSignificantDigits',
	    'ls': 'maximumSignificantDigits',
	    'mf': 'minimumFractionDigits',
	    'lf': 'maximumFractionDigits'
	};
	var percentSign = 'percentSign';
	var minusSign = 'minusSign';
	var mapper$1 = ['infinity', 'nan', 'group', 'decimal', 'exponential'];
	/**
	 * Module for number formatting.
	 *
	 * @private
	 */
	var NumberFormat = /** @class */ (function () {
	    function NumberFormat() {
	    }
	    /**
	     * Returns the formatter function for given skeleton.
	     *
	     * @param {string} culture -  Specifies the culture name to be which formatting.
	     * @param {NumberFormatOptions} option - Specific the format in which number  will format.
	     * @param {Object} cldr - Specifies the global cldr data collection.
	     * @returns {Function} ?
	     */
	    NumberFormat.numberFormatter = function (culture, option, cldr) {
	        var _this = this;
	        var fOptions = extend({}, option);
	        var cOptions = {};
	        var dOptions = {};
	        var symbolPattern;
	        var dependable = IntlBase.getDependables(cldr, culture, '', true);
	        dependable.numericObject;
	        dOptions.numberMapper = ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr), true);
	        dOptions.currencySymbol = IntlBase.getCurrencySymbol(dependable.numericObject, fOptions.currency || defaultCurrencyCode, option.altSymbol);
	        /* eslint-disable  @typescript-eslint/no-explicit-any */
	        dOptions.percentSymbol = dOptions.numberMapper.numberSymbols["" + percentSign];
	        dOptions.minusSymbol = dOptions.numberMapper.numberSymbols["" + minusSign];
	        var symbols = dOptions.numberMapper.numberSymbols;
	        if ((option.format) && !(IntlBase.formatRegex.test(option.format))) {
	            cOptions = IntlBase.customFormat(option.format, dOptions, dependable.numericObject);
	        }
	        else {
	            extend(fOptions, IntlBase.getProperNumericSkeleton(option.format || 'N'));
	            fOptions.isCurrency = fOptions.type === 'currency';
	            fOptions.isPercent = fOptions.type === 'percent';
	            {
	                symbolPattern = IntlBase.getSymbolPattern(fOptions.type, dOptions.numberMapper.numberSystem, dependable.numericObject, fOptions.isAccount);
	            }
	            fOptions.groupOne = this.checkValueRange(fOptions.maximumSignificantDigits, fOptions.minimumSignificantDigits, true);
	            this.checkValueRange(fOptions.maximumFractionDigits, fOptions.minimumFractionDigits, false, true);
	            if (!isUndefined(fOptions.fractionDigits)) {
	                fOptions.minimumFractionDigits = fOptions.maximumFractionDigits = fOptions.fractionDigits;
	            }
	            if (isUndefined(fOptions.useGrouping)) {
	                fOptions.useGrouping = true;
	            }
	            if (fOptions.isCurrency && !isBlazor()) {
	                symbolPattern = symbolPattern.replace(/\u00A4/g, IntlBase.defaultCurrency);
	            }
	            {
	                var split = symbolPattern.split(';');
	                cOptions.nData = IntlBase.getFormatData(split[1] || '-' + split[0], true, dOptions.currencySymbol);
	                cOptions.pData = IntlBase.getFormatData(split[0], false, dOptions.currencySymbol);
	                if (fOptions.useGrouping) {
	                    fOptions.groupSeparator = symbols[mapper$1[2]];
	                    fOptions.groupData = this.getGroupingDetails(split[0]);
	                }
	            }
	            var minFrac = isUndefined(fOptions.minimumFractionDigits);
	            if (minFrac) {
	                fOptions.minimumFractionDigits = cOptions.nData.minimumFraction;
	            }
	            if (isUndefined(fOptions.maximumFractionDigits)) {
	                var mval = cOptions.nData.maximumFraction;
	                fOptions.maximumFractionDigits = isUndefined(mval) && fOptions.isPercent ? 0 : mval;
	            }
	            var mfrac = fOptions.minimumFractionDigits;
	            var lfrac = fOptions.maximumFractionDigits;
	            if (!isUndefined(mfrac) && !isUndefined(lfrac)) {
	                if (mfrac > lfrac) {
	                    fOptions.maximumFractionDigits = mfrac;
	                }
	            }
	        }
	        extend(cOptions.nData, fOptions);
	        extend(cOptions.pData, fOptions);
	        return function (value) {
	            if (isNaN(value)) {
	                return symbols[mapper$1[1]];
	            }
	            else if (!isFinite(value)) {
	                return symbols[mapper$1[0]];
	            }
	            return _this.intNumberFormatter(value, cOptions, dOptions, option);
	        };
	    };
	    /**
	     * Returns grouping details for the pattern provided
	     *
	     * @param {string} pattern ?
	     * @returns {GroupDetails} ?
	     */
	    NumberFormat.getGroupingDetails = function (pattern) {
	        var ret = {};
	        var match = pattern.match(IntlBase.negativeDataRegex);
	        if (match && match[4]) {
	            var pattern_1 = match[4];
	            var p = pattern_1.lastIndexOf(',');
	            if (p !== -1) {
	                var temp = pattern_1.split('.')[0];
	                ret.primary = (temp.length - p) - 1;
	                var s = pattern_1.lastIndexOf(',', p - 1);
	                if (s !== -1) {
	                    ret.secondary = p - 1 - s;
	                }
	            }
	        }
	        return ret;
	    };
	    /**
	     * Returns if the provided integer range is valid.
	     *
	     * @param {number} val1 ?
	     * @param {number} val2 ?
	     * @param {boolean} checkbothExist ?
	     * @param {boolean} isFraction ?
	     * @returns {boolean} ?
	     */
	    NumberFormat.checkValueRange = function (val1, val2, checkbothExist, isFraction) {
	        var decide = isFraction ? 'f' : 's';
	        var dint = 0;
	        var str1 = errorText['l' + decide];
	        // eslint-disable-next-line
	        var str2 = errorText['m' + decide];
	        if (!isUndefined(val1)) {
	            this.checkRange(val1, str1, isFraction);
	            dint++;
	        }
	        if (!isUndefined(val2)) {
	            this.checkRange(val2, str2, isFraction);
	            dint++;
	        }
	        if (dint === 2) {
	            if (val1 < val2) {
	                throwError(str2 + 'specified must be less than the' + str1);
	            }
	            else {
	                return true;
	            }
	        }
	        else if (checkbothExist && dint === 1) {
	            throwError('Both' + str2 + 'and' + str2 + 'must be present');
	        }
	        return false;
	    };
	    /**
	     * Check if the provided fraction range is valid
	     *
	     * @param {number} val ?
	     * @param {string} text ?
	     * @param {boolean} isFraction ?
	     * @returns {void} ?
	     */
	    NumberFormat.checkRange = function (val, text, isFraction) {
	        var range = isFraction ? [0, 20] : [1, 21];
	        if (val < range[0] || val > range[1]) {
	            throwError(text + 'value must be within the range' + range[0] + 'to' + range[1]);
	        }
	    };
	    /**
	     * Returns formatted numeric string for provided formatting options
	     *
	     * @param {number} value ?
	     * @param {base.GenericFormatOptions} fOptions ?
	     * @param {CommonOptions} dOptions ?
	     * @returns {string} ?
	     */
	    NumberFormat.intNumberFormatter = function (value, fOptions, dOptions, option) {
	        var curData;
	        if (isUndefined(fOptions.nData.type)) {
	            return undefined;
	        }
	        else {
	            if (value < 0) {
	                value = value * -1;
	                curData = fOptions.nData;
	            }
	            else if (value === 0) {
	                curData = fOptions.zeroData || fOptions.pData;
	            }
	            else {
	                curData = fOptions.pData;
	            }
	            var fValue = '';
	            if (curData.isPercent) {
	                value = value * 100;
	            }
	            if (curData.groupOne) {
	                fValue = this.processSignificantDigits(value, curData.minimumSignificantDigits, curData.maximumSignificantDigits);
	            }
	            else {
	                fValue = this.processFraction(value, curData.minimumFractionDigits, curData.maximumFractionDigits, option);
	                if (curData.minimumIntegerDigits) {
	                    fValue = this.processMinimumIntegers(fValue, curData.minimumIntegerDigits);
	                }
	                if (dOptions.isCustomFormat && curData.minimumFractionDigits < curData.maximumFractionDigits
	                    && /\d+\.\d+/.test(fValue)) {
	                    var temp = fValue.split('.');
	                    var decimalPart = temp[1];
	                    var len = decimalPart.length;
	                    for (var i = len - 1; i >= 0; i--) {
	                        if (decimalPart["" + i] === '0' && i >= curData.minimumFractionDigits) {
	                            decimalPart = decimalPart.slice(0, i);
	                        }
	                        else {
	                            break;
	                        }
	                    }
	                    fValue = temp[0] + '.' + decimalPart;
	                }
	            }
	            if (curData.type === 'scientific') {
	                fValue = value.toExponential(curData.maximumFractionDigits);
	                fValue = fValue.replace('e', dOptions.numberMapper.numberSymbols[mapper$1[4]]);
	            }
	            fValue = fValue.replace('.', dOptions.numberMapper.numberSymbols[mapper$1[3]]);
	            fValue = curData.format === "#,###,,;(#,###,,)" ? this.customPivotFormat(parseInt(fValue)) : fValue;
	            if (curData.useGrouping) {
	                /* eslint-disable  @typescript-eslint/no-explicit-any */
	                fValue = this.groupNumbers(fValue, curData.groupData.primary, curData.groupSeparator || ',', dOptions.numberMapper.numberSymbols[mapper$1[3]] || '.', curData.groupData.secondary);
	            }
	            fValue = ParserBase.convertValueParts(fValue, IntlBase.latnParseRegex, dOptions.numberMapper.mapper);
	            if (curData.nlead === 'N/A') {
	                return curData.nlead;
	            }
	            else {
	                if (fValue === '0' && option && option.format === '0') {
	                    return fValue + curData.nend;
	                }
	                return curData.nlead + fValue + curData.nend;
	            }
	        }
	    };
	    /**
	     * Returns significant digits processed numeric string
	     *
	     * @param {number} value ?
	     * @param {number} min ?
	     * @param {number} max ?
	     * @returns {string} ?
	     */
	    NumberFormat.processSignificantDigits = function (value, min, max) {
	        var temp = value + '';
	        var tn;
	        var length = temp.length;
	        if (length < min) {
	            return value.toPrecision(min);
	        }
	        else {
	            temp = value.toPrecision(max);
	            tn = +temp;
	            return tn + '';
	        }
	    };
	    /**
	     * Returns grouped numeric string
	     *
	     * @param {string} val ?
	     * @param {number} level1 ?
	     * @param {string} sep ?
	     * @param {string} decimalSymbol ?
	     * @param {number} level2 ?
	     * @returns {string} ?
	     */
	    NumberFormat.groupNumbers = function (val, level1, sep, decimalSymbol, level2) {
	        var flag = !isNullOrUndefined(level2) && level2 !== 0;
	        var split = val.split(decimalSymbol);
	        var prefix = split[0];
	        var length = prefix.length;
	        var str = '';
	        while (length > level1) {
	            str = prefix.slice(length - level1, length) + (str.length ?
	                (sep + str) : '');
	            length -= level1;
	            if (flag) {
	                level1 = level2;
	                flag = false;
	            }
	        }
	        split[0] = prefix.slice(0, length) + (str.length ? sep : '') + str;
	        return split.join(decimalSymbol);
	    };
	    /**
	     * Returns fraction processed numeric string
	     *
	     * @param {number} value ?
	     * @param {number} min ?
	     * @param {number} max ?
	     * @returns {string} ?
	     */
	    NumberFormat.processFraction = function (value, min, max, option) {
	        var temp = (value + '').split('.')[1];
	        var length = temp ? temp.length : 0;
	        if (min && length < min) {
	            var ret = '';
	            if (length === 0) {
	                ret = value.toFixed(min);
	            }
	            else {
	                ret += value;
	                for (var j = 0; j < min - length; j++) {
	                    ret += '0';
	                }
	                return ret;
	            }
	            return value.toFixed(min);
	        }
	        else if (!isNullOrUndefined(max) && (length > max || max === 0)) {
	            return value.toFixed(max);
	        }
	        var str = value + '';
	        if (str[0] === '0' && option && option.format === '###.00') {
	            str = str.slice(1);
	        }
	        return str;
	    };
	    /**
	     * Returns integer processed numeric string
	     *
	     * @param {string} value ?
	     * @param {number} min ?
	     * @returns {string} ?
	     */
	    NumberFormat.processMinimumIntegers = function (value, min) {
	        var temp = value.split('.');
	        var lead = temp[0];
	        var len = lead.length;
	        if (len < min) {
	            for (var i = 0; i < min - len; i++) {
	                lead = '0' + lead;
	            }
	            temp[0] = lead;
	        }
	        return temp.join('.');
	    };
	    /**
	     * Returns custom format for pivot table
	     *
	     * @param {number} value ?
	     */
	    NumberFormat.customPivotFormat = function (value) {
	        if (value >= 500000) {
	            value /= 1000000;
	            var _a = value.toString().split("."); _a[0]; var decimal = _a[1];
	            return decimal && +decimal.substring(0, 1) >= 5
	                ? Math.ceil(value).toString()
	                : Math.floor(value).toString();
	        }
	        return "";
	    };
	    return NumberFormat;
	}());

	var standalone = 'stand-alone';
	var latnRegex = /^[0-9]*$/;
	var timeSetter = {
	    minute: 'setMinutes',
	    hour: 'setHours',
	    second: 'setSeconds',
	    day: 'setDate',
	    month: 'setMonth',
	    milliseconds: 'setMilliseconds'
	};
	var month = 'months';
	/* tslint:disable no-any */
	/**
	 * Date Parser.
	 *
	 * @private
	 */
	var DateParser = /** @class */ (function () {
	    function DateParser() {
	    }
	    /**
	     * Returns the parser function for given skeleton.
	     *
	     * @param {string} culture -  Specifies the culture name to be which formatting.
	     * @param {DateFormatOptions} option - Specific the format in which string date  will be parsed.
	     * @param {Object} cldr - Specifies the global cldr data collection.
	     * @returns {Function} ?
	     */
	    DateParser.dateParser = function (culture, option, cldr) {
	        var _this = this;
	        var dependable = IntlBase.getDependables(cldr, culture, option.calendar);
	        var numOptions = ParserBase.getCurrentNumericOptions(dependable.parserObject, ParserBase.getNumberingSystem(cldr), false, isBlazor());
	        var parseOptions = {};
	        var resPattern = option.format ||
	            IntlBase.getResultantPattern(option.skeleton, dependable.dateObject, option.type, false, '');
	        var regexString = '';
	        var hourOnly;
	        if (isUndefined(resPattern)) {
	            throwError('Format options or type given must be invalid');
	        }
	        else {
	            resPattern = IntlBase.ConvertDateToWeekFormat(resPattern);
	            parseOptions = { isIslamic: IntlBase.islamicRegex.test(option.calendar), pattern: resPattern, evalposition: {}, culture: culture };
	            var patternMatch = resPattern.match(IntlBase.dateParseRegex) || [];
	            var length_1 = patternMatch.length;
	            var gmtCorrection = 0;
	            var zCorrectTemp = 0;
	            var isgmtTraversed = false;
	            var nRegx = numOptions.numericRegex;
	            // eslint-disable-next-line
	            var numMapper = ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr));
	            for (var i = 0; i < length_1; i++) {
	                var str = patternMatch[parseInt(i.toString(), 10)];
	                var len = str.length;
	                var char = (str[0] === 'K') ? 'h' : str[0];
	                var isNumber = void 0;
	                var canUpdate = void 0;
	                // eslint-disable-next-line
	                var charKey = datePartMatcher[char];
	                var optional = (len === 2) ? '' : '?';
	                if (isgmtTraversed) {
	                    gmtCorrection = zCorrectTemp;
	                    isgmtTraversed = false;
	                }
	                switch (char) {
	                    case 'E':
	                    case 'c':
	                        // eslint-disable-next-line
	                        var weekData = void 0;
	                        {
	                            // eslint-disable-next-line
	                            weekData = dependable.dateObject[IntlBase.days][standalone][IntlBase.monthIndex[len]];
	                        }
	                        // eslint-disable-next-line
	                        var weekObject = ParserBase.reverseObject(weekData);
	                        // tslint:enable
	                        regexString += '(' + Object.keys(weekObject).join('|') + ')';
	                        break;
	                    case 'M':
	                    case 'L':
	                    case 'd':
	                    case 'm':
	                    case 's':
	                    case 'h':
	                    case 'H':
	                    case 'f':
	                        canUpdate = true;
	                        if ((char === 'M' || char === 'L') && len > 2) {
	                            var monthData = void 0;
	                            {
	                                // eslint-disable-next-line
	                                monthData = dependable.dateObject[month][standalone][IntlBase.monthIndex[len]];
	                            }
	                            // eslint-disable-next-line
	                            parseOptions[charKey] = ParserBase.reverseObject(monthData);
	                            // eslint-disable-next-line
	                            regexString += '(' + Object.keys(parseOptions[charKey]).join('|') + ')';
	                        }
	                        else if (char === 'f') {
	                            if (len > 3) {
	                                continue;
	                            }
	                            isNumber = true;
	                            regexString += '(' + nRegx + nRegx + '?' + nRegx + '?' + ')';
	                        }
	                        else {
	                            isNumber = true;
	                            regexString += '(' + nRegx + nRegx + optional + ')';
	                        }
	                        if (char === 'h') {
	                            parseOptions.hour12 = true;
	                        }
	                        break;
	                    case 'W':
	                        // eslint-disable-next-line
	                        var opt = len === 1 ? '?' : '';
	                        regexString += '(' + nRegx + opt + nRegx + ')';
	                        break;
	                    case 'y':
	                        canUpdate = isNumber = true;
	                        if (len === 2) {
	                            regexString += '(' + nRegx + nRegx + ')';
	                        }
	                        else {
	                            regexString += '(' + nRegx + '{' + len + ',})';
	                        }
	                        break;
	                    case 'a':
	                        canUpdate = true;
	                        // eslint-disable-next-line
	                        var periodValur = getValue('dayPeriods.format.wide', dependable.dateObject);
	                        // eslint-disable-next-line
	                        parseOptions[charKey] = ParserBase.reverseObject(periodValur);
	                        // eslint-disable-next-line
	                        regexString += '(' + Object.keys(parseOptions[charKey]).join('|') + ')';
	                        break;
	                    case 'G':
	                        canUpdate = true;
	                        // eslint-disable-next-line
	                        var eText = (len <= 3) ? 'eraAbbr' : (len === 4) ? 'eraNames' : 'eraNarrow';
	                        // eslint-disable-next-line
	                        parseOptions[charKey] = ParserBase.reverseObject(getValue('eras.' + eText, dependable.dateObject));
	                        // eslint-disable-next-line
	                        regexString += '(' + Object.keys(parseOptions[charKey]).join('|') + '?)';
	                        break;
	                    case 'z':
	                        // eslint-disable-next-line
	                        var tval = new Date().getTimezoneOffset();
	                        canUpdate = (tval !== 0);
	                        // eslint-disable-next-line
	                        parseOptions[charKey] = getValue('dates.timeZoneNames', dependable.parserObject);
	                        // eslint-disable-next-line
	                        var tzone = parseOptions[charKey];
	                        hourOnly = (len < 4);
	                        // eslint-disable-next-line
	                        var hpattern = hourOnly ? '+H;-H' : tzone.hourFormat;
	                        hpattern = hpattern.replace(/:/g, numMapper.timeSeparator);
	                        regexString += '(' + this.parseTimeZoneRegx(hpattern, tzone, nRegx) + ')?';
	                        isgmtTraversed = true;
	                        zCorrectTemp = hourOnly ? 6 : 12;
	                        break;
	                    case '\'':
	                        // eslint-disable-next-line
	                        var iString = str.replace(/'/g, '');
	                        regexString += '(' + iString + ')?';
	                        break;
	                    default:
	                        regexString += '([\\D])';
	                        break;
	                }
	                if (canUpdate) {
	                    parseOptions.evalposition["" + charKey] = { isNumber: isNumber, pos: i + 1 + gmtCorrection, hourOnly: hourOnly };
	                }
	                if (i === length_1 - 1 && !isNullOrUndefined(regexString)) {
	                    var regExp = RegExp;
	                    parseOptions.parserRegex = new regExp('^' + regexString + '$', 'i');
	                }
	            }
	        }
	        return function (value) {
	            var parsedDateParts = _this.internalDateParse(value, parseOptions, numOptions);
	            if (isNullOrUndefined(parsedDateParts) || !Object.keys(parsedDateParts).length) {
	                return null;
	            }
	            if (parseOptions.isIslamic) {
	                var dobj = {};
	                var tYear = parsedDateParts.year;
	                var tDate = parsedDateParts.day;
	                var tMonth = parsedDateParts.month;
	                var ystrig = tYear ? (tYear + '') : '';
	                var is2DigitYear = (ystrig.length === 2);
	                if (!tYear || !tMonth || !tDate || is2DigitYear) {
	                    dobj = HijriParser.getHijriDate(new Date());
	                }
	                if (is2DigitYear) {
	                    tYear = parseInt((dobj.year + '').slice(0, 2) + ystrig, 10);
	                }
	                // tslint:disable-next-line
	                var dateObject = HijriParser.toGregorian(tYear || dobj.year, tMonth || dobj.month, tDate || dobj.date);
	                parsedDateParts.year = dateObject.getFullYear();
	                parsedDateParts.month = dateObject.getMonth() + 1;
	                parsedDateParts.day = dateObject.getDate();
	            }
	            return _this.getDateObject(parsedDateParts);
	        };
	    };
	    /* tslint:disable */
	    /**
	     * Returns date object for provided date options
	     *
	     * @param {DateParts} options ?
	     * @param {Date} value ?
	     * @returns {Date} ?
	     */
	    DateParser.getDateObject = function (options, value) {
	        var res = value || new Date();
	        res.setMilliseconds(0);
	        var tKeys = ['hour', 'minute', 'second', 'milliseconds', 'month', 'day'];
	        var y = options.year;
	        var desig = options.designator;
	        var tzone = options.timeZone;
	        if (!isUndefined(y)) {
	            var len = (y + '').length;
	            if (len <= 2) {
	                var century = Math.floor(res.getFullYear() / 100) * 100;
	                y += century;
	            }
	            res.setFullYear(y);
	        }
	        for (var _i = 0, tKeys_1 = tKeys; _i < tKeys_1.length; _i++) {
	            var key = tKeys_1[_i];
	            // eslint-disable-next-line
	            var tValue = options[key];
	            if (isUndefined(tValue) && key === 'day') {
	                res.setDate(1);
	            }
	            if (!isUndefined(tValue)) {
	                if (key === 'month') {
	                    tValue -= 1;
	                    if (tValue < 0 || tValue > 11) {
	                        return new Date('invalid');
	                    }
	                    var pDate = res.getDate();
	                    res.setDate(1);
	                    // eslint-disable-next-line
	                    res[timeSetter[key]](tValue);
	                    var lDate = new Date(res.getFullYear(), tValue + 1, 0).getDate();
	                    res.setDate(pDate < lDate ? pDate : lDate);
	                }
	                else {
	                    if (key === 'day') {
	                        var lastDay = new Date(res.getFullYear(), res.getMonth() + 1, 0).getDate();
	                        if ((tValue < 1 || tValue > lastDay)) {
	                            return null;
	                        }
	                    }
	                    // eslint-disable-next-line
	                    res[timeSetter[key]](tValue);
	                }
	            }
	        }
	        if (!isUndefined(desig)) {
	            var hour = res.getHours();
	            if (desig === 'pm') {
	                res.setHours(hour + (hour === 12 ? 0 : 12));
	            }
	            else if (hour === 12) {
	                res.setHours(0);
	            }
	        }
	        if (!isUndefined(tzone)) {
	            var tzValue = tzone - res.getTimezoneOffset();
	            if (tzValue !== 0) {
	                res.setMinutes(res.getMinutes() + tzValue);
	            }
	        }
	        return res;
	    };
	    /**
	     * Returns date parsing options for provided value along with parse and numeric options
	     *
	     * @param {string} value ?
	     * @param {ParseOptions} parseOptions ?
	     * @param {NumericOptions} num ?
	     * @returns {DateParts} ?
	     */
	    DateParser.internalDateParse = function (value, parseOptions, num) {
	        var matches = value.match(parseOptions.parserRegex);
	        var retOptions = { 'hour': 0, 'minute': 0, 'second': 0 };
	        if (isNullOrUndefined(matches)) {
	            return null;
	        }
	        else {
	            var props = Object.keys(parseOptions.evalposition);
	            for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {
	                var prop = props_1[_i];
	                var curObject = parseOptions.evalposition["" + prop];
	                var matchString = matches[curObject.pos];
	                if (curObject.isNumber) {
	                    // eslint-disable-next-line
	                    retOptions[prop] = this.internalNumberParser(matchString, num);
	                }
	                else {
	                    if (prop === 'timeZone' && !isUndefined(matchString)) {
	                        var pos = curObject.pos;
	                        var val = void 0;
	                        var tmatch = matches[pos + 1];
	                        var flag = !isUndefined(tmatch);
	                        if (curObject.hourOnly) {
	                            val = this.getZoneValue(flag, tmatch, matches[pos + 4], num) * 60;
	                        }
	                        else {
	                            val = this.getZoneValue(flag, tmatch, matches[pos + 7], num) * 60;
	                            val += this.getZoneValue(flag, matches[pos + 4], matches[pos + 10], num);
	                        }
	                        if (!isNullOrUndefined(val)) {
	                            retOptions["" + prop] = val;
	                        }
	                    }
	                    else {
	                        // eslint-disable-next-line
	                        matchString = ((prop === 'month') && (!parseOptions.isIslamic) && (parseOptions.culture === 'en' || parseOptions.culture === 'en-GB' || parseOptions.culture === 'en-US'))
	                            ? matchString[0].toUpperCase() + matchString.substring(1).toLowerCase() : matchString;
	                        // eslint-disable-next-line
	                        retOptions[prop] = parseOptions[prop][matchString];
	                    }
	                }
	            }
	            if (parseOptions.hour12) {
	                retOptions.hour12 = true;
	            }
	        }
	        return retOptions;
	    };
	    /**
	     * Returns parsed number for provided Numeric string and Numeric Options
	     *
	     * @param {string} value ?
	     * @param {NumericOptions} option ?
	     * @returns {number} ?
	     */
	    DateParser.internalNumberParser = function (value, option) {
	        value = ParserBase.convertValueParts(value, option.numberParseRegex, option.numericPair);
	        if (latnRegex.test(value)) {
	            return +value;
	        }
	        return null;
	    };
	    /**
	     * Returns parsed time zone RegExp for provided hour format and time zone
	     *
	     * @param {string} hourFormat ?
	     * @param {base.TimeZoneOptions} tZone ?
	     * @param {string} nRegex ?
	     * @returns {string} ?
	     */
	    DateParser.parseTimeZoneRegx = function (hourFormat, tZone, nRegex) {
	        var pattern = tZone.gmtFormat;
	        var ret;
	        var cRegex = '(' + nRegex + ')' + '(' + nRegex + ')';
	        var splitStr;
	        ret = hourFormat.replace('+', '\\+');
	        if (hourFormat.indexOf('HH') !== -1) {
	            ret = ret.replace(/HH|mm/g, '(' + cRegex + ')');
	        }
	        else {
	            ret = ret.replace(/H|m/g, '(' + cRegex + '?)');
	        }
	        // eslint-disable-next-line
	        splitStr = (ret.split(';').map(function (str) {
	            return pattern.replace('{0}', str);
	        }));
	        ret = splitStr.join('|') + '|' + tZone.gmtZeroFormat;
	        return ret;
	    };
	    /**
	     * Returns zone based value.
	     *
	     * @param {boolean} flag ?
	     * @param {string} val1 ?
	     * @param {string} val2 ?
	     * @param {NumericOptions} num ?
	     * @returns {number} ?
	     */
	    DateParser.getZoneValue = function (flag, val1, val2, num) {
	        var ival = flag ? val1 : val2;
	        if (!ival) {
	            return 0;
	        }
	        var value = this.internalNumberParser(ival, num);
	        if (flag) {
	            return -value;
	        }
	        return value;
	    };
	    return DateParser;
	}());

	var regExp$1 = RegExp;
	var parseRegex = new regExp$1('^([^0-9]*)' + '(([0-9,]*[0-9]+)(\.[0-9]+)?)' + '([Ee][+-]?[0-9]+)?([^0-9]*)$');
	var groupRegex = /,/g;
	var keys = ['minusSign', 'infinity'];
	/**
	 * Module for Number Parser.
	 *
	 * @private
	 */
	var NumberParser = /** @class */ (function () {
	    function NumberParser() {
	    }
	    /**
	     * Returns the parser function for given skeleton.
	     *
	     * @param {string} culture -  Specifies the culture name to be which formatting.
	     * @param {NumberFormatOptions} option - Specific the format in which number  will parsed.
	     * @param {Object} cldr - Specifies the global cldr data collection.
	     * @returns {Function} ?
	     */
	    NumberParser.numberParser = function (culture, option, cldr) {
	        var _this = this;
	        var dependable = IntlBase.getDependables(cldr, culture, '', true);
	        var parseOptions = { custom: true };
	        var numOptions;
	        if ((IntlBase.formatRegex.test(option.format)) || !(option.format)) {
	            extend(parseOptions, IntlBase.getProperNumericSkeleton(option.format || 'N'));
	            parseOptions.custom = false;
	            if (!parseOptions.fractionDigits) {
	                if (option.maximumFractionDigits) {
	                    parseOptions.maximumFractionDigits = option.maximumFractionDigits;
	                }
	            }
	        }
	        else {
	            extend(parseOptions, IntlBase.customFormat(option.format, null, null));
	        }
	        getValue('numbers', dependable.parserObject);
	        // eslint-disable-next-line
	        numOptions = ParserBase.getCurrentNumericOptions(dependable.parserObject, ParserBase.getNumberingSystem(cldr), true, isBlazor());
	        parseOptions.symbolRegex = ParserBase.getSymbolRegex(Object.keys(numOptions.symbolMatch));
	        // eslint-disable-next-line
	        parseOptions.infinity = numOptions.symbolNumberSystem[keys[1]];
	        var symbolpattern;
	        {
	            symbolpattern = IntlBase.getSymbolPattern(parseOptions.type, numOptions.numberSystem, dependable.numericObject, parseOptions.isAccount);
	            if (symbolpattern) {
	                symbolpattern = symbolpattern.replace(/\u00A4/g, IntlBase.defaultCurrency);
	                var split = symbolpattern.split(';');
	                parseOptions.nData = IntlBase.getFormatData(split[1] || '-' + split[0], true, '');
	                parseOptions.pData = IntlBase.getFormatData(split[0], true, '');
	            }
	        }
	        return function (value) {
	            return _this.getParsedNumber(value, parseOptions, numOptions);
	        };
	    };
	    /**
	     * Returns parsed number for the provided formatting options
	     *
	     * @param {string} value ?
	     * @param {NumericParts} options ?
	     * @param {NumericOptions} numOptions ?
	     * @returns {number} ?
	     */
	    NumberParser.getParsedNumber = function (value, options, numOptions) {
	        var isNegative;
	        var isPercent;
	        var tempValue;
	        var lead;
	        var end;
	        var ret;
	        if (value.indexOf(options.infinity) !== -1) {
	            return Infinity;
	        }
	        else {
	            value = ParserBase.convertValueParts(value, options.symbolRegex, numOptions.symbolMatch);
	            value = ParserBase.convertValueParts(value, numOptions.numberParseRegex, numOptions.numericPair);
	            value = value.indexOf('-') !== -1 ? value.replace('-.', '-0.') : value;
	            if (value.indexOf('.') === 0) {
	                value = '0' + value;
	            }
	            var matches = value.match(parseRegex);
	            if (isNullOrUndefined(matches)) {
	                return NaN;
	            }
	            lead = matches[1];
	            tempValue = matches[2];
	            var exponent = matches[5];
	            end = matches[6];
	            isNegative = options.custom ? ((lead === options.nData.nlead) && (end === options.nData.nend)) :
	                ((lead.indexOf(options.nData.nlead) !== -1) && (end.indexOf(options.nData.nend) !== -1));
	            isPercent = isNegative ?
	                options.nData.isPercent :
	                options.pData.isPercent;
	            tempValue = tempValue.replace(groupRegex, '');
	            if (exponent) {
	                tempValue += exponent;
	            }
	            ret = +tempValue;
	            if (options.type === 'percent' || isPercent) {
	                ret = ret / 100;
	            }
	            if (options.custom || options.fractionDigits) {
	                ret = parseFloat(ret.toFixed(options.custom ?
	                    (isNegative ? options.nData.maximumFractionDigits : options.pData.maximumFractionDigits) : options.fractionDigits));
	            }
	            if (options.maximumFractionDigits) {
	                ret = this.convertMaxFracDigits(tempValue, options, ret, isNegative);
	            }
	            if (isNegative) {
	                ret *= -1;
	            }
	            return ret;
	        }
	    };
	    NumberParser.convertMaxFracDigits = function (value, options, ret, isNegative) {
	        var decimalSplitValue = value.split('.');
	        if (decimalSplitValue[1] && decimalSplitValue[1].length > options.maximumFractionDigits) {
	            ret = +(ret.toFixed(options.custom ?
	                (isNegative ? options.nData.maximumFractionDigits : options.pData.maximumFractionDigits) : options.maximumFractionDigits));
	        }
	        return ret;
	    };
	    return NumberParser;
	}());

	var Observer = /** @class */ (function () {
	    function Observer(context) {
	        this.ranArray = [];
	        this.boundedEvents = {};
	        if (isNullOrUndefined(context)) {
	            return;
	        }
	        this.context = context;
	    }
	    /**
	     * To attach handler for given property in current context.
	     *
	     * @param {string} property - specifies the name of the event.
	     * @param {Function} handler - Specifies the handler function to be called while event notified.
	     * @param {Object} context - Specifies the context binded to the handler.
	     * @param {string} id - specifies the random generated id.
	     * @returns {void}
	     */
	    Observer.prototype.on = function (property, handler, context, id) {
	        if (isNullOrUndefined(handler)) {
	            return;
	        }
	        var cntxt = context || this.context;
	        if (this.notExist(property)) {
	            this.boundedEvents["" + property] = [{ handler: handler, context: cntxt }];
	            return;
	        }
	        if (!isNullOrUndefined(id)) {
	            if (this.ranArray.indexOf(id) === -1) {
	                this.ranArray.push(id);
	                this.boundedEvents["" + property].push({ handler: handler, context: cntxt, id: id });
	            }
	        }
	        else if (!this.isHandlerPresent(this.boundedEvents["" + property], handler)) {
	            this.boundedEvents["" + property].push({ handler: handler, context: cntxt });
	        }
	    };
	    /**
	     * To remove handlers from a event attached using on() function.
	     *
	     * @param {string} property - specifies the name of the event.
	     * @param {Function} handler - Optional argument specifies the handler function to be called while event notified.
	     * @param {string} id - specifies the random generated id.
	     * @returns {void} ?
	     */
	    Observer.prototype.off = function (property, handler, id) {
	        if (this.notExist(property)) {
	            return;
	        }
	        var curObject = getValue(property, this.boundedEvents);
	        if (handler) {
	            for (var i = 0; i < curObject.length; i++) {
	                if (id) {
	                    if (curObject[parseInt(i.toString(), 10)].id === id) {
	                        curObject.splice(i, 1);
	                        var indexLocation = this.ranArray.indexOf(id);
	                        if (indexLocation !== -1) {
	                            this.ranArray.splice(indexLocation, 1);
	                        }
	                        break;
	                    }
	                }
	                else if (handler === curObject[parseInt(i.toString(), 10)].handler) {
	                    curObject.splice(i, 1);
	                    break;
	                }
	            }
	        }
	        else {
	            delete this.boundedEvents["" + property];
	        }
	    };
	    /**
	     * To notify the handlers in the specified event.
	     *
	     * @param {string} property - Specifies the event to be notify.
	     * @param {Object} argument - Additional parameters to pass while calling the handler.
	     * @param {Function} successHandler - this function will invoke after event successfully triggered
	     * @param {Function} errorHandler - this function will invoke after event if it was failure to call.
	     * @returns {void} ?
	     */
	    Observer.prototype.notify = function (property, argument, successHandler, errorHandler) {
	        if (this.notExist(property)) {
	            if (successHandler) {
	                successHandler.call(this, argument);
	            }
	            return;
	        }
	        if (argument) {
	            argument.name = property;
	        }
	        var blazor = 'Blazor';
	        var curObject = getValue(property, this.boundedEvents).slice(0);
	        if (window["" + blazor]) {
	            return this.blazorCallback(curObject, argument, successHandler, errorHandler, 0);
	        }
	        else {
	            for (var _i = 0, curObject_1 = curObject; _i < curObject_1.length; _i++) {
	                var cur = curObject_1[_i];
	                cur.handler.call(cur.context, argument);
	            }
	            if (successHandler) {
	                successHandler.call(this, argument);
	            }
	        }
	    };
	    Observer.prototype.blazorCallback = function (objs, argument, successHandler, errorHandler, index) {
	        var _this = this;
	        var isTrigger = index === objs.length - 1;
	        if (index < objs.length) {
	            var obj_1 = objs[parseInt(index.toString(), 10)];
	            var promise = obj_1.handler.call(obj_1.context, argument);
	            if (promise && typeof promise.then === 'function') {
	                if (!successHandler) {
	                    return promise;
	                }
	                promise.then(function (data) {
	                    data = typeof data === 'string' && _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data;
	                    extend(argument, argument, data, true);
	                    if (successHandler && isTrigger) {
	                        successHandler.call(obj_1.context, argument);
	                    }
	                    else {
	                        return _this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);
	                    }
	                }).catch(function (data) {
	                    if (errorHandler) {
	                        errorHandler.call(obj_1.context, typeof data === 'string' &&
	                            _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data);
	                    }
	                });
	            }
	            else if (successHandler && isTrigger) {
	                successHandler.call(obj_1.context, argument);
	            }
	            else {
	                return this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);
	            }
	        }
	    };
	    // eslint-disable-next-line
	    Observer.prototype.dateReviver = function (key, value) {
	        var dPattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;
	        if (isBlazor && typeof value === 'string' && value.match(dPattern) !== null) {
	            return (new Date(value));
	        }
	        return (value);
	    };
	    Observer.prototype.isJson = function (value) {
	        try {
	            JSON.parse(value);
	        }
	        catch (e) {
	            return false;
	        }
	        return true;
	    };
	    /**
	     * To destroy handlers in the event
	     *
	     * @returns {void} ?
	     */
	    Observer.prototype.destroy = function () {
	        this.boundedEvents = this.context = undefined;
	    };
	    /**
	     * Returns if the property exists.
	     *
	     * @param {string} prop ?
	     * @returns {boolean} ?
	     */
	    Observer.prototype.notExist = function (prop) {
	        // eslint-disable-next-line
	        return this.boundedEvents.hasOwnProperty(prop) === false || this.boundedEvents[prop].length <= 0;
	    };
	    /**
	     * Returns if the handler is present.
	     *
	     * @param {BoundOptions[]} boundedEvents ?
	     * @param {Function} handler ?
	     * @returns {boolean} ?
	     */
	    Observer.prototype.isHandlerPresent = function (boundedEvents, handler) {
	        for (var _i = 0, boundedEvents_1 = boundedEvents; _i < boundedEvents_1.length; _i++) {
	            var cur = boundedEvents_1[_i];
	            if (cur.handler === handler) {
	                return true;
	            }
	        }
	        return false;
	    };
	    return Observer;
	}());

	/**
	 * Specifies the observer used for external change detection.
	 */
	var onIntlChange = new Observer();
	/**
	 * Specifies the default rtl status for EJ2 components.
	 */
	var rightToLeft = false;
	/**
	 * Specifies the CLDR data loaded for internationalization functionalities.
	 *
	 * @private
	 */
	var cldrData = {};
	/**
	 * Specifies the default culture value to be considered.
	 *
	 * @private
	 */
	var defaultCulture = 'en-US';
	/**
	 * Specifies default currency code to be considered
	 *
	 * @private
	 */
	var defaultCurrencyCode = 'USD';
	var mapper = ['numericObject', 'dateObject'];
	/**
	 * Internationalization class provides support to parse and format the number and date object to the desired format.
	 * ```typescript
	 * // To set the culture globally
	 * setCulture('en-GB');
	 *
	 * // To set currency code globally
	 * setCurrencyCode('EUR');
	 *
	 * //Load cldr data
	 * loadCldr(gregorainData);
	 * loadCldr(timeZoneData);
	 * loadCldr(numbersData);
	 * loadCldr(numberSystemData);
	 *
	 * // To use formatter in component side
	 * let Intl:Internationalization = new Internationalization();
	 *
	 * // Date formatting
	 * let dateFormatter: Function = Intl.getDateFormat({skeleton:'long',type:'dateTime'});
	 * dateFormatter(new Date('11/2/2016'));
	 * dateFormatter(new Date('25/2/2030'));
	 * Intl.formatDate(new Date(),{skeleton:'E'});
	 *
	 * //Number formatting
	 * let numberFormatter: Function = Intl.getNumberFormat({skeleton:'C5'})
	 * numberFormatter(24563334);
	 * Intl.formatNumber(123123,{skeleton:'p2'});
	 *
	 * // Date parser
	 * let dateParser: Function = Intl.getDateParser({skeleton:'short',type:'time'});
	 * dateParser('10:30 PM');
	 * Intl.parseDate('10',{skeleton:'H'});
	 * ```
	 */
	var Internationalization = /** @class */ (function () {
	    function Internationalization(cultureName) {
	        if (cultureName) {
	            this.culture = cultureName;
	        }
	    }
	    /**
	     * Returns the format function for given options.
	     *
	     * @param {DateFormatOptions} options - Specifies the format options in which the format function will return.
	     * @returns {Function} ?
	     */
	    Internationalization.prototype.getDateFormat = function (options) {
	        return DateFormat.dateFormat(this.getCulture(), options || { type: 'date', skeleton: 'short' }, cldrData);
	    };
	    /**
	     * Returns the format function for given options.
	     *
	     * @param {NumberFormatOptions} options - Specifies the format options in which the format function will return.
	     * @returns {Function} ?
	     */
	    Internationalization.prototype.getNumberFormat = function (options) {
	        if (options && !options.currency) {
	            options.currency = defaultCurrencyCode;
	        }
	        return NumberFormat.numberFormatter(this.getCulture(), options || {}, cldrData);
	    };
	    /**
	     * Returns the parser function for given options.
	     *
	     * @param {DateFormatOptions} options - Specifies the format options in which the parser function will return.
	     * @returns {Function} ?
	     */
	    Internationalization.prototype.getDateParser = function (options) {
	        return DateParser.dateParser(this.getCulture(), options || { skeleton: 'short', type: 'date' }, cldrData);
	    };
	    /**
	     * Returns the parser function for given options.
	     *
	     * @param {NumberFormatOptions} options - Specifies the format options in which the parser function will return.
	     * @returns {Function} ?
	     */
	    Internationalization.prototype.getNumberParser = function (options) {
	        return NumberParser.numberParser(this.getCulture(), options || { format: 'N' }, cldrData);
	    };
	    /**
	     * Returns the formatted string based on format options.
	     *
	     * @param {number} value - Specifies the number to format.
	     * @param {NumberFormatOptions} option - Specifies the format options in which the number will be formatted.
	     * @returns {string} ?
	     */
	    Internationalization.prototype.formatNumber = function (value, option) {
	        return this.getNumberFormat(option)(value);
	    };
	    /**
	     * Returns the formatted date string based on format options.
	     *
	     * @param {Date} value - Specifies the number to format.
	     * @param {DateFormatOptions} option - Specifies the format options in which the number will be formatted.
	     * @returns {string} ?
	     */
	    Internationalization.prototype.formatDate = function (value, option) {
	        return this.getDateFormat(option)(value);
	    };
	    /**
	     * Returns the date object for given date string and options.
	     *
	     * @param {string} value - Specifies the string to parse.
	     * @param {DateFormatOptions} option - Specifies the parse options in which the date string will be parsed.
	     * @returns {Date} ?
	     */
	    Internationalization.prototype.parseDate = function (value, option) {
	        return this.getDateParser(option)(value);
	    };
	    /**
	     * Returns the number object from the given string value and options.
	     *
	     * @param {string} value - Specifies the string to parse.
	     * @param {NumberFormatOptions} option - Specifies the parse options in which the  string number  will be parsed.
	     * @returns {number} ?
	     */
	    Internationalization.prototype.parseNumber = function (value, option) {
	        return this.getNumberParser(option)(value);
	    };
	    /**
	     * Returns Native Date Time Pattern
	     *
	     * @param {DateFormatOptions} option - Specifies the parse options for resultant date time pattern.
	     * @param {boolean} isExcelFormat - Specifies format value to be converted to excel pattern.
	     * @returns {string} ?
	     * @private
	     */
	    Internationalization.prototype.getDatePattern = function (option, isExcelFormat) {
	        return IntlBase.getActualDateTimeFormat(this.getCulture(), option, cldrData, isExcelFormat);
	    };
	    /**
	     * Returns Native Number Pattern
	     *
	     * @param {NumberFormatOptions} option - Specifies the parse options for resultant number pattern.
	     * @param {boolean} isExcel ?
	     * @returns {string} ?
	     * @private
	     */
	    Internationalization.prototype.getNumberPattern = function (option, isExcel) {
	        return IntlBase.getActualNumberFormat(this.getCulture(), option, cldrData, isExcel);
	    };
	    /**
	     * Returns the First Day of the Week
	     *
	     * @returns {number} ?
	     */
	    Internationalization.prototype.getFirstDayOfWeek = function () {
	        return IntlBase.getWeekData(this.getCulture(), cldrData);
	    };
	    /**
	     * Returns the culture
	     *
	     * @returns {string} ?
	     */
	    Internationalization.prototype.getCulture = function () {
	        return this.culture || defaultCulture;
	    };
	    return Internationalization;
	}());
	/**
	 * To get the default date CLDR object.
	 *
	 * @param {string} mode ?
	 * @returns {Object} ?
	 * @ignore
	 * @private
	 */
	function getDefaultDateObject(mode) {
	    // eslint-disable-next-line
	    return IntlBase.getDependables(cldrData, '', mode, false)[mapper[1]];
	}

	var regExp = RegExp;
	var blazorCultureFormats = {
	    'en-US': {
	        'd': 'M/d/y',
	        'D': 'EEEE, MMMM d, y',
	        'f': 'EEEE, MMMM d, y h:mm a',
	        'F': 'EEEE, MMMM d, y h:mm:s a',
	        'g': 'M/d/y h:mm a',
	        'G': 'M/d/yyyy h:mm:ss tt',
	        'm': 'MMMM d',
	        'M': 'MMMM d',
	        'r': 'ddd, dd MMM yyyy HH\':\'mm\':\'ss \'GMT\'',
	        'R': 'ddd, dd MMM yyyy HH\':\'mm\':\'ss \'GMT\'',
	        's': 'yyyy\'-\'MM\'-\'dd\'T\'HH\':\'mm\':\'ss',
	        't': 'h:mm tt',
	        'T': 'h:m:s tt',
	        'u': 'yyyy\'-\'MM\'-\'dd HH\':\'mm\':\'ss\'Z\'',
	        'U': 'dddd, MMMM d, yyyy h:mm:ss tt',
	        'y': 'MMMM yyyy',
	        'Y': 'MMMM yyyy'
	    }
	};
	/**
	 * Date base common constants and function for date parser and formatter.
	 */
	// eslint-disable-next-line
	var IntlBase;
	(function (IntlBase) {
	    /* eslint-disable */
	    // tslint:disable-next-line:max-line-length.
	    IntlBase.negativeDataRegex = /^(('[^']+'|''|[^*#@0,.E])*)(\*.)?((([#,]*[0,]*0+)(\.0*[0-9]*#*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;
	    IntlBase.customRegex = /^(('[^']+'|''|[^*#@0,.])*)(\*.)?((([0#,]*[0,]*[0#]*[0#\ ]*)(\.[0#]*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;
	    IntlBase.latnParseRegex = /0|1|2|3|4|5|6|7|8|9/g;
	    var fractionRegex = /[0-9]/g;
	    IntlBase.defaultCurrency = '$';
	    var mapper = ['infinity', 'nan', 'group', 'decimal'];
	    var patternRegex = /G|M|L|H|c|'| a|yy|y|EEEE|E/g;
	    var patternMatch = {
	        'G': '',
	        'M': 'm',
	        'L': 'm',
	        'H': 'h',
	        'c': 'd',
	        '\'': '"',
	        ' a': ' AM/PM',
	        'yy': 'yy',
	        'y': 'yyyy',
	        'EEEE': 'dddd',
	        'E': 'ddd'
	    };
	    IntlBase.dateConverterMapper = /dddd|ddd/ig;
	    var defaultFirstDay = 'sun';
	    IntlBase.islamicRegex = /^islamic/;
	    var firstDayMapper = {
	        'sun': 0,
	        'mon': 1,
	        'tue': 2,
	        'wed': 3,
	        'thu': 4,
	        'fri': 5,
	        'sat': 6
	    };
	    IntlBase.formatRegex = new regExp("(^[ncpae]{1})([0-1]?[0-9]|20)?$", "i");
	    IntlBase.currencyFormatRegex = new regExp("(^[ca]{1})([0-1]?[0-9]|20)?$", "i");
	    IntlBase.curWithoutNumberRegex = /(c|a)$/ig;
	    var typeMapper = {
	        '$': 'isCurrency',
	        '%': 'isPercent',
	        '-': 'isNegative',
	        0: 'nlead',
	        1: 'nend'
	    };
	    IntlBase.dateParseRegex = /([a-z])\1*|'([^']|'')+'|''|./gi;
	    IntlBase.basicPatterns = ['short', 'medium', 'long', 'full'];
	    /* tslint:disable:quotemark */
	    IntlBase.defaultObject = {
	        'dates': {
	            'calendars': {
	                'gregorian': {
	                    'months': {
	                        'stand-alone': {
	                            'abbreviated': {
	                                '1': 'Jan',
	                                '2': 'Feb',
	                                '3': 'Mar',
	                                '4': 'Apr',
	                                '5': 'May',
	                                '6': 'Jun',
	                                '7': 'Jul',
	                                '8': 'Aug',
	                                '9': 'Sep',
	                                '10': 'Oct',
	                                '11': 'Nov',
	                                '12': 'Dec'
	                            },
	                            'narrow': {
	                                '1': 'J',
	                                '2': 'F',
	                                '3': 'M',
	                                '4': 'A',
	                                '5': 'M',
	                                '6': 'J',
	                                '7': 'J',
	                                '8': 'A',
	                                '9': 'S',
	                                '10': 'O',
	                                '11': 'N',
	                                '12': 'D'
	                            },
	                            'wide': {
	                                '1': 'January',
	                                '2': 'February',
	                                '3': 'March',
	                                '4': 'April',
	                                '5': 'May',
	                                '6': 'June',
	                                '7': 'July',
	                                '8': 'August',
	                                '9': 'September',
	                                '10': 'October',
	                                '11': 'November',
	                                '12': 'December'
	                            }
	                        }
	                    },
	                    'days': {
	                        'stand-alone': {
	                            'abbreviated': {
	                                'sun': 'Sun',
	                                'mon': 'Mon',
	                                'tue': 'Tue',
	                                'wed': 'Wed',
	                                'thu': 'Thu',
	                                'fri': 'Fri',
	                                'sat': 'Sat'
	                            },
	                            'narrow': {
	                                'sun': 'S',
	                                'mon': 'M',
	                                'tue': 'T',
	                                'wed': 'W',
	                                'thu': 'T',
	                                'fri': 'F',
	                                'sat': 'S'
	                            },
	                            'short': {
	                                'sun': 'Su',
	                                'mon': 'Mo',
	                                'tue': 'Tu',
	                                'wed': 'We',
	                                'thu': 'Th',
	                                'fri': 'Fr',
	                                'sat': 'Sa'
	                            },
	                            'wide': {
	                                'sun': 'Sunday',
	                                'mon': 'Monday',
	                                'tue': 'Tuesday',
	                                'wed': 'Wednesday',
	                                'thu': 'Thursday',
	                                'fri': 'Friday',
	                                'sat': 'Saturday'
	                            }
	                        }
	                    },
	                    'dayPeriods': {
	                        'format': {
	                            'wide': {
	                                'am': 'AM',
	                                'pm': 'PM'
	                            }
	                        }
	                    },
	                    'eras': {
	                        'eraNames': {
	                            '0': 'Before Christ',
	                            '0-alt-variant': 'Before Common Era',
	                            '1': 'Anno Domini',
	                            '1-alt-variant': 'Common Era'
	                        },
	                        'eraAbbr': {
	                            '0': 'BC',
	                            '0-alt-variant': 'BCE',
	                            '1': 'AD',
	                            '1-alt-variant': 'CE'
	                        },
	                        'eraNarrow': {
	                            '0': 'B',
	                            '0-alt-variant': 'BCE',
	                            '1': 'A',
	                            '1-alt-variant': 'CE'
	                        }
	                    },
	                    'dateFormats': {
	                        'full': 'EEEE, MMMM d, y',
	                        'long': 'MMMM d, y',
	                        'medium': 'MMM d, y',
	                        'short': 'M/d/yy'
	                    },
	                    'timeFormats': {
	                        'full': 'h:mm:ss a zzzz',
	                        'long': 'h:mm:ss a z',
	                        'medium': 'h:mm:ss a',
	                        'short': 'h:mm a'
	                    },
	                    'dateTimeFormats': {
	                        'full': '{1} \'at\' {0}',
	                        'long': '{1} \'at\' {0}',
	                        'medium': '{1}, {0}',
	                        'short': '{1}, {0}',
	                        'availableFormats': {
	                            'd': 'd',
	                            'E': 'ccc',
	                            'Ed': 'd E',
	                            'Ehm': 'E h:mm a',
	                            'EHm': 'E HH:mm',
	                            'Ehms': 'E h:mm:ss a',
	                            'EHms': 'E HH:mm:ss',
	                            'Gy': 'y G',
	                            'GyMMM': 'MMM y G',
	                            'GyMMMd': 'MMM d, y G',
	                            'GyMMMEd': 'E, MMM d, y G',
	                            'h': 'h a',
	                            'H': 'HH',
	                            'hm': 'h:mm a',
	                            'Hm': 'HH:mm',
	                            'hms': 'h:mm:ss a',
	                            'Hms': 'HH:mm:ss',
	                            'hmsv': 'h:mm:ss a v',
	                            'Hmsv': 'HH:mm:ss v',
	                            'hmv': 'h:mm a v',
	                            'Hmv': 'HH:mm v',
	                            'M': 'L',
	                            'Md': 'M/d',
	                            'MEd': 'E, M/d',
	                            'MMM': 'LLL',
	                            'MMMd': 'MMM d',
	                            'MMMEd': 'E, MMM d',
	                            'MMMMd': 'MMMM d',
	                            'ms': 'mm:ss',
	                            'y': 'y',
	                            'yM': 'M/y',
	                            'yMd': 'M/d/y',
	                            'yMEd': 'E, M/d/y',
	                            'yMMM': 'MMM y',
	                            'yMMMd': 'MMM d, y',
	                            'yMMMEd': 'E, MMM d, y',
	                            'yMMMM': 'MMMM y'
	                        }
	                    }
	                },
	                'islamic': {
	                    'months': {
	                        'stand-alone': {
	                            'abbreviated': {
	                                '1': 'Muh.',
	                                '2': 'Saf.',
	                                '3': 'Rab. I',
	                                '4': 'Rab. II',
	                                '5': 'Jum. I',
	                                '6': 'Jum. II',
	                                '7': 'Raj.',
	                                '8': 'Sha.',
	                                '9': 'Ram.',
	                                '10': 'Shaw.',
	                                '11': 'Dhuʻl-Q.',
	                                '12': 'Dhuʻl-H.'
	                            },
	                            'narrow': {
	                                '1': '1',
	                                '2': '2',
	                                '3': '3',
	                                '4': '4',
	                                '5': '5',
	                                '6': '6',
	                                '7': '7',
	                                '8': '8',
	                                '9': '9',
	                                '10': '10',
	                                '11': '11',
	                                '12': '12'
	                            },
	                            'wide': {
	                                '1': 'Muharram',
	                                '2': 'Safar',
	                                '3': 'Rabiʻ I',
	                                '4': 'Rabiʻ II',
	                                '5': 'Jumada I',
	                                '6': 'Jumada II',
	                                '7': 'Rajab',
	                                '8': 'Shaʻban',
	                                '9': 'Ramadan',
	                                '10': 'Shawwal',
	                                '11': 'Dhuʻl-Qiʻdah',
	                                '12': 'Dhuʻl-Hijjah'
	                            }
	                        }
	                    },
	                    'days': {
	                        'stand-alone': {
	                            'abbreviated': {
	                                'sun': 'Sun',
	                                'mon': 'Mon',
	                                'tue': 'Tue',
	                                'wed': 'Wed',
	                                'thu': 'Thu',
	                                'fri': 'Fri',
	                                'sat': 'Sat'
	                            },
	                            'narrow': {
	                                'sun': 'S',
	                                'mon': 'M',
	                                'tue': 'T',
	                                'wed': 'W',
	                                'thu': 'T',
	                                'fri': 'F',
	                                'sat': 'S'
	                            },
	                            'short': {
	                                'sun': 'Su',
	                                'mon': 'Mo',
	                                'tue': 'Tu',
	                                'wed': 'We',
	                                'thu': 'Th',
	                                'fri': 'Fr',
	                                'sat': 'Sa'
	                            },
	                            'wide': {
	                                'sun': 'Sunday',
	                                'mon': 'Monday',
	                                'tue': 'Tuesday',
	                                'wed': 'Wednesday',
	                                'thu': 'Thursday',
	                                'fri': 'Friday',
	                                'sat': 'Saturday'
	                            }
	                        }
	                    },
	                    'dayPeriods': {
	                        'format': {
	                            'wide': {
	                                'am': 'AM',
	                                'pm': 'PM'
	                            }
	                        }
	                    },
	                    'eras': {
	                        'eraNames': {
	                            '0': 'AH'
	                        },
	                        'eraAbbr': {
	                            '0': 'AH'
	                        },
	                        'eraNarrow': {
	                            '0': 'AH'
	                        }
	                    },
	                    'dateFormats': {
	                        'full': 'EEEE, MMMM d, y G',
	                        'long': 'MMMM d, y G',
	                        'medium': 'MMM d, y G',
	                        'short': 'M/d/y GGGGG'
	                    },
	                    'timeFormats': {
	                        'full': 'h:mm:ss a zzzz',
	                        'long': 'h:mm:ss a z',
	                        'medium': 'h:mm:ss a',
	                        'short': 'h:mm a'
	                    },
	                    'dateTimeFormats': {
	                        'full': '{1} \'at\' {0}',
	                        'long': '{1} \'at\' {0}',
	                        'medium': '{1}, {0}',
	                        'short': '{1}, {0}',
	                        'availableFormats': {
	                            'd': 'd',
	                            'E': 'ccc',
	                            'Ed': 'd E',
	                            'Ehm': 'E h:mm a',
	                            'EHm': 'E HH:mm',
	                            'Ehms': 'E h:mm:ss a',
	                            'EHms': 'E HH:mm:ss',
	                            'Gy': 'y G',
	                            'GyMMM': 'MMM y G',
	                            'GyMMMd': 'MMM d, y G',
	                            'GyMMMEd': 'E, MMM d, y G',
	                            'h': 'h a',
	                            'H': 'HH',
	                            'hm': 'h:mm a',
	                            'Hm': 'HH:mm',
	                            'hms': 'h:mm:ss a',
	                            'Hms': 'HH:mm:ss',
	                            'M': 'L',
	                            'Md': 'M/d',
	                            'MEd': 'E, M/d',
	                            'MMM': 'LLL',
	                            'MMMd': 'MMM d',
	                            'MMMEd': 'E, MMM d',
	                            'MMMMd': 'MMMM d',
	                            'ms': 'mm:ss',
	                            'y': 'y G',
	                            'yyyy': 'y G',
	                            'yyyyM': 'M/y GGGGG',
	                            'yyyyMd': 'M/d/y GGGGG',
	                            'yyyyMEd': 'E, M/d/y GGGGG',
	                            'yyyyMMM': 'MMM y G',
	                            'yyyyMMMd': 'MMM d, y G',
	                            'yyyyMMMEd': 'E, MMM d, y G',
	                            'yyyyMMMM': 'MMMM y G',
	                            'yyyyQQQ': 'QQQ y G',
	                            'yyyyQQQQ': 'QQQQ y G'
	                        }
	                    }
	                }
	            },
	            'timeZoneNames': {
	                'hourFormat': '+HH:mm;-HH:mm',
	                'gmtFormat': 'GMT{0}',
	                'gmtZeroFormat': 'GMT'
	            }
	        },
	        'numbers': {
	            'currencies': {
	                'USD': {
	                    'displayName': 'US Dollar',
	                    'symbol': '$',
	                    'symbol-alt-narrow': '$'
	                },
	                'EUR': {
	                    'displayName': 'Euro',
	                    'symbol': '€',
	                    'symbol-alt-narrow': '€'
	                },
	                'GBP': {
	                    'displayName': 'British Pound',
	                    'symbol-alt-narrow': '£'
	                }
	            },
	            'defaultNumberingSystem': 'latn',
	            'minimumGroupingDigits': '1',
	            'symbols-numberSystem-latn': {
	                'decimal': '.',
	                'group': ',',
	                'list': ';',
	                'percentSign': '%',
	                'plusSign': '+',
	                'minusSign': '-',
	                'exponential': 'E',
	                'superscriptingExponent': '×',
	                'perMille': '‰',
	                'infinity': '∞',
	                'nan': 'NaN',
	                'timeSeparator': ':'
	            },
	            'decimalFormats-numberSystem-latn': {
	                'standard': '#,##0.###'
	            },
	            'percentFormats-numberSystem-latn': {
	                'standard': '#,##0%'
	            },
	            'currencyFormats-numberSystem-latn': {
	                'standard': '¤#,##0.00',
	                'accounting': '¤#,##0.00;(¤#,##0.00)'
	            },
	            'scientificFormats-numberSystem-latn': {
	                'standard': '#E0'
	            }
	        }
	    };
	    IntlBase.blazorDefaultObject = {
	        'numbers': {
	            'mapper': {
	                '0': '0',
	                '1': '1',
	                '2': '2',
	                '3': '3',
	                '4': '4',
	                '5': '5',
	                '6': '6',
	                '7': '7',
	                '8': '8',
	                '9': '9'
	            },
	            'mapperDigits': '0123456789',
	            'numberSymbols': {
	                'decimal': '.',
	                'group': ',',
	                'plusSign': '+',
	                'minusSign': '-',
	                'percentSign': '%',
	                'nan': 'NaN',
	                'timeSeparator': ':',
	                'infinity': '∞'
	            },
	            'timeSeparator': ':',
	            'currencySymbol': '$',
	            'currencypData': {
	                'nlead': '$',
	                'nend': '',
	                'groupSeparator': ',',
	                'groupData': {
	                    'primary': 3
	                },
	                'maximumFraction': 2,
	                'minimumFraction': 2
	            },
	            'percentpData': {
	                'nlead': '',
	                'nend': '%',
	                'groupSeparator': ',',
	                'groupData': {
	                    'primary': 3
	                },
	                'maximumFraction': 2,
	                'minimumFraction': 2
	            },
	            'percentnData': {
	                'nlead': '-',
	                'nend': '%',
	                'groupSeparator': ',',
	                'groupData': {
	                    'primary': 3
	                },
	                'maximumFraction': 2,
	                'minimumFraction': 2
	            },
	            'currencynData': {
	                'nlead': '($',
	                'nend': ')',
	                'groupSeparator': ',',
	                'groupData': {
	                    'primary': 3
	                },
	                'maximumFraction': 2,
	                'minimumFraction': 2
	            },
	            'decimalnData': {
	                'nlead': '-',
	                'nend': '',
	                'groupData': {
	                    'primary': 3
	                },
	                'maximumFraction': 2,
	                'minimumFraction': 2
	            },
	            'decimalpData': {
	                'nlead': '',
	                'nend': '',
	                'groupData': {
	                    'primary': 3
	                },
	                'maximumFraction': 2,
	                'minimumFraction': 2
	            }
	        },
	        'dates': {
	            'dayPeriods': {
	                'am': 'AM',
	                'pm': 'PM'
	            },
	            'dateSeperator': '/',
	            'days': {
	                'abbreviated': {
	                    'sun': 'Sun',
	                    'mon': 'Mon',
	                    'tue': 'Tue',
	                    'wed': 'Wed',
	                    'thu': 'Thu',
	                    'fri': 'Fri',
	                    'sat': 'Sat'
	                },
	                'short': {
	                    'sun': 'Su',
	                    'mon': 'Mo',
	                    'tue': 'Tu',
	                    'wed': 'We',
	                    'thu': 'Th',
	                    'fri': 'Fr',
	                    'sat': 'Sa'
	                },
	                'wide': {
	                    'sun': 'Sunday',
	                    'mon': 'Monday',
	                    'tue': 'Tuesday',
	                    'wed': 'Wednesday',
	                    'thu': 'Thursday',
	                    'fri': 'Friday',
	                    'sat': 'Saturday'
	                }
	            },
	            'months': {
	                'abbreviated': {
	                    '1': 'Jan',
	                    '2': 'Feb',
	                    '3': 'Mar',
	                    '4': 'Apr',
	                    '5': 'May',
	                    '6': 'Jun',
	                    '7': 'Jul',
	                    '8': 'Aug',
	                    '9': 'Sep',
	                    '10': 'Oct',
	                    '11': 'Nov',
	                    '12': 'Dec'
	                },
	                'wide': {
	                    '1': 'January',
	                    '2': 'February',
	                    '3': 'March',
	                    '4': 'April',
	                    '5': 'May',
	                    '6': 'June',
	                    '7': 'July',
	                    '8': 'August',
	                    '9': 'September',
	                    '10': 'October',
	                    '11': 'November',
	                    '12': 'December'
	                }
	            },
	            'eras': {
	                '1': 'AD'
	            }
	        }
	    };
	    /* tslint:enable:quotemark */
	    IntlBase.monthIndex = {
	        3: 'abbreviated',
	        4: 'wide',
	        5: 'narrow',
	        1: 'abbreviated'
	    };
	    /**
	     *
	     */
	    IntlBase.month = 'months';
	    IntlBase.days = 'days';
	    /**
	     * Default numerber Object
	     */
	    IntlBase.patternMatcher = {
	        C: 'currency',
	        P: 'percent',
	        N: 'decimal',
	        A: 'currency',
	        E: 'scientific'
	    };
	    /**
	     * Returns the resultant pattern based on the skeleton, dateObject and the type provided
	     *
	     * @private
	     * @param {string} skeleton ?
	     * @param {Object} dateObject ?
	     * @param {string} type ?
	     * @param {boolean} isIslamic ?
	     * @param {string} blazorCulture ?
	     * @returns {string} ?
	     */
	    function getResultantPattern(skeleton, dateObject, type, isIslamic, blazorCulture) {
	        var resPattern;
	        var iType = type || 'date';
	        if (blazorCulture) {
	            resPattern = compareBlazorDateFormats({ skeleton: skeleton }, blazorCulture).format ||
	                compareBlazorDateFormats({ skeleton: 'd' }, 'en-US').format;
	        }
	        else {
	            if (IntlBase.basicPatterns.indexOf(skeleton) !== -1) {
	                resPattern = getValue(iType + 'Formats.' + skeleton, dateObject);
	                if (iType === 'dateTime') {
	                    var dPattern = getValue('dateFormats.' + skeleton, dateObject);
	                    var tPattern = getValue('timeFormats.' + skeleton, dateObject);
	                    resPattern = resPattern.replace('{1}', dPattern).replace('{0}', tPattern);
	                }
	            }
	            else {
	                resPattern = getValue('dateTimeFormats.availableFormats.' + skeleton, dateObject);
	            }
	            if (isUndefined(resPattern) && skeleton === 'yMd') {
	                resPattern = 'M/d/y';
	            }
	        }
	        return resPattern;
	    }
	    IntlBase.getResultantPattern = getResultantPattern;
	    /**
	     * Returns the dependable object for provided cldr data and culture
	     *
	     * @private
	     * @param {Object} cldr ?
	     * @param {string} culture ?
	     * @param {string} mode ?
	     * @param {boolean} isNumber ?
	     * @returns {any} ?
	     */
	    function getDependables(cldr, culture, mode, isNumber) {
	        var ret = {};
	        var calendartype = mode || 'gregorian';
	        ret.parserObject = ParserBase.getMainObject(cldr, culture) || (IntlBase.defaultObject);
	        if (isNumber) {
	            ret.numericObject = getValue('numbers', ret.parserObject);
	        }
	        else {
	            var dateString = ('dates.calendars.' + calendartype);
	            ret.dateObject = getValue(dateString, ret.parserObject);
	        }
	        return ret;
	    }
	    IntlBase.getDependables = getDependables;
	    /**
	     * Returns the symbol pattern for provided parameters
	     *
	     * @private
	     * @param {string} type ?
	     * @param {string} numSystem ?
	     * @param {Object} obj ?
	     * @param {boolean} isAccount ?
	     * @returns {string} ?
	     */
	    function getSymbolPattern(type, numSystem, obj, isAccount) {
	        return getValue(type + 'Formats-numberSystem-' +
	            numSystem + (isAccount ? '.accounting' : '.standard'), obj) || (isAccount ? getValue(type + 'Formats-numberSystem-' +
	            numSystem + '.standard', obj) : '');
	    }
	    IntlBase.getSymbolPattern = getSymbolPattern;
	    /**
	     *
	     * @param {string} format ?
	     * @returns {string} ?
	     */
	    function ConvertDateToWeekFormat(format) {
	        var convertMapper = format.match(IntlBase.dateConverterMapper);
	        if (convertMapper && isBlazor()) {
	            var tempString = convertMapper[0].length === 3 ? 'EEE' : 'EEEE';
	            return format.replace(IntlBase.dateConverterMapper, tempString);
	        }
	        return format;
	    }
	    IntlBase.ConvertDateToWeekFormat = ConvertDateToWeekFormat;
	    /**
	     *
	     * @param {DateFormatOptions} formatOptions ?
	     * @param {string} culture ?
	     * @returns {DateFormatOptions} ?
	     */
	    function compareBlazorDateFormats(formatOptions, culture) {
	        var format = formatOptions.format || formatOptions.skeleton;
	        var curFormatMapper = getValue((culture || 'en-US') + '.' + format, blazorCultureFormats);
	        if (!curFormatMapper) {
	            curFormatMapper = getValue('en-US.' + format, blazorCultureFormats);
	        }
	        if (curFormatMapper) {
	            curFormatMapper = ConvertDateToWeekFormat(curFormatMapper);
	            formatOptions.format = curFormatMapper.replace(/tt/, 'a');
	        }
	        return formatOptions;
	    }
	    IntlBase.compareBlazorDateFormats = compareBlazorDateFormats;
	    /**
	     * Returns proper numeric skeleton
	     *
	     * @private
	     * @param {string} skeleton ?
	     * @returns {any} ?
	     */
	    function getProperNumericSkeleton(skeleton) {
	        var matches = skeleton.match(IntlBase.formatRegex);
	        var ret = {};
	        var pattern = matches[1].toUpperCase();
	        ret.isAccount = (pattern === 'A');
	        // eslint-disable-next-line
	        ret.type = IntlBase.patternMatcher[pattern];
	        if (skeleton.length > 1) {
	            ret.fractionDigits = parseInt(matches[2], 10);
	        }
	        return ret;
	    }
	    IntlBase.getProperNumericSkeleton = getProperNumericSkeleton;
	    /**
	     * Returns format data for number formatting like minimum fraction, maximum fraction, etc..,
	     *
	     * @private
	     * @param {string} pattern ?
	     * @param {boolean} needFraction ?
	     * @param {string} cSymbol ?
	     * @param {boolean} fractionOnly ?
	     * @returns {any} ?
	     */
	    function getFormatData(pattern, needFraction, cSymbol, fractionOnly) {
	        var nData = fractionOnly ? {} : { nlead: '', nend: '' };
	        var match = pattern.match(IntlBase.customRegex);
	        if (match) {
	            if (!fractionOnly) {
	                nData.nlead = changeCurrencySymbol(match[1], cSymbol);
	                nData.nend = changeCurrencySymbol(match[10], cSymbol);
	                nData.groupPattern = match[4];
	            }
	            var fraction = match[7];
	            if (fraction && needFraction) {
	                var fmatch = fraction.match(fractionRegex);
	                if (!isNullOrUndefined(fmatch)) {
	                    nData.minimumFraction = fmatch.length;
	                }
	                else {
	                    nData.minimumFraction = 0;
	                }
	                nData.maximumFraction = fraction.length - 1;
	            }
	        }
	        return nData;
	    }
	    IntlBase.getFormatData = getFormatData;
	    /**
	     * Changes currency symbol
	     *
	     * @private
	     * @param {string} val ?
	     * @param {string} sym ?
	     * @returns {string} ?
	     */
	    function changeCurrencySymbol(val, sym) {
	        if (val) {
	            return val.replace(IntlBase.defaultCurrency, sym);
	        }
	        return '';
	    }
	    IntlBase.changeCurrencySymbol = changeCurrencySymbol;
	    /**
	     * Returns currency symbol based on currency code ?
	     *
	     * @private
	     * @param {Object} numericObject ?
	     * @param {string} currencyCode ?
	     * @param {string} altSymbol ?
	     * @returns {string} ?
	     */
	    function getCurrencySymbol(numericObject, currencyCode, altSymbol) {
	        var symbol = altSymbol ? ('.' + altSymbol) : '.symbol';
	        var getCurrency = getValue('currencies.' + currencyCode + symbol, numericObject) ||
	            getValue('currencies.' + currencyCode + '.symbol-alt-narrow', numericObject) || '$';
	        return getCurrency;
	    }
	    IntlBase.getCurrencySymbol = getCurrencySymbol;
	    /**
	     * Returns formatting options for custom number format
	     *
	     * @private
	     * @param {string} format ?
	     * @param {CommonOptions} dOptions ?
	     * @param {any} obj ?
	     * @returns {any} ?
	     */
	    function customFormat(format, dOptions, obj) {
	        var options = {};
	        var formatSplit = format.split(';');
	        var data = ['pData', 'nData', 'zeroData'];
	        for (var i = 0; i < formatSplit.length; i++) {
	            // eslint-disable-next-line
	            options[data[i]] = customNumberFormat(formatSplit[i], dOptions, obj);
	        }
	        if (isNullOrUndefined(options.nData)) {
	            options.nData = extend({}, options.pData);
	            options.nData.nlead = isNullOrUndefined(dOptions) ? '-' + options.nData.nlead : dOptions.minusSymbol + options.nData.nlead;
	        }
	        return options;
	    }
	    IntlBase.customFormat = customFormat;
	    /**
	     * Returns custom formatting options
	     *
	     * @private
	     * @param {string} format ?
	     * @param {CommonOptions} dOptions ?
	     * @param {Object} numObject ?
	     * @returns {any} ?
	     */
	    function customNumberFormat(format, dOptions, numObject) {
	        var cOptions = { type: 'decimal', minimumFractionDigits: 0, maximumFractionDigits: 0 };
	        var pattern = format.match(IntlBase.customRegex);
	        if (isNullOrUndefined(pattern) || (pattern[5] === '' && format !== 'N/A')) {
	            cOptions.type = undefined;
	            return cOptions;
	        }
	        cOptions.nlead = pattern[1];
	        cOptions.nend = pattern[10];
	        var integerPart = pattern[6];
	        var spaceCapture = integerPart.match(/\ $/g) ? true : false;
	        var spaceGrouping = integerPart.replace(/\ $/g, '').indexOf(' ') !== -1;
	        cOptions.useGrouping = integerPart.indexOf(',') !== -1 || spaceGrouping;
	        integerPart = integerPart.replace(/,/g, '');
	        var fractionPart = pattern[7];
	        if (integerPart.indexOf('0') !== -1) {
	            cOptions.minimumIntegerDigits = integerPart.length - integerPart.indexOf('0');
	        }
	        if (!isNullOrUndefined(fractionPart)) {
	            cOptions.minimumFractionDigits = fractionPart.lastIndexOf('0');
	            cOptions.maximumFractionDigits = fractionPart.lastIndexOf('#');
	            if (cOptions.minimumFractionDigits === -1) {
	                cOptions.minimumFractionDigits = 0;
	            }
	            if (cOptions.maximumFractionDigits === -1 || cOptions.maximumFractionDigits < cOptions.minimumFractionDigits) {
	                cOptions.maximumFractionDigits = cOptions.minimumFractionDigits;
	            }
	        }
	        if (!isNullOrUndefined(dOptions)) {
	            dOptions.isCustomFormat = true;
	            extend(cOptions, isCurrencyPercent([cOptions.nlead, cOptions.nend], '$', dOptions.currencySymbol));
	            if (!cOptions.isCurrency) {
	                extend(cOptions, isCurrencyPercent([cOptions.nlead, cOptions.nend], '%', dOptions.percentSymbol));
	            }
	        }
	        else {
	            extend(cOptions, isCurrencyPercent([cOptions.nlead, cOptions.nend], '%', '%'));
	        }
	        if (!isNullOrUndefined(numObject)) {
	            var symbolPattern = getSymbolPattern(cOptions.type, dOptions.numberMapper.numberSystem, numObject, false);
	            if (cOptions.useGrouping) {
	                // eslint-disable-next-line
	                cOptions.groupSeparator = spaceGrouping ? ' ' : dOptions.numberMapper.numberSymbols[mapper[2]];
	                cOptions.groupData = NumberFormat.getGroupingDetails(symbolPattern.split(';')[0]);
	            }
	            cOptions.nlead = cOptions.nlead.replace(/'/g, '');
	            cOptions.nend = spaceCapture ? ' ' + cOptions.nend.replace(/'/g, '') : cOptions.nend.replace(/'/g, '');
	        }
	        return cOptions;
	    }
	    IntlBase.customNumberFormat = customNumberFormat;
	    /**
	     * Returns formatting options for currency or percent type
	     *
	     * @private
	     * @param {string[]} parts ?
	     * @param {string} actual ?
	     * @param {string} symbol ?
	     * @returns {any} ?
	     */
	    function isCurrencyPercent(parts, actual, symbol) {
	        var options = { nlead: parts[0], nend: parts[1] };
	        for (var i = 0; i < 2; i++) {
	            var part = parts[parseInt(i.toString(), 10)];
	            var loc = part.indexOf(actual);
	            if ((loc !== -1) && ((loc < part.indexOf('\'')) || (loc > part.lastIndexOf('\'')))) {
	                // eslint-disable-next-line
	                options[typeMapper[i]] = part.substr(0, loc) + symbol + part.substr(loc + 1);
	                // eslint-disable-next-line
	                options[typeMapper[actual]] = true;
	                options.type = options.isCurrency ? 'currency' : 'percent';
	                break;
	            }
	        }
	        return options;
	    }
	    IntlBase.isCurrencyPercent = isCurrencyPercent;
	    /**
	     * Returns culture based date separator
	     *
	     * @private
	     * @param {Object} dateObj ?
	     * @returns {string} ?
	     */
	    function getDateSeparator(dateObj) {
	        var value = (getValue('dateFormats.short', dateObj) || '').match(/[d‏M‏]([^d‏M])[d‏M‏]/i);
	        return value ? value[1] : '/';
	    }
	    IntlBase.getDateSeparator = getDateSeparator;
	    /**
	     * Returns Native Date Time pattern
	     *
	     * @private
	     * @param {string} culture ?
	     * @param {DateFormatOptions} options ?
	     * @param {Object} cldr ?
	     * @param {boolean} isExcelFormat ?
	     * @returns {string} ?
	     */
	    function getActualDateTimeFormat(culture, options, cldr, isExcelFormat) {
	        var dependable = getDependables(cldr, culture, options.calendar);
	        var actualPattern = options.format || getResultantPattern(options.skeleton, dependable.dateObject, options.type);
	        if (isExcelFormat) {
	            actualPattern = actualPattern.replace(patternRegex, function (pattern) {
	                // eslint-disable-next-line
	                return patternMatch[pattern];
	            });
	            if (actualPattern.indexOf('z') !== -1) {
	                var tLength = actualPattern.match(/z/g).length;
	                var timeZonePattern = void 0;
	                var options_1 = { 'timeZone': {} };
	                options_1.numMapper = ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr));
	                options_1.timeZone = getValue('dates.timeZoneNames', dependable.parserObject);
	                var value = new Date();
	                var timezone = value.getTimezoneOffset();
	                var pattern = (tLength < 4) ? '+H;-H' : options_1.timeZone.hourFormat;
	                pattern = pattern.replace(/:/g, options_1.numMapper.timeSeparator);
	                if (timezone === 0) {
	                    timeZonePattern = options_1.timeZone.gmtZeroFormat;
	                }
	                else {
	                    timeZonePattern = DateFormat.getTimeZoneValue(timezone, pattern);
	                    timeZonePattern = options_1.timeZone.gmtFormat.replace(/\{0\}/, timeZonePattern);
	                }
	                actualPattern = actualPattern.replace(/[z]+/, '"' + timeZonePattern + '"');
	            }
	            actualPattern = actualPattern.replace(/ $/, '');
	        }
	        return actualPattern;
	    }
	    IntlBase.getActualDateTimeFormat = getActualDateTimeFormat;
	    /**
	     *
	     * @param {string} actual ?
	     * @param {any} option ?
	     * @returns {any} ?
	     */
	    // eslint-disable-next-line
	    function processSymbol(actual, option) {
	        if (actual.indexOf(',') !== -1) {
	            // eslint-disable-next-line
	            var split = actual.split(',');
	            actual = (split[0] + getValue('numberMapper.numberSymbols.group', option) +
	                split[1].replace('.', getValue('numberMapper.numberSymbols.decimal', option)));
	        }
	        else {
	            actual = actual.replace('.', getValue('numberMapper.numberSymbols.decimal', option));
	        }
	        return actual;
	    }
	    /**
	     * Returns Native Number pattern
	     *
	     * @private
	     * @param {string} culture ?
	     * @param {NumberFormatOptions} options ?
	     * @param {Object} cldr ?
	     * @param {boolean} isExcel ?
	     * @returns {string} ?
	     */
	    function getActualNumberFormat(culture, options, cldr, isExcel) {
	        var dependable = getDependables(cldr, culture, '', true);
	        var parseOptions = { custom: true };
	        dependable.numericObject;
	        var minFrac;
	        var curObj = {};
	        var curMatch = (options.format || '').match(IntlBase.currencyFormatRegex);
	        IntlBase.formatRegex.test(options.format) ? getProperNumericSkeleton(options.format || 'N') : {};
	        var dOptions = {};
	        if (curMatch) {
	            dOptions.numberMapper = ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr), true);
	            var curCode = getCurrencySymbol(dependable.numericObject, options.currency || defaultCurrencyCode, options.altSymbol);
	            var symbolPattern = getSymbolPattern('currency', dOptions.numberMapper.numberSystem, dependable.numericObject, (/a/i).test(options.format));
	            symbolPattern = symbolPattern.replace(/\u00A4/g, curCode);
	            var split = symbolPattern.split(';');
	            curObj.hasNegativePattern = (split.length > 1);
	            curObj.nData = getFormatData(split[1] || '-' + split[0], true, curCode);
	            curObj.pData = getFormatData(split[0], false, curCode);
	            if (!curMatch[2] && !options.minimumFractionDigits && !options.maximumFractionDigits) {
	                minFrac = getFormatData(symbolPattern.split(';')[0], true, '', true).minimumFraction;
	            }
	        }
	        var actualPattern;
	        if ((IntlBase.formatRegex.test(options.format)) || !(options.format)) {
	            extend(parseOptions, getProperNumericSkeleton(options.format || 'N'));
	            parseOptions.custom = false;
	            actualPattern = '###0';
	            if (parseOptions.fractionDigits || options.minimumFractionDigits || options.maximumFractionDigits || minFrac) {
	                var defaultMinimum = 0;
	                if (parseOptions.fractionDigits) {
	                    options.minimumFractionDigits = options.maximumFractionDigits = parseOptions.fractionDigits;
	                }
	                actualPattern = fractionDigitsPattern(actualPattern, minFrac || parseOptions.fractionDigits ||
	                    options.minimumFractionDigits || defaultMinimum, options.maximumFractionDigits || defaultMinimum);
	            }
	            if (options.minimumIntegerDigits) {
	                actualPattern = minimumIntegerPattern(actualPattern, options.minimumIntegerDigits);
	            }
	            if (options.useGrouping) {
	                actualPattern = groupingPattern(actualPattern);
	            }
	            if (parseOptions.type === 'currency' || (parseOptions.type && isBlazor())) {
	                var cPattern = actualPattern;
	                actualPattern = curObj.pData.nlead + cPattern + curObj.pData.nend;
	                if (curObj.hasNegativePattern || isBlazor()) {
	                    actualPattern += ';' + curObj.nData.nlead + cPattern + curObj.nData.nend;
	                }
	            }
	            if (parseOptions.type === 'percent' && !isBlazor()) {
	                actualPattern += ' %';
	            }
	        }
	        else {
	            actualPattern = options.format.replace(/'/g, '"');
	        }
	        if (Object.keys(dOptions).length > 0) {
	            actualPattern = !isExcel ? processSymbol(actualPattern, dOptions) : actualPattern;
	        }
	        return actualPattern;
	    }
	    IntlBase.getActualNumberFormat = getActualNumberFormat;
	    /**
	     *
	     * @param {string} pattern ?
	     * @param {number} minDigits ?
	     * @param {number} maxDigits ?
	     * @returns {string} ?
	     */
	    function fractionDigitsPattern(pattern, minDigits, maxDigits) {
	        pattern += '.';
	        for (var a = 0; a < minDigits; a++) {
	            pattern += '0';
	        }
	        if (minDigits < maxDigits) {
	            var diff = maxDigits - minDigits;
	            for (var b = 0; b < diff; b++) {
	                pattern += '#';
	            }
	        }
	        return pattern;
	    }
	    IntlBase.fractionDigitsPattern = fractionDigitsPattern;
	    /**
	     *
	     * @param {string} pattern ?
	     * @param {number} digits ?
	     * @returns {string} ?
	     */
	    function minimumIntegerPattern(pattern, digits) {
	        var temp = pattern.split('.');
	        var integer = '';
	        for (var x = 0; x < digits; x++) {
	            integer += '0';
	        }
	        return temp[1] ? (integer + '.' + temp[1]) : integer;
	    }
	    IntlBase.minimumIntegerPattern = minimumIntegerPattern;
	    /**
	     *
	     * @param {string} pattern ?
	     * @returns {string} ?
	     */
	    function groupingPattern(pattern) {
	        var temp = pattern.split('.');
	        var integer = temp[0];
	        var no = 3 - integer.length % 3;
	        var hash = (no && no === 1) ? '#' : (no === 2 ? '##' : '');
	        integer = hash + integer;
	        pattern = '';
	        for (var x = integer.length - 1; x > 0; x = x - 3) {
	            pattern = ',' + integer[x - 2] + integer[x - 1] + integer[parseInt(x.toString(), 10)] + pattern;
	        }
	        pattern = pattern.slice(1);
	        return temp[1] ? (pattern + '.' + temp[1]) : pattern;
	    }
	    IntlBase.groupingPattern = groupingPattern;
	    /**
	     *
	     * @param {string} culture ?
	     * @param {Object} cldr ?
	     * @returns {number} ?
	     */
	    function getWeekData(culture, cldr) {
	        var firstDay = defaultFirstDay;
	        var mapper = getValue('supplemental.weekData.firstDay', cldr);
	        var iCulture = culture;
	        if ((/en-/).test(iCulture)) {
	            iCulture = iCulture.slice(3);
	        }
	        iCulture = iCulture.slice(0, 2).toUpperCase() + iCulture.substr(2);
	        if (mapper) {
	            firstDay = mapper["" + iCulture] || mapper[iCulture.slice(0, 2)] || defaultFirstDay;
	        }
	        return firstDayMapper["" + firstDay];
	    }
	    IntlBase.getWeekData = getWeekData;
	    /**
	     * @private
	     * @param {any} pData ?
	     * @param {string} aCurrency ?
	     * @param {string} rCurrency ?
	     * @returns {void} ?
	     */
	    function replaceBlazorCurrency(pData, aCurrency, rCurrency) {
	        var iCurrency = getBlazorCurrencySymbol(rCurrency);
	        if (aCurrency !== iCurrency) {
	            for (var _i = 0, pData_1 = pData; _i < pData_1.length; _i++) {
	                var data = pData_1[_i];
	                data.nend = data.nend.replace(aCurrency, iCurrency);
	                data.nlead = data.nlead.replace(aCurrency, iCurrency);
	            }
	        }
	    }
	    IntlBase.replaceBlazorCurrency = replaceBlazorCurrency;
	    /**
	     * @private
	     * @param {Date} date ?
	     * @returns {number} ?
	     */
	    function getWeekOfYear(date) {
	        var newYear = new Date(date.getFullYear(), 0, 1);
	        var day = newYear.getDay();
	        var weeknum;
	        day = (day >= 0 ? day : day + 7);
	        var daynum = Math.floor((date.getTime() - newYear.getTime() -
	            (date.getTimezoneOffset() - newYear.getTimezoneOffset()) * 60000) / 86400000) + 1;
	        if (day < 4) {
	            weeknum = Math.floor((daynum + day - 1) / 7) + 1;
	            if (weeknum > 52) {
	                var nYear = new Date(date.getFullYear() + 1, 0, 1);
	                var nday = nYear.getDay();
	                nday = nday >= 0 ? nday : nday + 7;
	                weeknum = nday < 4 ? 1 : 53;
	            }
	        }
	        else {
	            weeknum = Math.floor((daynum + day - 1) / 7);
	        }
	        return weeknum;
	    }
	    IntlBase.getWeekOfYear = getWeekOfYear;
	})(IntlBase || (IntlBase = {}));

	/**
	 * The Fetch class provides a way to make asynchronous network requests, typically to retrieve resources from a server.
	 * ```typescript
	 *   var fetchApi = new Fetch('index.html', 'GET');
	 *   fetchApi.send()
	 *      .then((value) => {
	 *          console.log(value);
	 *      }).catch((error) => {
	 *          console.log(error);
	 *      });
	 * ```
	 */
	var Fetch = /** @class */ (function () {
	    /**
	     * Constructor for Fetch class.
	     *
	     * @param {string|Object} options - Specifies the URL or Request object with URL to which the request is to be sent.
	     * @param {string} type - Specifies which request method is to be used, such as GET, POST, etc.
	     * @param {string} contentType - Specifies the content type of the request, which is used to indicate the original media type of the resource.
	     */
	    function Fetch(options, type, contentType) {
	        /**
	         * Specifies which request method is to be used, such as GET, POST, etc.
	         *
	         * @default GET
	         */
	        this.type = 'GET';
	        /**
	         * A boolean value indicating whether to reject the promise or not.
	         *
	         * @private
	         * @default true
	         */
	        this.emitError = true;
	        if (typeof options === 'string') {
	            this.url = options;
	            this.type = !isNullOrUndefined(type) ? type.toUpperCase() : this.type;
	            this.contentType = contentType;
	        }
	        else if (isObject(options) && Object.keys(options).length > 0) {
	            merge(this, options);
	        }
	        this.contentType = !isNullOrUndefined(this.contentType) ? this.contentType : 'application/json; charset=utf-8';
	    }
	    /**
	     * Send the request to server.
	     *
	     * @param {string|Object} data - Specifies the data that needs to be added to the request.
	     * @returns {Promise<Response>} - Returns the response to a request.
	     */
	    Fetch.prototype.send = function (data) {
	        var _this = this;
	        var contentTypes = {
	            'application/json': 'json',
	            'multipart/form-data': 'formData',
	            'application/octet-stream': 'blob',
	            'application/x-www-form-urlencoded': 'formData'
	        };
	        try {
	            if (isNullOrUndefined(this.fetchRequest) && this.type === 'GET') {
	                this.fetchRequest = new Request(this.url, { method: this.type });
	            }
	            else if (isNullOrUndefined(this.fetchRequest)) {
	                this.data = !isNullOrUndefined(data) ? data : this.data;
	                this.fetchRequest = new Request(this.url, {
	                    method: this.type,
	                    headers: { 'Content-Type': this.contentType },
	                    body: this.data
	                });
	            }
	            var eventArgs = { cancel: false, fetchRequest: this.fetchRequest };
	            this.triggerEvent(this['beforeSend'], eventArgs);
	            if (eventArgs.cancel) {
	                return null;
	            }
	            this.fetchResponse = fetch(this.fetchRequest);
	            return this.fetchResponse.then(function (response) {
	                _this.triggerEvent(_this['onLoad'], response);
	                if (!response.ok) {
	                    throw new Error(response.statusText);
	                }
	                var responseType = 'text';
	                for (var _i = 0, _a = Object.keys(contentTypes); _i < _a.length; _i++) {
	                    var key = _a[_i];
	                    if (response.headers.get('Content-Type').indexOf(key) !== -1) {
	                        responseType = contentTypes[key];
	                    }
	                }
	                return response[responseType]();
	                // eslint-disable-next-line
	            }).then(function (data) {
	                _this.triggerEvent(_this['onSuccess'], data, _this);
	                return data;
	                // eslint-disable-next-line
	            }).catch(function (error) {
	                var returnVal = {};
	                if (_this.emitError) {
	                    _this.triggerEvent(_this['onFailure'], error);
	                    returnVal = Promise.reject(error);
	                }
	                return returnVal;
	            });
	        }
	        catch (error) {
	            return error;
	        }
	    };
	    Fetch.prototype.triggerEvent = function (callback, data, instance) {
	        if (!isNullOrUndefined(callback) && typeof callback === 'function') {
	            callback(data, instance);
	        }
	    };
	    return Fetch;
	}());

	var REGX_MOBILE = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini|mobile/i;
	var REGX_IE = /msie|trident/i;
	var REGX_IE11 = /Trident\/7\./;
	var REGX_IOS = /(ipad|iphone|ipod touch)/i;
	var REGX_IOS7 = /(ipad|iphone|ipod touch);.*os 7_\d|(ipad|iphone|ipod touch);.*os 8_\d/i;
	var REGX_ANDROID = /android/i;
	var REGX_WINDOWS = /trident|windows phone|edge/i;
	var REGX_VERSION = /(version)[ /]([\w.]+)/i;
	var REGX_BROWSER = {
	    OPERA: /(opera|opr)(?:.*version|)[ /]([\w.]+)/i,
	    EDGE: /(edge)(?:.*version|)[ /]([\w.]+)/i,
	    CHROME: /(chrome|crios)[ /]([\w.]+)/i,
	    PANTHOMEJS: /(phantomjs)[ /]([\w.]+)/i,
	    SAFARI: /(safari)[ /]([\w.]+)/i,
	    WEBKIT: /(webkit)[ /]([\w.]+)/i,
	    MSIE: /(msie|trident) ([\w.]+)/i,
	    MOZILLA: /(mozilla)(?:.*? rv:([\w.]+)|)/i
	};
	/* istanbul ignore else  */
	if (typeof window !== 'undefined') {
	    window.browserDetails = window.browserDetails || {};
	}
	/**
	 * Get configuration details for Browser
	 *
	 * @private
	 */
	var Browser = /** @class */ (function () {
	    function Browser() {
	    }
	    Browser.extractBrowserDetail = function () {
	        var browserInfo = { culture: {} };
	        var keys = Object.keys(REGX_BROWSER);
	        var clientInfo = [];
	        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
	            var key = keys_1[_i];
	            clientInfo = Browser.userAgent.match(REGX_BROWSER["" + key]);
	            if (clientInfo) {
	                browserInfo.name = (clientInfo[1].toLowerCase() === 'opr' ? 'opera' : clientInfo[1].toLowerCase());
	                browserInfo.name = (clientInfo[1].toLowerCase() === 'crios' ? 'chrome' : browserInfo.name);
	                browserInfo.version = clientInfo[2];
	                browserInfo.culture.name = browserInfo.culture.language = navigator.language;
	                // eslint-disable-next-line
	                if (!!Browser.userAgent.match(REGX_IE11)) {
	                    browserInfo.name = 'msie';
	                    break;
	                }
	                var version = Browser.userAgent.match(REGX_VERSION);
	                if (browserInfo.name === 'safari' && version) {
	                    browserInfo.version = version[2];
	                }
	                break;
	            }
	        }
	        return browserInfo;
	    };
	    /**
	     * To get events from the browser
	     *
	     * @param {string} event - type of event triggered.
	     * @returns {boolean}
	     */
	    Browser.getEvent = function (event) {
	        // eslint-disable-next-line
	        var events = {
	            start: {
	                isPointer: 'pointerdown', isTouch: 'touchstart', isDevice: 'mousedown'
	            },
	            move: {
	                isPointer: 'pointermove', isTouch: 'touchmove', isDevice: 'mousemove'
	            },
	            end: {
	                isPointer: 'pointerup', isTouch: 'touchend', isDevice: 'mouseup'
	            },
	            cancel: {
	                isPointer: 'pointercancel', isTouch: 'touchcancel', isDevice: 'mouseleave'
	            }
	        };
	        return (Browser.isPointer ? events["" + event].isPointer :
	            (Browser.isTouch ? events["" + event].isTouch + (!Browser.isDevice ? ' ' + events["" + event].isDevice : '')
	                : events["" + event].isDevice));
	    };
	    /**
	     * To get the Touch start event from browser
	     *
	     * @returns {string}
	     */
	    Browser.getTouchStartEvent = function () {
	        return Browser.getEvent('start');
	    };
	    /**
	     * To get the Touch end event from browser
	     *
	     * @returns {string}
	     */
	    Browser.getTouchEndEvent = function () {
	        return Browser.getEvent('end');
	    };
	    /**
	     * To get the Touch move event from browser
	     *
	     * @returns {string}
	     */
	    Browser.getTouchMoveEvent = function () {
	        return Browser.getEvent('move');
	    };
	    /**
	     * To cancel the touch event from browser
	     *
	     * @returns {string}
	     */
	    Browser.getTouchCancelEvent = function () {
	        return Browser.getEvent('cancel');
	    };
	    /**
	     * Check whether the browser on the iPad device is Safari or not
	     *
	     * @returns {boolean}
	     */
	    Browser.isSafari = function () {
	        return (Browser.isDevice && Browser.isIos && Browser.isTouch && typeof window !== 'undefined'
	            && window.navigator.userAgent.toLowerCase().indexOf('iphone') === -1
	            && window.navigator.userAgent.toLowerCase().indexOf('safari') > -1);
	    };
	    /**
	     * To get the value based on provided key and regX
	     *
	     * @param {string} key ?
	     * @param {RegExp} regX ?
	     * @returns {Object} ?
	     */
	    Browser.getValue = function (key, regX) {
	        var browserDetails = typeof window !== 'undefined' ? window.browserDetails : {};
	        if (typeof navigator !== 'undefined' && navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1 && Browser.isTouch === true && !REGX_BROWSER.CHROME.test(navigator.userAgent)) {
	            browserDetails['isIos'] = true;
	            browserDetails['isDevice'] = true;
	            browserDetails['isTouch'] = true;
	            browserDetails['isPointer'] = true;
	        }
	        if ('undefined' === typeof browserDetails["" + key]) {
	            return browserDetails["" + key] = regX.test(Browser.userAgent);
	        }
	        return browserDetails["" + key];
	    };
	    Object.defineProperty(Browser, "userAgent", {
	        get: function () {
	            return Browser.uA;
	        },
	        //Properties
	        /**
	         * Property specifies the userAgent of the browser. Default userAgent value is based on the browser.
	         * Also we can set our own userAgent.
	         *
	         * @param {string} uA ?
	         */
	        set: function (uA) {
	            Browser.uA = uA;
	            window.browserDetails = {};
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Browser, "info", {
	        //Read Only Properties
	        /**
	         * Property is to get the browser information like Name, Version and Language
	         *
	         * @returns {BrowserInfo} ?
	         */
	        get: function () {
	            if (isUndefined(window.browserDetails.info)) {
	                return window.browserDetails.info = Browser.extractBrowserDetail();
	            }
	            return window.browserDetails.info;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Browser, "isIE", {
	        /**
	         * Property is to get whether the userAgent is based IE.
	         *
	         * @returns {boolean} ?
	         */
	        get: function () {
	            return Browser.getValue('isIE', REGX_IE);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Browser, "isTouch", {
	        /**
	         * Property is to get whether the browser has touch support.
	         *
	         * @returns {boolean} ?
	         */
	        get: function () {
	            if (isUndefined(window.browserDetails.isTouch)) {
	                return (window.browserDetails.isTouch =
	                    ('ontouchstart' in window.navigator) ||
	                        (window &&
	                            window.navigator &&
	                            (window.navigator.maxTouchPoints > 0)) || ('ontouchstart' in window));
	            }
	            return window.browserDetails.isTouch;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Browser, "isPointer", {
	        /**
	         * Property is to get whether the browser has Pointer support.
	         *
	         * @returns {boolean} ?
	         */
	        get: function () {
	            if (isUndefined(window.browserDetails.isPointer)) {
	                return window.browserDetails.isPointer = ('pointerEnabled' in window.navigator);
	            }
	            return window.browserDetails.isPointer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Browser, "isMSPointer", {
	        /**
	         * Property is to get whether the browser has MSPointer support.
	         *
	         * @returns {boolean} ?
	         */
	        get: function () {
	            if (isUndefined(window.browserDetails.isMSPointer)) {
	                return window.browserDetails.isMSPointer = ('msPointerEnabled' in window.navigator);
	            }
	            return window.browserDetails.isMSPointer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Browser, "isDevice", {
	        /**
	         * Property is to get whether the userAgent is device based.
	         *
	         * @returns {boolean} ?
	         */
	        get: function () {
	            return Browser.getValue('isDevice', REGX_MOBILE);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Browser, "isIos", {
	        /**
	         * Property is to get whether the userAgent is IOS.
	         *
	         * @returns {boolean} ?
	         */
	        get: function () {
	            return Browser.getValue('isIos', REGX_IOS);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Browser, "isIos7", {
	        /**
	         * Property is to get whether the userAgent is Ios7.
	         *
	         * @returns {boolean} ?
	         */
	        get: function () {
	            return Browser.getValue('isIos7', REGX_IOS7);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Browser, "isAndroid", {
	        /**
	         * Property is to get whether the userAgent is Android.
	         *
	         * @returns {boolean} ?
	         */
	        get: function () {
	            return Browser.getValue('isAndroid', REGX_ANDROID);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Browser, "isWebView", {
	        /**
	         * Property is to identify whether application ran in web view.
	         *
	         * @returns {boolean} ?
	         */
	        get: function () {
	            if (isUndefined(window.browserDetails.isWebView)) {
	                window.browserDetails.isWebView = !(isUndefined(window.cordova) && isUndefined(window.PhoneGap)
	                    && isUndefined(window.phonegap) && window.forge !== 'object');
	                return window.browserDetails.isWebView;
	            }
	            return window.browserDetails.isWebView;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Browser, "isWindows", {
	        /**
	         * Property is to get whether the userAgent is Windows.
	         *
	         * @returns {boolean} ?
	         */
	        get: function () {
	            return Browser.getValue('isWindows', REGX_WINDOWS);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Browser, "touchStartEvent", {
	        /**
	         * Property is to get the touch start event. It returns event name based on browser.
	         *
	         * @returns {string} ?
	         */
	        get: function () {
	            if (isUndefined(window.browserDetails.touchStartEvent)) {
	                return window.browserDetails.touchStartEvent = Browser.getTouchStartEvent();
	            }
	            return window.browserDetails.touchStartEvent;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Browser, "touchMoveEvent", {
	        /**
	         * Property is to get the touch move event. It returns event name based on browser.
	         *
	         * @returns {string} ?
	         */
	        get: function () {
	            if (isUndefined(window.browserDetails.touchMoveEvent)) {
	                return window.browserDetails.touchMoveEvent = Browser.getTouchMoveEvent();
	            }
	            return window.browserDetails.touchMoveEvent;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Browser, "touchEndEvent", {
	        /**
	         * Property is to get the touch end event. It returns event name based on browser.
	         *
	         * @returns {string} ?
	         */
	        get: function () {
	            if (isUndefined(window.browserDetails.touchEndEvent)) {
	                return window.browserDetails.touchEndEvent = Browser.getTouchEndEvent();
	            }
	            return window.browserDetails.touchEndEvent;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Browser, "touchCancelEvent", {
	        /**
	         * Property is to cancel the touch end event.
	         *
	         * @returns {string} ?
	         */
	        get: function () {
	            if (isUndefined(window.browserDetails.touchCancelEvent)) {
	                return window.browserDetails.touchCancelEvent = Browser.getTouchCancelEvent();
	            }
	            return window.browserDetails.touchCancelEvent;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /* istanbul ignore next */
	    Browser.uA = typeof navigator !== 'undefined' ? navigator.userAgent : '';
	    return Browser;
	}());

	/**
	 * EventHandler class provides option to add, remove, clear and trigger events to a HTML DOM element
	 * ```html
	 * <div id="Eventdiv">  </div>
	 * <script>
	 *   let node: HTMLElement = document.querySelector("#Eventdiv");
	 *   EventHandler.addEventListener(node, "click", function(){
	 *       // click handler function code
	 *   });
	 *   EventHandler.addEventListener(node, "onmouseover", function(){
	 *       // mouseover handler function code
	 *   });
	 *   EventHandler.removeEventListener(node, "click", function(){
	 *       // click handler function code
	 *   });
	 *   eventObj.clearEvents();
	 * </script>
	 * ```
	 */
	var EventHandler = /** @class */ (function () {
	    function EventHandler() {
	    }
	    // to get the event data based on element
	    EventHandler.addOrGetEventData = function (element) {
	        if ('__eventList' in element) {
	            return element.__eventList.events;
	        }
	        else {
	            element.__eventList = {};
	            return element.__eventList.events = [];
	        }
	    };
	    /**
	     * Add an event to the specified DOM element.
	     *
	     * @param {any} element - Target HTML DOM element
	     * @param {string} eventName - A string that specifies the name of the event
	     * @param {Function} listener - Specifies the function to run when the event occurs
	     * @param {Object} bindTo - A object that binds 'this' variable in the event handler
	     * @param {number} intDebounce - Specifies at what interval given event listener should be triggered.
	     * @returns {Function} ?
	     */
	    EventHandler.add = function (element, eventName, listener, bindTo, intDebounce) {
	        var eventData = EventHandler.addOrGetEventData(element);
	        var debounceListener;
	        if (intDebounce) {
	            debounceListener = debounce(listener, intDebounce);
	        }
	        else {
	            debounceListener = listener;
	        }
	        if (bindTo) {
	            debounceListener = debounceListener.bind(bindTo);
	        }
	        var event = eventName.split(' ');
	        for (var i = 0; i < event.length; i++) {
	            eventData.push({
	                name: event[parseInt(i.toString(), 10)],
	                listener: listener,
	                debounce: debounceListener
	            });
	            if (Browser.isIE) {
	                element.addEventListener(event[parseInt(i.toString(), 10)], debounceListener);
	            }
	            else {
	                element.addEventListener(event[parseInt(i.toString(), 10)], debounceListener, { passive: false });
	            }
	        }
	        return debounceListener;
	    };
	    /**
	     * Remove an event listener that has been attached before.
	     *
	     * @param {any} element - Specifies the target html element to remove the event
	     * @param {string} eventName - A string that specifies the name of the event to remove
	     * @param {Function} listener - Specifies the function to remove
	     * @returns {void} ?
	     */
	    EventHandler.remove = function (element, eventName, listener) {
	        var eventData = EventHandler.addOrGetEventData(element);
	        var event = eventName.split(' ');
	        var _loop_1 = function (j) {
	            var index = -1;
	            var debounceListener;
	            if (eventData && eventData.length !== 0) {
	                eventData.some(function (x, i) {
	                    return x.name === event[parseInt(j.toString(), 10)] && x.listener === listener ?
	                        (index = i, debounceListener = x.debounce, true) : false;
	                });
	            }
	            if (index !== -1) {
	                eventData.splice(index, 1);
	            }
	            if (debounceListener) {
	                element.removeEventListener(event[parseInt(j.toString(), 10)], debounceListener);
	            }
	        };
	        for (var j = 0; j < event.length; j++) {
	            _loop_1(j);
	        }
	    };
	    /**
	     * Clear all the event listeners that has been previously attached to the element.
	     *
	     * @param {any} element - Specifies the target html element to clear the events
	     * @returns {void} ?
	     */
	    EventHandler.clearEvents = function (element) {
	        var eventData;
	        var copyData;
	        // eslint-disable-next-line
	        eventData = EventHandler.addOrGetEventData(element);
	        // eslint-disable-next-line
	        copyData = extend([], copyData, eventData);
	        for (var i = 0; i < copyData.length; i++) {
	            element.removeEventListener(copyData[parseInt(i.toString(), 10)].name, copyData[parseInt(i.toString(), 10)].debounce);
	            eventData.shift();
	        }
	    };
	    /**
	     * Trigger particular event of the element.
	     *
	     * @param {any} element - Specifies the target html element to trigger the events
	     * @param {string} eventName - Specifies the event to trigger for the specified element.
	     * Can be a custom event, or any of the standard events.
	     * @param {any} eventProp - Additional parameters to pass on to the event properties
	     * @returns {void} ?
	     */
	    EventHandler.trigger = function (element, eventName, eventProp) {
	        var eventData = EventHandler.addOrGetEventData(element);
	        for (var _i = 0, eventData_1 = eventData; _i < eventData_1.length; _i++) {
	            var event_1 = eventData_1[_i];
	            if (event_1.name === eventName) {
	                event_1.debounce.call(this, eventProp);
	            }
	        }
	    };
	    return EventHandler;
	}());

	/**
	 * Functions related to dom operations.
	 */
	var SVG_REG = /^svg|^path|^g/;
	/**
	 * Function to create Html element.
	 *
	 * @param {string} tagName - Name of the tag, id and class names.
	 * @param {ElementProperties} properties - Object to set properties in the element.
	 * @param {ElementProperties} properties.id - To set the id to the created element.
	 * @param {ElementProperties} properties.className - To add classes to the element.
	 * @param {ElementProperties} properties.innerHTML - To set the innerHTML to element.
	 * @param {ElementProperties} properties.styles - To set the some custom styles to element.
	 * @param {ElementProperties} properties.attrs - To set the attributes to element.
	 * @returns {any} ?
	 * @private
	 */
	function createElement(tagName, properties) {
	    var element = (SVG_REG.test(tagName) ? document.createElementNS('http://www.w3.org/2000/svg', tagName) : document.createElement(tagName));
	    if (typeof (properties) === 'undefined') {
	        return element;
	    }
	    element.innerHTML = (properties.innerHTML ? properties.innerHTML : '');
	    if (properties.className !== undefined) {
	        element.className = properties.className;
	    }
	    if (properties.id !== undefined) {
	        element.id = properties.id;
	    }
	    if (properties.styles !== undefined) {
	        element.setAttribute('style', properties.styles);
	    }
	    if (properties.attrs !== undefined) {
	        attributes(element, properties.attrs);
	    }
	    return element;
	}
	/**
	 * The function used to add the classes to array of elements
	 *
	 * @param  {Element[]|NodeList} elements - An array of elements that need to add a list of classes
	 * @param  {string|string[]} classes - String or array of string that need to add an individual element as a class
	 * @returns {any} .
	 * @private
	 */
	function addClass(elements, classes) {
	    var classList = getClassList(classes);
	    var regExp = RegExp;
	    for (var _i = 0, _a = elements; _i < _a.length; _i++) {
	        var ele = _a[_i];
	        for (var _b = 0, classList_1 = classList; _b < classList_1.length; _b++) {
	            var className = classList_1[_b];
	            if (isObject(ele)) {
	                var curClass = getValue('attributes.className', ele);
	                if (isNullOrUndefined(curClass)) {
	                    setValue('attributes.className', className, ele);
	                }
	                else if (!new regExp('\\b' + className + '\\b', 'i').test(curClass)) {
	                    setValue('attributes.className', curClass + ' ' + className, ele);
	                }
	            }
	            else {
	                if (!ele.classList.contains(className)) {
	                    ele.classList.add(className);
	                }
	            }
	        }
	    }
	    return elements;
	}
	/**
	 * The function used to add the classes to array of elements
	 *
	 * @param  {Element[]|NodeList} elements - An array of elements that need to remove a list of classes
	 * @param  {string|string[]} classes - String or array of string that need to add an individual element as a class
	 * @returns {any} .
	 * @private
	 */
	function removeClass(elements, classes) {
	    var classList = getClassList(classes);
	    for (var _i = 0, _a = elements; _i < _a.length; _i++) {
	        var ele = _a[_i];
	        var flag = isObject(ele);
	        var canRemove = flag ? getValue('attributes.className', ele) : ele.className !== '';
	        if (canRemove) {
	            for (var _b = 0, classList_2 = classList; _b < classList_2.length; _b++) {
	                var className = classList_2[_b];
	                if (flag) {
	                    var classes_1 = getValue('attributes.className', ele);
	                    var classArr = classes_1.split(' ');
	                    var index = classArr.indexOf(className);
	                    if (index !== -1) {
	                        classArr.splice(index, 1);
	                    }
	                    setValue('attributes.className', classArr.join(' '), ele);
	                }
	                else {
	                    ele.classList.remove(className);
	                }
	            }
	        }
	    }
	    return elements;
	}
	/**
	 * The function used to get classlist.
	 *
	 * @param  {string | string[]} classes - An element the need to check visibility
	 * @returns {string[]} ?
	 * @private
	 */
	function getClassList(classes) {
	    var classList = [];
	    if (typeof classes === 'string') {
	        classList.push(classes);
	    }
	    else {
	        classList = classes;
	    }
	    return classList;
	}
	/**
	 * The function used to check element is visible or not.
	 *
	 * @param  {Element|Node} element - An element the need to check visibility
	 * @returns {boolean} ?
	 * @private
	 */
	function isVisible(element) {
	    var ele = element;
	    return (ele.style.visibility === '' && ele.offsetWidth > 0);
	}
	/**
	 * The function used to insert an array of elements into a first of the element.
	 *
	 * @param  {Element[]|NodeList} fromElements - An array of elements that need to prepend.
	 * @param  {Element} toElement - An element that is going to prepend.
	 * @param {boolean} isEval - ?
	 * @returns {Element[] | NodeList} ?
	 * @private
	 */
	function prepend(fromElements, toElement, isEval) {
	    var docFrag = document.createDocumentFragment();
	    for (var _i = 0, _a = fromElements; _i < _a.length; _i++) {
	        var ele = _a[_i];
	        docFrag.appendChild(ele);
	    }
	    toElement.insertBefore(docFrag, toElement.firstElementChild);
	    if (isEval) {
	        executeScript(toElement);
	    }
	    return fromElements;
	}
	/**
	 * The function used to insert an array of elements into last of the element.
	 *
	 * @param  {Element[]|NodeList} fromElements - An array of elements that need to append.
	 * @param  {Element} toElement - An element that is going to prepend.
	 * @param {boolean} isEval - ?
	 * @returns {Element[] | NodeList} ?
	 * @private
	 */
	function append(fromElements, toElement, isEval) {
	    var docFrag = document.createDocumentFragment();
	    if (fromElements instanceof NodeList) {
	        while (fromElements.length > 0) {
	            docFrag.appendChild(fromElements[0]);
	        }
	    }
	    else {
	        for (var _i = 0, _a = fromElements; _i < _a.length; _i++) {
	            var ele = _a[_i];
	            docFrag.appendChild(ele);
	        }
	    }
	    toElement.appendChild(docFrag);
	    if (isEval) {
	        executeScript(toElement);
	    }
	    return fromElements;
	}
	/**
	 * The function is used to evaluate script from Ajax request
	 *
	 * @param {Element} ele - An element is going to evaluate the script
	 * @returns {void} ?
	 */
	function executeScript(ele) {
	    var eleArray = ele.querySelectorAll('script');
	    eleArray.forEach(function (element) {
	        var script = document.createElement('script');
	        script.text = element.innerHTML;
	        document.head.appendChild(script);
	        detach(script);
	    });
	}
	/**
	 * The function used to remove the element from parentnode
	 *
	 * @param  {Element|Node|HTMLElement} element - An element that is going to detach from the Dom
	 * @returns {any} ?
	 * @private
	 */
	// eslint-disable-next-line
	function detach(element) {
	    var parentNode = element.parentNode;
	    if (parentNode) {
	        return parentNode.removeChild(element);
	    }
	}
	/**
	 * The function used to remove the element from Dom also clear the bounded events
	 *
	 * @param  {Element|Node|HTMLElement} element - An element remove from the Dom
	 * @returns {void} ?
	 * @private
	 */
	function remove(element) {
	    var parentNode = element.parentNode;
	    EventHandler.clearEvents(element);
	    parentNode.removeChild(element);
	}
	/**
	 * The function helps to set multiple attributes to an element
	 *
	 * @param  {Element|Node} element - An element that need to set attributes.
	 * @param  {string} attributes - JSON Object that is going to as attributes.
	 * @returns {Element} ?
	 * @private
	 */
	// eslint-disable-next-line
	function attributes(element, attributes) {
	    var keys = Object.keys(attributes);
	    var ele = element;
	    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
	        var key = keys_1[_i];
	        if (isObject(ele)) {
	            var iKey = key;
	            if (key === 'tabindex') {
	                iKey = 'tabIndex';
	            }
	            ele.attributes["" + iKey] = attributes["" + key];
	        }
	        else {
	            ele.setAttribute(key, attributes["" + key]);
	        }
	    }
	    return ele;
	}
	/**
	 * The function selects the element from giving context.
	 *
	 * @param  {string} selector - Selector string need fetch element
	 * @param  {Document|Element} context - It is an optional type, That specifies a Dom context.
	 * @param {boolean} needsVDOM ?
	 * @returns {any} ?
	 * @private
	 */
	// eslint-disable-next-line
	function select(selector, context, needsVDOM) {
	    if (context === void 0) { context = document; }
	    selector = querySelectId(selector);
	    return context.querySelector(selector);
	}
	/**
	 * The function selects an array of element from the given context.
	 *
	 * @param  {string} selector - Selector string need fetch element
	 * @param  {Document|Element} context - It is an optional type, That specifies a Dom context.
	 * @param {boolean} needsVDOM ?
	 * @returns {HTMLElement[]} ?
	 * @private
	 */
	// eslint-disable-next-line
	function selectAll(selector, context, needsVDOM) {
	    if (context === void 0) { context = document; }
	    selector = querySelectId(selector);
	    var nodeList = context.querySelectorAll(selector);
	    return nodeList;
	}
	/**
	 * The function selects an id of element from the given context.
	 *
	 * @param  {string} selector - Selector string need fetch element
	 * @returns {string} ?
	 * @private
	 */
	function querySelectId(selector) {
	    var charRegex = /(!|"|\$|%|&|'|\(|\)|\*|\/|:|;|<|=|\?|@|\]|\^|`|{|}|\||\+|~)/g;
	    if (selector.match(/#[0-9]/g) || selector.match(charRegex)) {
	        var idList = selector.split(',');
	        for (var i = 0; i < idList.length; i++) {
	            var list = idList[parseInt(i.toString(), 10)].split(' ');
	            for (var j = 0; j < list.length; j++) {
	                if (list[parseInt(j.toString(), 10)].indexOf('#') > -1) {
	                    if (!list[parseInt(j.toString(), 10)].match(/\[.*\]/)) {
	                        var splitId = list[parseInt(j.toString(), 10)].split('#');
	                        if (splitId[1].match(/^\d/) || splitId[1].match(charRegex)) {
	                            var setId = list[parseInt(j.toString(), 10)].split('.');
	                            setId[0] = setId[0].replace(/#/, '[id=\'') + '\']';
	                            list[parseInt(j.toString(), 10)] = setId.join('.');
	                        }
	                    }
	                }
	            }
	            idList[parseInt(i.toString(), 10)] = list.join(' ');
	        }
	        return idList.join(',');
	    }
	    return selector;
	}
	/**
	 * Returns single closest parent element based on class selector.
	 *
	 * @param  {Element} element - An element that need to find the closest element.
	 * @param  {string} selector - A classSelector of closest element.
	 * @returns {Element} ?
	 * @private
	 */
	function closest(element, selector) {
	    var el = element;
	    if (typeof el.closest === 'function') {
	        return el.closest(selector);
	    }
	    while (el && el.nodeType === 1) {
	        if (matches(el, selector)) {
	            return el;
	        }
	        el = el.parentNode;
	    }
	    return null;
	}
	/**
	 * Set the style attributes to Html element.
	 *
	 * @param {HTMLElement} element - Element which we want to set attributes
	 * @param {any} attrs - Set the given attributes to element
	 * @returns {void} ?
	 * @private
	 */
	function setStyleAttribute(element, attrs) {
	    if (attrs !== undefined) {
	        Object.keys(attrs).forEach(function (key) {
	            // eslint-disable-next-line
	            element.style[key] = attrs[key];
	        });
	    }
	}
	/**
	 * Method for add and remove classes to a dom element.
	 *
	 * @param {Element} element - Element for add and remove classes
	 * @param {string[]} addClasses - List of classes need to be add to the element
	 * @param {string[]} removeClasses - List of classes need to be remove from the element
	 * @returns {void} ?
	 * @private
	 */
	function classList(element, addClasses, removeClasses) {
	    addClass([element], addClasses);
	    removeClass([element], removeClasses);
	}
	/**
	 * Method to check whether the element matches the given selector.
	 *
	 * @param {Element} element - Element to compare with the selector.
	 * @param {string} selector - String selector which element will satisfy.
	 * @returns {void} ?
	 * @private
	 */
	function matches(element, selector) {
	    // eslint-disable-next-line
	    var matches = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;
	    if (matches) {
	        return matches.call(element, selector);
	    }
	    else {
	        return [].indexOf.call(document.querySelectorAll(selector), element) !== -1;
	    }
	}

	var isColEName = new RegExp(']');
	/* tslint:enable:no-any */
	/**
	 * Base library module is common module for Framework modules like touch,keyboard and etc.,
	 *
	 * @private
	 */
	var Base = /** @class */ (function () {
	    /**
	     * Base constructor accept options and element
	     *
	     * @param {Object} options ?
	     * @param {string} element ?
	     */
	    function Base(options, element) {
	        this.isRendered = false;
	        this.isComplexArraySetter = false;
	        this.isServerRendered = false;
	        this.allowServerDataBinding = true;
	        this.isProtectedOnChange = true;
	        this.properties = {};
	        this.changedProperties = {};
	        this.oldProperties = {};
	        this.bulkChanges = {};
	        this.refreshing = false;
	        this.ignoreCollectionWatch = false;
	        // eslint-disable-next-line
	        this.finalUpdate = function () { };
	        this.childChangedProperties = {};
	        this.modelObserver = new Observer(this);
	        if (!isUndefined(element)) {
	            if ('string' === typeof (element)) {
	                this.element = document.querySelector(element);
	            }
	            else {
	                this.element = element;
	            }
	            if (!isNullOrUndefined(this.element)) {
	                this.isProtectedOnChange = false;
	                this.addInstance();
	            }
	        }
	        if (!isUndefined(options)) {
	            this.setProperties(options, true);
	        }
	        this.isDestroyed = false;
	    }
	    /** Property base section */
	    /**
	     * Function used to set bunch of property at a time.
	     *
	     * @private
	     * @param  {Object} prop - JSON object which holds components properties.
	     * @param  {boolean} muteOnChange ? - Specifies to true when we set properties.
	     * @returns {void} ?
	     */
	    Base.prototype.setProperties = function (prop, muteOnChange) {
	        var prevDetection = this.isProtectedOnChange;
	        this.isProtectedOnChange = !!muteOnChange;
	        merge(this, prop);
	        if (muteOnChange !== true) {
	            merge(this.changedProperties, prop);
	            this.dataBind();
	        }
	        this.finalUpdate();
	        this.changedProperties = {};
	        this.oldProperties = {};
	        this.isProtectedOnChange = prevDetection;
	    };
	    /**
	     * Calls for child element data bind
	     *
	     * @param {Object} obj ?
	     * @param {Object} parent ?
	     * @returns {void} ?
	     */
	    // tslint:disable-next-line:no-any
	    Base.callChildDataBind = function (obj, parent) {
	        var keys = Object.keys(obj);
	        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
	            var key = keys_1[_i];
	            if (parent["" + key] instanceof Array) {
	                for (var _a = 0, _b = parent["" + key]; _a < _b.length; _a++) {
	                    var obj_1 = _b[_a];
	                    if (obj_1.dataBind !== undefined) {
	                        obj_1.dataBind();
	                    }
	                }
	            }
	            else {
	                parent["" + key].dataBind();
	            }
	        }
	    };
	    Base.prototype.clearChanges = function () {
	        this.finalUpdate();
	        this.changedProperties = {};
	        this.oldProperties = {};
	        this.childChangedProperties = {};
	    };
	    /**
	     * Bind property changes immediately to components
	     *
	     * @returns {void} ?
	     */
	    Base.prototype.dataBind = function () {
	        Base.callChildDataBind(this.childChangedProperties, this);
	        if (Object.getOwnPropertyNames(this.changedProperties).length) {
	            var prevDetection = this.isProtectedOnChange;
	            var newChanges = this.changedProperties;
	            var oldChanges = this.oldProperties;
	            this.clearChanges();
	            this.isProtectedOnChange = true;
	            this.onPropertyChanged(newChanges, oldChanges);
	            this.isProtectedOnChange = prevDetection;
	        }
	    };
	    /* tslint:disable:no-any */
	    Base.prototype.serverDataBind = function (newChanges) {
	        {
	            return;
	        }
	    };
	    /* tslint:enable:no-any */
	    Base.prototype.saveChanges = function (key, newValue, oldValue) {
	        if (this.isProtectedOnChange) {
	            return;
	        }
	        this.oldProperties["" + key] = oldValue;
	        this.changedProperties["" + key] = newValue;
	        this.finalUpdate();
	        this.finalUpdate = setImmediate(this.dataBind.bind(this));
	    };
	    /** Event Base Section */
	    /**
	     * Adds the handler to the given event listener.
	     *
	     * @param {string} eventName - A String that specifies the name of the event
	     * @param {Function} handler - Specifies the call to run when the event occurs.
	     * @returns {void} ?
	     */
	    Base.prototype.addEventListener = function (eventName, handler) {
	        this.modelObserver.on(eventName, handler);
	    };
	    /**
	     * Removes the handler from the given event listener.
	     *
	     * @param {string} eventName - A String that specifies the name of the event to remove
	     * @param {Function} handler - Specifies the function to remove
	     * @returns {void} ?
	     */
	    Base.prototype.removeEventListener = function (eventName, handler) {
	        this.modelObserver.off(eventName, handler);
	    };
	    /**
	     * Triggers the handlers in the specified event.
	     *
	     * @private
	     * @param {string} eventName - Specifies the event to trigger for the specified component properties.
	     * Can be a custom event, or any of the standard events.
	     * @param {Event} eventProp - Additional parameters to pass on to the event properties
	     * @param {Function} successHandler - this function will invoke after event successfully triggered
	     * @param {Function} errorHandler - this function will invoke after event if it failured to call.
	     * @returns {void} ?
	     */
	    Base.prototype.trigger = function (eventName, eventProp, successHandler, errorHandler) {
	        var _this = this;
	        if (this.isDestroyed !== true) {
	            var prevDetection = this.isProtectedOnChange;
	            this.isProtectedOnChange = false;
	            var data = this.modelObserver.notify(eventName, eventProp, successHandler, errorHandler);
	            if (isColEName.test(eventName)) {
	                var handler = getValue(eventName, this);
	                if (handler) {
	                    var blazor = 'Blazor';
	                    if (window["" + blazor]) {
	                        var promise = handler.call(this, eventProp);
	                        if (promise && typeof promise.then === 'function') {
	                            if (!successHandler) {
	                                data = promise;
	                            }
	                            else {
	                                promise.then(function (data) {
	                                    if (successHandler) {
	                                        data = typeof data === 'string' && _this.modelObserver.isJson(data) ?
	                                            JSON.parse(data) : data;
	                                        successHandler.call(_this, data);
	                                    }
	                                }).catch(function (data) {
	                                    if (errorHandler) {
	                                        data = typeof data === 'string' && _this.modelObserver.isJson(data) ? JSON.parse(data) : data;
	                                        errorHandler.call(_this, data);
	                                    }
	                                });
	                            }
	                        }
	                        else if (successHandler) {
	                            successHandler.call(this, eventProp);
	                        }
	                    }
	                    else {
	                        handler.call(this, eventProp);
	                        if (successHandler) {
	                            successHandler.call(this, eventProp);
	                        }
	                    }
	                }
	                else if (successHandler) {
	                    successHandler.call(this, eventProp);
	                }
	            }
	            this.isProtectedOnChange = prevDetection;
	            return data;
	        }
	    };
	    /**
	     * To maintain instance in base class
	     *
	     * @returns {void} ?
	     */
	    Base.prototype.addInstance = function () {
	        // Add module class to the root element
	        var moduleClass = 'e-' + this.getModuleName().toLowerCase();
	        addClass([this.element], ['e-lib', moduleClass]);
	        if (!isNullOrUndefined(this.element.ej2_instances)) {
	            this.element.ej2_instances.push(this);
	        }
	        else {
	            setValue('ej2_instances', [this], this.element);
	        }
	    };
	    /**
	     * To remove the instance from the element
	     *
	     * @returns {void} ?
	     */
	    Base.prototype.destroy = function () {
	        var _this = this;
	        // eslint-disable-next-line
	        this.element.ej2_instances =
	            this.element.ej2_instances.filter(function (i) { return i !== _this; });
	        removeClass([this.element], ['e-' + this.getModuleName()]);
	        if (this.element.ej2_instances.length === 0) {
	            // Remove module class from the root element
	            removeClass([this.element], ['e-lib']);
	        }
	        this.clearChanges();
	        this.modelObserver.destroy();
	        this.isDestroyed = true;
	    };
	    return Base;
	}());

	/**
	 * Returns the Class Object
	 *
	 * @param {ClassObject} instance - instance of ClassObject
	 * @param {string} curKey - key of the current instance
	 * @param {Object} defaultValue - default Value
	 * @param {Object[]} type ?
	 * @returns {ClassObject} ?
	 */
	// eslint-disable-next-line
	function getObject(instance, curKey, defaultValue, type) {
	    // eslint-disable-next-line
	    if (!instance.properties.hasOwnProperty(curKey) || !(instance.properties[curKey] instanceof type)) {
	        instance.properties["" + curKey] = createInstance(type, [instance, curKey, defaultValue]);
	    }
	    return instance.properties["" + curKey];
	}
	/**
	 * Returns object array
	 *
	 * @param {ClassObject} instance ?
	 * @param {string} curKey ?
	 * @param {Object[]} defaultValue ?
	 * @param {Object} type ?
	 * @param {boolean} isSetter ?
	 * @param {boolean} isFactory ?
	 * @returns {Object[]} ?
	 */
	// eslint-disable-next-line
	function getObjectArray(instance, curKey, defaultValue, type, isSetter, isFactory) {
	    var result = [];
	    var len = defaultValue ? defaultValue.length : 0;
	    for (var i = 0; i < len; i++) {
	        var curType = type;
	        if (isFactory) {
	            curType = type(defaultValue[parseInt(i.toString(), 10)], instance);
	        }
	        if (isSetter) {
	            var inst = createInstance(curType, [instance, curKey, {}, true]);
	            inst.setProperties(defaultValue[parseInt(i.toString(), 10)], true);
	            result.push(inst);
	        }
	        else {
	            result.push(createInstance(curType, [instance, curKey, defaultValue[parseInt(i.toString(), 10)], false]));
	        }
	    }
	    return result;
	}
	/**
	 * Returns the properties of the object
	 *
	 * @param {Object} defaultValue ?
	 * @param {string} curKey ?
	 * @returns {void} ?
	 */
	function propertyGetter(defaultValue, curKey) {
	    return function () {
	        // eslint-disable-next-line
	        if (!this.properties.hasOwnProperty(curKey)) {
	            this.properties["" + curKey] = defaultValue;
	        }
	        return this.properties["" + curKey];
	    };
	}
	/**
	 * Set the properties for the object
	 *
	 * @param {Object} defaultValue ?
	 * @param {string} curKey ?
	 * @returns {void} ?
	 */
	function propertySetter(defaultValue, curKey) {
	    return function (newValue) {
	        if (this.properties["" + curKey] !== newValue) {
	            // eslint-disable-next-line
	            var oldVal = this.properties.hasOwnProperty(curKey) ? this.properties[curKey] : defaultValue;
	            this.saveChanges(curKey, newValue, oldVal);
	            this.properties["" + curKey] = newValue;
	        }
	    };
	}
	/**
	 * Returns complex objects
	 *
	 * @param {Object} defaultValue ?
	 * @param {string} curKey ?
	 * @param {Object[]} type ?
	 * @returns {void} ?
	 */
	// eslint-disable-next-line
	function complexGetter(defaultValue, curKey, type) {
	    return function () {
	        return getObject(this, curKey, defaultValue, type);
	    };
	}
	/**
	 * Sets complex objects
	 *
	 * @param {Object} defaultValue ?
	 * @param {string} curKey ?
	 * @param {Object[]} type ?
	 * @returns {void} ?
	 */
	function complexSetter(defaultValue, curKey, type) {
	    return function (newValue) {
	        getObject(this, curKey, defaultValue, type).setProperties(newValue);
	    };
	}
	/**
	 *
	 * @param {Object[]} defaultValue ?
	 * @param {string} curKey ?
	 * @param {Object[]} type ?
	 * @returns {void} ?
	 */
	function complexArrayGetter(defaultValue, curKey, type) {
	    return function () {
	        var _this = this;
	        // eslint-disable-next-line
	        if (!this.properties.hasOwnProperty(curKey)) {
	            var defCollection = getObjectArray(this, curKey, defaultValue, type, false);
	            this.properties["" + curKey] = defCollection;
	        }
	        var ignore = ((this.controlParent !== undefined && this.controlParent.ignoreCollectionWatch)
	            || this.ignoreCollectionWatch);
	        // eslint-disable-next-line
	        if (!this.properties[curKey].hasOwnProperty('push') && !ignore) {
	            ['push', 'pop'].forEach(function (extendFunc) {
	                var descriptor = {
	                    value: complexArrayDefinedCallback(extendFunc, curKey, type, _this.properties["" + curKey]).bind(_this),
	                    configurable: true
	                };
	                Object.defineProperty(_this.properties["" + curKey], extendFunc, descriptor);
	            });
	        }
	        // eslint-disable-next-line
	        if (!this.properties[curKey].hasOwnProperty('isComplexArray')) {
	            Object.defineProperty(this.properties["" + curKey], 'isComplexArray', { value: true });
	        }
	        return this.properties["" + curKey];
	    };
	}
	/**
	 *
	 * @param {Object[]} defaultValue ?
	 * @param {string} curKey ?
	 * @param {Object[]} type ?
	 * @returns {void} ?
	 */
	function complexArraySetter(defaultValue, curKey, type) {
	    return function (newValue) {
	        this.isComplexArraySetter = true;
	        var oldValueCollection = getObjectArray(this, curKey, defaultValue, type, false);
	        var newValCollection = getObjectArray(this, curKey, newValue, type, true);
	        this.isComplexArraySetter = false;
	        this.saveChanges(curKey, newValCollection, oldValueCollection);
	        this.properties["" + curKey] = newValCollection;
	    };
	}
	/**
	 *
	 * @param {string} dFunc ?
	 * @param {string} curKey ?
	 * @param {Object} type ?
	 * @param {Object} prop ?
	 * @returns {Object} ?
	 */
	function complexArrayDefinedCallback(dFunc, curKey, type, prop) {
	    /* tslint:disable no-function-expression */
	    return function () {
	        var newValue = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            newValue[_i] = arguments[_i];
	        }
	        var keyString = this.propName ? this.getParentKey() + '.' + curKey + '-' : curKey + '-';
	        switch (dFunc) {
	            case 'push':
	                for (var i = 0; i < newValue.length; i++) {
	                    Array.prototype["" + dFunc].apply(prop, [newValue[parseInt(i.toString(), 10)]]);
	                    var model_1 = getArrayModel(keyString + (prop.length - 1), newValue[parseInt(i.toString(), 10)], !this.controlParent, dFunc);
	                    this.serverDataBind(model_1, newValue[parseInt(i.toString(), 10)], false, dFunc);
	                }
	                break;
	            case 'pop':
	                Array.prototype["" + dFunc].apply(prop);
	                // eslint-disable-next-line
	                var model = getArrayModel(keyString + prop.length, null, !this.controlParent, dFunc);
	                this.serverDataBind(model, { ejsAction: 'pop' }, false, dFunc);
	                break;
	        }
	        return prop;
	    };
	}
	/**
	 *
	 * @param {string} keyString ?
	 * @param {Object} value ?
	 * @param {boolean} isControlParent ?
	 * @param {string} arrayFunction ?
	 * @returns {Object} ?
	 */
	function getArrayModel(keyString, value, isControlParent, arrayFunction) {
	    var modelObject = keyString;
	    if (isControlParent) {
	        modelObject = {};
	        modelObject["" + keyString] = value;
	        if (value && typeof value === 'object') {
	            var action = 'ejsAction';
	            modelObject["" + keyString]["" + action] = arrayFunction;
	        }
	    }
	    return modelObject;
	}
	// eslint-disable-next-line
	/**
	 * Method used to create property. General syntax below.
	 *
	 * @param {Object} defaultValue - Specifies the default value of property.
	 * @returns {PropertyDecorator} ?
	 * ```
	 * @Property('TypeScript')
	 * propertyName: Type;
	 * ```
	 * @private
	 */
	function Property(defaultValue) {
	    return function (target, key) {
	        var propertyDescriptor = {
	            set: propertySetter(defaultValue, key),
	            get: propertyGetter(defaultValue, key),
	            enumerable: true,
	            configurable: true
	        };
	        //new property creation
	        Object.defineProperty(target, key, propertyDescriptor);
	        addPropertyCollection(target, key, 'prop', defaultValue);
	    };
	}
	/**
	 * Method used to create complex property. General syntax below.
	 *
	 * @param  {any} defaultValue - Specifies the default value of property.
	 * @param  {Function} type - Specifies the class type of complex object.
	 * @returns {PropertyDecorator} ?
	 * ```
	 * @Complex<Type>({},Type)
	 * propertyName: Type;
	 * ```
	 * @private
	 */
	function Complex(defaultValue, type) {
	    return function (target, key) {
	        var propertyDescriptor = {
	            set: complexSetter(defaultValue, key, type),
	            get: complexGetter(defaultValue, key, type),
	            enumerable: true,
	            configurable: true
	        };
	        //new property creation
	        Object.defineProperty(target, key, propertyDescriptor);
	        addPropertyCollection(target, key, 'complexProp', defaultValue, type);
	    };
	}
	/**
	 * Method used to create complex array property. General syntax below.
	 *
	 * @param  {any} defaultValue - Specifies the default value of property.
	 * @param  {Function} type - Specifies the class type of complex object.
	 * @returns {PropertyDecorator} ?
	 * ```
	 * @Collection([], Type);
	 * propertyName: Type;
	 * ```
	 * @private
	 */
	function Collection(defaultValue, type) {
	    return function (target, key) {
	        var propertyDescriptor = {
	            set: complexArraySetter(defaultValue, key, type),
	            get: complexArrayGetter(defaultValue, key, type),
	            enumerable: true,
	            configurable: true
	        };
	        //new property creation
	        Object.defineProperty(target, key, propertyDescriptor);
	        addPropertyCollection(target, key, 'colProp', defaultValue, type);
	    };
	}
	/**
	 * Method used to create event property. General syntax below.
	 *
	 * @returns {PropertyDecorator} ?
	 * ```
	 * @Event(()=>{return true;})
	 * ```
	 * @private
	 */
	function Event() {
	    return function (target, key) {
	        var eventDescriptor = {
	            set: function (newValue) {
	                var oldValue = this.properties["" + key];
	                if (oldValue !== newValue) {
	                    var finalContext = getParentContext(this, key);
	                    if (isUndefined(oldValue) === false) {
	                        finalContext.context.removeEventListener(finalContext.prefix, oldValue);
	                    }
	                    finalContext.context.addEventListener(finalContext.prefix, newValue);
	                    this.properties["" + key] = newValue;
	                }
	            },
	            get: propertyGetter(undefined, key),
	            enumerable: true,
	            configurable: true
	        };
	        Object.defineProperty(target, key, eventDescriptor);
	        addPropertyCollection(target, key, 'event');
	    };
	}
	/**
	 * NotifyPropertyChanges is triggers the call back when the property has been changed.
	 *
	 * @param {Function} classConstructor ?
	 * @returns {void} ?
	 * ```
	 *  @NotifyPropertyChanges
	 * class DemoClass implements INotifyPropertyChanged {
	 *
	 *     @Property()
	 *     property1: string;
	 *
	 *     dataBind: () => void;
	 *
	 *     constructor() { }
	 *
	 *     onPropertyChanged(newProp: any, oldProp: any) {
	 *         // Called when property changed
	 *     }
	 * }
	 * ```
	 * @private
	 */
	// eslint-disable-next-line
	function NotifyPropertyChanges(classConstructor) {
	    /** Need to code */
	}
	/**
	 * Method  used to create the builderObject for the target component.
	 *
	 * @param {BuildInfo} target ?
	 * @param {string} key ?
	 * @param {string} propertyType ?
	 * @param {Object} defaultValue ?
	 * @param {Function} type ?
	 * @returns {void} ?
	 * @private
	 */
	function addPropertyCollection(target, key, propertyType, defaultValue, type) {
	    if (isUndefined(target.propList)) {
	        target.propList = {
	            props: [],
	            complexProps: [],
	            colProps: [],
	            events: [],
	            propNames: [],
	            complexPropNames: [],
	            colPropNames: [],
	            eventNames: []
	        };
	    }
	    // eslint-disable-next-line
	    target.propList[propertyType + 's'].push({
	        propertyName: key,
	        defaultValue: defaultValue,
	        type: type
	    });
	    // eslint-disable-next-line
	    target.propList[propertyType + 'Names'].push(key);
	}
	/**
	 * Returns parent options for the object
	 *
	 * @param {Object} context ?
	 * @param {string} prefix ?
	 * @returns {ParentOption} ?
	 * @private
	 */
	function getParentContext(context, prefix) {
	    // eslint-disable-next-line
	    if (context.hasOwnProperty('parentObj') === false) {
	        return { context: context, prefix: prefix };
	    }
	    else {
	        var curText = getValue('propName', context);
	        if (curText) {
	            prefix = curText + '-' + prefix;
	        }
	        return getParentContext(getValue('parentObj', context), prefix);
	    }
	}

	var __extends$N = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	/**
	 * The Animation framework provide options to animate the html DOM elements
	 * ```typescript
	 *   let animeObject = new Animation({
	 *      name: 'SlideLeftIn',
	 *      duration: 1000
	 *   });
	 *   animeObject.animate('#anime1');
	 *   animeObject.animate('#anime2', { duration: 500 });
	 * ```
	 */
	var Animation$1 = /** @class */ (function (_super) {
	    __extends$N(Animation, _super);
	    function Animation(options) {
	        var _this = _super.call(this, options, undefined) || this;
	        /**
	         * @private
	         */
	        _this.easing = {
	            ease: 'cubic-bezier(0.250, 0.100, 0.250, 1.000)',
	            linear: 'cubic-bezier(0.250, 0.250, 0.750, 0.750)',
	            easeIn: 'cubic-bezier(0.420, 0.000, 1.000, 1.000)',
	            easeOut: 'cubic-bezier(0.000, 0.000, 0.580, 1.000)',
	            easeInOut: 'cubic-bezier(0.420, 0.000, 0.580, 1.000)',
	            elasticInOut: 'cubic-bezier(0.5,-0.58,0.38,1.81)',
	            elasticIn: 'cubic-bezier(0.17,0.67,0.59,1.81)',
	            elasticOut: 'cubic-bezier(0.7,-0.75,0.99,1.01)'
	        };
	        return _this;
	    }
	    Animation_1 = Animation;
	    /**
	     * Applies animation to the current element.
	     *
	     * @param {string | HTMLElement} element - Element which needs to be animated.
	     * @param {AnimationModel} options - Overriding default animation settings.
	     * @returns {void} ?
	     */
	    Animation.prototype.animate = function (element, options) {
	        options = !options ? {} : options;
	        var model = this.getModel(options);
	        if (typeof element === 'string') {
	            var elements = Array.prototype.slice.call(selectAll(element, document));
	            for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
	                var element_1 = elements_1[_i];
	                model.element = element_1;
	                Animation_1.delayAnimation(model);
	            }
	        }
	        else {
	            model.element = element;
	            Animation_1.delayAnimation(model);
	        }
	    };
	    /**
	     * Stop the animation effect on animated element.
	     *
	     * @param {HTMLElement} element - Element which needs to be stop the animation.
	     * @param {AnimationOptions} model - Handling the animation model at stop function.
	     * @return {void}
	     */
	    Animation.stop = function (element, model) {
	        element.style.animation = '';
	        element.removeAttribute('e-animate');
	        var animationId = element.getAttribute('e-animation-id');
	        if (animationId) {
	            var frameId = parseInt(animationId, 10);
	            cancelAnimationFrame(frameId);
	            element.removeAttribute('e-animation-id');
	        }
	        if (model && model.end) {
	            model.end.call(this, model);
	        }
	    };
	    /**
	     * Set delay to animation element
	     *
	     * @param {AnimationModel} model ?
	     * @returns {void}
	     */
	    Animation.delayAnimation = function (model) {
	        if (animationMode === 'Disable' || animationMode === GlobalAnimationMode.Disable) {
	            if (model.begin) {
	                model.begin.call(this, model);
	            }
	            if (model.end) {
	                model.end.call(this, model);
	            }
	        }
	        else {
	            if (model.delay) {
	                setTimeout(function () { Animation_1.applyAnimation(model); }, model.delay);
	            }
	            else {
	                Animation_1.applyAnimation(model);
	            }
	        }
	    };
	    /**
	     * Triggers animation
	     *
	     * @param {AnimationModel} model ?
	     * @returns {void}
	     */
	    Animation.applyAnimation = function (model) {
	        var _this = this;
	        model.timeStamp = 0;
	        var step = 0;
	        var timerId = 0;
	        var prevTimeStamp = 0;
	        var duration = model.duration;
	        model.element.setAttribute('e-animate', 'true');
	        var startAnimation = function (timeStamp) {
	            try {
	                if (timeStamp) {
	                    // let step: number = model.timeStamp = timeStamp - startTime;
	                    /** phantomjs workaround for timestamp fix */
	                    prevTimeStamp = prevTimeStamp === 0 ? timeStamp : prevTimeStamp;
	                    model.timeStamp = (timeStamp + model.timeStamp) - prevTimeStamp;
	                    prevTimeStamp = timeStamp;
	                    /** phantomjs workaround end */
	                    // trigger animation begin event
	                    if (!step && model.begin) {
	                        model.begin.call(_this, model);
	                    }
	                    step = step + 1;
	                    var avg = model.timeStamp / step;
	                    if (model.timeStamp < duration && model.timeStamp + avg < duration && model.element.getAttribute('e-animate')) {
	                        // apply animation effect to the current element
	                        model.element.style.animation = model.name + ' ' + model.duration + 'ms ' + model.timingFunction;
	                        if (model.progress) {
	                            model.progress.call(_this, model);
	                        }
	                        // repeat requestAnimationFrame
	                        requestAnimationFrame(startAnimation);
	                    }
	                    else {
	                        // clear requestAnimationFrame
	                        cancelAnimationFrame(timerId);
	                        model.element.removeAttribute('e-animation-id');
	                        model.element.removeAttribute('e-animate');
	                        model.element.style.animation = '';
	                        if (model.end) {
	                            model.end.call(_this, model);
	                        }
	                    }
	                }
	                else {
	                    //startTime = performance.now();
	                    // set initial requestAnimationFrame
	                    timerId = requestAnimationFrame(startAnimation);
	                    model.element.setAttribute('e-animation-id', timerId.toString());
	                }
	            }
	            catch (e) {
	                cancelAnimationFrame(timerId);
	                model.element.removeAttribute('e-animation-id');
	                if (model.fail) {
	                    model.fail.call(_this, e);
	                }
	            }
	        };
	        startAnimation();
	    };
	    /**
	     * Returns Animation Model
	     *
	     * @param {AnimationModel} options ?
	     * @returns {AnimationModel} ?
	     */
	    Animation.prototype.getModel = function (options) {
	        return {
	            name: options.name || this.name,
	            delay: options.delay || this.delay,
	            duration: (options.duration !== undefined ? options.duration : this.duration),
	            begin: options.begin || this.begin,
	            end: options.end || this.end,
	            fail: options.fail || this.fail,
	            progress: options.progress || this.progress,
	            timingFunction: this.easing[options.timingFunction] ? this.easing[options.timingFunction] :
	                (options.timingFunction || this.easing[this.timingFunction])
	        };
	    };
	    /**
	     * @private
	     * @param {AnimationModel} newProp ?
	     * @param {AnimationModel} oldProp ?
	     * @returns {void} ?
	     */
	    // eslint-disable-next-line
	    Animation.prototype.onPropertyChanged = function (newProp, oldProp) {
	        // no code needed
	    };
	    /**
	     * Returns module name as animation
	     *
	     * @private
	     * @returns {void} ?
	     */
	    Animation.prototype.getModuleName = function () {
	        return 'animation';
	    };
	    /**
	     *
	     * @private
	     * @returns {void} ?
	     */
	    Animation.prototype.destroy = function () {
	        //Override base destroy;
	    };
	    var Animation_1;
	    __decorate$h([
	        Property('FadeIn')
	    ], Animation.prototype, "name", void 0);
	    __decorate$h([
	        Property(400)
	    ], Animation.prototype, "duration", void 0);
	    __decorate$h([
	        Property('ease')
	    ], Animation.prototype, "timingFunction", void 0);
	    __decorate$h([
	        Property(0)
	    ], Animation.prototype, "delay", void 0);
	    __decorate$h([
	        Event()
	    ], Animation.prototype, "progress", void 0);
	    __decorate$h([
	        Event()
	    ], Animation.prototype, "begin", void 0);
	    __decorate$h([
	        Event()
	    ], Animation.prototype, "end", void 0);
	    __decorate$h([
	        Event()
	    ], Animation.prototype, "fail", void 0);
	    Animation = Animation_1 = __decorate$h([
	        NotifyPropertyChanges
	    ], Animation);
	    return Animation;
	}(Base));
	/**
	 * Ripple provides material theme's wave effect when an element is clicked
	 * ```html
	 * <div id='ripple'></div>
	 * <script>
	 *   rippleEffect(document.getElementById('ripple'));
	 * </script>
	 * ```
	 *
	 * @private
	 * @param {HTMLElement} element - Target element
	 * @param {RippleOptions} rippleOptions - Ripple options .
	 * @param {Function} done .
	 * @returns {void} .
	 */
	function rippleEffect(element, rippleOptions, done) {
	    var rippleModel = getRippleModel(rippleOptions);
	    if (rippleModel.rippleFlag === false || (rippleModel.rippleFlag === undefined && !isRippleEnabled)) {
	        return (function () {
	            // do nothing.
	        });
	    }
	    element.setAttribute('data-ripple', 'true');
	    EventHandler.add(element, 'mousedown', rippleHandler, { parent: element, rippleOptions: rippleModel });
	    EventHandler.add(element, 'mouseup', rippleUpHandler, { parent: element, rippleOptions: rippleModel, done: done });
	    EventHandler.add(element, 'mouseleave', rippleLeaveHandler, { parent: element, rippleOptions: rippleModel });
	    if (Browser.isPointer) {
	        EventHandler.add(element, 'transitionend', rippleLeaveHandler, { parent: element, rippleOptions: rippleModel });
	    }
	    return (function () {
	        element.removeAttribute('data-ripple');
	        EventHandler.remove(element, 'mousedown', rippleHandler);
	        EventHandler.remove(element, 'mouseup', rippleUpHandler);
	        EventHandler.remove(element, 'mouseleave', rippleLeaveHandler);
	        EventHandler.remove(element, 'transitionend', rippleLeaveHandler);
	    });
	}
	/**
	 * Handler for ripple model
	 *
	 * @param {RippleOptions} rippleOptions ?
	 * @returns {RippleOptions} ?
	 */
	function getRippleModel(rippleOptions) {
	    var rippleModel = {
	        selector: rippleOptions && rippleOptions.selector ? rippleOptions.selector : null,
	        ignore: rippleOptions && rippleOptions.ignore ? rippleOptions.ignore : null,
	        rippleFlag: rippleOptions && rippleOptions.rippleFlag,
	        isCenterRipple: rippleOptions && rippleOptions.isCenterRipple,
	        duration: rippleOptions && rippleOptions.duration ? rippleOptions.duration : 350
	    };
	    return rippleModel;
	}
	/**
	 * Handler for ripple event
	 *
	 * @param {MouseEvent} e ?
	 * @returns {void} ?
	 * @private
	 */
	function rippleHandler(e) {
	    var target = (e.target);
	    var selector = this.rippleOptions.selector;
	    var element = selector ? closest(target, selector) : target;
	    if (!element || (this.rippleOptions && closest(target, this.rippleOptions.ignore))) {
	        return;
	    }
	    var offset = element.getBoundingClientRect();
	    var offsetX = e.pageX - document.body.scrollLeft;
	    var offsetY = e.pageY - ((!document.body.scrollTop && document.documentElement) ?
	        document.documentElement.scrollTop : document.body.scrollTop);
	    var pageX = Math.max(Math.abs(offsetX - offset.left), Math.abs(offsetX - offset.right));
	    var pageY = Math.max(Math.abs(offsetY - offset.top), Math.abs(offsetY - offset.bottom));
	    var radius = Math.sqrt(pageX * pageX + pageY * pageY);
	    var diameter = radius * 2 + 'px';
	    var x = offsetX - offset.left - radius;
	    var y = offsetY - offset.top - radius;
	    if (this.rippleOptions && this.rippleOptions.isCenterRipple) {
	        x = 0;
	        y = 0;
	        diameter = '100%';
	    }
	    element.classList.add('e-ripple');
	    var duration = this.rippleOptions.duration.toString();
	    var styles = 'width: ' + diameter + ';height: ' + diameter + ';left: ' + x + 'px;top: ' + y + 'px;' +
	        'transition-duration: ' + duration + 'ms;';
	    var rippleElement = createElement('div', { className: 'e-ripple-element', styles: styles });
	    element.appendChild(rippleElement);
	    window.getComputedStyle(rippleElement).getPropertyValue('opacity');
	    rippleElement.style.transform = 'scale(1)';
	    if (element !== this.parent) {
	        EventHandler.add(element, 'mouseleave', rippleLeaveHandler, { parent: this.parent, rippleOptions: this.rippleOptions });
	    }
	}
	/**
	 * Handler for ripple element mouse up event
	 *
	 * @param {MouseEvent} e ?
	 * @returns {void} ?
	 * @private
	 */
	function rippleUpHandler(e) {
	    removeRipple(e, this);
	}
	/**
	 * Handler for ripple element mouse move event
	 *
	 * @param {MouseEvent} e ?
	 * @returns {void} ?
	 * @private
	 */
	function rippleLeaveHandler(e) {
	    removeRipple(e, this);
	}
	/**
	 * Handler for removing ripple element
	 *
	 * @param {MouseEvent} e ?
	 * @param {RippleArgs} eventArgs ?
	 * @returns {void} ?
	 * @private
	 */
	function removeRipple(e, eventArgs) {
	    var duration = eventArgs.rippleOptions.duration;
	    var target = (e.target);
	    var selector = eventArgs.rippleOptions.selector;
	    var element = selector ? closest(target, selector) : target;
	    if (!element || (element && element.className.indexOf('e-ripple') === -1)) {
	        return;
	    }
	    var rippleElements = selectAll('.e-ripple-element', element);
	    var rippleElement = rippleElements[rippleElements.length - 1];
	    if (rippleElement) {
	        rippleElement.style.opacity = '0.5';
	    }
	    if (eventArgs.parent !== element) {
	        EventHandler.remove(element, 'mouseleave', rippleLeaveHandler);
	    }
	    /* tslint:disable:align */
	    setTimeout(function () {
	        if (rippleElement && rippleElement.parentNode) {
	            rippleElement.parentNode.removeChild(rippleElement);
	        }
	        if (!element.getElementsByClassName('e-ripple-element').length) {
	            element.classList.remove('e-ripple');
	        }
	        if (eventArgs.done) {
	            eventArgs.done(e);
	        }
	    }, duration);
	}
	var isRippleEnabled = false;
	/**
	 * Defines the Modes of Global animation.
	 *
	 * @private
	 */
	var animationMode;
	/**
	 * Defines the global animation modes for all components.
	 */
	var GlobalAnimationMode;
	(function (GlobalAnimationMode) {
	    /**
	    * Defines the global animation mode as Default. Animation is enabled or disabled based on the component's animation settings.
	    */
	    GlobalAnimationMode["Default"] = "Default";
	    /**
	    * Defines the global animation mode as Enable. Enables the animation for all components, regardless of the individual component's animation settings.
	    */
	    GlobalAnimationMode["Enable"] = "Enable";
	    /**
	    * Defines the global animation mode as Disable. Disables the animation for all components, regardless of the individual component's animation settings.
	    */
	    GlobalAnimationMode["Disable"] = "Disable";
	})(GlobalAnimationMode || (GlobalAnimationMode = {}));

	/**
	 * Module loading operations
	 */
	var MODULE_SUFFIX = 'Module';
	var ModuleLoader = /** @class */ (function () {
	    function ModuleLoader(parent) {
	        this.loadedModules = [];
	        this.parent = parent;
	    }
	    /**
	     * Inject required modules in component library
	     *
	     * @returns {void} ?
	     * @param {ModuleDeclaration[]} requiredModules - Array of modules to be required
	     * @param {Function[]} moduleList - Array of modules to be injected from sample side
	     */
	    ModuleLoader.prototype.inject = function (requiredModules, moduleList) {
	        var reqLength = requiredModules.length;
	        if (reqLength === 0) {
	            this.clean();
	            return;
	        }
	        if (this.loadedModules.length) {
	            this.clearUnusedModule(requiredModules);
	        }
	        for (var i = 0; i < reqLength; i++) {
	            var modl = requiredModules[parseInt(i.toString(), 10)];
	            for (var _i = 0, moduleList_1 = moduleList; _i < moduleList_1.length; _i++) {
	                var module = moduleList_1[_i];
	                var modName = modl.member;
	                if (module && module.prototype.getModuleName() === modl.member && !this.isModuleLoaded(modName)) {
	                    var moduleObject = createInstance(module, modl.args);
	                    var memberName = this.getMemberName(modName);
	                    if (modl.isProperty) {
	                        setValue(memberName, module, this.parent);
	                    }
	                    else {
	                        setValue(memberName, moduleObject, this.parent);
	                    }
	                    var loadedModule = modl;
	                    loadedModule.member = memberName;
	                    this.loadedModules.push(loadedModule);
	                }
	            }
	        }
	    };
	    /**
	     * To remove the created object while destroying the control
	     *
	     * @returns {void}
	     */
	    ModuleLoader.prototype.clean = function () {
	        for (var _i = 0, _a = this.loadedModules; _i < _a.length; _i++) {
	            var modules = _a[_i];
	            if (!modules.isProperty) {
	                getValue(modules.member, this.parent).destroy();
	            }
	        }
	        this.loadedModules = [];
	    };
	    /**
	     * Removes all unused modules
	     *
	     * @param {ModuleDeclaration[]} moduleList ?
	     * @returns {void} ?
	     */
	    ModuleLoader.prototype.clearUnusedModule = function (moduleList) {
	        var _this = this;
	        var usedModules = moduleList.map(function (arg) { return _this.getMemberName(arg.member); });
	        var removableModule = this.loadedModules.filter(function (module) {
	            return usedModules.indexOf(module.member) === -1;
	        });
	        for (var _i = 0, removableModule_1 = removableModule; _i < removableModule_1.length; _i++) {
	            var mod = removableModule_1[_i];
	            if (!mod.isProperty) {
	                getValue(mod.member, this.parent).destroy();
	            }
	            this.loadedModules.splice(this.loadedModules.indexOf(mod), 1);
	            deleteObject(this.parent, mod.member);
	        }
	    };
	    /**
	     * To get the name of the member.
	     *
	     * @param {string} name ?
	     * @returns {string} ?
	     */
	    ModuleLoader.prototype.getMemberName = function (name) {
	        return name[0].toLowerCase() + name.substring(1) + MODULE_SUFFIX;
	    };
	    /**
	     * Returns boolean based on whether the module specified is loaded or not
	     *
	     * @param {string} modName ?
	     * @returns {boolean} ?
	     */
	    ModuleLoader.prototype.isModuleLoaded = function (modName) {
	        for (var _i = 0, _a = this.loadedModules; _i < _a.length; _i++) {
	            var mod = _a[_i];
	            if (mod.member === this.getMemberName(modName)) {
	                return true;
	            }
	        }
	        return false;
	    };
	    return ModuleLoader;
	}());

	/**
	 * To detect the changes for inner properties.
	 *
	 * @private
	 */
	var ChildProperty = /** @class */ (function () {
	    function ChildProperty(parent, propName, defaultValue, isArray) {
	        this.isComplexArraySetter = false;
	        this.properties = {};
	        this.changedProperties = {};
	        this.childChangedProperties = {};
	        this.oldProperties = {};
	        // eslint-disable-next-line
	        this.finalUpdate = function () { };
	        this.callChildDataBind = getValue('callChildDataBind', Base);
	        this.parentObj = parent;
	        this.controlParent = this.parentObj.controlParent || this.parentObj;
	        this.propName = propName;
	        this.isParentArray = isArray;
	        this.setProperties(defaultValue, true);
	    }
	    /**
	     * Updates the property changes
	     *
	     * @param {boolean} val ?
	     * @param {string} propName ?
	     * @returns {void} ?
	     */
	    ChildProperty.prototype.updateChange = function (val, propName) {
	        if (val === true) {
	            this.parentObj.childChangedProperties["" + propName] = val;
	        }
	        else {
	            delete this.parentObj.childChangedProperties["" + propName];
	        }
	        if (this.parentObj.updateChange) {
	            this.parentObj.updateChange(val, this.parentObj.propName);
	        }
	    };
	    /**
	     * Updates time out duration
	     *
	     * @returns {void} ?
	     */
	    ChildProperty.prototype.updateTimeOut = function () {
	        if (this.parentObj.updateTimeOut) {
	            this.parentObj.finalUpdate();
	            this.parentObj.updateTimeOut();
	        }
	        else {
	            var changeTime_1 = setTimeout(this.parentObj.dataBind.bind(this.parentObj));
	            var clearUpdate = function () {
	                clearTimeout(changeTime_1);
	            };
	            this.finalUpdate = clearUpdate;
	        }
	    };
	    /**
	     * Clears changed properties
	     *
	     * @returns {void} ?
	     */
	    ChildProperty.prototype.clearChanges = function () {
	        this.finalUpdate();
	        this.updateChange(false, this.propName);
	        this.oldProperties = {};
	        this.changedProperties = {};
	    };
	    /**
	     * Set property changes
	     *
	     * @param {Object} prop ?
	     * @param {boolean} muteOnChange ?
	     * @returns {void} ?
	     */
	    ChildProperty.prototype.setProperties = function (prop, muteOnChange) {
	        if (muteOnChange === true) {
	            merge(this, prop);
	            this.updateChange(false, this.propName);
	            this.clearChanges();
	        }
	        else {
	            merge(this, prop);
	        }
	    };
	    /**
	     * Binds data
	     *
	     * @returns {void} ?
	     */
	    ChildProperty.prototype.dataBind = function () {
	        this.callChildDataBind(this.childChangedProperties, this);
	        if (this.isParentArray) {
	            var curIndex = this.parentObj[this.propName].indexOf(this);
	            if (Object.keys(this.changedProperties).length) {
	                setValue(this.propName + '.' + curIndex, this.changedProperties, this.parentObj.changedProperties);
	                setValue(this.propName + '.' + curIndex, this.oldProperties, this.parentObj.oldProperties);
	            }
	        }
	        else {
	            this.parentObj.changedProperties[this.propName] = this.changedProperties;
	            this.parentObj.oldProperties[this.propName] = this.oldProperties;
	        }
	        this.clearChanges();
	    };
	    /**
	     * Saves changes to newer values
	     *
	     * @param {string} key ?
	     * @param {Object} newValue ?
	     * @param {Object} oldValue ?
	     * @param {boolean} restrictServerDataBind ?
	     * @returns {void} ?
	     */
	    ChildProperty.prototype.saveChanges = function (key, newValue, oldValue, restrictServerDataBind) {
	        if (this.controlParent.isProtectedOnChange) {
	            return;
	        }
	        if (!restrictServerDataBind) {
	            this.serverDataBind(key, newValue, true);
	        }
	        this.oldProperties["" + key] = oldValue;
	        this.changedProperties["" + key] = newValue;
	        this.updateChange(true, this.propName);
	        this.finalUpdate();
	        this.updateTimeOut();
	    };
	    ChildProperty.prototype.serverDataBind = function (key, value, isSaveChanges, action) {
	    };
	    ChildProperty.prototype.getParentKey = function (isSaveChanges) {
	        // eslint-disable-next-line
	        var index = '';
	        var propName = this.propName;
	        /* istanbul ignore next */
	        if (this.isParentArray) {
	            index = this.parentObj[this.propName].indexOf(this);
	            var valueLength = this.parentObj[this.propName].length;
	            valueLength = isSaveChanges ? valueLength : (valueLength > 0 ? valueLength - 1 : 0);
	            index = index !== -1 ? '-' + index : '-' + valueLength;
	            propName = propName + index;
	        }
	        if (this.controlParent !== this.parentObj) {
	            propName = this.parentObj.getParentKey() + '.' + this.propName + index;
	        }
	        return propName;
	    };
	    return ChildProperty;
	}());

	var componentList = ['grid', 'pivotview', 'treegrid', 'spreadsheet', 'rangeNavigator', 'DocumentEditor', 'listbox', 'inplaceeditor', 'PdfViewer', 'richtexteditor', 'DashboardLayout', 'chart', 'stockChart', 'circulargauge', 'diagram', 'heatmap', 'lineargauge', 'maps', 'slider', 'smithchart', 'barcode', 'sparkline', 'treemap', 'bulletChart', 'kanban', 'daterangepicker', 'schedule', 'gantt', 'signature', 'query-builder', 'drop-down-tree', 'carousel', 'filemanager', 'uploader', 'accordion', 'tab', 'treeview'];
	var bypassKey = [115, 121, 110, 99, 102, 117, 115, 105,
	    111, 110, 46, 105, 115, 76, 105, 99, 86, 97, 108,
	    105, 100, 97, 116, 101, 100];
	var accountURL;
	/**
	 * License validation module
	 *
	 * @private
	 */
	var LicenseValidator = /** @class */ (function () {
	    function LicenseValidator(key) {
	        this.isValidated = false;
	        this.isLicensed = true;
	        this.version = '23';
	        this.platform = /JavaScript|ASPNET|ASPNETCORE|ASPNETMVC|FileFormats|essentialstudio/i;
	        this.errors = {
	            noLicense: '<span>This application was built using a trial version of Syncfusion Essential Studio.' +
	                ' To remove the license validation message permanently, a valid license key must be included.</span>',
	            trailExpired: '<span>This application was built using a trial version of Syncfusion Essential Studio.' +
	                ' To remove the license validation message permanently, a valid license key must be included.</span>',
	            versionMismatched: '<span>The included Syncfusion license key is invalid.</span>',
	            platformMismatched: '<span>The included Syncfusion license key is invalid.</span>',
	            invalidKey: '<span>The included Syncfusion license key is invalid.</span>'
	        };
	        /**
	         * To manage licensing operation.
	         */
	        this.manager = (function () {
	            var licKey = null;
	            /**
	             * Sets the license key.
	             *
	             * @param {string} key - Specifies the license key.
	             * @returns {void}
	             */
	            function set(key) { licKey = key; }
	            /**
	             * Gets the license key.
	             *
	             * @returns {string} -Gets the license key.
	             */
	            function get() { return licKey; }
	            return {
	                setKey: set,
	                getKey: get
	            };
	        })();
	        /**
	         * To manage npx licensing operation.
	         */
	        this.npxManager = (function () {
	            var npxLicKey = 'npxKeyReplace';
	            /**
	             * Gets the license key.
	             *
	             * @returns {string} - Gets the license key.
	             */
	            function get() { return npxLicKey; }
	            return {
	                getKey: get
	            };
	        })();
	        this.manager.setKey(key);
	    }
	    /**
	     * To validate the provided license key.
	    */
	    LicenseValidator.prototype.validate = function () {
	        var contentKey = [115, 121, 110, 99, 102, 117, 115, 105, 111, 110, 46,
	            108, 105, 99, 101, 110, 115, 101, 67, 111, 110, 116, 101, 110, 116];
	        var URLKey = [115, 121, 110, 99, 102, 117, 115, 105, 111, 110, 46,
	            99, 108, 97, 105, 109, 65, 99, 99, 111, 117, 110, 116, 85, 82, 76];
	        if (!this.isValidated && (containerObject && !getValue(convertToChar(bypassKey), containerObject) && !getValue('Blazor', containerObject))) {
	            var validateMsg = void 0;
	            var validateURL = void 0;
	            if ((this.manager && this.manager.getKey()) || (this.npxManager && this.npxManager.getKey() !== 'npxKeyReplace')) {
	                var result = this.getInfoFromKey();
	                if (result && result.length) {
	                    for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
	                        var res = result_1[_i];
	                        if (!this.platform.test(res.platform) || res.invalidPlatform) {
	                            validateMsg = this.errors.platformMismatched;
	                        }
	                        else if (res.version.indexOf(this.version) === -1) {
	                            validateMsg = this.errors.versionMismatched;
	                            validateMsg = validateMsg.replace('##LicenseVersion', res.version);
	                            validateMsg = validateMsg.replace('##Requireversion', this.version + '.x');
	                        }
	                        else if (res.expiryDate) {
	                            var expDate = new Date(res.expiryDate);
	                            var currDate = new Date();
	                            if (expDate !== currDate && expDate < currDate) {
	                                validateMsg = this.errors.trailExpired;
	                            }
	                            else {
	                                break;
	                            }
	                        }
	                    }
	                }
	                else {
	                    validateMsg = this.errors.invalidKey;
	                }
	            }
	            else {
	                var licenseContent = getValue(convertToChar(contentKey), containerObject);
	                validateURL = getValue(convertToChar(URLKey), containerObject);
	                if (licenseContent && licenseContent !== '') {
	                    validateMsg = licenseContent;
	                }
	                else {
	                    validateMsg = this.errors.noLicense;
	                }
	            }
	            if (validateMsg && typeof document !== 'undefined' && !isNullOrUndefined(document)) {
	                accountURL = (validateURL && validateURL !== '') ? validateURL : "https://www.syncfusion.com/account/claim-license-key?pl=SmF2YVNjcmlwdA==&vs=MjM=&utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information";
	                var errorDiv = createElement('div', {
	                    innerHTML: "<img src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzE5OV80KSI+CjxwYXRoIGQ9Ik0xMiAyMUMxNi45NzA2IDIxIDIxIDE2Ljk3MDYgMjEgMTJDMjEgNy4wMjk0NCAxNi45NzA2IDMgMTIgM0M3LjAyOTQ0IDMgMyA3LjAyOTQ0IDMgMTJDMyAxNi45NzA2IDcuMDI5NDQgMjEgMTIgMjFaIiBzdHJva2U9IiM3MzczNzMiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik0xMS4yNSAxMS4yNUgxMlYxNi41SDEyLjc1IiBmaWxsPSIjNjE2MDYzIi8+CjxwYXRoIGQ9Ik0xMS4yNSAxMS4yNUgxMlYxNi41SDEyLjc1IiBzdHJva2U9IiM3MzczNzMiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik0xMS44MTI1IDlDMTIuNDMzOCA5IDEyLjkzNzUgOC40OTYzMiAxMi45Mzc1IDcuODc1QzEyLjkzNzUgNy4yNTM2OCAxMi40MzM4IDYuNzUgMTEuODEyNSA2Ljc1QzExLjE5MTIgNi43NSAxMC42ODc1IDcuMjUzNjggMTAuNjg3NSA3Ljg3NUMxMC42ODc1IDguNDk2MzIgMTEuMTkxMiA5IDExLjgxMjUgOVoiIGZpbGw9IiM3MzczNzMiLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8xOTlfNCI+CjxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K' style=\"top: 6px;\n                    position: absolute;\n                    left: 16px;\n                    width: 24px;\n                    height: 24px;\"/>" + validateMsg + ' ' + '<a style="text-decoration: none;color: #0D6EFD;font-weight: 500;" href=' + accountURL + '>Claim your free account</a>'
	                });
	                errorDiv.setAttribute('style', "position: fixed;\n                top: 10px;\n                left: 10px;\n                right: 10px;\n                font-size: 14px;\n                background: #EEF2FF;\n                color: #222222;\n                z-index: 999999999;\n                text-align: left;\n                border: 1px solid #EEEEEE;\n                padding: 10px 11px 10px 50px;\n                border-radius: 8px;\n                font-family: Helvetica Neue, Helvetica, Arial;");
	                document.body.appendChild(errorDiv);
	                this.isLicensed = false;
	            }
	            this.isValidated = true;
	            setValue(convertToChar(bypassKey), this.isValidated, containerObject);
	        }
	        return this.isLicensed;
	    };
	    LicenseValidator.prototype.getDecryptedData = function (key) {
	        try {
	            return atob(key);
	        }
	        catch (error) {
	            return '';
	        }
	    };
	    /**
	     * Get license information from key.
	     *
	     * @returns {IValidator} - Get license information from key.
	     */
	    LicenseValidator.prototype.getInfoFromKey = function () {
	        try {
	            var licKey = '';
	            var pkey = [5439488, 7929856, 5111808, 6488064, 4587520, 7667712, 5439488,
	                6881280, 5177344, 7208960, 4194304, 4456448, 6619136, 7733248, 5242880, 7077888,
	                6356992, 7602176, 4587520, 7274496, 7471104, 7143424];
	            var decryptedStr = [];
	            var resultArray = [];
	            var invalidPlatform = false;
	            var isNpxKey = false;
	            if (this.manager.getKey()) {
	                licKey = this.manager.getKey();
	            }
	            else {
	                isNpxKey = true;
	                licKey = this.npxManager.getKey().split('npxKeyReplace')[1];
	            }
	            var licKeySplit = licKey.split(';');
	            for (var _i = 0, licKeySplit_1 = licKeySplit; _i < licKeySplit_1.length; _i++) {
	                var lKey = licKeySplit_1[_i];
	                var decodeStr = this.getDecryptedData(lKey);
	                if (!decodeStr) {
	                    continue;
	                }
	                var k = 0;
	                var buffr = '';
	                if (!isNpxKey) {
	                    for (var i = 0; i < decodeStr.length; i++, k++) {
	                        if (k === pkey.length) {
	                            k = 0;
	                        }
	                        var c = decodeStr.charCodeAt(i);
	                        buffr += String.fromCharCode(c ^ (pkey[parseInt(k.toString(), 10)] >> 16));
	                    }
	                }
	                else {
	                    var charKey = decodeStr[decodeStr.length - 1];
	                    var decryptedKey = [];
	                    for (var i = 0; i < decodeStr.length; i++) {
	                        decryptedKey[parseInt(i.toString(), 10)] = decodeStr[parseInt(i.toString(), 10)].charCodeAt(0) - charKey.charCodeAt(0);
	                    }
	                    for (var i = 0; i < decryptedKey.length; i++) {
	                        buffr += String.fromCharCode(decryptedKey[parseInt(i.toString(), 10)]);
	                    }
	                }
	                if (this.platform.test(buffr)) {
	                    decryptedStr = buffr.split(';');
	                    invalidPlatform = false;
	                    // checked the length to verify the key in proper strucutre
	                    if (decryptedStr.length > 3) {
	                        resultArray.push({ platform: decryptedStr[0],
	                            version: decryptedStr[1],
	                            expiryDate: decryptedStr[2] });
	                    }
	                }
	                else if (buffr && buffr.split(';').length > 3) {
	                    invalidPlatform = true;
	                }
	            }
	            if (invalidPlatform && !resultArray.length) {
	                return [{ invalidPlatform: invalidPlatform }];
	            }
	            else {
	                return resultArray.length ? resultArray : null;
	            }
	        }
	        catch (error) {
	            return null;
	        }
	    };
	    return LicenseValidator;
	}());
	var licenseValidator = new LicenseValidator();
	/**
	 * Converts the given number to characters.
	 *
	 * @param {number} cArr - Specifies the license key as number.
	 * @returns {string}
	 */
	function convertToChar(cArr) {
	    var ret = '';
	    for (var _i = 0, cArr_1 = cArr; _i < cArr_1.length; _i++) {
	        var arr = cArr_1[_i];
	        ret += String.fromCharCode(arr);
	    }
	    return ret;
	}
	/**
	 * To set license key.
	 *
	 * @param {string} key - license key
	 * @returns {void}
	 */
	function registerLicense(key) {
	    licenseValidator = new LicenseValidator(key);
	}
	var validateLicense = function (key) {
	    if (key) {
	        registerLicense(key);
	    }
	    return licenseValidator.validate();
	};
	// Method for create overlay over the sample
	var createLicenseOverlay = function () {
	    var bannerTemplate = "\n    <div style=\"\n    position: fixed;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background-color: rgba(0, 0, 0, 0.5);\n    z-index: 99999;\n    \">\n        <div style=\"\n    background: #FFFFFF;\n    height: 455px;\n    width: 840px;\n    font-family: Helvetica Neue, Helvetica, Arial;\n    color: #000000;\n    box-shadow: 0px 4.8px 14.4px rgb(0 0 0 / 18%), 0px 25.6px 57.6px rgb(0 0 0 / 22%);\n    display: block;\n    margin: 8% auto;\n    border-radius: 20px;\n    \">\n            <div style=\"\n    position: absolute;\nwidth: 838px;\nheight: 62px;\nbackground-color: #F9F9F9;\nborder: 1px solid #EEEEEE;\nborder-top-left-radius: 20px;\nborder-top-right-radius: 20px;\n\">\n                <img src=\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQ2IiBoZWlnaHQ9IjMyIiB2aWV3Qm94PSIwIDAgMTQ2IDMyIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNNDAuNTk2NSAxNS4wMDc4SDMyLjQyNUMzMS41NTU3IDE1LjAwNzggMzAuOTAzNyAxNS4xODEyIDMwLjUxMjUgMTUuNDg0NkMzMC4xMjEzIDE1LjgzMTQgMjkuOTA0IDE2LjMwODIgMjkuOTA0IDE3LjA0NTFDMjkuOTA0IDE3LjYwODYgMzAuMDc3OCAxOC4wNDIxIDMwLjQyNTYgMTguMzAyMkMzMC43NzMzIDE4LjYwNTYgMzEuMjk0OSAxOC43MzU2IDMxLjk5MDMgMTguNzM1NkgzNi4zMzY5QzM4LjExODkgMTguNzM1NiAzOS40MjI5IDE5LjA4MjQgNDAuMTYxOCAxOS43MzI2QzQwLjk0NDIgMjAuNDI2MiA0MS4yOTE5IDIxLjU1MzIgNDEuMjkxOSAyMy4xMTM3QzQxLjI5MTkgMjQuNzE3NiA0MC44NTcyIDI1Ljg4OCAzOS45ODc5IDI2LjY2ODJDMzkuMTE4NiAyNy40MDUxIDM3LjcyNzcgMjcuNzk1MyAzNS44NTg3IDI3Ljc5NTNIMjcuMDc4N1YyNS4wMjFIMzUuMzM3MkMzNi4yOTM0IDI1LjAyMSAzNi45NDU0IDI0Ljg5MSAzNy4zMzY2IDI0LjYzMDlDMzcuNzI3NyAyNC4zNzA4IDM3LjkwMTYgMjMuODk0IDM3LjkwMTYgMjMuMjg3MUMzNy45MDE2IDIyLjYzNjkgMzcuNzI3NyAyMi4xNjAxIDM3LjM4IDIxLjlDMzcuMDMyMyAyMS42Mzk5IDM2LjQyMzggMjEuNDY2NSAzNS41NTQ1IDIxLjQ2NjVIMzEuNjQyNkMyOS44NjA1IDIxLjQ2NjUgMjguNTEzMSAyMS4xMTk4IDI3LjY4NzMgMjAuMzgyOEMyNi44NjE0IDE5LjY0NTkgMjYuNDI2OCAxOC41MTg5IDI2LjQyNjggMTcuMDAxN0MyNi40MjY4IDE1LjM1NDUgMjYuODYxNCAxNC4xNDA4IDI3LjczMDcgMTMuMzYwNkMyOC42IDEyLjU4MDMgMjkuOTkwOSAxMi4yMzM1IDMxLjkwMzQgMTIuMjMzNUg0MC41OTY1VjE1LjAwNzhaIiBmaWxsPSIjMzU0M0E4Ii8+CjxwYXRoIGQ9Ik00OC4wNzI3IDI1LjI4MTFINTAuNTA2OFYxNi4zOTQ5SDUzLjU0OTNWMjcuNTM1MkM1My41NDkzIDI5LjA1MjQgNTMuMjAxNiAzMC4xNzk0IDUyLjUwNjIgMzAuOTE2M0M1MS44MTA3IDMxLjY1MzIgNTAuNzI0MSAzMiA0OS4yNDYzIDMySDQzLjMzNVYyOS42NTkySDQ4LjcyNDdDNDkuMjg5NyAyOS42NTkyIDQ5Ljc2NzkgMjkuNTI5MiA1MC4wNzIxIDI5LjIyNThDNTAuMzc2NCAyOC45NjU3IDUwLjU1MDIgMjguNTMyMiA1MC41NTAyIDI4LjAxMlYyNy44Mzg2SDQ3Ljg5ODlDNDYuMjAzNyAyNy44Mzg2IDQ0Ljk0MzIgMjcuNDkxOSA0NC4yNDc4IDI2Ljg0MTZDNDMuNTA4OSAyNi4xNDgxIDQzLjE2MTEgMjUuMDY0NCA0My4xNjExIDIzLjQ2MDVWMTYuMzk0OUg0Ni4xNjAyVjIzLjIwMDVDNDYuMTYwMiAyNC4wNjc0IDQ2LjI5MDYgMjQuNjMwOSA0Ni41NTE0IDI0Ljg5MUM0Ni43MjUzIDI1LjE1MTEgNDcuMjQ2OSAyNS4yODExIDQ4LjA3MjcgMjUuMjgxMVoiIGZpbGw9IiMzNTQzQTgiLz4KPHBhdGggZD0iTTU1Ljg5NjUgMTYuMzk0OUg2MS41OTA0QzYzLjMyOTEgMTYuMzk0OSA2NC41NDYxIDE2LjY5ODMgNjUuMjg1IDE3LjM0ODVDNjYuMDIzOSAxNy45OTg4IDY2LjM3MTYgMTkuMDgyNCA2Ni4zNzE2IDIwLjU1NjNWMjcuNzk1M0g2My4zMjkxVjIwLjk0NjRDNjMuMzI5MSAyMC4wNzk0IDYzLjE5ODcgMTkuNTE1OSA2Mi45Mzc5IDE5LjI5OTJDNjIuNjc3MSAxOS4wMzkxIDYyLjE1NTUgMTguOTA5MSA2MS4zMjk3IDE4LjkwOTFINTguODk1NlYyNy44Mzg2SDU1Ljg1M1YxNi4zOTQ5SDU1Ljg5NjVaIiBmaWxsPSIjMzU0M0E4Ii8+CjxwYXRoIGQ9Ik03NC45MzQyIDI1LjM2NzhINzguMTUwNlYyNy43OTUySDc0LjAyMTRDNzIuOTc4MiAyNy43OTUyIDcyLjEwODkgMjcuNjY1MiA3MS40NTcgMjcuNDkxOEM3MC44MDUgMjcuMjc1IDcwLjE5NjUgMjYuOTI4MyA2OS43MTgzIDI2LjQ1MTRDNjkuMTk2OCAyNS45MzEzIDY4Ljc2MjEgMjUuMjgxMSA2OC40NTc4IDI0LjU0NDJDNjguMTUzNiAyMy44MDcyIDY4LjAyMzIgMjIuOTgzNiA2OC4wMjMyIDIyLjE2QzY4LjAyMzIgMjEuMjkzMSA2OC4xNTM2IDIwLjQ2OTUgNjguNDU3OCAxOS42ODkyQzY4Ljc2MjEgMTguOTA5IDY5LjE1MzMgMTguMzAyMSA2OS43MTgzIDE3Ljc4MTlDNzAuMjM5OSAxNy4zMDUxIDcwLjgwNSAxNi45NTgzIDcxLjUwMDQgMTYuNzQxNkM3Mi4xOTU5IDE2LjUyNDkgNzMuMDIxNyAxNi40MzgyIDc0LjA2NDkgMTYuNDM4Mkg3OC4xOTQxVjE4LjkwOUg3NC45MzQyQzczLjQ5OTggMTguOTA5IDcyLjU0MzYgMTkuMTY5MSA3MS45Nzg1IDE5LjY0NTlDNzEuNDU2OSAyMC4xMjI3IDcxLjE1MjcgMjAuOTg5NyA3MS4xNTI3IDIyLjIwMzRDNzEuMTUyNyAyMi44OTY5IDcxLjI4MzEgMjMuNDYwNSA3MS41MDA0IDIzLjkzNzNDNzEuNzE3NyAyNC40MTQxIDcyLjA2NTUgMjQuNzYwOSA3Mi41MDAxIDI1LjA2NDNDNzIuNzE3NCAyNS4xOTQ0IDcyLjk3ODIgMjUuMjgxMSA3My4yODI1IDI1LjM2NzhDNzMuNjMwMiAyNS4zMjQ0IDc0LjE1MTggMjUuMzY3OCA3NC45MzQyIDI1LjM2NzhaIiBmaWxsPSIjMzU0M0E4Ii8+CjxwYXRoIGQ9Ik04MC44NDU2IDE4LjY0ODlINzguNjcyNFYxNi4zNTE1SDgwLjg0NTZWMTUuMTgxMUM4MC44NDU2IDE0LjAxMDggODEuMDYzIDEzLjIzMDUgODEuNDk3NiAxMi44NDA0QzgxLjkzMjMgMTIuNDUwMyA4Mi43NTgxIDEyLjIzMzUgODMuOTc1MSAxMi4yMzM1SDg2Ljg0MzhWMTQuNDAwOUg4NS40MDk1Qzg0Ljg4NzkgMTQuNDAwOSA4NC41NDAyIDE0LjQ4NzYgODQuMzIyOSAxNC42NjFDODQuMTA1NSAxNC44MzQ0IDgzLjk3NTEgMTUuMDk0NSA4My45NzUxIDE1LjQ0MTJWMTYuMzUxNUg4Ni44NDM4VjE4LjY0ODlIODMuOTc1MVYyNy43OTUzSDgwLjg0NTZWMTguNjQ4OVoiIGZpbGw9IiMzNTQzQTgiLz4KPHBhdGggZD0iTTk4LjQwNTYgMjcuNzk1M0g5Mi43MTE2QzkxLjAxNjUgMjcuNzk1MyA4OS44NDI5IDI3LjQ0ODUgODkuMDYwNSAyNi43OTgzQzg4LjMyMTYgMjYuMTQ4MSA4Ny45MzA0IDI1LjA2NDQgODcuOTMwNCAyMy41OTA2VjE2LjM5NDlIOTAuOTI5NVYyMy40MTcyQzkwLjkyOTUgMjQuMTk3NCA5MS4wNTk5IDI0LjY3NDMgOTEuMzIwNyAyNC45MzQ0QzkxLjU4MTUgMjUuMTk0NCA5Mi4xMDMxIDI1LjMyNDUgOTIuOTI4OSAyNS4zMjQ1SDk1LjM2M1YxNi4zOTQ5SDk4LjQwNTZWMjcuNzk1M1oiIGZpbGw9IiMzNTQzQTgiLz4KPHBhdGggZD0iTTEwMC42MjIgMjUuNDExMkgxMDcuMDExQzEwNy41NzcgMjUuNDExMiAxMDguMDExIDI1LjMyNDUgMTA4LjI3MiAyNS4xNTExQzEwOC41MzMgMjQuOTc3NyAxMDguNjYzIDI0LjY3NDMgMTA4LjY2MyAyNC4zMjc1QzEwOC42NjMgMjMuOTM3NCAxMDguNTMzIDIzLjY3NzMgMTA4LjI3MiAyMy40NjA1QzEwOC4wMTEgMjMuMjg3MSAxMDcuNTc3IDIzLjIwMDUgMTA3LjA1NSAyMy4yMDA1SDEwNC40NDdDMTAyLjg4MiAyMy4yMDA1IDEwMS44MzkgMjIuOTgzNyAxMDEuMzE4IDIyLjUwNjlDMTAwLjc1MiAyMi4wMzAxIDEwMC40OTIgMjEuMjA2NSAxMDAuNDkyIDE5Ljk5MjdDMTAwLjQ5MiAxOC43NzkgMTAwLjgzOSAxNy44Njg3IDEwMS40OTEgMTcuMjYxOEMxMDIuMTQzIDE2LjY5ODMgMTAzLjE4NyAxNi4zOTQ5IDEwNC41MzQgMTYuMzk0OUgxMTEuMDU0VjE4Ljc3OUgxMDUuNzA4QzEwNC44MzggMTguNzc5IDEwNC4yNzMgMTguODY1NyAxMDQuMDEyIDE4Ljk5NTdDMTAzLjc1MiAxOS4xNjkxIDEwMy42MjEgMTkuNDI5MiAxMDMuNjIxIDE5LjgxOTRDMTAzLjYyMSAyMC4xNjYxIDEwMy43NTIgMjAuNDI2MiAxMDMuOTY5IDIwLjU5OTZDMTA0LjE4NiAyMC43NzMgMTA0LjU3NyAyMC44NTk3IDEwNS4wNTYgMjAuODU5N0gxMDcuNzk0QzEwOS4wNTQgMjAuODU5NyAxMTAuMDExIDIxLjE2MzEgMTEwLjY2MyAyMS43MjY2QzExMS4zMTUgMjIuMjkwMiAxMTEuNjYyIDIzLjE1NzEgMTExLjY2MiAyNC4yNDA4QzExMS42NjIgMjUuMjgxMSAxMTEuMzU4IDI2LjE0ODEgMTEwLjc5MyAyNi43OTgzQzExMC4yMjggMjcuNDQ4NSAxMDkuNDQ2IDI3Ljc5NTMgMTA4LjUzMyAyNy43OTUzSDEwMC43MDlWMjUuNDExMkgxMDAuNjIyWiIgZmlsbD0iIzM1NDNBOCIvPgo8cGF0aCBkPSJNMTE2LjU3NCAxNS4wOTQ0SDExMy40MDFWMTIuMjc2OUgxMTYuNTc0VjE1LjA5NDRaTTExNi41NzQgMjcuNzk1M0gxMTMuNDAxVjE2LjM5NDlIMTE2LjU3NFYyNy43OTUzWiIgZmlsbD0iIzM1NDNBOCIvPgo8cGF0aCBkPSJNMTMwLjMwOSAyMi4xMTY3QzEzMC4zMDkgMjMuODkzOSAxMjkuNzQ0IDI1LjMyNDQgMTI4LjY1NyAyNi40MDgxQzEyNy41NzEgMjcuNDkxOCAxMjYuMDkzIDI4LjAxMiAxMjQuMjI0IDI4LjAxMkMxMjIuMzU1IDI4LjAxMiAxMjAuODc3IDI3LjQ5MTggMTE5Ljc5IDI2LjQwODFDMTE4LjcwNCAyNS4zMjQ0IDExOC4xMzkgMjMuODkzOSAxMTguMTM5IDIyLjExNjdDMTE4LjEzOSAyMC4zMzk0IDExOC43MDQgMTguOTA5IDExOS43OSAxNy44MjUzQzEyMC44NzcgMTYuNzQxNiAxMjIuMzk4IDE2LjIyMTQgMTI0LjIyNCAxNi4yMjE0QzEyNi4wNDkgMTYuMjIxNCAxMjcuNTI3IDE2Ljc0MTYgMTI4LjY1NyAxNy44MjUzQzEyOS43NDQgMTguODY1NiAxMzAuMzA5IDIwLjI5NjEgMTMwLjMwOSAyMi4xMTY3Wk0xMjEuMjY4IDIyLjExNjdDMTIxLjI2OCAyMy4yMDA0IDEyMS41MjkgMjQuMDY3MyAxMjIuMDUxIDI0LjY3NDJDMTIyLjU3MiAyNS4yODExIDEyMy4yNjggMjUuNTg0NSAxMjQuMTggMjUuNTg0NUMxMjUuMDkzIDI1LjU4NDUgMTI1Ljc4OSAyNS4yODExIDEyNi4zMSAyNC42NzQyQzEyNi44MzIgMjQuMDY3MyAxMjcuMDkzIDIzLjIwMDQgMTI3LjA5MyAyMi4xMTY3QzEyNy4wOTMgMjEuMDMzIDEyNi44MzIgMjAuMTY2MSAxMjYuMzEgMTkuNjAyNUMxMjUuNzg5IDE4Ljk5NTcgMTI1LjA5MyAxOC42OTIyIDEyNC4xMzcgMTguNjkyMkMxMjMuMjI0IDE4LjY5MjIgMTIyLjUyOSAxOC45OTU3IDEyMi4wMDcgMTkuNjAyNUMxMjEuNTI5IDIwLjE2NjEgMTIxLjI2OCAyMS4wMzMgMTIxLjI2OCAyMi4xMTY3WiIgZmlsbD0iIzM1NDNBOCIvPgo8cGF0aCBkPSJNMTMxLjc4NyAxNi4zOTQ5SDEzNy40ODFDMTM5LjIxOSAxNi4zOTQ5IDE0MC40MzYgMTYuNjk4MyAxNDEuMTc1IDE3LjM0ODVDMTQxLjkxNCAxNy45OTg4IDE0Mi4yNjIgMTkuMDgyNCAxNDIuMjYyIDIwLjU1NjNWMjcuNzk1M0gxMzkuMjE5VjIwLjk0NjRDMTM5LjIxOSAyMC4wNzk0IDEzOS4wODkgMTkuNTE1OSAxMzguODI4IDE5LjI5OTJDMTM4LjU2NyAxOS4wMzkxIDEzOC4wNDYgMTguOTA5MSAxMzcuMjIgMTguOTA5MUgxMzQuNzg2VjI3LjgzODZIMTMxLjc0M1YxNi4zOTQ5SDEzMS43ODdaIiBmaWxsPSIjMzU0M0E4Ii8+CjxwYXRoIGQ9Ik03LjEyODMxIDMuNzM3NDNIMFYxMC44NDY0SDcuMTI4MzFWMy43Mzc0M1oiIGZpbGw9IiMzNTQzQTgiLz4KPHBhdGggZD0iTTIzLjI1MTMgLTIuMTU3MjVlLTA1TDE4LjU1MTMgNS41MTY4NUwyNC4wODMxIDEwLjIwNDFMMjguNzgzMSA0LjY4NzI1TDIzLjI1MTMgLTIuMTU3MjVlLTA1WiIgZmlsbD0iI0ZGODYwMCIvPgo8cGF0aCBkPSJNMTUuNjA0MSAzLjczNzQzSDguNDc1ODNWMTAuODQ2NEgxNS42MDQxVjMuNzM3NDNaIiBmaWxsPSIjMzU0M0E4Ii8+CjxwYXRoIGQ9Ik03LjEyODMxIDEyLjE5MDJIMFYxOS4yOTkySDcuMTI4MzFWMTIuMTkwMloiIGZpbGw9IiMzNTQzQTgiLz4KPHBhdGggZD0iTTE1LjYwNDEgMTIuMTkwMkg4LjQ3NTgzVjE5LjI5OTJIMTUuNjA0MVYxMi4xOTAyWiIgZmlsbD0iIzM1NDNBOCIvPgo8cGF0aCBkPSJNMjQuMDc5NyAxMi4xOTAySDE2Ljk1MTRWMTkuMjk5MkgyNC4wNzk3VjEyLjE5MDJaIiBmaWxsPSIjRkY4NjAwIi8+CjxwYXRoIGQ9Ik03LjEyODMxIDIwLjY4NjNIMFYyNy43OTUzSDcuMTI4MzFWMjAuNjg2M1oiIGZpbGw9IiMzNTQzQTgiLz4KPHBhdGggZD0iTTE1LjYwNDEgMjAuNjg2M0g4LjQ3NTgzVjI3Ljc5NTNIMTUuNjA0MVYyMC42ODYzWiIgZmlsbD0iIzM1NDNBOCIvPgo8cGF0aCBkPSJNMjQuMTIzMiAyMC42ODYzSDE2Ljk5NDlWMjcuNzk1M0gyNC4xMjMyVjIwLjY4NjNaIiBmaWxsPSIjMzU0M0E4Ii8+CjxwYXRoIGQ9Ik0xNDYgMTUuODMxM0MxNDYgMTYuODcxNyAxNDUuMTc0IDE3LjY5NTMgMTQ0LjEzMSAxNy42OTUzQzE0My4wODggMTcuNjk1MyAxNDIuMjYyIDE2Ljg3MTcgMTQyLjI2MiAxNS44MzEzQzE0Mi4yNjIgMTQuNzkxIDE0My4wODggMTQuMDEwNyAxNDQuMTMxIDE0LjAxMDdDMTQ1LjEzMSAxMy45Njc0IDE0NiAxNC43OTEgMTQ2IDE1LjgzMTNaTTE0Mi45NTcgMTQuNzkxQzE0Mi42OTcgMTUuMDUxMSAxNDIuNTY2IDE1LjQ0MTIgMTQyLjU2NiAxNS44MzEzQzE0Mi41NjYgMTYuNjk4MyAxNDMuMjYyIDE3LjM5MTggMTQ0LjEzMSAxNy4zOTE4QzE0NSAxNy4zOTE4IDE0NS42OTYgMTYuNjk4MyAxNDUuNjk2IDE1LjgzMTNDMTQ1LjY5NiAxNS4wMDc3IDE0NSAxNC4yNzA4IDE0NC4xNzQgMTQuMjcwOEMxNDMuNjUzIDE0LjI3MDggMTQzLjI2MiAxNC40NDQyIDE0Mi45NTcgMTQuNzkxWk0xNDQuODcgMTYuOTE1SDE0NC40NzlMMTQzLjkxNCAxNi4wOTE0VjE2LjkxNUgxNDMuNjA5VjE0Ljc0NzZIMTQzLjk1N0MxNDQuNDM1IDE0Ljc0NzYgMTQ0LjY1MyAxNC45NjQ0IDE0NC42NTMgMTUuMzU0NUMxNDQuNjUzIDE1LjY1NzkgMTQ0LjQ3OSAxNS44NzQ3IDE0NC4xNzQgMTUuOTYxNEwxNDQuODcgMTYuOTE1Wk0xNDQuMDQ0IDE1LjY1NzlDMTQ0LjI2MSAxNS42NTc5IDE0NC4zOTIgMTUuNTI3OSAxNDQuMzkyIDE1LjM1NDVDMTQ0LjM5MiAxNS4xMzc4IDE0NC4yNjEgMTUuMDUxMSAxNDQuMDAxIDE1LjA1MTFIMTQzLjkxNFYxNS42NTc5SDE0NC4wNDRaIiBmaWxsPSIjMzU0M0E4Ii8+Cjwvc3ZnPgo=\" style=\"\n    text-align: left;\n    width: 146px;\n    position: absolute;\n    top: 14px;\n    left: 31px;\n\">\n            </div>\n            <div style=\"\n    position: relative;\n    top: 80px;\n    left: 32px;\n    font-size: 20px;\n    text-align: left;\n    font-weight: 700;\n    letter-spacing: 0.02em;\n    font-style: normal;\n    line-height: 125%;\n    \">Claim your FREE account and get a key in less than a minute</div>\n            <ul style=\"\n        font-size: 15px;\n        font-weight: 400;\n        color: #333333;\n        letter-spacing: 0.01em;\n        position: relative;\n        left: 32px;\n        top: 88px;\n        line-height: 180%;\n        \">\n                <li><span>Access to a 30-day free trial of any of our products.</span></li>\n                <li><span>Access to 24x5 support by developers via the <a href=\"https://support.syncfusion.com/create?utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information\" style=\"text-decoration: none;\n                color: #0D6EFD;\n                font-weight: 500;\">support tickets</a>, <a href=\"https://www.syncfusion.com/forums?utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information\" style=\"text-decoration: none;\n                color: #0D6EFD;\n                font-weight: 500;\">forum</a>, <a href=\"https://www.syncfusion.com/feedback?utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information\n                \" style=\"text-decoration: none;\n                color: #0D6EFD;\n                font-weight: 500;\">feature &amp; feedback page</a> and chat.</span></li>\n                <li><span>200+ <a href=\"https://www.syncfusion.com/succinctly-free-ebooks?utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information\" style=\"text-decoration: none;\n                color: #0D6EFD;\n                font-weight: 500;\">ebooks </a>on the latest technologies, industry trends, and research topics.</span>\n                </li>\n                <li><span>Largest collection of over 7,000 flat and wireframe icons for free with Syncfusion <a href=\"https://www.syncfusion.com/downloads/metrostudio?utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information\n                \" style=\"text-decoration: none;\n                color: #0D6EFD;\n                font-weight: 500;\">Metro Studio.</a></span></li>\n                <li><span>Free and unlimited access to Syncfusion technical <a href=\"https://www.syncfusion.com/blogs/?utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information\n                \" style=\"text-decoration: none;\n                color: #0D6EFD;\n                font-weight: 500;\">blogs</a> and <a href=\"https://www.syncfusion.com/resources/techportal/whitepapers?utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information\" style=\"text-decoration: none;\n                color: #0D6EFD;\n                font-weight: 500;\">whitepapers.</a></span></li>\n            </ul>\n            <div style=\"\n            font-size: 18px;\n            font-weight: 700;\n            position: relative;\n            line-height: 125%;\n            letter-spacing: 0.02em;\n            top: 90px;\n            left: 32px;\n    \">Syncfusion is trusted by 29,000+ businesses worldwide</div>\n            <img src=\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODIwIiBoZWlnaHQ9IjU2IiB2aWV3Qm94PSIwIDAgODIwIDU2IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPg0KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00MjcuNjE3IDIyLjU2NTlWMjQuNzIyNkM0MjYuNTU4IDI0LjM2MzggNDI1LjM5OCAyNC4xNTQ0IDQyNC40NzQgMjQuMTU0NEM0MjMuMzMzIDI0LjE1NDQgNDIyLjY5OCAyNC40OTEyIDQyMi42OTggMjUuMDk2M0M0MjIuNjk4IDI1LjQ4MjQgNDIyLjk3NiAyNS43MzgzIDQyMy43NzMgMjYuMDg1NEw0MjUuOTE3IDI3LjAxNzRDNDI3LjYzMyAyNy43NjM5IDQyOC40OTcgMjguODUzIDQyOC40OTcgMzAuMjY4MUM0MjguNDk3IDMyLjQ1MjIgNDI2LjU0NiAzMy44MyA0MjMuNDUyIDMzLjgzQzQyMi4zMjQgMzMuODMgNDIxLjAxOCAzMy42NzM2IDQxOS42MzYgMzMuMzcwOVYzMS4xNDE2QzQyMS4wMDYgMzEuNTAyOCA0MjIuMjYyIDMxLjY5NTcgNDIzLjIzOSAzMS42OTU3QzQyNC41MTggMzEuNjk1NyA0MjUuMjAzIDMxLjM1MDYgNDI1LjIwMyAzMC43MDc0QzQyNS4yMDMgMzAuMzIwOCA0MjQuOTM1IDMwLjAzNjcgNDI0LjMyMiAyOS43NzE3TDQyMS45NzUgMjguNzU5M0M0MjAuMjM2IDI4LjAwNzggNDE5LjQzMyAyNi45OTU0IDQxOS40MzMgMjUuNTUyMUM0MTkuNDMzIDIzLjQ4MzcgNDIxLjMxNCAyMi4xNjQ5IDQyNC4yNjUgMjIuMTY0OUM0MjUuMjk4IDIyLjE2NDkgNDI2LjU3IDIyLjMxNzEgNDI3LjYxNyAyMi41NjU5VjIyLjU2NTlaTTQzMC4xNjcgMjIuMzkwOUg0MzMuNjM1VjMzLjYwMzlINDMwLjE2N1YyMi4zOTA5Wk00NDQuOTExIDIyLjM5MDlWMjQuNDQ1MUg0MzkuNjc1VjI2Ljk3NDJINDQ0LjI0OVYyOC44MzIzSDQzOS42NzVWMzEuNDU0M0g0NDQuOTc4VjMzLjYwMzlINDM2LjMwNVYyMi4zOTA5SDQ0NC45MTFaTTQ2MS4yOTQgMjIuMzkwOVYzMy42MDM5SDQ1Ny45MzlWMjYuMjIzNkw0NTQuNjUyIDMzLjY5MTVINDUyLjUzMUw0NDkuMjY2IDI2LjIyMzZWMzMuNjAzOUg0NDYuOTQ5VjIyLjM5MDlINDUxLjE4NEw0NTQuMTc4IDI5LjIxMTRMNDU3LjE1NiAyMi4zOTA5SDQ2MS4yOTRWMjIuMzkwOVpNNDcyLjU3OSAyMi4zOTA5VjI0LjQ0NTFINDY3LjMzNVYyNi45NzQySDQ3MS45MDhWMjguODMyM0g0NjcuMzM1VjMxLjQ1NDNINDcyLjYzOFYzMy42MDM5SDQ2My45NTdWMjIuMzkwOUg0NzIuNTc5Wk00ODQuNzk0IDIyLjM5MDlWMzMuNjAzOUg0ODEuMDkzTDQ3Ni45MjYgMjYuNDEyM1YzMy42MDM5SDQ3NC42MDhWMjIuMzkwOUg0NzguNDA3TDQ4Mi40ODQgMjkuNDg3NlYyMi4zOTA5SDQ4NC43OTRaTTQ5NC44NTggMjIuNTY1OVYyNC43MjI2QzQ5My44MDcgMjQuMzY2MyA0OTIuNjQgMjQuMTU0NCA0OTEuNzMyIDI0LjE1NDRDNDkwLjU3MyAyNC4xNTQ0IDQ4OS45MzkgMjQuNDg1OCA0ODkuOTM5IDI1LjA5M0M0ODkuOTM5IDI1LjQ4ODYgNDkwLjE5OCAyNS43MjUgNDkxLjAyMyAyNi4wODU5TDQ5My4xNTcgMjcuMDE3OEM0OTQuODg1IDI3Ljc3MjIgNDk1LjczOSAyOC44NTE4IDQ5NS43MzkgMzAuMjgzNUM0OTUuNzM5IDMyLjQ1NTkgNDkzLjc4NiAzMy44MzA4IDQ5MC42OTkgMzMuODMwOEM0ODkuNTY5IDMzLjgzMDggNDg4LjI1OSAzMy42NzM2IDQ4Ni44NzggMzMuMzcxN1YzMS4xNDI0QzQ4OC4yNDcgMzEuNTAyOCA0ODkuNDk5IDMxLjY5NjUgNDkwLjQ3IDMxLjY5NjVDNDkxLjc0IDMxLjY5NjUgNDkyLjQ0NCAzMS4zNTE1IDQ5Mi40NDQgMzAuNzI4NUM0OTIuNDQ0IDMwLjMxNjMgNDkyLjE5NyAzMC4wNTA0IDQ5MS41NTUgMjkuNzcyNUw0ODkuMjE4IDI4Ljc2MDFDNDg3LjQ2NyAyOC4wMDI4IDQ4Ni42NzQgMjcuMDAyIDQ4Ni42NzQgMjUuNTUzM0M0ODYuNjc0IDIzLjQ4NjIgNDg4LjU1NiAyMi4xNjY1IDQ5MS41IDIyLjE2NjVDNDkyLjUzNiAyMi4xNjUzIDQ5My44MTMgMjIuMzE3MSA0OTQuODU4IDIyLjU2NTlWMjIuNTY1OVoiIGZpbGw9IiMwMEEwQjAiLz4NCjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMzUyLjQxMyAyNi44MTlDMzUwLjk5MiAyNS4yNzU5IDM0OS42MzggMjMuODMxNSAzNDguMzQ5IDIyLjE1NzRMMzQ3LjkyIDIxLjU5OTVDMzQ5LjQwNiAyMS4zNjkzIDM1MC42OTUgMjAuMzg0OCAzNTAuNjk1IDE4Ljc0MzNDMzUwLjY5NSAxNy4yMzMxIDM0OS41MzkgMTYuMjQ4MiAzNDcuODIxIDE2LjI0ODJDMzQ2LjU5OCAxNi4yNDgyIDM0NS43MDYgMTYuMzEzNyAzNDUuMjQzIDE2LjMxMzdDMzQ0LjcxNSAxNi4zMTM3IDM0NC4yODUgMTYuMzEzNyAzNDMuNzkgMTYuMjgwOEMzNDMuODU2IDE4LjE1MjEgMzQzLjg4OSAxOC4yODM0IDM0My44ODkgMTkuNDMyMlYyMy42MzQzQzM0My44ODkgMjQuNDU1MyAzNDMuODU2IDI1LjI3NTkgMzQzLjc5IDI2LjgxODZDMzQ0LjE1MyAyNi43MjAyIDM0NC41MTcgMjYuNzIwMiAzNDQuNzgxIDI2LjcyMDJDMzQ1LjA0NSAyNi43MjAyIDM0NS40MDkgMjYuNzUzMSAzNDUuNzA2IDI2LjgxODZDMzQ1LjY0IDI1Ljc2NzkgMzQ1LjYwNyAyNC4wMjgzIDM0NS42MDcgMjMuNjM0M1YyMS4yMDUxQzM0Ny4xNiAyMy4yMDc3IDM0OS4yMDkgMjUuNjY5NSAzNTAuMDAxIDI2LjgxODZDMzUwLjM5OCAyNi43MjAyIDM1MC43MjggMjYuNzIwMiAzNTEuMTI0IDI2LjcyMDJDMzUxLjQ1NSAyNi43MjA2IDM1MS45MTggMjYuNzIwNiAzNTIuNDEzIDI2LjgxOVYyNi44MTlaTTM0OC44NzggMTkuMDA2QzM0OC44NzggMjAuMDIzNCAzNDguMzE3IDIxLjIwNTQgMzQ2Ljc5NyAyMS4yMDU0QzM0Ni40IDIxLjIwNTQgMzQ2LjAwMyAyMS4yMDU0IDM0NS42MDcgMjEuMTcyNVYxNy4wNjg4QzM0Ni4wMDMgMTYuOTcwNCAzNDYuNDk5IDE2LjkwNDYgMzQ2Ljc2MyAxNi45MDQ2QzM0OC4wODUgMTYuOTA0OSAzNDguODc4IDE3LjY2IDM0OC44NzggMTkuMDA2VjE5LjAwNlpNMzgyLjM4IDI2Ljg4NDVDMzgxLjgxOSAyNi4yOTM2IDM4MC45NiAyNS4zNDE3IDM4MC4xMzQgMjQuNDIyM0MzODAuODI4IDIzLjY2NzIgMzgxLjU1NSAyMi41NTEgMzgxLjk4NCAyMS41OTkxQzM4MS43MTkgMjEuNDY3OCAzODEuMzU2IDIxLjIwNTEgMzgxLjA5MiAyMC45NzUzQzM4MC45OTMgMjEuNzk1OSAzODAuNDMyIDIyLjg3OTIgMzc5LjYzOSAyMy44MzE1QzM3OC41MTUgMjIuNTE4NSAzNzguMjE4IDIyLjE1NzQgMzc3LjE5MyAyMC43Nzg1QzM3OC41ODEgMTkuODkyMSAzNzkuMjQyIDE4Ljg3NDMgMzc5LjI0MiAxOC4wNTM3QzM3OS4yNDIgMTcuMTAxNyAzNzguNTgxIDE2LjExNjkgMzc2Ljk2MiAxNi4xMTY5QzM3NS4yMTEgMTYuMTE2OSAzNzQuMzUyIDE3LjIwMDIgMzc0LjM1MiAxOC40ODAzQzM3NC4zNTIgMTkuMjM1NCAzNzQuNTUgMTkuODkxNyAzNzUuMzc2IDIwLjk3NTNDMzc0LjA1NCAyMS42OTc1IDM3Mi43NjYgMjIuNzQ3OSAzNzIuNzY2IDI0LjQyMjNDMzcyLjc2NiAyNi4wNjM5IDM3NC4wODcgMjYuOTE3NCAzNzUuNzA3IDI2LjkxNzRDMzc3LjE5MyAyNi45MTc0IDM3OC4xNTEgMjYuMzI2NiAzNzguOTEyIDI1LjYzNjlMMzc5LjkwMiAyNi44MTlDMzgwLjIgMjYuNzg2MSAzODAuNTMxIDI2LjcyMDYgMzgwLjg2MSAyNi43MjA2QzM4MS4zMjQgMjYuNzIwNiAzODEuODUyIDI2Ljc4NjEgMzgyLjM4IDI2Ljg4NDVWMjYuODg0NVpNMzgzLjM3MiA0MC4wMTU4QzM4MS45MTggMzguNDczIDM4MC41OTcgMzcuMDYxMiAzNzkuMzA4IDM1LjM4NzFMMzc4Ljg3OCAzNC44Mjg4QzM4MC4zMzIgMzQuNTk5MSAzODEuNjU0IDMzLjYxNSAzODEuNjU0IDMxLjk0MDFDMzgxLjY1NCAzMC40NjMyIDM4MC40OTggMjkuNDQ1NCAzNzguNzc5IDI5LjQ0NTRDMzc3LjU1NyAyOS40NDU0IDM3Ni42MzIgMjkuNTQzNSAzNzYuMTY5IDI5LjU0MzVDMzc1LjY3MyAyOS41NDM1IDM3NS4yNDQgMjkuNTQzNSAzNzQuNzQ4IDI5LjQ3NzZDMzc0LjgxNCAzMS4zODIyIDM3NC44NDggMzEuNDgwMiAzNzQuODQ4IDMyLjYyOTRWMzYuODMxMUMzNzQuODQ4IDM3LjY1MjQgMzc0LjgxNCAzOC41MDUyIDM3NC43NDggNDAuMDE1NEMzNzUuMTEyIDM5Ljk0OTYgMzc1LjQ3NSAzOS45NDk2IDM3NS43MDcgMzkuOTQ5NkMzNzYuMDA0IDM5Ljk0OTYgMzc2LjM2OCAzOS45NDk2IDM3Ni42MzIgNDAuMDE1NEMzNzYuNTY1IDM4Ljk5OCAzNzYuNTMzIDM3LjI1ODEgMzc2LjUzMyAzNi44MzExVjM0LjQzNDhDMzc4LjExOSAzNi40MDQyIDM4MC4xNjcgMzguODk5NiAzODAuOTYgNDAuMDE1NEMzODEuMzU2IDM5Ljk0OTYgMzgxLjY4NyAzOS45NDk2IDM4Mi4wODMgMzkuOTQ5NkMzODIuMzggMzkuOTUgMzgyLjg3NiAzOS45NSAzODMuMzcyIDQwLjAxNThaTTM2Mi4xNiAyNi44MTlDMzYwLjk3MSAyNS41NzE1IDM1OC44ODkgMjIuOTc4IDM1OC4wNjMgMjEuOTkzNUwzNTcuMjM3IDIwLjk3NTdDMzU4LjA5NiAxOS45NTgzIDM1OC42OSAxOS4zMzQxIDM1OS4zMTkgMTguNTc5QzM2MC4wNDUgMTcuNzkxIDM2MC43MDYgMTYuOTcwNCAzNjEuNDk5IDE2LjI0ODJDMzYxLjEzNiAxNi4zMTM3IDM2MC45MzcgMTYuMzEzNyAzNjAuNzM5IDE2LjMxMzdDMzYwLjU0MSAxNi4zMTM3IDM2MC4zNDMgMTYuMzEzNyAzNjAuMTQ0IDE2LjI0ODJDMzU5LjkxMyAxNi42MDkzIDM1OS41NSAxNy4wNjg4IDM1OS4xNTMgMTcuNTI4N0MzNTguNzU2IDE3Ljk1NTYgMzU4LjM2IDE4LjM4MjIgMzU4LjA2MyAxOC43NDMzQzM1Ny4yMzYgMTkuNjk1MiAzNTYuNzc0IDIwLjE1NDcgMzU1LjU4NSAyMS4yNzA5VjE5LjQ2NTVDMzU1LjU4NSAxOC40MTUxIDM1NS41ODUgMTcuNzI1NSAzNTUuNjUxIDE2LjI0ODJDMzU1LjMyMSAxNi4zMTM3IDM1NC45NTcgMTYuMzEzNyAzNTQuNzI2IDE2LjMxMzdDMzU0LjQ2MSAxNi4zMTM3IDM1NC4wMzIgMTYuMzEzNyAzNTMuNzY4IDE2LjI0ODJDMzUzLjgzMyAxNy44MjM5IDM1My44NjcgMTguMjgzNCAzNTMuODY3IDE5LjQzMjVWMjMuNjM0N0MzNTMuODY3IDI0LjY4NSAzNTMuODMzIDI1LjMwODggMzUzLjc2OCAyNi44MTlDMzU0LjE2NCAyNi43MjA2IDM1NC40OTUgMjYuNzIwNiAzNTQuNzI2IDI2LjcyMDZDMzU0Ljk1NyAyNi43MjA2IDM1NS4zNTMgMjYuNzUzNSAzNTUuNjUxIDI2LjgxOUMzNTUuNTg1IDI1LjE0NDkgMzU1LjU4NSAyNC4xNTk3IDM1NS41ODUgMjMuNjM0N1YyMS40MzUyQzM1Ni44MDcgMjIuODc5NiAzNTguNjkgMjUuMjQzMyAzNTkuNzQ4IDI2LjgxOUMzNjAuMTMgMjYuNzU2MyAzNjAuNTE3IDI2LjcyMzQgMzYwLjkwNSAyNi43MjA2QzM2MS4yMDIgMjYuNzIwNiAzNjEuNjY1IDI2LjcyMDYgMzYyLjE2IDI2LjgxOVYyNi44MTlaTTM3Mi42MDEgNDAuMDE1OEMzNzIuNTY4IDM5Ljg1MTkgMzcyLjUzNSAzOS43MjA2IDM3Mi41MzUgMzkuNTIzNEMzNzIuNTM1IDM5LjM5MjggMzcyLjU2OCAzOS4yMjgxIDM3Mi42MDEgMzkuMDk2NEMzNzEuMjggMzkuMTI5NyAzNjguOTAxIDM5LjE5NTIgMzY4LjM3MiAzOS4xOTUyVjM0LjY2NDlDMzY5LjY5NCAzNC42NjQ5IDM3MC45ODIgMzQuNjY0OSAzNzIuMjcgMzQuNzk2M0MzNzIuMjM4IDM0LjYzMjQgMzcyLjIwNCAzNC40Njc3IDM3Mi4yMDQgMzQuMzM2NEMzNzIuMjA0IDM0LjIwNTggMzcyLjIwNCAzNC4wNDE5IDM3Mi4yNyAzMy44NDQ3QzM3MS4zNDYgMzMuOTQyOCAzNjkuMTk4IDMzLjk3NiAzNjguMzcyIDMzLjk3NlYzMC4yNjZDMzY5LjgyNiAzMC4yNjYgMzcwLjY4NSAzMC4yNjYgMzcxLjE4IDMwLjI5OTNMMzcyLjUwMiAzMC4zNjUxQzM3Mi40MzYgMzAuMTY3OSAzNzIuNDM2IDMwLjA2OTIgMzcyLjQzNiAyOS45MDUzQzM3Mi40MzYgMjkuNzQxNCAzNzIuNDM2IDI5LjcwODEgMzcyLjUwMiAyOS40NDU4QzM3MS40MTEgMjkuNDc4MyAzNjkuOTI1IDI5LjU0MzggMzY5LjI2NCAyOS41NDM4QzM2OC44MDIgMjkuNTQzOCAzNjcuMzQ4IDI5LjUxMTMgMzY2LjU4NyAyOS40NDU4QzM2Ni42NTQgMzAuMjY2NCAzNjYuNjg2IDMxLjYxMjMgMzY2LjY4NiAzMi41NjQyVjM2Ljg2NTFDMzY2LjY4NiAzNy40ODg1IDM2Ni42MiAzOC43MzU3IDM2Ni41ODcgNDAuMDE2MkMzNjcuNTEzIDM5Ljk1MDMgMzY4LjgwMiAzOS45NTAzIDM2OS4yNjQgMzkuOTUwM0MzNzAuMDI0IDM5Ljk1IDM3MS42NDMgMzkuOTUgMzcyLjYwMSA0MC4wMTU4Wk0zNjQuNjA1IDM5LjEyOTRDMzY0LjQ0IDM4LjgwMDggMzY0LjM0MSAzOC4zMDg4IDM2NC4yNzUgMzguMDQ2MUMzNjIuOTIgMzkuMTYxOSAzNjEuOTk1IDM5LjM5MjQgMzYwLjkzOCAzOS4zOTI0QzM1OC41OTIgMzkuMzkyNCAzNTcuMzM3IDM3LjI5MTMgMzU3LjMzNyAzNC42NjQ5QzM1Ny4zMzcgMzEuNzQzNiAzNTguNzU3IDMwLjAzNjIgMzYxLjE2OSAzMC4wMzYyQzM2Mi40MjUgMzAuMDM2MiAzNjMuNjE0IDMwLjU5NDUgMzY0LjE3NiAzMS4xNTI4QzM2NC4yMDggMzAuODg5OCAzNjQuMzA4IDMwLjM2NDggMzY0LjQ3MyAzMC4wNjg4QzM2My4zMTYgMjkuNTExMyAzNjIuMjU5IDI5LjM0NjYgMzYxLjEwMiAyOS4zNDY2QzM1Ny4yMzcgMjkuMzQ2NiAzNTUuNDUzIDMxLjc0MzYgMzU1LjQ1MyAzNC44Mjg4QzM1NS40NTMgMzguMzA5MSAzNTcuNzk4IDQwLjE0NzEgMzYwLjczOSA0MC4xNDcxQzM2Mi40MjUgNDAuMTQ3MSAzNjMuODEyIDM5LjYyMjIgMzY0LjYwNSAzOS4xMjk0VjM5LjEyOTRaTTM0Mi4zMDMgMjYuODE5QzM0MC41MTkgMjMuNDA0OSAzMzguOCAxOS4xMzczIDMzNy41NzggMTYuMTE2OUgzMzcuMzhDMzM2LjU4NyAxOC4wMjA3IDMzNS4xMzMgMjEuMjcwOSAzMzQuNzM3IDIyLjE4OTlDMzM0LjI3NCAyMy4zMDYxIDMzMy4yNSAyNS41MDU2IDMzMi41ODkgMjYuODE4NkMzMzIuODAzIDI2Ljc1MzggMzMzLjAyNiAyNi43MjA2IDMzMy4yNSAyNi43MjAyQzMzMy40NDggMjYuNzIwMiAzMzMuNjEzIDI2Ljc1MzEgMzMzLjg0NSAyNi44MTg2QzMzNC4xNzUgMjUuOTMyMiAzMzQuNjM4IDI0LjgxNiAzMzUuMTMzIDIzLjYzNDNDMzM1Ljc5NCAyMy42MDE0IDMzNi4zODkgMjMuNTY4OCAzMzYuOTg0IDIzLjU2ODhDMzM3LjYxMiAyMy41Njg4IDMzOC4yNzIgMjMuNjAxNCAzMzguOTMzIDIzLjYzNDNMMzM5LjU5NCAyNS4yMUwzNDAuMjU1IDI2LjgxODZDMzQwLjcxNyAyNi43MjAyIDM0MS4wOCAyNi43MjAyIDM0MS4zMTIgMjYuNzIwMkMzNDEuNjA5IDI2LjcyMDYgMzQxLjg3MyAyNi43MjA2IDM0Mi4zMDMgMjYuODE5VjI2LjgxOVpNMzUzLjYzNiAyOS40NDU0QzM1My40MzggMjkuNTExMyAzNTMuMjczIDI5LjU0MzUgMzUzLjEwNyAyOS41NDM1QzM1Mi45MDkgMjkuNTQzNSAzNTIuNzQ0IDI5LjUxMDkgMzUyLjU0NiAyOS40NDU0QzM1Mi42NDQgMzAuNzU4NCAzNTIuNjc4IDMyLjA3MTQgMzUyLjY3OCAzMy4zNTE5VjM2LjczMzRDMzUyLjE0OSAzNi4yNzM2IDM1MC44NiAzNS4wOTE5IDM0OS4zNzQgMzMuNzEzQzM0Ny44NiAzMi4zMDc0IDM0Ni4zOTQgMzAuODUxMSAzNDQuOTc5IDI5LjM0NjZIMzQ0Ljc0OEMzNDQuNzgxIDMwLjgyNDMgMzQ0LjgxNCAzMi40IDM0NC44MTQgMzMuODExNFYzNS44Nzk5QzM0NC44MTQgMzcuNjUyOCAzNDQuODE0IDM4LjYwNDcgMzQ0LjcxNSA0MC4wMTYyQzM0NC45OCAzOS45NTAzIDM0NS4xMTIgMzkuOTUwMyAzNDUuMzEgMzkuOTUwM0MzNDUuNDQyIDM5Ljk1MDMgMzQ1LjU3NSAzOS45NTAzIDM0NS44MDYgNDAuMDE2MkMzNDUuNzQgMzguNjcwNiAzNDUuNzA3IDM2LjQ3MDggMzQ1LjcwNyAzNS44Nzk5VjMyLjU5NjhDMzQ4LjE4NSAzNC44NjI1IDM1MS4yMjQgMzcuODgyNiAzNTMuNDcxIDQwLjE0NzVIMzUzLjYwM0MzNTMuNjAzIDM4LjkzMjkgMzUzLjUzNyAzNy43MTc5IDM1My41MzcgMzYuNTA0VjM0LjYzMjdDMzUzLjUzNiAzMi40MzI1IDM1My41MzYgMzEuMzQ5MyAzNTMuNjM2IDI5LjQ0NTRaTTM0Mi41NjcgNDAuMDE1OEMzNDIuNTM0IDM5Ljg1MTkgMzQyLjUwMSAzOS43MjA2IDM0Mi41MDEgMzkuNTIzNEMzNDIuNTAxIDM5LjM5MjggMzQyLjUzNCAzOS4yMjgxIDM0Mi41NjcgMzkuMDk2NEMzNDEuMjQ2IDM5LjEyOTcgMzM4Ljg2NyAzOS4xOTUyIDMzOC4zNzEgMzkuMTk1MlYzNC42NjQ5QzMzOS42NiAzNC42NjQ5IDM0MC45NDggMzQuNjY0OSAzNDIuMjM3IDM0Ljc5NjNDMzQyLjIwNCAzNC42MzI0IDM0Mi4xNzEgMzQuNDY3NyAzNDIuMTcxIDM0LjMzNjRDMzQyLjE3MSAzNC4yMDU4IDM0Mi4xNzEgMzQuMDQxOSAzNDIuMjM3IDMzLjg0NDdDMzQxLjMxMiAzMy45NDI4IDMzOS4xOTcgMzMuOTc2IDMzOC4zNzEgMzMuOTc2VjMwLjI2NkMzMzkuNzkyIDMwLjI2NiAzNDAuNjUxIDMwLjI2NiAzNDEuMTc5IDMwLjI5OTNMMzQyLjQ2OCAzMC4zNjUxQzM0Mi40MzUgMzAuMTY3OSAzNDIuNDM1IDMwLjA2OTIgMzQyLjQzNSAyOS45MDUzQzM0Mi40MzUgMjkuNzQxNCAzNDIuNDM1IDI5LjY3NTUgMzQyLjQ2OCAyOS40NDU4QzM0MS4zNzggMjkuNDc4MyAzMzkuODkxIDI5LjU0MzggMzM5LjIzIDI5LjU0MzhDMzM4Ljc2NyAyOS41NDM4IDMzNy4zMTQgMjkuNTExMyAzMzYuNTU0IDI5LjQ0NThDMzM2LjYyIDMwLjI2NjQgMzM2LjY1MyAzMS42MTIzIDMzNi42NTMgMzIuNTY0MlYzNi44NjUxQzMzNi42NTMgMzcuNDg4NSAzMzYuNTg3IDM4LjczNTcgMzM2LjU1NCA0MC4wMTYyQzMzNy41MTIgMzkuOTUwMyAzMzguNzY3IDM5Ljk1MDMgMzM5LjIzIDM5Ljk1MDNDMzM5Ljk5IDM5Ljk1IDM0MS42NDIgMzkuOTUgMzQyLjU2NyA0MC4wMTU4VjQwLjAxNThaTTMzMS4yMDEgMjYuODE5QzMzMC42NzMgMjMuMjQwNiAzMzAuMjEgMTkuNDk4NCAzMjkuODQ3IDE2LjExNjlDMzI5Ljc0OCAxNi4xNDk4IDMyOS43MTQgMTYuMTQ5OCAzMjkuNjQ5IDE2LjExNjlDMzI4Ljk1NSAxNy4zMzE1IDMyOC4xNjIgMTguNjQ0NSAzMjcuNTY3IDE5LjU2MzlDMzI3LjAwNiAyMC40NTAzIDMyNi4zNDUgMjEuNTAwNyAzMjUuNTg1IDIyLjYxNjlDMzIzLjk5OSAyMC41ODE3IDMyMi4zNDcgMTguMDIxMSAzMjEuMjU2IDE2LjExNjlDMzIxLjE5IDE2LjE0OTggMzIxLjE1NyAxNi4xMTY5IDMyMS4wOTEgMTYuMTE2OUMzMjAuNzI4IDE5LjQ5OCAzMjAuMjMyIDIzLjI3MzIgMzE5LjczNiAyNi44MTlDMzIwLjAwMSAyNi43MjA2IDMyMC4xNjYgMjYuNzIwNiAzMjAuMjk4IDI2LjcyMDZDMzIwLjQ5NiAyNi43MjA2IDMyMC42MjggMjYuNzUzNSAzMjAuODU5IDI2LjgxOUMzMjAuOTkyIDI0LjQ1NTMgMzIxLjI1NiAyMi4xMjQ0IDMyMS41NTMgMTkuNjYyM0MzMjIuODQyIDIxLjUzMzYgMzIzLjk2NSAyMy4xNDIyIDMyNS4yMjEgMjQuODQ5M0MzMjYuMjc4IDIzLjIwNzcgMzI3LjM2OCAyMS40MzQ4IDMyOC41NTggMTkuNjI5NEMzMjguODg4IDIyLjE1NyAzMjkuMTg2IDI0LjQ1NTMgMzI5LjM1MSAyNi44MTlDMzI5Ljc4IDI2LjcyMDYgMzMwLjA3OCAyNi43MjA2IDMzMC4yNzYgMjYuNzIwNkMzMzAuNTQgMjYuNzIwNiAzMzAuODA1IDI2LjcyMDYgMzMxLjIwMSAyNi44MTlWMjYuODE5Wk0zMzQuOTY4IDMyLjIwMjhDMzM0Ljk2OCAzMC4yOTg5IDMzMy40NDggMjkuNDQ1NCAzMzEuNTk4IDI5LjQ0NTRDMzMwLjc3MiAyOS40NDU0IDMyOS44OCAyOS41NDM1IDMyOS4yNTIgMjkuNTQzNUMzMjkuMDIxIDI5LjU0MzUgMzI4LjUyNSAyOS41NDM1IDMyNy45OTcgMjkuNDc3NkMzMjguMDMgMzAuNTI4MyAzMjguMDk2IDMxLjQxNDggMzI4LjA5NiAzMi40MzIyVjM2LjkyOTVDMzI4LjA5NiAzNy45MTQ4IDMyOC4wMyAzOC45OTggMzI3Ljk5NyA0MC4wMTU0QzMyOC40MjYgMzkuOTQ5NiAzMjguNzI0IDM5Ljk0OTYgMzI4LjkyMiAzOS45NDk2QzMyOS4xNTMgMzkuOTQ5NiAzMjkuNDg0IDM5Ljk0OTYgMzI5Ljg4IDQwLjAxNTRDMzI5LjgxNSAzOS4wMzE5IDMyOS43ODIgMzguMDQ2NSAzMjkuNzgxIDM3LjA2MDlWMzUuNDJDMzMwLjE0NSAzNS40NTI2IDMzMC41MDggMzUuNDUyNiAzMzAuOTA1IDM1LjQ1MjZDMzMyLjgyIDM1LjQ1MjYgMzM0Ljk2OCAzNC43MzA0IDMzNC45NjggMzIuMjAyOFYzMi4yMDI4Wk0zMjYuMDE0IDM2Ljg5NzNDMzI2LjAxNCAzNS4yNTU4IDMyNC45MjQgMzQuNTMzNiAzMjMuMDQgMzMuNzQ1NkMzMjEuNjg2IDMzLjE4OCAzMjAuOTkyIDMyLjY5NTYgMzIwLjk5MiAzMS42NDQ1QzMyMC45OTIgMzAuNjYgMzIxLjc1MiAzMC4wMzYyIDMyMy4wMDggMzAuMDM2MkMzMjMuODM0IDMwLjAzNjIgMzI0LjU2MSAzMC4zMzE1IDMyNS4yMjIgMzAuODU2OEMzMjUuMjg3IDMwLjQ5NTcgMzI1LjQ1MyAzMC4xMzQ3IDMyNS42NTEgMjkuODM5NEMzMjQuODU4IDI5LjQ3ODMgMzIzLjk5OSAyOS4zNDcgMzIzLjA3NCAyOS4zNDdDMzIwLjM2NSAyOS4zNDcgMzE5LjUwNSAzMC44OTA1IDMxOS41MDUgMzIuMjAzNUMzMTkuNTA1IDMzLjgxMTggMzIwLjI5OSAzNC41NjcyIDMyMi4zNDcgMzUuMzU1M0MzMjMuNjM2IDM1Ljg0NyAzMjQuMjk2IDM2LjQ3MTEgMzI0LjI5NiAzNy41NTQ0QzMyNC4yOTYgMzguNzAzNSAzMjMuNDM3IDM5LjQyNTcgMzIyLjI0OCAzOS40MjU3QzMyMS41NTQgMzkuNDI1NyAzMjAuMzY1IDM5LjA2NDYgMzE5LjUzOSAzOC4zMDk5QzMxOS41MDUgMzguNzM2MSAzMTkuNTA1IDM5LjEzMDQgMzE5LjM3MyAzOS40OTE1QzMxOS45MDIgMzkuNzU0NiAzMjEuMTI1IDQwLjE0NzkgMzIyLjIxNSA0MC4xNDc5QzMyNC45OSA0MC4xNDcxIDMyNi4wMTQgMzguNDM5NyAzMjYuMDE0IDM2Ljg5NzNWMzYuODk3M1pNMzc4LjE1MiAxNy45ODgyQzM3OC4xNTIgMTguOTczIDM3Ny40NTggMTkuNjYyMyAzNzYuNzY0IDIwLjIyMDJDMzc2LjMwMSAxOS41NjM5IDM3NS43NCAxOC42NzcxIDM3NS43NCAxNy45ODgyQzM3NS43NCAxNy4yMzMxIDM3Ni4yNjggMTYuODA2MSAzNzYuOTk1IDE2LjgwNjFDMzc3Ljk4NyAxNi44MDY1IDM3OC4xNTIgMTcuNjkyNiAzNzguMTUyIDE3Ljk4ODJWMTcuOTg4MlpNMzc4LjQ4MiAyNS4wMTMyQzM3OC4xMTkgMjUuMzQxNyAzNzcuMjYgMjUuOTY1NSAzNzYuNTMzIDI1Ljk2NTVDMzc1LjU3NCAyNS45NjU1IDM3NC40MTggMjUuMjc1OSAzNzQuNDE4IDIzLjc5ODZDMzc0LjQxOCAyMi40ODU1IDM3NS4yNzcgMjEuODk0NyAzNzUuODA2IDIxLjU2NjVDMzc3LjAyOCAyMy4yNDA2IDM3Ny4wOTUgMjMuMzM5MSAzNzguNDgyIDI1LjAxMzJaTTM3OS44MDQgMzIuMjAyOEMzNzkuODA0IDMzLjI1MzUgMzc5LjI3NSAzNC40MDI2IDM3Ny43NTUgMzQuNDAyNkMzNzcuMzI2IDM0LjQwMjYgMzc2LjkyOSAzNC40MDI2IDM3Ni41MzMgMzQuMzY5M1YzMC4yNjU2QzM3Ni45MjkgMzAuMTY3NiAzNzcuNDI1IDMwLjEzNDMgMzc3LjcyMiAzMC4xMzQzQzM3OS4wMTEgMzAuMTM0MyAzNzkuODA0IDMwLjg4OTggMzc5LjgwNCAzMi4yMDI4Wk0zMzguNjAyIDIyLjgxNDFDMzM3LjkwOSAyMi44NDY2IDMzNy41NDUgMjIuODQ2NiAzMzcuMDgyIDIyLjg0NjZDMzM2LjUyMSAyMi44NDY2IDMzNi4xOSAyMi44NDY2IDMzNS40NjMgMjIuODE0MUwzMzcuMDgyIDE5LjAwNkwzMzguNjAyIDIyLjgxNDFaTTMzMy4xNTEgMzIuMzAwOEMzMzMuMTUxIDMzLjgxMTEgMzMyLjI1OCAzNC43OTU5IDMzMC44MDUgMzQuNzk1OUMzMzAuNTA3IDM0Ljc5NTkgMzMwLjE3NyAzNC43OTU5IDMyOS43OCAzNC43MzAxVjMwLjIzMjdDMzMwLjI0MyAzMC4xNjY5IDMzMC42MzkgMzAuMTMzOSAzMzEuMDM2IDMwLjEzMzlDMzMyLjQyNCAzMC4xMzQzIDMzMy4xNTEgMzEuMDIxMSAzMzMuMTUxIDMyLjMwMDhaTTM2OS41MjggMjMuNjY3NkMzNjkuNTI4IDIyLjAyNiAzNjguNDM4IDIxLjMwMzkgMzY2LjU1NSAyMC41MTYyQzM2NS4yIDE5Ljk1ODMgMzY0LjUwNiAxOS40OTg4IDM2NC41MDYgMTguNDE1MUMzNjQuNTA2IDE3LjQ2MzIgMzY1LjI2NiAxNi44MDY1IDM2Ni41MjEgMTYuODA2NUMzNjcuMzQ4IDE2LjgwNjUgMzY4LjA3NSAxNy4xMDE3IDM2OC43MzUgMTcuNjI3NUMzNjguODAyIDE3LjI2NjQgMzY4Ljk2NyAxNi45MDQ5IDM2OS4xMzEgMTYuNjQyMkMzNjguMzcyIDE2LjI4MTEgMzY3LjQ3OSAxNi4xMTcyIDM2Ni41ODcgMTYuMTE3MkMzNjMuOTQ0IDE2LjExNzIgMzYyLjk4NiAxNy42NiAzNjIuOTg2IDE5LjAwNkMzNjIuOTg2IDIwLjU4MTcgMzYzLjgxMiAyMS4zMzY4IDM2NS44NjEgMjIuMTI0NEMzNjcuMTQ5IDIyLjYxNjkgMzY3LjgxIDIzLjI0MDYgMzY3LjgxIDI0LjM1NjhDMzY3LjgxIDI1LjQ3MyAzNjYuOTUxIDI2LjE5NTIgMzY1Ljc2MiAyNi4xOTUyQzM2NS4wMzUgMjYuMTk1MiAzNjMuODc5IDI1LjgzNDEgMzYzLjA1MiAyNS4xMTE5QzM2My4wMiAyNS41Mzg5IDM2Mi45ODYgMjUuOSAzNjIuODg3IDI2LjI2MTFDMzYzLjM4MyAyNi41MjM4IDM2NC42MDYgMjYuOTE3NCAzNjUuNzI5IDI2LjkxNzRDMzY4LjUwNCAyNi45MTc0IDM2OS41MjggMjUuMjQzMyAzNjkuNTI4IDIzLjY2NzZWMjMuNjY3NloiIGZpbGw9IiMwMzY1NTUiLz4NCjxwYXRoIGQ9Ik02NDAuNDE2IDIwLjU1NzNDNjM4LjY3MSAxOS44MzU0IDYzNy42MzEgMTkuNTU1MSA2MzYuNTk4IDE5LjU1NTFDNjM1LjUxNCAxOS41NTUxIDYzNC44MTkgMTkuOTE3IDYzNC44MTkgMjAuNDc2NUM2MzQuODE5IDIyLjE2NDUgNjQwLjk2MiAyMS42ODkzIDY0MC45NjIgMjUuNTkzNkM2NDAuOTYyIDI3Ljc0NjQgNjM5LjAyNCAyOC45OTc0IDYzNi4zMzIgMjguOTk3NEM2MzQuMjIgMjguOTk3NCA2MzMuMTggMjguNDg4IDYzMS45ODMgMjcuOTExNlYyNS40OTYyQzYzMy43MSAyNi41NjM1IDYzNC43NjggMjYuOTQwMSA2MzYuMTAxIDI2Ljk0MDFDNjM3LjI1NiAyNi45NDAxIDYzNy44NzkgMjYuNTYzNSA2MzcuODc5IDI1LjkwNjNDNjM3Ljg3OSAyNC4wNjg1IDYzMS43MzcgMjQuNzQxNSA2MzEuNzM3IDIwLjcyMTNDNjMxLjczNyAxOC43ODI3IDYzMy41MzQgMTcuNDk5IDYzNi4zMzIgMTcuNDk5QzYzNy42ODIgMTcuNDk5IDYzOC45MDEgMTcuNzYzNSA2NDAuNDE2IDE4LjM3MDdWMjAuNTU3M1pNNjQ5LjAxNiAyOC40ODQxQzY0Ny45OTIgMjguODMwNiA2NDcuMTI2IDI4Ljk5NTQgNjQ2LjI2MiAyOC45OTU0QzY0My40MDIgMjguOTk1NCA2NDEuNTUyIDI3LjQ0MjIgNjQxLjU1MiAyNS4wNzkyQzY0MS41NTIgMjIuNzU5NCA2NDMuNDczIDIxLjEyMDIgNjQ2LjE1NiAyMS4xMjAyQzY0Ni45ODUgMjEuMTIwMiA2NDguMDQ0IDIxLjMxODIgNjQ4Ljg5MSAyMS42MTIzVjIzLjM4ODFDNjQ4LjIyMSAyMy4wNTYyIDY0Ny40NDQgMjIuODc0MSA2NDYuODA5IDIyLjg3NDFDNjQ1LjI3MyAyMi44NzQxIDY0NC4yODYgMjMuNzM0MyA2NDQuMjg2IDI1LjA2MTlDNjQ0LjI4NiAyNi40MDggNjQ1LjI1NiAyNy4yOTQgNjQ2LjcyIDI3LjI5NEM2NDcuMzM3IDI3LjI5NCA2NDcuODg2IDI3LjE2MjMgNjQ5LjAxNiAyNi43NjhMNjQ5LjAxNiAyOC40ODQxWk02NzEuMzIgMjQuMjA5QzY3MS40MjUgMjMuMTU0OCA2NzIuMDgxIDIyLjU0NTcgNjczLjA4NyAyMi41NDU3QzY3NC4wNzYgMjIuNTQ1NyA2NzQuNzQ2IDIzLjE3MjEgNjc0Ljg1MiAyNC4yMDlINjcxLjMyWk02NzIuOTEgMjEuMTIyOUM2NzAuNCAyMS4xMjI5IDY2OC42MTQgMjIuNzc1NSA2NjguNjE0IDI1LjEwMTJDNjY4LjYxNCAyNy40NDQxIDY3MC40NzEgMjguOTk1NCA2NzMuMzM1IDI4Ljk5NTRDNjczLjk3IDI4Ljk5NTQgNjc1LjUwNCAyOC45OTU0IDY3Ni45NjYgMjcuOTg3VjI2LjUwNDJDNjc1Ljc2OSAyNy4yOTkzIDY3NC45NzcgMjcuNTczMSA2NzMuOTU1IDI3LjU3MzFDNjcyLjM0MSAyNy41NzMxIDY3MS4zNTQgMjYuNzk0OSA2NzEuMjY1IDI1LjQ2NjZINjc3LjExQzY3Ny4yMzIgMjIuNjkzOSA2NzUuMjc5IDIxLjEyMjkgNjcyLjkxIDIxLjEyMjlWMjEuMTIyOVpNNjc4LjA5OSAyOC44NTcySDY4MC42NTRWMjEuMjYyN0g2NzguMDk5VjI4Ljg1NzJaTTY4Ny43NjcgMjYuNzgxNUM2ODcuMjM0IDI3LjIyODEgNjg2Ljc5MiAyNy40MDcyIDY4Ni4yNDYgMjcuNDA3MkM2ODUuMDQzIDI3LjQwNzIgNjg0LjI4MSAyNi40ODM4IDY4NC4yODEgMjUuMTAwNEM2ODQuMjgxIDIzLjU4NDEgNjg1LjA0MyAyMi43MTAxIDY4Ni4zMzEgMjIuNzEwMUM2ODYuNzkyIDIyLjcxMDEgNjg3LjM5NCAyMi45MDggNjg3Ljc2NyAyMy4xNTU5VjI2Ljc4MTVaTTY4Ny43NjcgMTcuNjM5MVYyMS41OTU4QzY4Ny4wNzYgMjEuMjg0NyA2ODYuMzg4IDIxLjEyMDIgNjg1LjY0NCAyMS4xMjAyQzY4My4zMTMgMjEuMTIwMiA2ODEuNyAyMi43MjY2IDY4MS43IDI1LjA1MDdDNjgxLjcgMjcuMzI0OCA2ODMuMzEzIDI4Ljk5NzQgNjg1LjUgMjguOTk3NEM2ODYuMzY3IDI4Ljk5NzQgNjg3LjAzNyAyOC43ODU2IDY4Ny43NjcgMjguMjQzNVYyOC44NTQ5SDY5MC4zMjJWMTcuNjM5MUg2ODcuNzY3Wk02OTQuMTA1IDI0LjIwOUM2OTQuMjExIDIzLjE1NDggNjk0Ljg2NCAyMi41NDU3IDY5NS44NjggMjIuNTQ1N0M2OTYuODU4IDIyLjU0NTcgNjk3LjUzNSAyMy4xNzIxIDY5Ny42NDEgMjQuMjA5SDY5NC4xMDVaTTY5NS42OTQgMjEuMTIyOUM2OTMuMTg0IDIxLjEyMjkgNjkxLjQgMjIuNzc1NSA2OTEuNCAyNS4xMDEyQzY5MS40IDI3LjQ0NDEgNjkzLjI1OSAyOC45OTU0IDY5Ni4xMTkgMjguOTk1NEM2OTYuNzUzIDI4Ljk5NTQgNjk4LjI5IDI4Ljk5NTQgNjk5Ljc1NSAyNy45ODdWMjYuNTA0MkM2OTguNTU3IDI3LjI5OTMgNjk3Ljc2MyAyNy41NzMxIDY5Ni43MzYgMjcuNTczMUM2OTUuMTMxIDI3LjU3MzEgNjk0LjE0IDI2Ljc5NDkgNjk0LjA1MSAyNS40NjY2SDY5OS44OTRDNzAwLjAxNSAyMi42OTM5IDY5OC4wNjEgMjEuMTIyOSA2OTUuNjk0IDIxLjEyMjkiIGZpbGw9IiMwMDlFNEQiLz4NCjxwYXRoIGQ9Ik03MDMuNzIxIDIzLjQzNjhINzAzLjc1OEM3MDQuNTE3IDIxLjg1NjIgNzA1LjM2NiAyMS4xMTUgNzA2LjM1MiAyMS4xMTVDNzA2Ljg2MiAyMS4xMTUgNzA3LjMwMyAyMS4yOTY0IDcwOC4wNDQgMjEuODA3Nkw3MDcuMzQxIDIzLjkxMzNDNzA2LjY3IDIzLjUxODYgNzA2LjIyOSAyMy4zNTM1IDcwNS44MjMgMjMuMzUzNUM3MDQuODg2IDIzLjM1MzUgNzA0LjI4NiAyNC4xNzc1IDcwMy43MjEgMjUuNTcwNFYyOC44NDY2SDcwMS4xNjJWMjEuMjU0MUg3MDMuNzIxVjIzLjQzNjhaTTY4MC43NzUgMTguMDY3NEM2ODEuMDE1IDE4LjY1NzUgNjgwLjU4MyAxOS40ODA1IDY3OS44MTQgMTkuOTA0QzY3OS4wNDEgMjAuMzI3MSA2NzguMjI0IDIwLjE5MjggNjc3Ljk4NiAxOS42MDI3QzY3Ny43NDMgMTkuMDExNyA2NzguMTczIDE4LjE4NzcgNjc4Ljk0NSAxNy43NjY2QzY3OS43MTYgMTcuMzQxMSA2ODAuNTMzIDE3LjQ3NTkgNjgwLjc3NSAxOC4wNjc0WiIgZmlsbD0iIzAwOUU0RCIvPg0KPHBhdGggZD0iTTY1OC4yMiAyNC4wMjMxQzY1OC4yMiAyMS45NjUxIDY1Ni43MTkgMjEuMTIyNiA2NTUuMjM5IDIxLjEyMjZDNjU0LjIzMiAyMS4xMjI2IDY1My40MDQgMjEuNTE4NCA2NTIuNjY0IDIyLjM5MjFINjUyLjYyOVYxNy42MzkySDY1MC4wNzFWMjguODM1M0g2NTIuNjI5VjI0LjAyMzFDNjUzLjIyOCAyMy4yMTYxIDY1My43MzggMjIuODcxMSA2NTQuMzM4IDIyLjg3MTFDNjU1LjEzNCAyMi44NzExIDY1NS42NjIgMjMuMzk4NiA2NTUuNjYyIDI0LjUzMjlWMjcuMjAwOEM2NTYuNTIgMjYuNzg5NiA2NTcuMzkzIDI2LjUzNzQgNjU4LjIyIDI2LjQ0MzhWMjQuMDIzMVpNNjY0LjYzNiAyMS4xMTk5QzY2My41OTQgMjEuMTE5OSA2NjIuNzk5IDIxLjQ4MTEgNjYxLjk4NCAyMi4zNDkzVjIxLjI2MjRINjU5LjQyOFYyNi40MjM0QzY2MC4zMTMgMjYuNTA1OCA2NjEuNDQzIDI2Ljg4NDcgNjYxLjk4NCAyNy41MTA0VjIzLjk2MzRDNjYyLjY1NyAyMy4wMjMyIDY2My4xMzQgMjIuNzA5NyA2NjMuNzcgMjIuNzA5N0M2NjQuNDk0IDIyLjcwOTcgNjY1LjA0NSAyMy4xNTU2IDY2NS4wNDUgMjQuMjI2NFYyOC44MzcySDY2Ny42MDJWMjQuMDI4OUM2NjcuNjAyIDIxLjc5MjYgNjY1LjkwOCAyMS4xMTk5IDY2NC42MzYgMjEuMTE5OVYyMS4xMTk5Wk02NjkuMDE1IDMxLjAxODFINjY2LjA0M1YzMi45ODY0SDY2OC45MDlWMzMuODMxMkg2NjYuMDQzVjM1Ljg2MTlINjY5LjEwM1YzNi43MDU1SDY2NS4wNDZWMzAuMTc1Mkg2NjkuMDE1TDY2OS4wMTUgMzEuMDE4MVpNNjcxLjQ0MiAzNi43MDkzSDY3Mi4zNTJWMzAuMTczM0g2NzEuNDQyVjM2LjcwOTNaTTY3Ni44NTkgMzMuMDQ4NEM2NzcuNTA0IDMzLjA0ODQgNjc3LjkwNCAzMy40NjMxIDY3Ny45MzUgMzQuMTE0Mkg2NzUuNjE2QzY3NS43NDIgMzMuNDM0MiA2NzYuMTYxIDMzLjA0ODQgNjc2Ljg1OSAzMy4wNDg0Wk02NzUuNiAzNC42ODFINjc4Ljg0MkM2NzguODQyIDMzLjA4NjkgNjc4LjA2MiAzMi4zMTggNjc2LjgzOCAzMi4zMThDNjc1LjU2OSAzMi4zMTggNjc0LjY4OCAzMy4xOTI0IDY3NC42ODggMzQuNDk2OUM2NzQuNjg4IDM1LjY4OSA2NzUuNDg0IDM2Ljc4OTggNjc2LjkxNyAzNi43ODk4QzY3Ny42OTggMzYuNzg5OCA2NzguMjAzIDM2LjYyODEgNjc4Ljc2MyAzNi4yODJWMzUuNDU2QzY3OC4yMjIgMzUuNzg1NiA2NzcuNjk4IDM1Ljk3NTggNjc3LjE0NyAzNS45NzU4QzY3Ni4yNjUgMzUuOTc1OCA2NzUuNzQyIDM1LjUzNSA2NzUuNiAzNC42ODA2VjM0LjY4MVpNNjg0Ljc4NiAzMy41MzA5QzY4NC4yNjMgMzMuMTk2NiA2ODMuOTE0IDMzLjA5ODUgNjgzLjUxNSAzMy4wOTg1QzY4Mi42ODIgMzMuMDk4NSA2ODIuMTA1IDMzLjY5NDUgNjgyLjEwNSAzNC41NjdDNjgyLjEwNSAzNS40NTYgNjgyLjcxOSAzNS45OTE2IDY4My42NjggMzUuOTkxNkM2ODQuMDU4IDM1Ljk5MTYgNjg0LjQzIDM1Ljg5NzMgNjg0Ljg4OCAzNS43MDU5VjM2LjU0MjZDNjg0LjU4MiAzNi42Nzc0IDY4My45OTcgMzYuNzg5OCA2ODMuNTE1IDM2Ljc4OThDNjgyLjEzNiAzNi43ODk4IDY4MS4xOCAzNS45MDYyIDY4MS4xOCAzNC42NDMyQzY4MS4xOCAzMy4yMTc4IDY4Mi4wNTQgMzIuMzE4IDY4My40NTMgMzIuMzE4QzY4My45ODcgMzIuMzE4IDY4NC4zNDYgMzIuNDMzOSA2ODQuNzg3IDMyLjYxNDVMNjg0Ljc4NiAzMy41MzA5Wk02ODguOTM0IDMyLjQwMDRINjkwLjM5NVYzMy4xNjUxSDY4OC45MzRWMzUuMzc1MkM2ODguOTM0IDM1Ljg4MTEgNjg5LjMyNyAzNi4wMjc0IDY4OS41OTMgMzYuMDI3NEM2ODkuOTIyIDM2LjAyNzQgNjkwLjI2MiAzNS45MiA2OTAuNjMgMzUuNzA3OVYzNi41MDM3QzY5MC4zMSAzNi42Njc4IDY4OS44MiAzNi43ODk4IDY4OS41MTkgMzYuNzg5OEM2ODguNTI4IDM2Ljc4OTggNjg4LjAyNyAzNi4yMTYxIDY4OC4wMjcgMzUuNDM5MVYzMy4xNjUxSDY4Ny4yMjRWMzMuMDcwM0w2ODguOTM0IDMxLjUxMDJWMzIuNDAwNFpNNjkzLjg3NiAzMi40MDA0VjMzLjM5NjlINjkzLjg5NUM2OTQuMzU5IDMyLjYzNDUgNjk0LjggMzIuMzE4IDY5NS4yMyAzMi4zMThDNjk1LjYwMSAzMi4zMTggNjk1Ljk0NyAzMi40ODAxIDY5Ni4zMjkgMzIuODE2Nkw2OTUuODQ3IDMzLjU2NDRDNjk1LjU3IDMzLjMwOTEgNjk1LjIxMSAzMy4xMzMxIDY5NC45OTUgMzMuMTMzMUM2OTQuMzY4IDMzLjEzMzEgNjkzLjg3NiAzMy43MjY4IDY5My44NzYgMzQuNDYyNlYzNi43MDkzSDY5Mi45NjdWMzIuNDAwNEg2OTMuODc2Wk03MDUuNjU3IDMzLjUzMDlDNzA1LjEzMSAzMy4xOTY2IDcwNC43ODIgMzMuMDk4NSA3MDQuMzgxIDMzLjA5ODVDNzAzLjU0OSAzMy4wOTg1IDcwMi45NzcgMzMuNjk0NSA3MDIuOTc3IDM0LjU2N0M3MDIuOTc3IDM1LjQ1NiA3MDMuNTkyIDM1Ljk5MTYgNzA0LjUzNSAzNS45OTE2QzcwNC45MjUgMzUuOTkxNiA3MDUuMjk1IDM1Ljg5NzMgNzA1Ljc2IDM1LjcwNTlWMzYuNTQyNkM3MDUuNDQ3IDM2LjY3NzQgNzA0Ljg2MiAzNi43ODk4IDcwNC4zOCAzNi43ODk4QzcwMy4wMDQgMzYuNzg5OCA3MDIuMDQ0IDM1LjkwNjIgNzAyLjA0NCAzNC42NDMyQzcwMi4wNDQgMzMuMjE3OCA3MDIuOTIyIDMyLjMxOCA3MDQuMzIgMzIuMzE4QzcwNC44NTUgMzIuMzE4IDcwNS4yMTIgMzIuNDMzOSA3MDUuNjU3IDMyLjYxNDVMNzA1LjY1NyAzMy41MzA5Wk02OTguNzQyIDM2LjcwOTNINjk5LjY1MlYzMi40MDA4SDY5OC43NDJWMzYuNzA5M1oiIGZpbGw9IiMwMDlFNEQiLz4NCjxwYXRoIGQ9Ik02OTkuNjg0IDMwLjg1MjVDNjk5Ljc3MyAzMS4wNjA0IDY5OS42MTggMzEuMzU0NCA2OTkuMzQ0IDMxLjUwNDFDNjk5LjA2OCAzMS42NTQzIDY5OC43NzYgMzEuNjA2MiA2OTguNjkzIDMxLjM5NzhDNjk4LjYxIDMxLjE4NzQgNjk4Ljc2MSAzMC44OTU4IDY5OS4wMzggMzAuNzQ1NkM2OTkuMzExIDMwLjU5MzUgNjk5LjYwMSAzMC42NDIxIDY5OS42ODQgMzAuODUyNVYzMC44NTI1Wk02NTguOTQgMzEuMjAwOUM2NTguNzc5IDMxLjIwMDkgNjU4LjcxMSAzMS4yMjU1IDY1OC42NDYgMzEuMjkzOEM2NTguNjIgMzEuMzIwMyA2NTguNjEgMzEuMzQ3MiA2NTguNiAzMS40MDExTDY1Ny43ODQgMzQuMjg3QzY1Ny41OTMgMzUuMjk5MiA2NTYuMjU5IDM2LjMwOTkgNjU0LjUyMSAzNi4zMDk5SDY1Mi4xMDRMNjUyLjUyMyAzNC44MjdINjU0LjA3NkM2NTQuMjM0IDM0LjgyNyA2NTQuMzU4IDM0Ljc3MjEgNjU0LjQ2MiAzNC42NjQzQzY1NC41IDM0LjYyMjUgNjU0LjU1IDM0LjU1NyA2NTQuNTU2IDM0LjQ4OTZMNjU1LjIwMSAzMS45NjgxQzY1NS4zOTEgMzAuOTU1NSA2NTYuNTM4IDI5LjgzNjkgNjU4LjI3NiAyOS44MzY5SDY2MC43NTFMNjYwLjQzNSAzMS4yMDA5SDY1OC45NFpNNjU5LjQ5NyAzMi45NTk2TDY1OS43NzMgMzIuMDI1OUg2NjIuMjg4QzY2Mi41OTggMzAuNjcyIDY2Mi4zNTQgMjkuNDE3NyA2NjEuNDczIDI4LjU5NjFDNjU5LjY4OSAyNi45MzMyIDY1NS45NTcgMjcuNDk4MyA2NTMuMTc3IDI5Ljk3NzlDNjUyLjc0MyAzMC4zNjMgNjUyLjM3NiAzMC43NzkzIDY1Mi4wNDIgMzEuMjA0OEg2NTMuNTU2TDY1My4yMDQgMzIuMTQwNEg2NTEuMzk1QzY1MS4yMjIgMzIuNDM1NCA2NTEuMDYgMzIuNzI4MSA2NTAuOTM2IDMzLjAyNUg2NTMuMDgxTDY1Mi43MzcgMzMuOTYwN0g2NTAuNjNDNjUwLjI2OSAzNS4zOTAxIDY1MC40OTkgMzYuNzIzMyA2NTEuNDA2IDM3LjU2OTlDNjUzLjE2NyAzOS4yMTE2IDY1Ni44ODggMzguNjM0NiA2NTkuNjY3IDM2LjE1NTRDNjYwLjE1MyAzNS43MjQyIDY2MC41NTUgMzUuMjU4NyA2NjAuOTE4IDM0Ljc4MDhINjU4Ljk3M0w2NTkuMjY5IDMzLjg0NzFINjYxLjU0M0M2NjEuNzEgMzMuNTUwMSA2NjEuODYzIDMzLjI1NjUgNjYxLjk4MyAzMi45NTk2SDY1OS40OTdaIiBmaWxsPSIjMDA5RTREIi8+DQo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfNThfMTExKSI+DQo8cGF0aCBkPSJNNzc1LjA2OCA0MS4yMjc0Qzc2Ni4yODUgNDIuMDQ2MyA3NTcuMTMxIDQwLjc1NjQgNzU1Ljg0OCAzMy44MTlDNzU1LjIyMSAzMC4zOTkgNzU2Ljc2NSAyNi43NzI1IDc1OC44MSAyNC41MTg0VjIzLjMxNDhDNzU1LjEyNiAyNi41OCA3NTMuMTMgMzAuNzExNSA3NTQuMjggMzUuNTkyQzc1NS43NDggNDEuODUxOCA3NjMuNjAzIDQ1LjM5NjcgNzc1LjU5NSA0NC4yMTk1Qzc4MC4zNDIgNDMuNzU0NSA3ODYuNTUgNDIuMjEyIDc5MC44NjkgMzkuODE0NFYzNi40MTA5Qzc4Ni45NDkgMzguNzcxMyA3ODAuNDY4IDQwLjcyMTEgNzc1LjA2OCA0MS4yMjc0VjQxLjIyNzRaTTc5OC4yMDUgMjMuMjMzNUM3OTYuMTIyIDEyLjk1MzMgNzc2LjM3MyAxMi4zMDE2IDc2My42NDMgMjAuMTMzOFYyMC45OTg5Qzc3Ni4zNTkgMTQuMzkxNSA3OTQuMzk1IDE0LjQzMTcgNzk2LjAzNyAyMy45MDE2Qzc5Ni41ODkgMjcuMDM0MiA3OTQuODQzIDMwLjI5NzggNzkxLjcyMyAzMi4xNzdWMzQuNjM0MkM3OTUuNDc2IDMzLjI0MzIgNzk5LjMyNCAyOC43NDQyIDc5OC4yMDUgMjMuMjMzNVYyMy4yMzM1WiIgZmlsbD0iIzBFN0RDMiIvPg0KPHBhdGggZD0iTTc5MC4xNTkgMjEuNzM2OEg3ODcuODU2VjMyLjEwM0M3ODcuODU2IDMzLjMxNzkgNzg4LjQzNyAzNC4zNzQ0IDc5MC4xNTkgMzQuNTQzMlYyMS43MzY4Wk03NjIuNzM5IDI1LjUyMTdINzYwLjQzMkw3NjAuNDMxIDMyLjI5NDNDNzYwLjQzMSAzMy41MTM0IDc2MS4wMTMgMzQuNTY4OCA3NjIuNzM5IDM0LjczNDRWMjUuNTIxN1YyNS41MjE3Wk03NjAuNDMyIDIyLjA1MjFINzYyLjczMlYyNC4yNTg0SDc2MC40MzJWMjIuMDUyMVpNNzc2LjUzIDM0LjYyNzJDNzc0LjY2NiAzNC42MjcyIDc3My44NzcgMzMuMzE3NyA3NzMuODc3IDMyLjAyOFYyMy4wMzU1SDc3Ni4xNlYyNS41MjE3SDc3Ny44NzlWMjcuMzg1M0g3NzYuMTZWMzEuODg1NEM3NzYuMTYgMzIuNDExMyA3NzYuNDA3IDMyLjcwNDQgNzc2Ljk1IDMyLjcwNDRINzc3Ljg3OVYzNC42MjcyTDc3Ni41MyAzNC42MjcyVjM0LjYyNzJaTTc4MC43MzEgMzAuNzk2MUM3ODAuNzMxIDMxLjk3NjggNzgxLjQ2MSAzMi44NDQ2IDc4Mi43NTQgMzIuODQ0NkM3ODMuNzY2IDMyLjg0NDYgNzg0LjI2NiAzMi41NjA1IDc4NC44NSAzMS45NzY4TDc4Ni4yNjEgMzMuMzM0OUM3ODUuMzU3IDM0LjIzNzkgNzg0LjQwOSAzNC43ODcgNzgyLjczNyAzNC43ODdDNzgwLjU1MiAzNC43ODcgNzc4LjQ1OSAzMy41ODE5IDc3OC40NTkgMzAuMDY4NkM3NzguNDU5IDI3LjA2NTEgNzgwLjI4OCAyNS4zNjczIDc4Mi42ODYgMjUuMzY3M0M3ODUuMTI0IDI1LjM2NzMgNzg2LjUyNSAyNy4zNTQ5IDc4Ni41MjUgMjkuOTYzOVYzMC43OTYzSDc4MC43MzFWMzAuNzk2MVpNNzgyLjU4NiAyNy4yNzU2Qzc4MS44MDUgMjcuMjc1NiA3ODEuMjA0IDI3LjY4MjMgNzgwLjk1IDI4LjIzMDlDNzgwLjgwMiAyOC41NjA3IDc4MC43NDcgMjguODE3NyA3ODAuNzMxIDI5LjIyMjlINzg0LjI0OUM3ODQuMjA0IDI4LjIzMDkgNzgzLjc1OSAyNy4yNzU2IDc4Mi41ODYgMjcuMjc1NlpNNzY4LjkzOSAyNy4zODUzQzc2OS42MDggMjcuMzg1MyA3NjkuODg3IDI3LjcxOTggNzY5Ljg4NyAyOC4yNjI2VjM0LjY0MDZINzcyLjE3VjI4LjI0OTJDNzcyLjE3IDI2Ljk1NDIgNzcxLjQ4NyAyNS41MjQxIDc2OS40ODIgMjUuNTI0MUw3NjQuNzY2IDI1LjUyMTdWMzQuNjQwNkg3NjcuMDVWMjcuMzg1M0g3NjguOTM5VjI3LjM4NTNaTTc5Mi42MzcgMjMuNTg5MUM3OTIuMTI5IDIzLjU4OTEgNzkxLjcyNCAyMy4xNzU0IDc5MS43MjQgMjIuNjYyOUM3OTEuNzI0IDIyLjE1MjkgNzkyLjEyOSAyMS43MzY4IDc5Mi42MzcgMjEuNzM2OEM3OTMuMTQyIDIxLjczNjggNzkzLjU1NiAyMi4xNTI5IDc5My41NTYgMjIuNjYyOUM3OTMuNTU2IDIzLjE3NTQgNzkzLjE0MiAyMy41ODkxIDc5Mi42MzcgMjMuNTg5MVpNNzkyLjYzNyAyMS44OTEyQzc5Mi4yMTggMjEuODkxMiA3OTEuODgyIDIyLjI0MDcgNzkxLjg4MiAyMi42NjI5Qzc5MS44ODIgMjMuMDg3NiA3OTIuMjE4IDIzLjQzMDkgNzkyLjYzNyAyMy40MzA5Qzc5My4wNTUgMjMuNDMwOSA3OTMuNDAyIDIzLjA4NzYgNzkzLjQwMiAyMi42NjI5Qzc5My40MDIgMjIuMjQwNyA3OTMuMDU1IDIxLjg5MTIgNzkyLjYzNyAyMS44OTEyWk03OTMuMDQzIDIzLjIxOEg3OTIuODcyQzc5Mi44NjQgMjMuMjE3OSA3OTIuODU3IDIzLjIxNTcgNzkyLjg1MSAyMy4yMTE2Qzc5Mi44NDUgMjMuMjA3NSA3OTIuODQgMjMuMjAxNyA3OTIuODM3IDIzLjE5NDlMNzkyLjYwNSAyMi43OTdDNzkyLjU5OCAyMi43ODg1IDc5Mi41NzkgMjIuNzc4OCA3OTIuNTczIDIyLjc3ODhINzkyLjQ2N1YyMy4xNzU0Qzc5Mi40NjcgMjMuMTk1IDc5Mi40NTMgMjMuMjE4MSA3OTIuNDI4IDIzLjIxODFINzkyLjI3NEM3OTIuMjUxIDIzLjIxODEgNzkyLjIzNSAyMy4xOTUgNzkyLjIzNSAyMy4xNzU0VjIyLjE3NDlDNzkyLjIzNSAyMi4xMTY0IDc5Mi4yNTQgMjIuMDkyNCA3OTIuMzA1IDIyLjA4NUM3OTIuMzYxIDIyLjA3OSA3OTIuNTA1IDIyLjA3MTYgNzkyLjU4NiAyMi4wNzE2Qzc5Mi44NzIgMjIuMDcxNiA3OTMuMDM5IDIyLjE1NjYgNzkzLjAzOSAyMi40MjQ0VjIyLjQ0NEM3OTMuMDM5IDIyLjYwOTQgNzkyLjk1OSAyMi42OTk1IDc5Mi44MzMgMjIuNzM5N0w3OTMuMDc0IDIzLjE1NDdDNzkzLjA3OCAyMy4xNjQgNzkzLjA4IDIzLjE3MzkgNzkzLjA4IDIzLjE4NEM3OTMuMDggMjMuMTk5NyA3OTMuMDcyIDIzLjIxOCA3OTMuMDQzIDIzLjIxOFYyMy4yMThaTTc5Mi44MjEgMjIuNDI0NEM3OTIuODIxIDIyLjMxMjcgNzkyLjc1MiAyMi4yNzczIDc5Mi42MDUgMjIuMjc3M0g3OTIuNDU5VjIyLjU5NDdDNzkyLjQ4MiAyMi41OTQ3IDc5Mi41ODYgMjIuNTk5NiA3OTIuNjA1IDIyLjU5OTZDNzkyLjc1MiAyMi41OTk2IDc5Mi44MjEgMjIuNTUgNzkyLjgyMSAyMi40NDRWMjIuNDI0NFoiIGZpbGw9IiMwRTdEQzIiLz4NCjwvZz4NCjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMV81OF8xMTEpIj4NCjxwYXRoIGQ9Ik01MzMuNzczIDIwLjk5MTFDNTI5LjI2MyAyMC45OTExIDUyNS41OTkgMjQuNjU0NyA1MjUuNTk5IDI5LjE2NDRDNTI1LjU5OSAzMy42NzQxIDUyOS4yNjMgMzcuMzM3NyA1MzMuNzczIDM3LjMzNzdDNTM4LjI4MiAzNy4zMzc3IDU0MS45NDYgMzMuNjc0MSA1NDEuOTQ2IDI5LjE2NDRDNTQxLjk0NiAyNC42NTQ3IDUzOC4yODIgMjAuOTkxMSA1MzMuNzczIDIwLjk5MTFaTTUzMy43NzMgMzYuNTE4NkM1MjkuNzEzIDM2LjUxODYgNTI2LjQxOSAzMy4yMTUgNTI2LjQxOSAyOS4xNjQ0QzUyNi40MTkgMjUuMTEzNyA1MjkuNzEzIDIxLjgxMDIgNTMzLjc3MyAyMS44MTAyQzUzNy44MzIgMjEuODEwMiA1NDEuMTI3IDI1LjExMzcgNTQxLjEyNyAyOS4xNjQ0QzU0MS4xMjcgMzMuMjE1IDUzNy44MzIgMzYuNTE4NiA1MzMuNzczIDM2LjUxODZaIiBmaWxsPSJibGFjayIvPg0KPHBhdGggZD0iTTUzNi42OSAyMy45MjUyQzUzNi42NjMgMjMuOTA3MiA1MzYuNjI3IDIzLjg5ODIgNTM2LjU5MSAyMy44OTgyQzUzNi40ODMgMjMuODk4MiA1MzYuNDAyIDIzLjk3OTIgNTM2LjQwMiAyNC4wODczVjI2LjY0MzdDNTM2LjQwMiAyNi43MzM3IDUzNi4zMyAyNi44MDU3IDUzNi4yNCAyNi44MDU3SDUzMS4yOUM1MzEuMiAyNi44MDU3IDUzMS4xMzcgMjYuNzMzNyA1MzEuMTI4IDI2LjY0MzdWMjQuMDg3M0M1MzEuMTI4IDI0LjA1MTMgNTMxLjExOSAyNC4wMjQyIDUzMS4xMDEgMjMuOTg4MkM1MzEuMDQ3IDIzLjg5ODIgNTMwLjkzIDIzLjg3MTIgNTMwLjgzOSAyMy45MjUyQzUyOS4wMTIgMjUuMDUwNCA1MjcuOTA1IDI3LjAwMzcgNTI3LjkwNSAyOS4xNjQxQzUyNy45MDUgMzEuMzI0NCA1MjkuMDEyIDMzLjI3NzcgNTMwLjg1NyAzNC40MDI5QzUzMC44ODUgMzQuNDIwOSA1MzAuOTIxIDM0LjQyOTkgNTMwLjk1NyAzNC40Mjk5QzUzMS4wNjUgMzQuNDI5OSA1MzEuMTQ2IDM0LjM0ODkgNTMxLjE0NiAzNC4yNDA5VjMxLjY4NDVDNTMxLjE0NiAzMS41OTQ0IDUzMS4yMTggMzEuNTMxNCA1MzEuMzA4IDMxLjUyMjRINTM2LjI1OEM1MzYuMzQ4IDMxLjUyMjQgNTM2LjQyIDMxLjU5NDQgNTM2LjQyIDMxLjY4NDVWMzQuMjQwOUM1MzYuNDIgMzQuMjc2OSA1MzYuNDI5IDM0LjMwMzkgNTM2LjQ0NyAzNC4zMzk5QzUzNi41MDEgMzQuNDI5OSA1MzYuNjE4IDM0LjQ1NjkgNTM2LjcwOCAzNC40MDI5QzUzOC41NTQgMzMuMjc3NyA1MzkuNjYxIDMxLjMyNDQgNTM5LjY2MSAyOS4xNjQxQzUzOS42NjEgMjcuMDAzNyA1MzguNTM2IDI1LjA1MDQgNTM2LjY5IDIzLjkyNTJWMjMuOTI1MlpNNTMwLjE5MSAzMi4zNjg2TDUzMC4yMTggMzIuNjc0Nkw1MzAuMDIgMzIuNDMxNkM1MjguNDk5IDMwLjUxNDMgNTI4LjQ5OSAyNy44MDQ4IDUzMC4wMiAyNS44ODc1TDUzMC4xOTEgMjUuNjcxNUw1MzAuMjE4IDI1LjY0NDVMNTMwLjE5MSAyNS45NTk2QzUzMC4xNjQgMjYuMjExNiA1MzAuMTU1IDI2LjQ3MjYgNTMwLjE1NSAyNi43MzM3VjMxLjU4NTRDNTMwLjE1NSAzMS44NDY1IDUzMC4xNzMgMzIuMTA3NSA1MzAuMTkxIDMyLjM2ODZaTTUzNi40MDIgMzAuMzg4M0M1MzYuNDAyIDMwLjQ3ODMgNTM2LjMzIDMwLjU1MDMgNTM2LjI0IDMwLjU1MDNINTMxLjI5QzUzMS4yIDMwLjU1MDMgNTMxLjEzNyAzMC40NzgzIDUzMS4xMjggMzAuMzg4M1YyNy45Mzk5QzUzMS4xMjggMjcuODQ5OSA1MzEuMiAyNy43Nzc4IDUzMS4yOSAyNy43Nzc4SDUzNi4yNEM1MzYuMzMgMjcuNzc3OCA1MzYuNDAyIDI3Ljg0OTkgNTM2LjQwMiAyNy45Mzk5VjMwLjM4ODNaTTUzNy41MTkgMzIuNDMxNkw1MzcuMzIxIDMyLjY3NDZMNTM3LjM0OCAzMi4zNjg2QzUzNy4zNzUgMzIuMTE2NSA1MzcuMzg0IDMxLjg1NTUgNTM3LjM4NCAzMS41OTQ0VjI2LjczMzdDNTM3LjM4NCAyNi40NzI2IDUzNy4zNzUgMjYuMjExNiA1MzcuMzQ4IDI1Ljk1OTZMNTM3LjMzOSAyNS44MjQ1TDUzNy4zMyAyNS42ODA1VjI1LjY0NDVMNTM3LjUxOSAyNS44ODc1QzUzOC4yNTcgMjYuODA1NyA1MzguNjYyIDI3Ljk3NTkgNTM4LjY2MiAyOS4xNTUxQzUzOC42NjIgMzAuMzM0MiA1MzguMjU3IDMxLjUxMzQgNTM3LjUxOSAzMi40MzE2VjMyLjQzMTZaIiBmaWxsPSJibGFjayIvPg0KPHBhdGggZD0iTTU1NC4yNzYgMjkuMDIwMkM1NTQuMjMxIDI5LjAwMjIgNTU0LjE3NyAyOC45ODQyIDU1NC4xNzcgMjguOTMwMkM1NTQuMTc3IDI4Ljg5NDIgNTU0LjE5NSAyOC44NjcyIDU1NC4yMzEgMjguODQ5MkM1NTQuMjk0IDI4LjgyMjIgNTU1Ljg1MSAyOC4yNjQxIDU1NS44NTEgMjYuNDI3OEM1NTUuODUxIDI0LjM4NDUgNTU0LjQ3NCAyMy4xNjkzIDU1Mi4xNTIgMjMuMTY5M0g1NDYuNTI2VjM1LjE3NzJINTUyLjY2NUM1NTQuNDU2IDM1LjE3NzIgNTU2LjM4MiAzMy45MDggNTU2LjM4MiAzMS44NjQ2QzU1Ni4zODIgMjkuOTExMyA1NTQuOTA2IDI5LjIyNzIgNTU0LjI3NiAyOS4wMjAyVjI5LjAyMDJaTTU0OS4zNjEgMjUuNjI2N0M1NDkuMzYxIDI1LjU4MTcgNTQ5LjM5NyAyNS41NDU2IDU0OS40NDIgMjUuNTQ1Nkg1NTEuNjc1QzU1Mi40MTMgMjUuNTQ1NiA1NTIuOTE3IDI2LjA0MDcgNTUyLjkxNyAyNi43Nzg4QzU1Mi45MTcgMjcuMzU0OSA1NTIuNDY3IDI3Ljk3NiA1NTEuNjIxIDI3Ljk3Nkg1NDkuNDQyQzU0OS4zOTcgMjcuOTc2IDU0OS4zNjEgMjcuOTQgNTQ5LjM2MSAyNy44OTVWMjUuNjI2N1pNNTUxLjY3NSAzMi44MDk4SDU0OS40NDJDNTQ5LjM5NyAzMi44MDk4IDU0OS4zNjEgMzIuNzczOCA1NDkuMzYxIDMyLjcyODhWMzAuMzM0NEM1NDkuMzYxIDMwLjI4OTQgNTQ5LjM5NyAzMC4yNTM0IDU0OS40NDIgMzAuMjUzNEg1NTEuNjIxQzU1Mi42OTIgMzAuMjUzNCA1NTMuMzA0IDMwLjcxMjUgNTUzLjMwNCAzMS41MjI2QzU1My4zMDQgMzIuMzU5NyA1NTIuNzM3IDMyLjgwOTggNTUxLjY3NSAzMi44MDk4VjMyLjgwOThaTTU3NS4zODQgMjcuOTQ5TDU3NC45NTIgMjcuODU5QzU3My45OCAyNy42NTIgNTczLjAzNSAyNy4zOTA5IDU3My4wMzUgMjYuNTUzOEM1NzMuMDM1IDI1LjcxNjcgNTczLjgxOCAyNS4zMzg2IDU3NC41OTIgMjUuMzM4NkM1NzUuNTAxIDI1LjMzODYgNTc2LjQwMSAyNS43NDM3IDU3Ny4wODYgMjYuNDQ1OEw1NzguODY4IDI0LjY4MTVDNTc4LjEwMyAyMy44MzU0IDU3Ni43NDQgMjIuODYzMiA1NzQuNTQ3IDIyLjg2MzJDNTcxLjkwMSAyMi44NjMyIDU3MC4xMTggMjQuMzY2NSA1NzAuMTE4IDI2LjYwNzhDNTcwLjExOCAyOC45NzUyIDU3MS45ODIgMjkuODY2MyA1NzMuNTQ4IDMwLjE5OTRMNTczLjk3MSAzMC4yODk0QzU3NS40OTIgMzAuNjEzNSA1NzYuMjEyIDMwLjg1NjUgNTc2LjIxMiAzMS43MjA2QzU3Ni4yMTIgMzIuNDk0NyA1NzUuNTE5IDMzLjAwNzggNTc0LjQ5MyAzMy4wMDc4QzU3My4yODcgMzMuMDA3OCA1NzIuMjE2IDMyLjQ3NjcgNTcxLjQwNiAzMS40Nzc2TDU2OS41NzggMzMuMjY4OUM1NzAuNTUxIDM0LjQyMTEgNTcxLjgzOCAzNS40NjUyIDU3NC41MjkgMzUuNDY1MkM1NzYuODI1IDM1LjQ2NTIgNTc5LjE1NiAzNC4xMzMgNTc5LjE1NiAzMS41NzY2QzU3OS4xNDcgMjguOTU3MiA1NzcuMzY1IDI4LjM2MzEgNTc1LjM4NCAyNy45NDlWMjcuOTQ5Wk01OTkuMTAzIDIzLjE2OTNWMjcuNTYyQzU5OS4xMDMgMjcuNjA3IDU5OS4wNjcgMjcuNjQzIDU5OS4wMjIgMjcuNjQzSDU5NS4zMzFDNTk1LjI4NiAyNy42NDMgNTk1LjI1IDI3LjYwNyA1OTUuMjUgMjcuNTYyVjIzLjE2OTNINTkyLjIyNlYzNS4xNzcySDU5NS4yNVYzMC40NjA0QzU5NS4yNSAzMC40MTU0IDU5NS4yODYgMzAuMzc5NCA1OTUuMzMxIDMwLjM3OTRINTk5LjAyMkM1OTkuMDY3IDMwLjM3OTQgNTk5LjEwMyAzMC40MTU0IDU5OS4xMDMgMzAuNDYwNFYzNS4xNzcySDYwMi4xNDZWMjMuMTY5M0g1OTkuMTAzWk01ODYuMTQxIDMyLjcxOThDNTg0Ljc4MiAzMi43MTk4IDU4My4zMTUgMzEuNTg1NiA1ODMuMzE1IDI5LjA5MjJDNTgzLjMxNSAyNi44MTQ4IDU4NC42OTIgMjUuNjI2NyA1ODYuMDUxIDI1LjYyNjdDNTg3LjA0MSAyNS42MjY3IDU4Ny43MzQgMjYuMDQwNyA1ODguMjgzIDI2Ljk1ODlMNTkwLjYwNiAyNS40MTk2QzU4OS40MTggMjMuNjczMyA1ODguMDA0IDIyLjg4MTIgNTg2LjAzMyAyMi44ODEyQzU4Mi4xNzEgMjIuODgxMiA1ODAuNDQzIDI2LjAwNDcgNTgwLjQ0MyAyOS4wOTIyQzU4MC40NDMgMzIuODQ1OCA1ODIuNzI5IDM1LjQ2NTIgNTg1Ljk5NyAzNS40NjUyQzU4OC40MjcgMzUuNDY1MiA1ODkuNTM1IDM0LjU3NDEgNTkwLjY5NiAzMi45MjY4TDU4OC4zNTUgMzEuMzUxNkM1ODcuODMzIDMyLjE5NzcgNTg3LjI2NiAzMi43MTk4IDU4Ni4xNDEgMzIuNzE5OFpNNTYzLjE3OCAyMi44NjMyQzU1OS44NzUgMjIuODYzMiA1NTcuNjYxIDI1LjM5MjYgNTU3LjY2MSAyOS4xNjQyQzU1Ny42NjEgMzIuOTM1OCA1NTkuODc1IDM1LjQ2NTIgNTYzLjE3OCAzNS40NjUyQzU2Ni40ODIgMzUuNDY1MiA1NjguNjk2IDMyLjkzNTggNTY4LjY5NiAyOS4xNjQyQzU2OC42OTYgMjUuMzkyNiA1NjYuNDgyIDIyLjg2MzIgNTYzLjE3OCAyMi44NjMyVjIyLjg2MzJaTTU2My4xNzggMzIuNzE5OEM1NjEuNTU4IDMyLjcxOTggNTYwLjUxNCAzMS4zMjQ2IDU2MC41MTQgMjkuMTY0MkM1NjAuNTE0IDI3LjAxMjkgNTYxLjU1OCAyNS42MjY3IDU2My4xNzggMjUuNjI2N0M1NjQuODA4IDI1LjYyNjcgNTY1Ljg2MSAyNy4wMTI5IDU2NS44NjEgMjkuMTY0MkM1NjUuODYxIDMxLjMyNDYgNTY0LjgwOCAzMi43MTk4IDU2My4xNzggMzIuNzE5OFoiIGZpbGw9IiNGODAwMDAiLz4NCjwvZz4NCjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQ2LjM0NCAyMi4xODExQzE0Ny41OTUgMjIuMjg1NCAxNDguODQ1IDIxLjU1NTMgMTQ5LjYyNyAyMC42Mjk4QzE1MC4zOTUgMTkuNjc4MSAxNTAuOTAzIDE4LjQwMDUgMTUwLjc3MyAxNy4wOTY5QzE0OS42NjYgMTcuMTQ5MSAxNDguMjk4IDE3LjgyNjkgMTQ3LjUxNyAxOC43Nzg2QzE0Ni44IDE5LjU5OTkgMTQ2LjE4OCAyMC45Mjk2IDE0Ni4zNDQgMjIuMTgxMVpNMTQ3Ljg0MSAyMy4wNzk3QzE0OC42NTMgMjIuNzYwNiAxNDkuNjU4IDIyLjM2NTYgMTUwLjc2IDIyLjQyOTFDMTUxLjQ2MyAyMi40ODEyIDE1My40OTUgMjIuNjg5OCAxNTQuNzk4IDI0LjYxOTJDMTU0Ljc5MiAyNC42MjM3IDE1NC43NzggMjQuNjMyMyAxNTQuNzU5IDI0LjY0NUMxNTQuNDM2IDI0Ljg1NDggMTUyLjM5IDI2LjE4NzEgMTUyLjQxNCAyOC44MTY5QzE1Mi40MzkgMzEuOTQ5OSAxNTQuOTg4IDMzLjExODMgMTU1LjMyMiAzMy4yNzExQzE1NS4zNDQgMzMuMjgxMSAxNTUuMzU2IDMzLjI4NjcgMTU1LjM1OCAzMy4yODgzQzE1NS4zNTYgMzMuMjkyNiAxNTUuMzU0IDMzLjMwMSAxNTUuMzUgMzMuMzEzM0MxNTUuMjgzIDMzLjUyODggMTU0Ljg0NSAzNC45NDg5IDE1My44NDcgMzYuNDA0QzE1Mi45MjIgMzcuNzU5OCAxNTEuOTcxIDM5LjA4OTUgMTUwLjQ2IDM5LjExNTZDMTQ5Ljc0OSAzOS4xMjgzIDE0OS4yNyAzOC45MjExIDE0OC43NzIgMzguNzA1NEMxNDguMjQ3IDM4LjQ3ODUgMTQ3LjcwMSAzOC4yNDIyIDE0Ni44NCAzOC4yNDIyQzE0NS45NDcgMzguMjQyMiAxNDUuMzc2IDM4LjQ4NDggMTQ0LjgyNiAzOC43MTg0QzE0NC4zNDggMzguOTIxNCAxNDMuODg3IDM5LjExNzQgMTQzLjI0NSAzOS4xNDE3QzE0MS43ODYgMzkuMTkzOCAxNDAuNjc5IDM3LjcwNzcgMTM5Ljc1NCAzNi4zNTE5QzEzNy44NjYgMzMuNjE0MyAxMzYuNDIgMjguNjM0NCAxMzguMzc0IDI1LjI3MUMxMzkuMzI1IDIzLjU4OTMgMTQxLjA1NyAyMi41MzM0IDE0Mi45MTkgMjIuNTA3M0MxNDMuNzMyIDIyLjQ5MjUgMTQ0LjUwNyAyMi44MDA2IDE0NS4xODQgMjMuMDcwMUMxNDUuNzAyIDIzLjI3NTggMTQ2LjE2MiAyMy40NTg5IDE0Ni41NCAyMy40NTg5QzE0Ni44NzcgMjMuNDU4OSAxNDcuMzE5IDIzLjI4NTEgMTQ3Ljg0MSAyMy4wNzk3WiIgZmlsbD0iYmxhY2siLz4NCjxwYXRoIGQ9Ik0zNi44NTg3IDM3LjUyNDFIMzEuOTg3NEwzNS4wMzQyIDE5LjY2NjhIMzkuOTA1MkwzNi44NTg3IDM3LjUyNDFaIiBmaWxsPSIjMDA1NzlGIi8+DQo8cGF0aCBkPSJNNTQuNTE1NyAyMC4xMDQxQzUzLjU1NDkgMTkuNzQyOCA1Mi4wMzA5IDE5LjM0MzggNTAuMTQ2NiAxOS4zNDM4QzQ1LjMzNjEgMTkuMzQzOCA0MS45NDg2IDIxLjc3NTMgNDEuOTI3OCAyNS4yNTE2QzQxLjg4NzggMjcuODE2NSA0NC4zNTMxIDI5LjI0MSA0Ni4xOTcgMzAuMDk2MkM0OC4wODE2IDMwLjk3MDEgNDguNzIyMyAzMS41NDA1IDQ4LjcyMjMgMzIuMzE5NEM0OC43MDMxIDMzLjUxNTcgNDcuMTk5NCAzNC4wNjcyIDQ1Ljc5NjkgMzQuMDY3MkM0My44NTIxIDM0LjA2NzIgNDIuODEgMzMuNzgyOSA0MS4yMjY0IDMzLjExNzNMNDAuNTg1IDMyLjgzMkwzOS45MDMzIDM2Ljg0MDZDNDEuMDQ1OCAzNy4zMzM5IDQzLjE1MDcgMzcuNzcxNyA0NS4zMzYxIDM3Ljc5MDlDNTAuNDQ3MyAzNy43OTA5IDUzLjc3NDkgMzUuMzk3MSA1My44MTQzIDMxLjY5MjVDNTMuODMzOCAyOS42NTk3IDUyLjUzMiAyOC4xMDIgNDkuNzI1NCAyNi44MjkyQzQ4LjAyMTcgMjYuMDEyMSA0Ni45NzgzIDI1LjQ2MTIgNDYuOTc4MyAyNC42MjUyQzQ2Ljk5ODMgMjMuODY1MiA0Ny44NjA4IDIzLjA4NjggNDkuNzg0IDIzLjA4NjhDNTEuMzY3NyAyMy4wNDg2IDUyLjUzMTIgMjMuNDA5NCA1My40MTI2IDIzLjc3MDVMNTMuODUzMiAyMy45NjAxTDU0LjUxNTcgMjAuMTA0MVoiIGZpbGw9IiMwMDU3OUYiLz4NCjxwYXRoIGQ9Ik02MC45OTI0IDMxLjE5NzlDNjEuMzkzNiAzMC4xNzIgNjIuOTM3MiAyNi4yMDE2IDYyLjkzNzIgMjYuMjAxNkM2Mi45MTcgMjYuMjM5NyA2My4zMzc2IDI1LjE1NjggNjMuNTc4MSAyNC40OTE5TDYzLjkxODYgMjYuMDMwNkM2My45MTg2IDI2LjAzMDYgNjQuODQxIDMwLjMwNTEgNjUuMDQxNCAzMS4xOTc5QzY0LjI4IDMxLjE5NzkgNjEuOTU0NiAzMS4xOTc5IDYwLjk5MjQgMzEuMTk3OVpNNjcuMDA1NCAxOS42NjY4SDYzLjIzNzRDNjIuMDc1NSAxOS42NjY4IDYxLjE5MjcgMTkuOTg5NSA2MC42OTE0IDIxLjE0ODRMNTMuNDU1OCAzNy41MjM5SDU4LjU2NzFDNTguNTY3MSAzNy41MjM5IDU5LjQwODUgMzUuMzE5OSA1OS41ODk0IDM0Ljg0NTJDNjAuMTUwMSAzNC44NDUyIDY1LjEyMjMgMzQuODQ1MiA2NS44NDM3IDM0Ljg0NTJDNjUuOTgzNSAzNS40NzIxIDY2LjQyNDkgMzcuNTIzOSA2Ni40MjQ5IDM3LjUyMzlINzAuOTM1Mkw2Ny4wMDU0IDE5LjY2NjhWMTkuNjY2OFoiIGZpbGw9IiMwMDU3OUYiLz4NCjxwYXRoIGQ9Ik0yNy45MTggMTkuNjY2OEwyMy4xNDc1IDMxLjg0MzhMMjIuNjI2MiAyOS4zNzQxQzIxLjc0NDIgMjYuNTI0NSAxOC45NzgxIDIzLjQyODQgMTUuODkxNCAyMS44ODlMMjAuMjYxIDM3LjUwNTJIMjUuNDEyMkwzMy4wNjkgMTkuNjY2OEgyNy45MThWMTkuNjY2OFoiIGZpbGw9IiMwMDU3OUYiLz4NCjxwYXRoIGQ9Ik0xOC43MTg0IDE5LjY2NjhIMTAuODgxMUwxMC44MDA5IDIwLjAyNzZDMTYuOTE0NSAyMS41MDk1IDIwLjk2MzUgMjUuMDgxNSAyMi42MjcgMjkuMzc0OUwyMC45MjMyIDIxLjE2NzlDMjAuNjQyNyAyMC4wMjc0IDE5Ljc4MDcgMTkuNzA0NCAxOC43MTg0IDE5LjY2NjhaIiBmaWxsPSIjRkFBNjFBIi8+DQo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDJfNThfMTExKSI+DQo8cGF0aCBkPSJNMjIxLjE1OCAxNy40OTlWMTguOTM1NkgyMzEuMzA2VjE3LjQ5OUgyMjEuMTU4Wk0yMzIuNzQ0IDE3LjQ5OVYxOC45MzU2SDI0Ny4yMDZDMjQ3LjIwNiAxOC45MzU2IDI0NS43MjkgMTcuNDk5IDI0My43NzMgMTcuNDk5SDIzMi43NDRaTTI1MC4wNDMgMTcuNDk5VjE4LjkzNTZIMjU4Ljc5M0wyNTguMjczIDE3LjQ5OUgyNTAuMDQzWk0yNjUuMDY1IDE3LjQ5OUwyNjQuNTQ2IDE4LjkzNTZIMjczLjIxNlYxNy40OTlIMjY1LjA2NVpNMjIxLjE1OCAyMC4yOTI5VjIxLjcyOTZIMjMxLjMwNlYyMC4yOTI5SDIyMS4xNThaTTIzMi43NDQgMjAuMjk1VjIxLjcyOTdIMjQ4Ljg4NEMyNDguODg0IDIxLjcyOTcgMjQ4LjY5NiAyMC42MjM5IDI0OC4zNjcgMjAuMjk1SDIzMi43NDRaTTI1MC4wNDMgMjAuMjk1VjIxLjcyOTdIMjU5Ljc1MkwyNTkuMjcxIDIwLjI5NUgyNTAuMDQzWk0yNjQuMDI3IDIwLjI5NUwyNjMuNTQ2IDIxLjcyOTdIMjczLjIxNlYyMC4yOTVIMjY0LjAyN1YyMC4yOTVaTTIyNC4wNzQgMjMuMDg2OVYyNC41MjU3SDIyOC40NjlWMjMuMDg2OUgyMjQuMDc0VjIzLjA4NjlaTTIzNS42NjEgMjMuMDg2OVYyNC41MjU3SDI0MC4wNTZWMjMuMDg2OUgyMzUuNjYxVjIzLjA4NjlaTTI0NC4zMzEgMjMuMDg2OVYyNC41MjU3SDI0OC43MjZDMjQ4LjcyNiAyNC41MjU3IDI0OS4wMDUgMjMuNzY1OSAyNDkuMDA1IDIzLjA4NjlIMjQ0LjMzMVYyMy4wODY5Wk0yNTIuOTYgMjMuMDg2OVYyNC41MjU3SDI2MC43NTJMMjYwLjIzMiAyMy4wODY5SDI1Mi45NlYyMy4wODY5Wk0yNjMuMDY5IDIzLjA4NjlMMjYyLjU0OCAyNC41MjU3SDI3MC4zNzlWMjMuMDg2OUgyNjMuMDY5VjIzLjA4NjlaTTIyNC4wNzQgMjUuODgzVjI3LjMxOTdIMjI4LjQ2OVYyNS44ODNIMjI0LjA3NFYyNS44ODNaTTIzNS42NjEgMjUuODgzVjI3LjMxOTdIMjQ2Ljg4N0MyNDYuODg3IDI3LjMxOTcgMjQ3LjgyNiAyNi41ODI1IDI0OC4xMjUgMjUuODgzSDIzNS42NjFaTTI1Mi45NiAyNS44ODNWMjcuMzE5N0gyNTcuMzU1VjI2LjUyTDI1Ny42MzQgMjcuMzE5N0gyNjUuNjg0TDI2NS45ODQgMjYuNTJWMjcuMzE5N0gyNzAuMzc5VjI1Ljg4M0gyNjIuMTI5TDI2MS42OTEgMjcuMDk5OUwyNjEuMjUxIDI1Ljg4M0gyNTIuOTZaTTIyNC4wNzQgMjguNjc3VjMwLjExMzdIMjI4LjQ2OVYyOC42NzdIMjI0LjA3NFpNMjM1LjY2MSAyOC42NzdWMzAuMTEzN0gyNDguMTI1QzI0Ny44MjYgMjkuNDE2NSAyNDYuODg3IDI4LjY3NyAyNDYuODg3IDI4LjY3N0gyMzUuNjYxWk0yNTIuOTYgMjguNjc3VjMwLjExMzdIMjU3LjM1NVYyOC42NzdIMjUyLjk2Wk0yNTguMTUzIDI4LjY3N0wyNTguNjg1IDMwLjExMzdIMjY0LjcyMUwyNjUuMjI2IDI4LjY3N0gyNTguMTUzWk0yNjUuOTg0IDI4LjY3N1YzMC4xMTM3SDI3MC4zNzlWMjguNjc3SDI2NS45ODRaTTIyNC4wNzQgMzEuNDcxVjMyLjkwNzZIMjI4LjQ2OVYzMS40NzFIMjI0LjA3NFpNMjM1LjY2MSAzMS40NzFWMzIuOTA3NkgyNDAuMDU2VjMxLjQ3MUgyMzUuNjYxWk0yNDQuMzMxIDMxLjQ3MVYzMi45MDc2SDI0OS4wMDVDMjQ5LjAwNSAzMi4yMjk2IDI0OC43MjYgMzEuNDcxIDI0OC43MjYgMzEuNDcxSDI0NC4zMzFWMzEuNDcxWk0yNTIuOTYgMzEuNDcxVjMyLjkwNzZIMjU3LjM1NVYzMS40NzFIMjUyLjk2Wk0yNTkuMTUxIDMxLjQ3MUwyNTkuNjY2IDMyLjkwNzZIMjYzLjcxM0wyNjQuMjMyIDMxLjQ3MUgyNTkuMTUxWk0yNjUuOTg0IDMxLjQ3MVYzMi45MDc2SDI3MC4zNzlWMzEuNDcxSDI2NS45ODRaTTIyMS4yMzcgMzQuMjY1VjM1LjcwMzdIMjMxLjM4NlYzNC4yNjVIMjIxLjIzN1pNMjMyLjc0NCAzNC4yNjVWMzUuNzAzN0gyNDguMzY3QzI0OC42OTYgMzUuMzc0MyAyNDguODg0IDM0LjI2NSAyNDguODg0IDM0LjI2NUgyMzIuNzQ0VjM0LjI2NVpNMjUwLjEyMyAzNC4yNjVWMzUuNzAzN0gyNTcuMzU1VjM0LjI2NUgyNTAuMTIzWk0yNjAuMTUxIDM0LjI2NUwyNjAuNjggMzUuNzAzN0gyNjIuNzM5TDI2My4yMzYgMzQuMjY1SDI2MC4xNTFaTTI2NS45ODQgMzQuMjY1VjM1LjcwMzdIMjczLjI5NVYzNC4yNjVIMjY1Ljk4NFpNMjIxLjIzNyAzNy4wNjFWMzguNDk3N0gyMzEuMzg2VjM3LjA2MUgyMjEuMjM3Wk0yMzIuNzQ0IDM3LjA2MVYzOC40OTU2SDI0My43NzNDMjQ1LjcyOSAzOC40OTU2IDI0Ny4yMDYgMzcuMDYxIDI0Ny4yMDYgMzcuMDYxSDIzMi43NDRaTTI1MC4xMjMgMzcuMDYxVjM4LjQ5NzdIMjU3LjM1NVYzNy4wNjFIMjUwLjEyM1pNMjYxLjE1NSAzNy4wNjFMMjYxLjY2NCAzOC40OTM2TDI2MS43NTIgMzguNDk1NkwyNjIuMjY5IDM3LjA2MUgyNjEuMTU1VjM3LjA2MVpNMjY1Ljk4NCAzNy4wNjFWMzguNDk3N0gyNzMuMjk1VjM3LjA2MUgyNjUuOTg0WiIgZmlsbD0iIzFGNzBDMSIvPg0KPC9nPg0KPGRlZnM+DQo8Y2xpcFBhdGggaWQ9ImNsaXAwXzU4XzExMSI+DQo8cmVjdCB3aWR0aD0iNDQuNDQ3MyIgaGVpZ2h0PSIyOS42MzE1IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzUzLjk1NSAxNC44MTU1KSIvPg0KPC9jbGlwUGF0aD4NCjxjbGlwUGF0aCBpZD0iY2xpcDFfNThfMTExIj4NCjxyZWN0IHdpZHRoPSI3Ni41NDgxIiBoZWlnaHQ9IjE2LjM1MDciIGZpbGw9IndoaXRlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1MjUuNTk5IDIwLjk4ODkpIi8+DQo8L2NsaXBQYXRoPg0KPGNsaXBQYXRoIGlkPSJjbGlwMl81OF8xMTEiPg0KPHJlY3Qgd2lkdGg9IjUyLjEzNzIiIGhlaWdodD0iMjAuOTk4NyIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIyMS4xNTggMTcuNDk5KSIvPg0KPC9jbGlwUGF0aD4NCjwvZGVmcz4NCjwvc3ZnPg0K\" style=\"\n            width: 742.5px;\n            position: relative;\n            top: 107px;\n            left: 32px;\n            \">\n            <a href=" + accountURL + " style=\"\n        float: left;\n        border-radius: 56px;\n        background: #0D6EFD;\n        padding-top: 8px;\n        width: 280px;\n        height: 38px;\n        text-align: center;\n        position: relative;\n        top: 127px;\n        left: 274px;\n        font-size: 16px;\n        color: white;\n        text-decoration: none;\n        letter-spacing: 0.02em;\n    \">Claim your FREE account</a>\n            <div style=\"\n    font-size: 14px;\n    position: relative;\n    top: 180px;\n    left: 19px;\n    letter-spacing: 0.02em;\n    font-weight: 500;\n    line-height: 125%;\n\">have a Syncfusion account? <a href=\"https://www.syncfusion.com/account/login?ReturnUrl=/account/login\" style=\"text-decoration: none;\ncolor: #0D6EFD;\nfont-weight: 500;\">Sign In</a></div>\n        </div>\n    </div>";
	    if (typeof document !== 'undefined' && !isNullOrUndefined(document)) {
	        var errorBackground = createElement('div', {
	            innerHTML: bannerTemplate
	        });
	        document.body.appendChild(errorBackground);
	    }
	};

	var __extends$M = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var componentCount = 0;
	var lastPageID;
	var lastHistoryLen = 0;
	// Decalre the static variable to count the instance
	var instancecount = 0;
	// Decalre the static variable to find if control limit exceed or not
	var isvalid = true;
	// We have added styles to inline type so here declare the static variable to detect if banner is added or not
	var isBannerAdded = false;
	/**
	 * Base class for all Essential JavaScript components
	 */
	var Component = /** @class */ (function (_super) {
	    __extends$M(Component, _super);
	    /**
	     * Initialize the constructor for component base
	     *
	     * @param {Object} options ?
	     * @param {string} selector ?
	     */
	    function Component(options, selector) {
	        var _this = _super.call(this, options, selector) || this;
	        _this.randomId = uniqueID();
	        /**
	         * string template option for Blazor template rendering
	         *
	         * @private
	         */
	        _this.isStringTemplate = false;
	        _this.needsID = false;
	        _this.isReactHybrid = false;
	        if (isNullOrUndefined(_this.enableRtl)) {
	            _this.setProperties({ 'enableRtl': rightToLeft }, true);
	        }
	        if (isNullOrUndefined(_this.locale)) {
	            _this.setProperties({ 'locale': defaultCulture }, true);
	        }
	        _this.moduleLoader = new ModuleLoader(_this);
	        _this.localObserver = new Observer(_this);
	        // tslint:disable-next-line:no-function-constructor-with-string-args
	        onIntlChange.on('notifyExternalChange', _this.detectFunction, _this, _this.randomId);
	        // Based on the considered control list we have count the instance
	        if (typeof window !== "undefined" && typeof document !== "undefined" && !validateLicense()) {
	            if (componentList.indexOf(_this.getModuleName()) !== -1) {
	                instancecount = instancecount + 1;
	                if (instancecount > 5) {
	                    isvalid = false;
	                }
	            }
	        }
	        if (!isUndefined(selector)) {
	            _this.appendTo();
	        }
	        return _this;
	    }
	    Component.prototype.requiredModules = function () {
	        return [];
	    };
	    /**
	     * Destroys the sub modules while destroying the widget
	     *
	     * @returns {void} ?
	     */
	    Component.prototype.destroy = function () {
	        if (this.isDestroyed) {
	            return;
	        }
	        if (this.enablePersistence) {
	            this.setPersistData();
	            this.detachUnloadEvent();
	        }
	        this.localObserver.destroy();
	        if (this.refreshing) {
	            return;
	        }
	        removeClass([this.element], ['e-control']);
	        this.trigger('destroyed', { cancel: false });
	        _super.prototype.destroy.call(this);
	        this.moduleLoader.clean();
	        onIntlChange.off('notifyExternalChange', this.detectFunction, this.randomId);
	    };
	    /**
	     * Applies all the pending property changes and render the component again.
	     *
	     * @returns {void} ?
	     */
	    Component.prototype.refresh = function () {
	        this.refreshing = true;
	        this.moduleLoader.clean();
	        this.destroy();
	        this.clearChanges();
	        this.localObserver = new Observer(this);
	        this.preRender();
	        this.injectModules();
	        this.render();
	        this.refreshing = false;
	    };
	    Component.prototype.accessMount = function () {
	        if (this.mount && !this.isReactHybrid) {
	            this.mount();
	        }
	    };
	    /**
	     * Returns the route element of the component
	     *
	     * @returns {HTMLElement} ?
	     */
	    Component.prototype.getRootElement = function () {
	        if (this.isReactHybrid) {
	            // eslint-disable-next-line
	            return this.actualElement;
	        }
	        else {
	            return this.element;
	        }
	    };
	    /**
	     * Returns the persistence data for component
	     *
	     * @returns {any} ?
	     */
	    // eslint-disable-next-line
	    Component.prototype.getLocalData = function () {
	        var eleId = this.getModuleName() + this.element.id;
	        {
	            return window.localStorage.getItem(eleId);
	        }
	    };
	    /**
	     * Adding unload event to persist data when enable persistence true
	     */
	    Component.prototype.attachUnloadEvent = function () {
	        this.handleUnload = this.handleUnload.bind(this);
	        window.addEventListener('unload', this.handleUnload);
	    };
	    /**
	     * Handling unload event to persist data when enable persistence true
	     */
	    Component.prototype.handleUnload = function () {
	        this.setPersistData();
	    };
	    /**
	     * Removing unload event to persist data when enable persistence true
	     */
	    Component.prototype.detachUnloadEvent = function () {
	        window.removeEventListener('unload', this.handleUnload);
	    };
	    /**
	     * Appends the control within the given HTML element
	     *
	     * @param {string | HTMLElement} selector - Target element where control needs to be appended
	     * @returns {void} ?
	     */
	    Component.prototype.appendTo = function (selector) {
	        if (!isNullOrUndefined(selector) && typeof (selector) === 'string') {
	            this.element = select(selector, document);
	        }
	        else if (!isNullOrUndefined(selector)) {
	            this.element = selector;
	        }
	        if (!isNullOrUndefined(this.element)) {
	            var moduleClass = 'e-' + this.getModuleName().toLowerCase();
	            addClass([this.element], ['e-control', moduleClass]);
	            this.isProtectedOnChange = false;
	            if (this.needsID && !this.element.id) {
	                this.element.id = this.getUniqueID(this.getModuleName());
	            }
	            if (this.enablePersistence) {
	                this.mergePersistData();
	                this.attachUnloadEvent();
	            }
	            var inst = getValue('ej2_instances', this.element);
	            if (!inst || inst.indexOf(this) === -1) {
	                _super.prototype.addInstance.call(this);
	            }
	            this.preRender();
	            this.injectModules();
	            // Checked weather cases are valid or not. If control leads to more than five counts  
	            if (!isvalid && !isBannerAdded) {
	                createLicenseOverlay();
	                isBannerAdded = true;
	            }
	            this.render();
	            if (!this.mount) {
	                this.trigger('created');
	            }
	            else {
	                this.accessMount();
	            }
	        }
	    };
	    /**
	     * It is used to process the post rendering functionalities to a component.
	     *
	     * @param {Node} wrapperElement ?
	     * @returns {void} ?
	     */
	    Component.prototype.renderComplete = function (wrapperElement) {
	        this.isRendered = true;
	    };
	    /**
	     * When invoked, applies the pending property changes immediately to the component.
	     *
	     * @returns {void} ?
	     */
	    Component.prototype.dataBind = function () {
	        this.injectModules();
	        _super.prototype.dataBind.call(this);
	    };
	    /**
	     * Attach one or more  event handler to the current component context.
	     * It is used for internal handling event internally within the component only.
	     *
	     * @param {BoundOptions[]| string} event - It is  optional type either to  Set the collection of event list or the eventName.
	     * @param {Function} handler - optional parameter Specifies the handler to run when the event occurs
	     * @param {Object} context - optional parameter Specifies the context to be bind in the handler.
	     * @returns {void} ?
	     * @private
	     */
	    Component.prototype.on = function (event, handler, context) {
	        if (typeof event === 'string') {
	            this.localObserver.on(event, handler, context);
	        }
	        else {
	            for (var _i = 0, event_1 = event; _i < event_1.length; _i++) {
	                var arg = event_1[_i];
	                this.localObserver.on(arg.event, arg.handler, arg.context);
	            }
	        }
	    };
	    /**
	     * To remove one or more event handler that has been attached with the on() method.
	     *
	     * @param {BoundOptions[]| string} event - It is  optional type either to  Set the collection of event list or the eventName.
	     * @param {Function} handler - optional parameter Specifies the function to run when the event occurs
	     * @returns {void} ?
	     * @private
	     */
	    Component.prototype.off = function (event, handler) {
	        if (typeof event === 'string') {
	            this.localObserver.off(event, handler);
	        }
	        else {
	            for (var _i = 0, event_2 = event; _i < event_2.length; _i++) {
	                var arg = event_2[_i];
	                this.localObserver.off(arg.event, arg.handler);
	            }
	        }
	    };
	    /**
	     * To notify the handlers in the specified event.
	     *
	     * @param {string} property - Specifies the event to be notify.
	     * @param {Object} argument - Additional parameters to pass while calling the handler.
	     * @returns {void} ?
	     * @private
	     */
	    Component.prototype.notify = function (property, argument) {
	        if (this.isDestroyed !== true) {
	            this.localObserver.notify(property, argument);
	        }
	    };
	    /**
	     * Get injected modules
	     *
	     * @returns {Function} ?
	     * @private
	     */
	    Component.prototype.getInjectedModules = function () {
	        return this.injectedModules;
	    };
	    /**
	     * Dynamically injects the required modules to the component.
	     *
	     * @param {Function} moduleList ?
	     * @returns {void} ?
	     */
	    Component.Inject = function () {
	        var moduleList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            moduleList[_i] = arguments[_i];
	        }
	        if (!this.prototype.injectedModules) {
	            this.prototype.injectedModules = [];
	        }
	        for (var i = 0; i < moduleList.length; i++) {
	            if (this.prototype.injectedModules.indexOf(moduleList[parseInt(i.toString(), 10)]) === -1) {
	                this.prototype.injectedModules.push(moduleList[parseInt(i.toString(), 10)]);
	            }
	        }
	    };
	    /**
	     * This is a instance method to create an element.
	     *
	     * @param {string} tagName ?
	     * @param {ElementProperties} prop ?
	     * @param {boolean} isVDOM ?
	     * @returns {any} ?
	     * @private
	     */
	    // eslint-disable-next-line
	    Component.prototype.createElement = function (tagName, prop, isVDOM) {
	        return createElement(tagName, prop);
	    };
	    /**
	     *
	     * @param {Function} handler - handler to be triggered after state Updated.
	     * @param {any} argument - Arguments to be passed to caller.
	     * @returns {void} .
	     * @private
	     */
	    // eslint-disable-next-line
	    Component.prototype.triggerStateChange = function (handler, argument) {
	        if (this.isReactHybrid) {
	            // eslint-disable-next-line
	            this.setState();
	            this.currentContext = { calls: handler, args: argument };
	        }
	    };
	    // tslint: enable: no-any
	    Component.prototype.injectModules = function () {
	        if (this.injectedModules && this.injectedModules.length) {
	            this.moduleLoader.inject(this.requiredModules(), this.injectedModules);
	        }
	    };
	    Component.prototype.detectFunction = function (args) {
	        var prop = Object.keys(args);
	        if (prop.length) {
	            this[prop[0]] = args[prop[0]];
	        }
	    };
	    Component.prototype.mergePersistData = function () {
	        var data;
	        {
	            data = window.localStorage.getItem(this.getModuleName() + this.element.id);
	        }
	        if (!(isNullOrUndefined(data) || (data === ''))) {
	            this.setProperties(JSON.parse(data), true);
	        }
	    };
	    Component.prototype.setPersistData = function () {
	        if (!this.isDestroyed) {
	            {
	                window.localStorage.setItem(this.getModuleName() + this.element.id, this.getPersistData());
	            }
	        }
	    };
	    // eslint-disable-next-line
	    Component.prototype.renderReactTemplates = function (callback) {
	        if (!isNullOrUndefined(callback)) {
	            callback();
	        }
	    };
	    // eslint-disable-next-line
	    Component.prototype.clearTemplate = function (templateName, index) {
	        //No Code
	    };
	    Component.prototype.getUniqueID = function (definedName) {
	        if (this.isHistoryChanged()) {
	            componentCount = 0;
	        }
	        lastPageID = this.pageID(location.href);
	        lastHistoryLen = history.length;
	        return definedName + '_' + lastPageID + '_' + componentCount++;
	    };
	    Component.prototype.pageID = function (url) {
	        var hash = 0;
	        if (url.length === 0) {
	            return hash;
	        }
	        for (var i = 0; i < url.length; i++) {
	            var char = url.charCodeAt(i);
	            hash = ((hash << 5) - hash) + char;
	            hash = hash & hash; // Convert to 32bit integer
	        }
	        return Math.abs(hash);
	    };
	    Component.prototype.isHistoryChanged = function () {
	        return lastPageID !== this.pageID(location.href) || lastHistoryLen !== history.length;
	    };
	    Component.prototype.addOnPersist = function (options) {
	        var _this = this;
	        var persistObj = {};
	        for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {
	            var key = options_1[_i];
	            var objValue = void 0;
	            // eslint-disable-next-line
	            objValue = getValue(key, this);
	            if (!isUndefined(objValue)) {
	                setValue(key, this.getActualProperties(objValue), persistObj);
	            }
	        }
	        return JSON.stringify(persistObj, function (key, value) {
	            return _this.getActualProperties(value);
	        });
	    };
	    Component.prototype.getActualProperties = function (obj) {
	        if (obj instanceof ChildProperty) {
	            return getValue('properties', obj);
	        }
	        else {
	            return obj;
	        }
	    };
	    Component.prototype.ignoreOnPersist = function (options) {
	        return JSON.stringify(this.iterateJsonProperties(this.properties, options));
	    };
	    Component.prototype.iterateJsonProperties = function (obj, ignoreList) {
	        var newObj = {};
	        var _loop_1 = function (key) {
	            if (ignoreList.indexOf(key) === -1) {
	                // eslint-disable-next-line
	                var value = obj[key];
	                if (typeof value === 'object' && !(value instanceof Array)) {
	                    var newList = ignoreList.filter(function (str) {
	                        var regExp = RegExp;
	                        return new regExp(key + '.').test(str);
	                    }).map(function (str) {
	                        return str.replace(key + '.', '');
	                    });
	                    newObj["" + key] = this_1.iterateJsonProperties(this_1.getActualProperties(value), newList);
	                }
	                else {
	                    newObj["" + key] = value;
	                }
	            }
	        };
	        var this_1 = this;
	        for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
	            var key = _a[_i];
	            _loop_1(key);
	        }
	        return newObj;
	    };
	    __decorate$g([
	        Property(false)
	    ], Component.prototype, "enablePersistence", void 0);
	    __decorate$g([
	        Property()
	    ], Component.prototype, "enableRtl", void 0);
	    __decorate$g([
	        Property()
	    ], Component.prototype, "locale", void 0);
	    Component = __decorate$g([
	        NotifyPropertyChanges
	    ], Component);
	    return Component;
	}(Base));
	//Function handling for page navigation detection
	/* istanbul ignore next */
	(function () {
	    if (typeof window !== 'undefined') {
	        window.addEventListener('popstate', 
	        /* istanbul ignore next */
	        function () {
	            componentCount = 0;
	        });
	    }
	})();

	var __extends$L = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var defaultPosition = { left: 0, top: 0, bottom: 0, right: 0 };
	var isDraggedObject = { isDragged: false };
	/**
	 * Specifies the position coordinates
	 */
	var Position = /** @class */ (function (_super) {
	    __extends$L(Position, _super);
	    function Position() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$f([
	        Property(0)
	    ], Position.prototype, "left", void 0);
	    __decorate$f([
	        Property(0)
	    ], Position.prototype, "top", void 0);
	    return Position;
	}(ChildProperty));
	/**
	 * Draggable Module provides support to enable draggable functionality in Dom Elements.
	 * ```html
	 * <div id='drag'>Draggable</div>
	 * <script>
	 * var ele = document.getElementById('drag');
	 * var drag:Draggable = new Draggable(ele,{
	 *     clone:false,
	 *     drag: function(e) {
	 *      //drag handler code.
	 *      },
	 *     handle:'.class'
	 * });
	 * </script>
	 * ```
	 */
	/** @class */ ((function (_super) {
	    __extends$L(Draggable, _super);
	    function Draggable(element, options) {
	        var _this = _super.call(this, options, element) || this;
	        _this.dragLimit = Draggable_1.getDefaultPosition();
	        _this.borderWidth = Draggable_1.getDefaultPosition();
	        _this.padding = Draggable_1.getDefaultPosition();
	        _this.diffX = 0;
	        _this.prevLeft = 0;
	        _this.prevTop = 0;
	        _this.dragProcessStarted = false;
	        _this.eleTop = 0;
	        /* eslint-disable @typescript-eslint/no-explicit-any */
	        _this.tapHoldTimer = 0;
	        _this.externalInitialize = false;
	        _this.diffY = 0;
	        _this.parentScrollX = 0;
	        _this.parentScrollY = 0;
	        _this.droppables = {};
	        _this.bind();
	        return _this;
	    }
	    Draggable_1 = Draggable;
	    Draggable.prototype.bind = function () {
	        this.toggleEvents();
	        if (Browser.isIE) {
	            addClass([this.element], 'e-block-touch');
	        }
	        this.droppables[this.scope] = {};
	    };
	    Draggable.getDefaultPosition = function () {
	        return extend({}, defaultPosition);
	    };
	    Draggable.prototype.toggleEvents = function (isUnWire) {
	        var ele;
	        if (!isUndefined(this.handle)) {
	            ele = select(this.handle, this.element);
	        }
	        var handler = (this.enableTapHold && Browser.isDevice && Browser.isTouch) ? this.mobileInitialize : this.initialize;
	        if (isUnWire) {
	            EventHandler.remove(ele || this.element, Browser.isSafari() ? 'touchstart' : Browser.touchStartEvent, handler);
	        }
	        else {
	            EventHandler.add(ele || this.element, Browser.isSafari() ? 'touchstart' : Browser.touchStartEvent, handler, this);
	        }
	    };
	    /* istanbul ignore next */
	    Draggable.prototype.mobileInitialize = function (evt) {
	        var _this = this;
	        var target = evt.currentTarget;
	        this.tapHoldTimer = setTimeout(function () {
	            _this.externalInitialize = true;
	            _this.removeTapholdTimer();
	            _this.initialize(evt, target);
	        }, this.tapHoldThreshold);
	        EventHandler.add(document, Browser.isSafari() ? 'touchmove' : Browser.touchMoveEvent, this.removeTapholdTimer, this);
	        EventHandler.add(document, Browser.isSafari() ? 'touchend' : Browser.touchEndEvent, this.removeTapholdTimer, this);
	    };
	    /* istanbul ignore next */
	    Draggable.prototype.removeTapholdTimer = function () {
	        clearTimeout(this.tapHoldTimer);
	        EventHandler.remove(document, Browser.isSafari() ? 'touchmove' : Browser.touchMoveEvent, this.removeTapholdTimer);
	        EventHandler.remove(document, Browser.isSafari() ? 'touchend' : Browser.touchEndEvent, this.removeTapholdTimer);
	    };
	    /* istanbul ignore next */
	    Draggable.prototype.getScrollableParent = function (element, axis) {
	        var scroll = { 'vertical': 'scrollHeight', 'horizontal': 'scrollWidth' };
	        var client = { 'vertical': 'clientHeight', 'horizontal': 'clientWidth' };
	        if (isNullOrUndefined(element)) {
	            return null;
	        }
	        if (element[scroll["" + axis]] > element[client["" + axis]]) {
	            if (axis === 'vertical' ? element.scrollTop > 0 : element.scrollLeft > 0) {
	                if (axis === 'vertical') {
	                    this.parentScrollY = this.parentScrollY +
	                        (this.parentScrollY === 0 ? element.scrollTop : element.scrollTop - this.parentScrollY);
	                    this.tempScrollHeight = element.scrollHeight;
	                }
	                else {
	                    this.parentScrollX = this.parentScrollX +
	                        (this.parentScrollX === 0 ? element.scrollLeft : element.scrollLeft - this.parentScrollX);
	                    this.tempScrollWidth = element.scrollWidth;
	                }
	                if (!isNullOrUndefined(element)) {
	                    return this.getScrollableParent(element.parentNode, axis);
	                }
	                else {
	                    return element;
	                }
	            }
	            else {
	                return this.getScrollableParent(element.parentNode, axis);
	            }
	        }
	        else {
	            return this.getScrollableParent(element.parentNode, axis);
	        }
	    };
	    Draggable.prototype.getScrollableValues = function () {
	        this.parentScrollX = 0;
	        this.parentScrollY = 0;
	        this.element.classList.contains('e-dialog') && this.element.classList.contains('e-dlg-modal');
	        this.getScrollableParent(this.element.parentNode, 'vertical');
	        this.getScrollableParent(this.element.parentNode, 'horizontal');
	    };
	    Draggable.prototype.initialize = function (evt, curTarget) {
	        this.currentStateTarget = evt.target;
	        if (this.isDragStarted()) {
	            return;
	        }
	        else {
	            this.isDragStarted(true);
	            this.externalInitialize = false;
	        }
	        this.target = (evt.currentTarget || curTarget);
	        this.dragProcessStarted = false;
	        if (this.abort) {
	            /* tslint:disable no-any */
	            var abortSelectors = this.abort;
	            if (typeof abortSelectors === 'string') {
	                abortSelectors = [abortSelectors];
	            }
	            for (var i = 0; i < abortSelectors.length; i++) {
	                if (!isNullOrUndefined(closest(evt.target, abortSelectors[parseInt(i.toString(), 10)]))) {
	                    /* istanbul ignore next */
	                    if (this.isDragStarted()) {
	                        this.isDragStarted(true);
	                    }
	                    return;
	                }
	            }
	        }
	        if (this.preventDefault && !isUndefined(evt.changedTouches) && evt.type !== 'touchstart') {
	            evt.preventDefault();
	        }
	        this.element.setAttribute('aria-grabbed', 'true');
	        var intCoord = this.getCoordinates(evt);
	        this.initialPosition = { x: intCoord.pageX, y: intCoord.pageY };
	        if (!this.clone) {
	            var pos = this.element.getBoundingClientRect();
	            this.getScrollableValues();
	            if (evt.clientX === evt.pageX) {
	                this.parentScrollX = 0;
	            }
	            if (evt.clientY === evt.pageY) {
	                this.parentScrollY = 0;
	            }
	            this.relativeXPosition = intCoord.pageX - (pos.left + this.parentScrollX);
	            this.relativeYPosition = intCoord.pageY - (pos.top + this.parentScrollY);
	        }
	        if (this.externalInitialize) {
	            this.intDragStart(evt);
	        }
	        else {
	            EventHandler.add(document, Browser.isSafari() ? 'touchmove' : Browser.touchMoveEvent, this.intDragStart, this);
	            EventHandler.add(document, Browser.isSafari() ? 'touchend' : Browser.touchEndEvent, this.intDestroy, this);
	        }
	        this.toggleEvents(true);
	        if (evt.type !== 'touchstart' && this.isPreventSelect) {
	            document.body.classList.add('e-prevent-select');
	        }
	        this.externalInitialize = false;
	        EventHandler.trigger(document.documentElement, Browser.isSafari() ? 'touchstart' : Browser.touchStartEvent, evt);
	    };
	    Draggable.prototype.intDragStart = function (evt) {
	        this.removeTapholdTimer();
	        var isChangeTouch = !isUndefined(evt.changedTouches);
	        if (isChangeTouch && (evt.changedTouches.length !== 1)) {
	            return;
	        }
	        var intCordinate = this.getCoordinates(evt);
	        var pos;
	        var styleProp = getComputedStyle(this.element);
	        this.margin = {
	            left: parseInt(styleProp.marginLeft, 10),
	            top: parseInt(styleProp.marginTop, 10),
	            right: parseInt(styleProp.marginRight, 10),
	            bottom: parseInt(styleProp.marginBottom, 10)
	        };
	        var element = this.element;
	        if (this.clone && this.dragTarget) {
	            var intClosest = closest(evt.target, this.dragTarget);
	            if (!isNullOrUndefined(intClosest)) {
	                element = intClosest;
	            }
	        }
	        /* istanbul ignore next */
	        if (this.isReplaceDragEle) {
	            element = this.currentStateCheck(evt.target, element);
	        }
	        this.offset = this.calculateParentPosition(element);
	        this.position = this.getMousePosition(evt, this.isDragScroll);
	        var x = this.initialPosition.x - intCordinate.pageX;
	        var y = this.initialPosition.y - intCordinate.pageY;
	        var distance = Math.sqrt((x * x) + (y * y));
	        if ((distance >= this.distance || this.externalInitialize)) {
	            var ele = this.getHelperElement(evt);
	            if (!ele || isNullOrUndefined(ele)) {
	                return;
	            }
	            if (isChangeTouch) {
	                evt.preventDefault();
	            }
	            var dragTargetElement = this.helperElement = ele;
	            this.parentClientRect = this.calculateParentPosition(dragTargetElement.offsetParent);
	            if (this.dragStart) {
	                var curTarget = this.getProperTargetElement(evt);
	                var args = {
	                    event: evt,
	                    element: element,
	                    target: curTarget,
	                    bindEvents: null,
	                    dragElement: dragTargetElement
	                };
	                this.trigger('dragStart', args);
	            }
	            if (this.dragArea) {
	                this.setDragArea();
	            }
	            else {
	                this.dragLimit = { left: 0, right: 0, bottom: 0, top: 0 };
	                this.borderWidth = { top: 0, left: 0 };
	            }
	            pos = { left: this.position.left - this.parentClientRect.left, top: this.position.top - this.parentClientRect.top };
	            if (this.clone && !this.enableTailMode) {
	                this.diffX = this.position.left - this.offset.left;
	                this.diffY = this.position.top - this.offset.top;
	            }
	            this.getScrollableValues();
	            // when drag element has margin-top
	            var styles = getComputedStyle(element);
	            var marginTop = parseFloat(styles.marginTop);
	            /* istanbul ignore next */
	            if (this.clone && marginTop !== 0) {
	                pos.top += marginTop;
	            }
	            this.eleTop = !isNaN(parseFloat(styles.top)) ? parseFloat(styles.top) - this.offset.top : 0;
	            /* istanbul ignore next */
	            // if (this.eleTop > 0) {
	            //     pos.top += this.eleTop;
	            // }
	            if (this.enableScrollHandler && !this.clone) {
	                pos.top -= this.parentScrollY;
	                pos.left -= this.parentScrollX;
	            }
	            var posValue = this.getProcessedPositionValue({
	                top: (pos.top - this.diffY) + 'px',
	                left: (pos.left - this.diffX) + 'px'
	            });
	            if (this.dragArea && typeof this.dragArea !== 'string' && this.dragArea.classList.contains('e-kanban-content') && this.dragArea.style.position === 'relative') {
	                pos.top += this.dragArea.scrollTop;
	            }
	            this.dragElePosition = { top: pos.top, left: pos.left };
	            setStyleAttribute(dragTargetElement, this.getDragPosition({ position: 'absolute', left: posValue.left, top: posValue.top }));
	            EventHandler.remove(document, Browser.isSafari() ? 'touchmove' : Browser.touchMoveEvent, this.intDragStart);
	            EventHandler.remove(document, Browser.isSafari() ? 'touchend' : Browser.touchEndEvent, this.intDestroy);
	            {
	                this.bindDragEvents(dragTargetElement);
	            }
	        }
	    };
	    Draggable.prototype.bindDragEvents = function (dragTargetElement) {
	        if (isVisible(dragTargetElement)) {
	            EventHandler.add(document, Browser.isSafari() ? 'touchmove' : Browser.touchMoveEvent, this.intDrag, this);
	            EventHandler.add(document, Browser.isSafari() ? 'touchend' : Browser.touchEndEvent, this.intDragStop, this);
	            this.setGlobalDroppables(false, this.element, dragTargetElement);
	        }
	        else {
	            this.toggleEvents();
	            document.body.classList.remove('e-prevent-select');
	        }
	    };
	    Draggable.prototype.elementInViewport = function (el) {
	        this.top = el.offsetTop;
	        this.left = el.offsetLeft;
	        this.width = el.offsetWidth;
	        this.height = el.offsetHeight;
	        while (el.offsetParent) {
	            el = el.offsetParent;
	            this.top += el.offsetTop;
	            this.left += el.offsetLeft;
	        }
	        return (this.top >= window.pageYOffset &&
	            this.left >= window.pageXOffset &&
	            (this.top + this.height) <= (window.pageYOffset + window.innerHeight) &&
	            (this.left + this.width) <= (window.pageXOffset + window.innerWidth));
	    };
	    Draggable.prototype.getProcessedPositionValue = function (value) {
	        if (this.queryPositionInfo) {
	            return this.queryPositionInfo(value);
	        }
	        return value;
	    };
	    Draggable.prototype.calculateParentPosition = function (ele) {
	        if (isNullOrUndefined(ele)) {
	            return { left: 0, top: 0 };
	        }
	        var rect = ele.getBoundingClientRect();
	        var style = getComputedStyle(ele);
	        return {
	            left: (rect.left + window.pageXOffset) - parseInt(style.marginLeft, 10),
	            top: (rect.top + window.pageYOffset) - parseInt(style.marginTop, 10)
	        };
	    };
	    // tslint:disable-next-line:max-func-body-length
	    Draggable.prototype.intDrag = function (evt) {
	        if (!isUndefined(evt.changedTouches) && (evt.changedTouches.length !== 1)) {
	            return;
	        }
	        if (this.clone && evt.changedTouches && Browser.isDevice && Browser.isTouch) {
	            evt.preventDefault();
	        }
	        var left;
	        var top;
	        this.position = this.getMousePosition(evt, this.isDragScroll);
	        var docHeight = this.getDocumentWidthHeight('Height');
	        if (docHeight < this.position.top) {
	            this.position.top = docHeight;
	        }
	        var docWidth = this.getDocumentWidthHeight('Width');
	        if (docWidth < this.position.left) {
	            this.position.left = docWidth;
	        }
	        if (this.drag) {
	            var curTarget = this.getProperTargetElement(evt);
	            this.trigger('drag', { event: evt, element: this.element, target: curTarget });
	        }
	        var eleObj = this.checkTargetElement(evt);
	        if (eleObj.target && eleObj.instance) {
	            /* tslint:disable no-any */
	            var flag = true;
	            if (this.hoverObject) {
	                if (this.hoverObject.instance !== eleObj.instance) {
	                    this.triggerOutFunction(evt, eleObj);
	                }
	                else {
	                    flag = false;
	                }
	            }
	            if (flag) {
	                eleObj.instance.dragData[this.scope] = this.droppables[this.scope];
	                eleObj.instance.intOver(evt, eleObj.target);
	                this.hoverObject = eleObj;
	            }
	        }
	        else if (this.hoverObject) {
	            this.triggerOutFunction(evt, eleObj);
	        }
	        var helperElement = this.droppables[this.scope].helper;
	        this.parentClientRect = this.calculateParentPosition(this.helperElement.offsetParent);
	        var tLeft = this.parentClientRect.left;
	        var tTop = this.parentClientRect.top;
	        var intCoord = this.getCoordinates(evt);
	        var pagex = intCoord.pageX;
	        var pagey = intCoord.pageY;
	        var dLeft = this.position.left - this.diffX;
	        var dTop = this.position.top - this.diffY;
	        var styles = getComputedStyle(helperElement);
	        if (this.dragArea) {
	            if (this.enableAutoScroll) {
	                this.setDragArea();
	            }
	            if (this.pageX !== pagex || this.skipDistanceCheck) {
	                var helperWidth = helperElement.offsetWidth + (parseFloat(styles.marginLeft)
	                    + parseFloat(styles.marginRight));
	                if (this.dragLimit.left > dLeft && dLeft > 0) {
	                    left = this.dragLimit.left;
	                }
	                else if (this.dragLimit.right + window.pageXOffset < dLeft + helperWidth && dLeft > 0) {
	                    left = dLeft - (dLeft - this.dragLimit.right) + window.pageXOffset - helperWidth;
	                }
	                else {
	                    left = dLeft < 0 ? this.dragLimit.left : dLeft;
	                }
	            }
	            if (this.pageY !== pagey || this.skipDistanceCheck) {
	                var helperHeight = helperElement.offsetHeight + (parseFloat(styles.marginTop)
	                    + parseFloat(styles.marginBottom));
	                if (this.dragLimit.top > dTop && dTop > 0) {
	                    top = this.dragLimit.top;
	                }
	                else if (this.dragLimit.bottom + window.pageYOffset < dTop + helperHeight && dTop > 0) {
	                    top = dTop - (dTop - this.dragLimit.bottom) + window.pageYOffset - helperHeight;
	                }
	                else {
	                    top = dTop < 0 ? this.dragLimit.top : dTop;
	                }
	            }
	        }
	        else {
	            left = dLeft;
	            top = dTop;
	        }
	        var iTop = tTop + this.borderWidth.top;
	        var iLeft = tLeft + this.borderWidth.left;
	        if (this.dragProcessStarted) {
	            if (isNullOrUndefined(top)) {
	                top = this.prevTop;
	            }
	            if (isNullOrUndefined(left)) {
	                left = this.prevLeft;
	            }
	        }
	        var draEleTop;
	        var draEleLeft;
	        if (this.helperElement.classList.contains('e-treeview')) {
	            if (this.dragArea) {
	                this.dragLimit.top = this.clone ? this.dragLimit.top : 0;
	                draEleTop = (top - iTop) < 0 ? this.dragLimit.top : (top - this.borderWidth.top);
	                draEleLeft = (left - iLeft) < 0 ? this.dragLimit.left : (left - this.borderWidth.left);
	            }
	            else {
	                draEleTop = top - this.borderWidth.top;
	                draEleLeft = left - this.borderWidth.left;
	            }
	        }
	        else {
	            if (this.dragArea) {
	                var isDialogEle = this.helperElement.classList.contains('e-dialog');
	                this.dragLimit.top = this.clone ? this.dragLimit.top : 0;
	                draEleTop = (top - iTop) < 0 ? this.dragLimit.top : (top - iTop);
	                draEleLeft = (left - iLeft) < 0 ? isDialogEle ? (left - (iLeft - this.borderWidth.left)) :
	                    this.dragElePosition.left : (left - iLeft);
	            }
	            else {
	                draEleTop = top - iTop;
	                draEleLeft = left - iLeft;
	            }
	        }
	        var marginTop = parseFloat(getComputedStyle(this.element).marginTop);
	        // when drag-element has margin-top
	        /* istanbul ignore next */
	        if (marginTop > 0) {
	            if (this.clone) {
	                draEleTop += marginTop;
	                if (dTop < 0) {
	                    if ((marginTop + dTop) >= 0) {
	                        draEleTop = marginTop + dTop;
	                    }
	                    else {
	                        draEleTop -= marginTop;
	                    }
	                }
	                if (this.dragArea) {
	                    draEleTop = (this.dragLimit.bottom < draEleTop) ? this.dragLimit.bottom : draEleTop;
	                }
	            }
	            if ((top - iTop) < 0) {
	                if (dTop + marginTop + (helperElement.offsetHeight - iTop) >= 0) {
	                    var tempDraEleTop = this.dragLimit.top + dTop - iTop;
	                    if ((tempDraEleTop + marginTop + iTop) < 0) {
	                        draEleTop -= marginTop + iTop;
	                    }
	                    else {
	                        draEleTop = tempDraEleTop;
	                    }
	                }
	                else {
	                    draEleTop -= marginTop + iTop;
	                }
	            }
	        }
	        if (this.dragArea && this.helperElement.classList.contains('e-treeview')) {
	            var helperHeight = helperElement.offsetHeight + (parseFloat(styles.marginTop)
	                + parseFloat(styles.marginBottom));
	            draEleTop = (draEleTop + helperHeight) > this.dragLimit.bottom ? (this.dragLimit.bottom - helperHeight) : draEleTop;
	        }
	        /* istanbul ignore next */
	        // if(this.eleTop > 0) {
	        //      draEleTop += this.eleTop;
	        // }
	        if (this.enableScrollHandler && !this.clone) {
	            draEleTop -= this.parentScrollY;
	            draEleLeft -= this.parentScrollX;
	        }
	        if (this.dragArea && typeof this.dragArea !== 'string' && this.dragArea.classList.contains('e-kanban-content') && this.dragArea.style.position === 'relative') {
	            draEleTop += this.dragArea.scrollTop;
	        }
	        var dragValue = this.getProcessedPositionValue({ top: draEleTop + 'px', left: draEleLeft + 'px' });
	        setStyleAttribute(helperElement, this.getDragPosition(dragValue));
	        if (!this.elementInViewport(helperElement) && this.enableAutoScroll && !this.helperElement.classList.contains('e-treeview')) {
	            this.helperElement.scrollIntoView();
	        }
	        var elements = document.querySelectorAll(':hover');
	        if (this.enableAutoScroll && this.helperElement.classList.contains('e-treeview')) {
	            if (elements.length === 0) {
	                elements = this.getPathElements(evt);
	            }
	            /* tslint:disable no-any */
	            var scrollParent = this.getScrollParent(elements, false);
	            if (this.elementInViewport(this.helperElement)) {
	                this.getScrollPosition(scrollParent, draEleTop);
	            }
	            else if (!this.elementInViewport(this.helperElement)) {
	                elements = [].slice.call(document.querySelectorAll(':hover'));
	                if (elements.length === 0) {
	                    elements = this.getPathElements(evt);
	                }
	                scrollParent = this.getScrollParent(elements, true);
	                this.getScrollPosition(scrollParent, draEleTop);
	            }
	        }
	        this.dragProcessStarted = true;
	        this.prevLeft = left;
	        this.prevTop = top;
	        this.position.left = left;
	        this.position.top = top;
	        this.pageX = pagex;
	        this.pageY = pagey;
	    };
	    /* tslint:disable no-any */
	    Draggable.prototype.getScrollParent = function (node, reverse) {
	        /* tslint:disable no-any */
	        var nodeEl = reverse ? node.reverse() : node;
	        var hasScroll;
	        for (var i = nodeEl.length - 1; i >= 0; i--) {
	            hasScroll = window.getComputedStyle(nodeEl[parseInt(i.toString(), 10)])['overflow-y'];
	            if ((hasScroll === 'auto' || hasScroll === 'scroll')
	                && nodeEl[parseInt(i.toString(), 10)].scrollHeight > nodeEl[parseInt(i.toString(), 10)].clientHeight) {
	                return nodeEl[parseInt(i.toString(), 10)];
	            }
	        }
	        hasScroll = window.getComputedStyle(document.scrollingElement)['overflow-y'];
	        if (hasScroll === 'visible') {
	            document.scrollingElement.style.overflow = 'auto';
	            return document.scrollingElement;
	        }
	    };
	    Draggable.prototype.getScrollPosition = function (nodeEle, draEleTop) {
	        if (nodeEle && nodeEle === document.scrollingElement) {
	            if ((nodeEle.clientHeight + document.scrollingElement.scrollTop - this.helperElement.clientHeight) < draEleTop
	                && nodeEle.getBoundingClientRect().height + this.parentClientRect.top > draEleTop) {
	                nodeEle.scrollTop += this.helperElement.clientHeight;
	            }
	            else if (nodeEle.scrollTop > draEleTop - this.helperElement.clientHeight) {
	                nodeEle.scrollTop -= this.helperElement.clientHeight;
	            }
	        }
	        else if (nodeEle && nodeEle !== document.scrollingElement) {
	            if ((nodeEle.clientHeight + nodeEle.getBoundingClientRect().top - this.helperElement.clientHeight + document.scrollingElement.scrollTop) < draEleTop) {
	                nodeEle.scrollTop += this.helperElement.clientHeight;
	            }
	            else if (nodeEle.getBoundingClientRect().top > (draEleTop - this.helperElement.clientHeight - document.scrollingElement.scrollTop)) {
	                nodeEle.scrollTop -= this.helperElement.clientHeight;
	            }
	        }
	    };
	    Draggable.prototype.getPathElements = function (evt) {
	        var elementTop = evt.clientX > 0 ? evt.clientX : 0;
	        var elementLeft = evt.clientY > 0 ? evt.clientY : 0;
	        return document.elementsFromPoint(elementTop, elementLeft);
	    };
	    Draggable.prototype.triggerOutFunction = function (evt, eleObj) {
	        this.hoverObject.instance.intOut(evt, eleObj.target);
	        this.hoverObject.instance.dragData[this.scope] = null;
	        this.hoverObject = null;
	    };
	    Draggable.prototype.getDragPosition = function (dragValue) {
	        var temp = extend({}, dragValue);
	        if (this.axis) {
	            if (this.axis === 'x') {
	                delete temp.top;
	            }
	            else if (this.axis === 'y') {
	                delete temp.left;
	            }
	        }
	        return temp;
	    };
	    Draggable.prototype.getDocumentWidthHeight = function (str) {
	        var docBody = document.body;
	        var docEle = document.documentElement;
	        var returnValue = Math.max(docBody['scroll' + str], docEle['scroll' + str], docBody['offset' + str], docEle['offset' + str], docEle['client' + str]);
	        return returnValue;
	    };
	    Draggable.prototype.intDragStop = function (evt) {
	        this.dragProcessStarted = false;
	        if (!isUndefined(evt.changedTouches) && (evt.changedTouches.length !== 1)) {
	            return;
	        }
	        var type = ['touchend', 'pointerup', 'mouseup'];
	        if (type.indexOf(evt.type) !== -1) {
	            if (this.dragStop) {
	                var curTarget = this.getProperTargetElement(evt);
	                this.trigger('dragStop', { event: evt, element: this.element, target: curTarget, helper: this.helperElement });
	            }
	            this.intDestroy(evt);
	        }
	        else {
	            this.element.setAttribute('aria-grabbed', 'false');
	        }
	        var eleObj = this.checkTargetElement(evt);
	        if (eleObj.target && eleObj.instance) {
	            eleObj.instance.dragStopCalled = true;
	            eleObj.instance.dragData[this.scope] = this.droppables[this.scope];
	            eleObj.instance.intDrop(evt, eleObj.target);
	        }
	        this.setGlobalDroppables(true);
	        document.body.classList.remove('e-prevent-select');
	    };
	    /**
	     * @private
	     */
	    Draggable.prototype.intDestroy = function (evt) {
	        this.dragProcessStarted = false;
	        this.toggleEvents();
	        document.body.classList.remove('e-prevent-select');
	        this.element.setAttribute('aria-grabbed', 'false');
	        EventHandler.remove(document, Browser.isSafari() ? 'touchmove' : Browser.touchMoveEvent, this.intDragStart);
	        EventHandler.remove(document, Browser.isSafari() ? 'touchend' : Browser.touchEndEvent, this.intDragStop);
	        EventHandler.remove(document, Browser.isSafari() ? 'touchend' : Browser.touchEndEvent, this.intDestroy);
	        EventHandler.remove(document, Browser.isSafari() ? 'touchmove' : Browser.touchMoveEvent, this.intDrag);
	        if (this.isDragStarted()) {
	            this.isDragStarted(true);
	        }
	    };
	    // triggers when property changed
	    Draggable.prototype.onPropertyChanged = function (newProp, oldProp) {
	        //No Code to handle
	    };
	    Draggable.prototype.getModuleName = function () {
	        return 'draggable';
	    };
	    Draggable.prototype.isDragStarted = function (change) {
	        if (change) {
	            isDraggedObject.isDragged = !isDraggedObject.isDragged;
	        }
	        return isDraggedObject.isDragged;
	    };
	    Draggable.prototype.setDragArea = function () {
	        var eleWidthBound;
	        var eleHeightBound;
	        var top = 0;
	        var left = 0;
	        var ele;
	        var type = typeof this.dragArea;
	        if (type === 'string') {
	            ele = select(this.dragArea);
	        }
	        else {
	            ele = this.dragArea;
	        }
	        if (ele) {
	            var elementArea = ele.getBoundingClientRect();
	            eleWidthBound = ele.scrollWidth ? ele.scrollWidth : elementArea.right - elementArea.left;
	            eleHeightBound = ele.scrollHeight ? (this.dragArea && !isNullOrUndefined(this.helperElement) && this.helperElement.classList.contains('e-treeview')) ? ele.clientHeight : ele.scrollHeight : elementArea.bottom - elementArea.top;
	            var keys = ['Top', 'Left', 'Bottom', 'Right'];
	            var styles = getComputedStyle(ele);
	            for (var i = 0; i < keys.length; i++) {
	                var key = keys[parseInt(i.toString(), 10)];
	                var tborder = styles['border' + key + 'Width'];
	                var tpadding = styles['padding' + key];
	                var lowerKey = key.toLowerCase();
	                this.borderWidth["" + lowerKey] = isNaN(parseFloat(tborder)) ? 0 : parseFloat(tborder);
	                this.padding["" + lowerKey] = isNaN(parseFloat(tpadding)) ? 0 : parseFloat(tpadding);
	            }
	            if (this.dragArea && !isNullOrUndefined(this.helperElement) && this.helperElement.classList.contains('e-treeview')) {
	                top = elementArea.top + document.scrollingElement.scrollTop;
	            }
	            else {
	                top = elementArea.top;
	            }
	            left = elementArea.left;
	            this.dragLimit.left = left + this.borderWidth.left + this.padding.left;
	            this.dragLimit.top = ele.offsetTop + this.borderWidth.top + this.padding.top;
	            this.dragLimit.right = left + eleWidthBound - (this.borderWidth.right + this.padding.right);
	            this.dragLimit.bottom = top + eleHeightBound - (this.borderWidth.bottom + this.padding.bottom);
	        }
	    };
	    Draggable.prototype.getProperTargetElement = function (evt) {
	        var intCoord = this.getCoordinates(evt);
	        var ele;
	        var prevStyle = this.helperElement.style.pointerEvents || '';
	        var isPointer = evt.type.indexOf('pointer') !== -1 && Browser.info.name === 'safari' && parseInt(Browser.info.version) > 12;
	        if (compareElementParent(evt.target, this.helperElement) || evt.type.indexOf('touch') !== -1 || isPointer) {
	            this.helperElement.style.pointerEvents = 'none';
	            ele = document.elementFromPoint(intCoord.clientX, intCoord.clientY);
	            this.helperElement.style.pointerEvents = prevStyle;
	        }
	        else {
	            ele = evt.target;
	        }
	        return ele;
	    };
	    /* istanbul ignore next */
	    Draggable.prototype.currentStateCheck = function (ele, oldEle) {
	        var elem;
	        if (!isNullOrUndefined(this.currentStateTarget) && this.currentStateTarget !== ele) {
	            elem = this.currentStateTarget;
	        }
	        else {
	            elem = !isNullOrUndefined(oldEle) ? oldEle : ele;
	        }
	        return elem;
	    };
	    Draggable.prototype.getMousePosition = function (evt, isdragscroll) {
	        /* tslint:disable no-any */
	        var dragEle = evt.srcElement !== undefined ? evt.srcElement : evt.target;
	        var intCoord = this.getCoordinates(evt);
	        var pageX;
	        var pageY;
	        var isOffsetParent = isNullOrUndefined(dragEle.offsetParent);
	        /* istanbul ignore next */
	        if (isdragscroll) {
	            pageX = this.clone ? intCoord.pageX :
	                (intCoord.pageX + (isOffsetParent ? 0 : dragEle.offsetParent.scrollLeft)) - this.relativeXPosition;
	            pageY = this.clone ? intCoord.pageY :
	                (intCoord.pageY + (isOffsetParent ? 0 : dragEle.offsetParent.scrollTop)) - this.relativeYPosition;
	        }
	        else {
	            pageX = this.clone ? intCoord.pageX : (intCoord.pageX + window.pageXOffset) - this.relativeXPosition;
	            pageY = this.clone ? intCoord.pageY : (intCoord.pageY + window.pageYOffset) - this.relativeYPosition;
	        }
	        if (document.scrollingElement && (!isdragscroll && !this.clone)) {
	            var isVerticalScroll = document.scrollingElement.scrollHeight > 0 && document.scrollingElement.scrollHeight > document.scrollingElement.clientHeight && document.scrollingElement.scrollTop > 0;
	            var isHorrizontalScroll = document.scrollingElement.scrollWidth > 0 && document.scrollingElement.scrollWidth > document.scrollingElement.clientWidth && document.scrollingElement.scrollLeft > 0;
	            pageX = isHorrizontalScroll ? pageX - document.scrollingElement.scrollLeft : pageX;
	            pageY = isVerticalScroll ? pageY - document.scrollingElement.scrollTop : pageY;
	        }
	        return {
	            left: pageX - (this.margin.left + this.cursorAt.left),
	            top: pageY - (this.margin.top + this.cursorAt.top)
	        };
	    };
	    Draggable.prototype.getCoordinates = function (evt) {
	        if (evt.type.indexOf('touch') > -1) {
	            return evt.changedTouches[0];
	        }
	        return evt;
	    };
	    Draggable.prototype.getHelperElement = function (evt) {
	        var element;
	        if (this.clone) {
	            if (this.helper) {
	                element = this.helper({ sender: evt, element: this.target });
	            }
	            else {
	                element = createElement('div', { className: 'e-drag-helper e-block-touch', innerHTML: 'Draggable' });
	                document.body.appendChild(element);
	            }
	        }
	        else {
	            element = this.element;
	        }
	        return element;
	    };
	    Draggable.prototype.setGlobalDroppables = function (reset, drag, helper) {
	        this.droppables[this.scope] = reset ? null : {
	            draggable: drag,
	            helper: helper,
	            draggedElement: this.element
	        };
	    };
	    Draggable.prototype.checkTargetElement = function (evt) {
	        var target = this.getProperTargetElement(evt);
	        var dropIns = this.getDropInstance(target);
	        if (!dropIns && target && !isNullOrUndefined(target.parentNode)) {
	            var parent_1 = closest(target.parentNode, '.e-droppable') || target.parentElement;
	            if (parent_1) {
	                dropIns = this.getDropInstance(parent_1);
	            }
	        }
	        return { target: target, instance: dropIns };
	    };
	    Draggable.prototype.getDropInstance = function (ele) {
	        var name = 'getModuleName';
	        var drop;
	        var eleInst = ele && ele.ej2_instances;
	        if (eleInst) {
	            for (var _i = 0, eleInst_1 = eleInst; _i < eleInst_1.length; _i++) {
	                var inst = eleInst_1[_i];
	                if (inst["" + name]() === 'droppable') {
	                    drop = inst;
	                    break;
	                }
	            }
	        }
	        return drop;
	    };
	    Draggable.prototype.destroy = function () {
	        this.toggleEvents(true);
	        _super.prototype.destroy.call(this);
	    };
	    var Draggable_1;
	    __decorate$f([
	        Complex({}, Position)
	    ], Draggable.prototype, "cursorAt", void 0);
	    __decorate$f([
	        Property(true)
	    ], Draggable.prototype, "clone", void 0);
	    __decorate$f([
	        Property()
	    ], Draggable.prototype, "dragArea", void 0);
	    __decorate$f([
	        Property()
	    ], Draggable.prototype, "isDragScroll", void 0);
	    __decorate$f([
	        Property()
	    ], Draggable.prototype, "isReplaceDragEle", void 0);
	    __decorate$f([
	        Property(true)
	    ], Draggable.prototype, "isPreventSelect", void 0);
	    __decorate$f([
	        Event()
	    ], Draggable.prototype, "drag", void 0);
	    __decorate$f([
	        Event()
	    ], Draggable.prototype, "dragStart", void 0);
	    __decorate$f([
	        Event()
	    ], Draggable.prototype, "dragStop", void 0);
	    __decorate$f([
	        Property(1)
	    ], Draggable.prototype, "distance", void 0);
	    __decorate$f([
	        Property()
	    ], Draggable.prototype, "handle", void 0);
	    __decorate$f([
	        Property()
	    ], Draggable.prototype, "abort", void 0);
	    __decorate$f([
	        Property()
	    ], Draggable.prototype, "helper", void 0);
	    __decorate$f([
	        Property('default')
	    ], Draggable.prototype, "scope", void 0);
	    __decorate$f([
	        Property('')
	    ], Draggable.prototype, "dragTarget", void 0);
	    __decorate$f([
	        Property()
	    ], Draggable.prototype, "axis", void 0);
	    __decorate$f([
	        Property()
	    ], Draggable.prototype, "queryPositionInfo", void 0);
	    __decorate$f([
	        Property(false)
	    ], Draggable.prototype, "enableTailMode", void 0);
	    __decorate$f([
	        Property(false)
	    ], Draggable.prototype, "skipDistanceCheck", void 0);
	    __decorate$f([
	        Property(true)
	    ], Draggable.prototype, "preventDefault", void 0);
	    __decorate$f([
	        Property(false)
	    ], Draggable.prototype, "enableAutoScroll", void 0);
	    __decorate$f([
	        Property(false)
	    ], Draggable.prototype, "enableTapHold", void 0);
	    __decorate$f([
	        Property(750)
	    ], Draggable.prototype, "tapHoldThreshold", void 0);
	    __decorate$f([
	        Property(false)
	    ], Draggable.prototype, "enableScrollHandler", void 0);
	    Draggable = Draggable_1 = __decorate$f([
	        NotifyPropertyChanges
	    ], Draggable);
	    return Draggable;
	})(Base));

	var __extends$K = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	/**
	 * Droppable Module provides support to enable droppable functionality in Dom Elements.
	 * ```html
	 * <div id='drop'>Droppable</div>
	 * <script>
	 * let ele:HTMLElement = document.getElementById('drop');
	 * var drag:Droppable = new Droppable(ele,{
	 *     accept:'.drop',
	 *     drop: function(e) {
	 *      //drop handler code.
	 *     }
	 * });
	 * </script>
	 * ```
	 */
	/** @class */ ((function (_super) {
	    __extends$K(Droppable, _super);
	    function Droppable(element, options) {
	        var _this = _super.call(this, options, element) || this;
	        _this.mouseOver = false;
	        _this.dragData = {};
	        _this.dragStopCalled = false;
	        _this.bind();
	        return _this;
	    }
	    Droppable.prototype.bind = function () {
	        this.wireEvents();
	    };
	    Droppable.prototype.wireEvents = function () {
	        EventHandler.add(this.element, Browser.isSafari() ? 'touchend' : Browser.touchEndEvent, this.intDrop, this);
	    };
	    // triggers when property changed
	    // eslint-disable-next-line
	    Droppable.prototype.onPropertyChanged = function (newProp, oldProp) {
	        //No Code to handle
	    };
	    Droppable.prototype.getModuleName = function () {
	        return 'droppable';
	    };
	    Droppable.prototype.intOver = function (event, element) {
	        if (!this.mouseOver) {
	            var drag = this.dragData[this.scope];
	            this.trigger('over', { event: event, target: element, dragData: drag });
	            this.mouseOver = true;
	        }
	    };
	    Droppable.prototype.intOut = function (event, element) {
	        if (this.mouseOver) {
	            this.trigger('out', { evt: event, target: element });
	            this.mouseOver = false;
	        }
	    };
	    Droppable.prototype.intDrop = function (evt, element) {
	        if (!this.dragStopCalled) {
	            return;
	        }
	        else {
	            this.dragStopCalled = false;
	        }
	        var accept = true;
	        var drag = this.dragData[this.scope];
	        var isDrag = drag ? (drag.helper && isVisible(drag.helper)) : false;
	        var area;
	        if (isDrag) {
	            area = this.isDropArea(evt, drag.helper, element);
	            if (this.accept) {
	                accept = matches(drag.helper, this.accept);
	            }
	        }
	        if (isDrag && this.drop && area.canDrop && accept) {
	            this.trigger('drop', { event: evt, target: area.target, droppedElement: drag.helper, dragData: drag });
	        }
	        this.mouseOver = false;
	    };
	    Droppable.prototype.isDropArea = function (evt, helper, element) {
	        var area = { canDrop: true, target: element || evt.target };
	        var isTouch = evt.type === 'touchend';
	        if (isTouch || area.target === helper) {
	            helper.style.display = 'none';
	            var coord = isTouch ? (evt.changedTouches[0]) : evt;
	            var ele = document.elementFromPoint(coord.clientX, coord.clientY);
	            area.canDrop = false;
	            area.canDrop = compareElementParent(ele, this.element);
	            if (area.canDrop) {
	                area.target = ele;
	            }
	            helper.style.display = '';
	        }
	        return area;
	    };
	    Droppable.prototype.destroy = function () {
	        EventHandler.remove(this.element, Browser.isSafari() ? 'touchend' : Browser.touchEndEvent, this.intDrop);
	        _super.prototype.destroy.call(this);
	    };
	    __decorate$e([
	        Property()
	    ], Droppable.prototype, "accept", void 0);
	    __decorate$e([
	        Property('default')
	    ], Droppable.prototype, "scope", void 0);
	    __decorate$e([
	        Event()
	    ], Droppable.prototype, "drop", void 0);
	    __decorate$e([
	        Event()
	    ], Droppable.prototype, "over", void 0);
	    __decorate$e([
	        Event()
	    ], Droppable.prototype, "out", void 0);
	    Droppable = __decorate$e([
	        NotifyPropertyChanges
	    ], Droppable);
	    return Droppable;
	})(Base));

	var __extends$J = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var keyCode = {
	    'backspace': 8,
	    'tab': 9,
	    'enter': 13,
	    'shift': 16,
	    'control': 17,
	    'alt': 18,
	    'pause': 19,
	    'capslock': 20,
	    'space': 32,
	    'escape': 27,
	    'pageup': 33,
	    'pagedown': 34,
	    'end': 35,
	    'home': 36,
	    'leftarrow': 37,
	    'uparrow': 38,
	    'rightarrow': 39,
	    'downarrow': 40,
	    'insert': 45,
	    'delete': 46,
	    'f1': 112,
	    'f2': 113,
	    'f3': 114,
	    'f4': 115,
	    'f5': 116,
	    'f6': 117,
	    'f7': 118,
	    'f8': 119,
	    'f9': 120,
	    'f10': 121,
	    'f11': 122,
	    'f12': 123,
	    'semicolon': 186,
	    'plus': 187,
	    'comma': 188,
	    'minus': 189,
	    'dot': 190,
	    'forwardslash': 191,
	    'graveaccent': 192,
	    'openbracket': 219,
	    'backslash': 220,
	    'closebracket': 221,
	    'singlequote': 222
	};
	/**
	 * KeyboardEvents class enables you to bind key action desired key combinations for ex., Ctrl+A, Delete, Alt+Space etc.
	 * ```html
	 * <div id='testEle'>  </div>;
	 * <script>
	 *   let node: HTMLElement = document.querySelector('#testEle');
	 *   let kbInstance = new KeyboardEvents({
	 *       element: node,
	 *       keyConfigs:{ selectAll : 'ctrl+a' },
	 *       keyAction: function (e:KeyboardEvent, action:string) {
	 *           // handler function code
	 *       }
	 *   });
	 * </script>
	 * ```
	 */
	var KeyboardEvents = /** @class */ (function (_super) {
	    __extends$J(KeyboardEvents, _super);
	    /**
	     * Initializes the KeyboardEvents
	     *
	     * @param {HTMLElement} element ?
	     * @param {KeyboardEventsModel} options ?
	     */
	    function KeyboardEvents(element, options) {
	        var _this = _super.call(this, options, element) || this;
	        /**
	         * To handle a key press event returns null
	         *
	         * @param {KeyboardEventArgs} e ?
	         * @returns {void} ?
	         */
	        _this.keyPressHandler = function (e) {
	            var isAltKey = e.altKey;
	            var isCtrlKey = e.ctrlKey;
	            var isShiftKey = e.shiftKey;
	            var curkeyCode = e.which;
	            var keys = Object.keys(_this.keyConfigs);
	            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
	                var key = keys_1[_i];
	                var configCollection = _this.keyConfigs["" + key].split(',');
	                for (var _a = 0, configCollection_1 = configCollection; _a < configCollection_1.length; _a++) {
	                    var rconfig = configCollection_1[_a];
	                    var rKeyObj = KeyboardEvents_1.getKeyConfigData(rconfig.trim());
	                    if (isAltKey === rKeyObj.altKey && isCtrlKey === rKeyObj.ctrlKey &&
	                        isShiftKey === rKeyObj.shiftKey && curkeyCode === rKeyObj.keyCode) {
	                        e.action = key;
	                        if (_this.keyAction) {
	                            _this.keyAction(e);
	                        }
	                    }
	                }
	            }
	        };
	        _this.bind();
	        return _this;
	    }
	    KeyboardEvents_1 = KeyboardEvents;
	    /**
	     * Unwire bound events and destroy the instance.
	     *
	     * @returns {void} ?
	     */
	    KeyboardEvents.prototype.destroy = function () {
	        this.unwireEvents();
	        _super.prototype.destroy.call(this);
	    };
	    /**
	     * Function can be used to specify certain action if a property is changed
	     *
	     * @param {KeyboardEventsModel} newProp ?
	     * @param {KeyboardEventsModel} oldProp ?
	     * @returns {void} ?
	     * @private
	     */
	    // eslint-disable-next-line
	    KeyboardEvents.prototype.onPropertyChanged = function (newProp, oldProp) {
	        // No code are needed
	    };
	    KeyboardEvents.prototype.bind = function () {
	        this.wireEvents();
	    };
	    /**
	     * To get the module name, returns 'keyboard'.
	     *
	     * @returns {string} ?
	     * @private
	     */
	    KeyboardEvents.prototype.getModuleName = function () {
	        return 'keyboard';
	    };
	    /**
	     * Wiring event handlers to events
	     *
	     * @returns {void} ?
	     * @private
	     */
	    KeyboardEvents.prototype.wireEvents = function () {
	        this.element.addEventListener(this.eventName, this.keyPressHandler);
	    };
	    /**
	     * Unwiring event handlers to events
	     *
	     * @returns {void} ?
	     * @private
	     */
	    KeyboardEvents.prototype.unwireEvents = function () {
	        this.element.removeEventListener(this.eventName, this.keyPressHandler);
	    };
	    /**
	     * To get the key configuration data
	     *
	     * @param {string} config - configuration data
	     * @returns {KeyData} ?
	     */
	    KeyboardEvents.getKeyConfigData = function (config) {
	        if (config in this.configCache) {
	            return this.configCache["" + config];
	        }
	        var keys = config.toLowerCase().split('+');
	        var keyData = {
	            altKey: (keys.indexOf('alt') !== -1 ? true : false),
	            ctrlKey: (keys.indexOf('ctrl') !== -1 ? true : false),
	            shiftKey: (keys.indexOf('shift') !== -1 ? true : false),
	            keyCode: null
	        };
	        if (keys[keys.length - 1].length > 1 && !!Number(keys[keys.length - 1])) {
	            keyData.keyCode = Number(keys[keys.length - 1]);
	        }
	        else {
	            keyData.keyCode = KeyboardEvents_1.getKeyCode(keys[keys.length - 1]);
	        }
	        KeyboardEvents_1.configCache["" + config] = keyData;
	        return keyData;
	    };
	    // Return the keycode value as string
	    KeyboardEvents.getKeyCode = function (keyVal) {
	        return keyCode["" + keyVal] || keyVal.toUpperCase().charCodeAt(0);
	    };
	    var KeyboardEvents_1;
	    KeyboardEvents.configCache = {};
	    __decorate$d([
	        Property({})
	    ], KeyboardEvents.prototype, "keyConfigs", void 0);
	    __decorate$d([
	        Property('keyup')
	    ], KeyboardEvents.prototype, "eventName", void 0);
	    __decorate$d([
	        Event()
	    ], KeyboardEvents.prototype, "keyAction", void 0);
	    KeyboardEvents = KeyboardEvents_1 = __decorate$d([
	        NotifyPropertyChanges
	    ], KeyboardEvents);
	    return KeyboardEvents;
	}(Base));

	/**
	 * L10n modules provides localized text for different culture.
	 * ```typescript
	 * import {setCulture} from '@syncfusion/ts-base-library';
	 * //load global locale object common for all components.
	 * L10n.load({
	 *    'fr-BE': {
	 *       'button': {
	 *            'check': 'vérifié'
	 *        }
	 *    }
	 * });
	 * //set globale default locale culture.
	 * setCulture('fr-BE');
	 * let instance: L10n = new L10n('button', {
	 *    check: 'checked'
	 * });
	 * //Get locale text for current property.
	 * instance.getConstant('check');
	 * //Change locale culture in a component.
	 * instance.setLocale('en-US');
	 * ```
	 */
	var L10n = /** @class */ (function () {
	    /**
	     * Constructor
	     *
	     * @param {string} controlName ?
	     * @param {Object} localeStrings ?
	     * @param {string} locale ?
	     */
	    function L10n(controlName, localeStrings, locale) {
	        this.controlName = controlName;
	        this.localeStrings = localeStrings;
	        this.setLocale(locale || defaultCulture);
	    }
	    /**
	     * Sets the locale text
	     *
	     * @param {string} locale ?
	     * @returns {void} ?
	     */
	    L10n.prototype.setLocale = function (locale) {
	        var intLocale = this.intGetControlConstant(L10n.locale, locale);
	        this.currentLocale = intLocale || this.localeStrings;
	    };
	    /**
	     * Sets the global locale for all components.
	     *
	     * @param {Object} localeObject - specifies the localeObject to be set as global locale.
	     * @returns {void} ?
	     */
	    L10n.load = function (localeObject) {
	        this.locale = extend(this.locale, localeObject, {}, true);
	    };
	    /**
	     * Returns current locale text for the property based on the culture name and control name.
	     *
	     * @param {string} prop - specifies the property for which localize text to be returned.
	     * @returns {string} ?
	     */
	    L10n.prototype.getConstant = function (prop) {
	        // Removed conditional operator because this method does not return correct value when passing 0 as value in localization
	        if (!isNullOrUndefined(this.currentLocale["" + prop])) {
	            return this.currentLocale["" + prop];
	        }
	        else {
	            return this.localeStrings["" + prop] || '';
	        }
	    };
	    /**
	     * Returns the control constant object for current object and the locale specified.
	     *
	     * @param {Object} curObject ?
	     * @param {string} locale ?
	     * @returns {Object} ?
	     */
	    L10n.prototype.intGetControlConstant = function (curObject, locale) {
	        if ((curObject)["" + locale]) {
	            return (curObject)["" + locale][this.controlName];
	        }
	        return null;
	    };
	    L10n.locale = {};
	    return L10n;
	}());

	var __extends$I = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	/**
	 * SwipeSettings is a framework module that provides support to handle swipe event like swipe up, swipe right, etc..,
	 */
	var SwipeSettings = /** @class */ (function (_super) {
	    __extends$I(SwipeSettings, _super);
	    function SwipeSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$c([
	        Property(50)
	    ], SwipeSettings.prototype, "swipeThresholdDistance", void 0);
	    return SwipeSettings;
	}(ChildProperty));
	var swipeRegex = /(Up|Down)/;
	/**
	 * Touch class provides support to handle the touch event like tap, double tap, tap hold, etc..,
	 * ```typescript
	 *    let node: HTMLElement;
	 * let touchObj: Touch = new Touch({
	 *    element: node,
	 *    tap: function (e) {
	 *        // tap handler function code
	 *    }
	 *    tapHold: function (e) {
	 *        // tap hold handler function code
	 *    }
	 *    scroll: function (e) {
	 *        // scroll handler function code
	 *    }
	 *    swipe: function (e) {
	 *        // swipe handler function code
	 *    }
	 * });
	 * ```
	 */
	var Touch = /** @class */ (function (_super) {
	    __extends$I(Touch, _super);
	    /* End-Properties */
	    function Touch(element, options) {
	        var _this = _super.call(this, options, element) || this;
	        _this.touchAction = true;
	        _this.tapCount = 0;
	        /**
	         *
	         * @param {MouseEventArgs | TouchEventArgs} evt ?
	         * @returns {void} ?
	         */
	        _this.startEvent = function (evt) {
	            if (_this.touchAction === true) {
	                var point = _this.updateChangeTouches(evt);
	                if (evt.changedTouches !== undefined) {
	                    _this.touchAction = false;
	                }
	                _this.isTouchMoved = false;
	                _this.movedDirection = '';
	                _this.startPoint = _this.lastMovedPoint = { clientX: point.clientX, clientY: point.clientY };
	                _this.startEventData = point;
	                _this.hScrollLocked = _this.vScrollLocked = false;
	                _this.tStampStart = Date.now();
	                _this.timeOutTapHold = setTimeout(function () { _this.tapHoldEvent(evt); }, _this.tapHoldThreshold);
	                EventHandler.add(_this.element, Browser.touchMoveEvent, _this.moveEvent, _this);
	                EventHandler.add(_this.element, Browser.touchEndEvent, _this.endEvent, _this);
	                EventHandler.add(_this.element, Browser.touchCancelEvent, _this.cancelEvent, _this);
	            }
	        };
	        /**
	         *
	         * @param {MouseEventArgs | TouchEventArgs} evt ?
	         * @returns {void} ?
	         */
	        _this.moveEvent = function (evt) {
	            var point = _this.updateChangeTouches(evt);
	            _this.movedPoint = point;
	            _this.isTouchMoved = !(point.clientX === _this.startPoint.clientX && point.clientY === _this.startPoint.clientY);
	            var eScrollArgs = {};
	            if (_this.isTouchMoved) {
	                clearTimeout(_this.timeOutTapHold);
	                _this.calcScrollPoints(evt);
	                var scrollArg = {
	                    startEvents: _this.startEventData,
	                    originalEvent: evt, startX: _this.startPoint.clientX,
	                    startY: _this.startPoint.clientY, distanceX: _this.distanceX,
	                    distanceY: _this.distanceY, scrollDirection: _this.scrollDirection,
	                    velocity: _this.getVelocity(point)
	                };
	                eScrollArgs = extend(eScrollArgs, {}, scrollArg);
	                _this.trigger('scroll', eScrollArgs);
	                _this.lastMovedPoint = { clientX: point.clientX, clientY: point.clientY };
	            }
	        };
	        /**
	         *
	         * @param {MouseEventArgs | TouchEventArgs} evt ?
	         * @returns {void} ?
	         */
	        _this.cancelEvent = function (evt) {
	            clearTimeout(_this.timeOutTapHold);
	            clearTimeout(_this.timeOutTap);
	            _this.tapCount = 0;
	            _this.swipeFn(evt);
	            EventHandler.remove(_this.element, Browser.touchCancelEvent, _this.cancelEvent);
	        };
	        /**
	         *
	         * @param {MouseEventArgs | TouchEventArgs} evt ?
	         * @returns {void} ?
	         */
	        _this.endEvent = function (evt) {
	            _this.swipeFn(evt);
	            if (!_this.isTouchMoved) {
	                if (typeof _this.tap === 'function') {
	                    _this.trigger('tap', { originalEvent: evt, tapCount: ++_this.tapCount });
	                    _this.timeOutTap = setTimeout(function () {
	                        _this.tapCount = 0;
	                    }, _this.tapThreshold);
	                }
	            }
	            _this.modeclear();
	        };
	        /**
	         *
	         * @param {MouseEventArgs | TouchEventArgs} evt ?
	         * @returns {void} ?
	         */
	        _this.swipeFn = function (evt) {
	            clearTimeout(_this.timeOutTapHold);
	            clearTimeout(_this.timeOutTap);
	            var point = _this.updateChangeTouches(evt);
	            var diffX = point.clientX - _this.startPoint.clientX;
	            var diffY = point.clientY - _this.startPoint.clientY;
	            diffX = Math.floor(diffX < 0 ? -1 * diffX : diffX);
	            diffY = Math.floor(diffY < 0 ? -1 * diffY : diffX);
	            _this.isTouchMoved = diffX > 1 || diffY > 1;
	            var isFirefox = (/Firefox/).test(Browser.userAgent);
	            if (isFirefox && point.clientX === 0 && point.clientY === 0 && evt.type === 'mouseup') {
	                _this.isTouchMoved = false;
	            }
	            _this.endPoint = point;
	            _this.calcPoints(evt);
	            var swipeArgs = {
	                originalEvent: evt,
	                startEvents: _this.startEventData,
	                startX: _this.startPoint.clientX,
	                startY: _this.startPoint.clientY,
	                distanceX: _this.distanceX, distanceY: _this.distanceY, swipeDirection: _this.movedDirection,
	                velocity: _this.getVelocity(point)
	            };
	            if (_this.isTouchMoved) {
	                var eSwipeArgs = void 0;
	                var tDistance = _this.swipeSettings.swipeThresholdDistance;
	                // eslint-disable-next-line
	                eSwipeArgs = extend(eSwipeArgs, _this.defaultArgs, swipeArgs);
	                var canTrigger = false;
	                var ele = _this.element;
	                var scrollBool = _this.isScrollable(ele);
	                var moved = swipeRegex.test(_this.movedDirection);
	                if ((tDistance < _this.distanceX && !moved) || (tDistance < _this.distanceY && moved)) {
	                    if (!scrollBool) {
	                        canTrigger = true;
	                    }
	                    else {
	                        canTrigger = _this.checkSwipe(ele, moved);
	                    }
	                }
	                if (canTrigger) {
	                    _this.trigger('swipe', eSwipeArgs);
	                }
	            }
	            _this.modeclear();
	        };
	        _this.modeclear = function () {
	            _this.modeClear = setTimeout(function () {
	                _this.touchAction = true;
	            }, (typeof _this.tap !== 'function' ? 0 : 20));
	            _this.lastTapTime = new Date().getTime();
	            EventHandler.remove(_this.element, Browser.touchMoveEvent, _this.moveEvent);
	            EventHandler.remove(_this.element, Browser.touchEndEvent, _this.endEvent);
	            EventHandler.remove(_this.element, Browser.touchCancelEvent, _this.cancelEvent);
	        };
	        _this.bind();
	        return _this;
	    }
	    // triggers when property changed
	    /**
	     *
	     * @private
	     * @param {TouchModel} newProp ?
	     * @param {TouchModel} oldProp ?
	     * @returns {void} ?
	     */
	    // eslint-disable-next-line
	    Touch.prototype.onPropertyChanged = function (newProp, oldProp) {
	        //No Code to handle
	    };
	    Touch.prototype.bind = function () {
	        this.wireEvents();
	        if (Browser.isIE) {
	            this.element.classList.add('e-block-touch');
	        }
	    };
	    /**
	     * To destroy the touch instance.
	     *
	     * @returns {void}
	     */
	    Touch.prototype.destroy = function () {
	        this.unwireEvents();
	        _super.prototype.destroy.call(this);
	    };
	    // Need to changes the event binding once we updated the event handler.
	    Touch.prototype.wireEvents = function () {
	        EventHandler.add(this.element, Browser.touchStartEvent, this.startEvent, this);
	    };
	    Touch.prototype.unwireEvents = function () {
	        EventHandler.remove(this.element, Browser.touchStartEvent, this.startEvent);
	    };
	    /**
	     * Returns module name as touch
	     *
	     * @returns {string} ?
	     * @private
	     */
	    Touch.prototype.getModuleName = function () {
	        return 'touch';
	    };
	    /**
	     * Returns if the HTML element is Scrollable.
	     *
	     * @param {HTMLElement} element - HTML Element to check if Scrollable.
	     * @returns {boolean} ?
	     */
	    Touch.prototype.isScrollable = function (element) {
	        var eleStyle = getComputedStyle(element);
	        var style = eleStyle.overflow + eleStyle.overflowX + eleStyle.overflowY;
	        if ((/(auto|scroll)/).test(style)) {
	            return true;
	        }
	        return false;
	    };
	    /**
	     *
	     * @param {MouseEventArgs | TouchEventArgs} evt ?
	     * @returns {void} ?
	     */
	    Touch.prototype.tapHoldEvent = function (evt) {
	        this.tapCount = 0;
	        this.touchAction = true;
	        var eTapArgs;
	        EventHandler.remove(this.element, Browser.touchMoveEvent, this.moveEvent);
	        EventHandler.remove(this.element, Browser.touchEndEvent, this.endEvent);
	        // eslint-disable-next-line
	        eTapArgs = { originalEvent: evt };
	        this.trigger('tapHold', eTapArgs);
	        EventHandler.remove(this.element, Browser.touchCancelEvent, this.cancelEvent);
	    };
	    Touch.prototype.calcPoints = function (evt) {
	        var point = this.updateChangeTouches(evt);
	        this.defaultArgs = { originalEvent: evt };
	        this.distanceX = Math.abs((Math.abs(point.clientX) - Math.abs(this.startPoint.clientX)));
	        this.distanceY = Math.abs((Math.abs(point.clientY) - Math.abs(this.startPoint.clientY)));
	        if (this.distanceX > this.distanceY) {
	            this.movedDirection = (point.clientX > this.startPoint.clientX) ? 'Right' : 'Left';
	        }
	        else {
	            this.movedDirection = (point.clientY < this.startPoint.clientY) ? 'Up' : 'Down';
	        }
	    };
	    Touch.prototype.calcScrollPoints = function (evt) {
	        var point = this.updateChangeTouches(evt);
	        this.defaultArgs = { originalEvent: evt };
	        this.distanceX = Math.abs((Math.abs(point.clientX) - Math.abs(this.lastMovedPoint.clientX)));
	        this.distanceY = Math.abs((Math.abs(point.clientY) - Math.abs(this.lastMovedPoint.clientY)));
	        if ((this.distanceX > this.distanceY || this.hScrollLocked === true) && this.vScrollLocked === false) {
	            this.scrollDirection = (point.clientX > this.lastMovedPoint.clientX) ? 'Right' : 'Left';
	            this.hScrollLocked = true;
	        }
	        else {
	            this.scrollDirection = (point.clientY < this.lastMovedPoint.clientY) ? 'Up' : 'Down';
	            this.vScrollLocked = true;
	        }
	    };
	    Touch.prototype.getVelocity = function (pnt) {
	        var newX = pnt.clientX;
	        var newY = pnt.clientY;
	        var newT = Date.now();
	        var xDist = newX - this.startPoint.clientX;
	        var yDist = newY - this.startPoint.clientX;
	        var interval = newT - this.tStampStart;
	        return Math.sqrt(xDist * xDist + yDist * yDist) / interval;
	    };
	    // eslint-disable-next-line
	    Touch.prototype.checkSwipe = function (ele, flag) {
	        var keys = ['scroll', 'offset'];
	        var temp = flag ? ['Height', 'Top'] : ['Width', 'Left'];
	        if ((ele[keys[0] + temp[0]] <= ele[keys[1] + temp[0]])) {
	            return true;
	        }
	        return (ele[keys[0] + temp[1]] === 0) ||
	            (ele[keys[1] + temp[0]] + ele[keys[0] + temp[1]] >= ele[keys[0] + temp[0]]);
	    };
	    Touch.prototype.updateChangeTouches = function (evt) {
	        var point = evt.changedTouches && evt.changedTouches.length !== 0 ? evt.changedTouches[0] : evt;
	        return point;
	    };
	    __decorate$c([
	        Event()
	    ], Touch.prototype, "tap", void 0);
	    __decorate$c([
	        Event()
	    ], Touch.prototype, "tapHold", void 0);
	    __decorate$c([
	        Event()
	    ], Touch.prototype, "swipe", void 0);
	    __decorate$c([
	        Event()
	    ], Touch.prototype, "scroll", void 0);
	    __decorate$c([
	        Property(350)
	    ], Touch.prototype, "tapThreshold", void 0);
	    __decorate$c([
	        Property(750)
	    ], Touch.prototype, "tapHoldThreshold", void 0);
	    __decorate$c([
	        Complex({}, SwipeSettings)
	    ], Touch.prototype, "swipeSettings", void 0);
	    Touch = __decorate$c([
	        NotifyPropertyChanges
	    ], Touch);
	    return Touch;
	}(Base));

	/**
	 * Template Engine
	 */
	var LINES = new RegExp('\\n|\\r|\\s\\s+', 'g');
	var QUOTES = new RegExp(/'|"/g);
	var IF_STMT = new RegExp('if ?\\(');
	var ELSEIF_STMT = new RegExp('else if ?\\(');
	var ELSE_STMT = new RegExp('else');
	var FOR_STMT = new RegExp('for ?\\(');
	var IF_OR_FOR = new RegExp('(/if|/for)');
	var CALL_FUNCTION = new RegExp('\\((.*)\\)', '');
	var NOT_NUMBER = new RegExp('^[0-9]+$', 'g');
	var WORD = new RegExp('[\\w"\'.\\s+]+', 'g');
	var DBL_QUOTED_STR = new RegExp('"(.*?)"', 'g');
	var WORDIF = new RegExp('[\\w"\'@#$.\\s-+]+', 'g');
	var exp = new RegExp('\\${([^}]*)}', 'g');
	// let cachedTemplate: Object = {};
	var ARR_OBJ = /^\..*/gm;
	var SINGLE_SLASH = /\\/gi;
	var DOUBLE_SLASH = /\\\\/gi;
	var WORDFUNC = new RegExp('[\\w"\'@#$.\\s+]+', 'g');
	var WINDOWFUNC = /\window\./gm;
	// /**
	//  * To render the template string from the given data.
	//  * @param  {string} template - String Template.
	//  * @param  {Object[]|JSON} data - DataSource for the template.
	//  * @param  {Object} helper? - custom helper object.
	//  */
	// export function template(template: string, data: JSON, helper?: Object): string {
	//     let hash: string = hashCode(template);
	//     let tmpl: Function;
	//     if (!cachedTemplate[hash]) {
	//         tmpl = cachedTemplate[hash] = compile(template, helper);
	//     } else {
	//         tmpl = cachedTemplate[hash];
	//     }
	//     return tmpl(data);
	// }
	/**
	 * Compile the template string into template function.
	 *
	 * @param {string | Function} template - The template string which is going to convert.
	 * @param {Object} helper - Helper functions as an object.
	 * @param {boolean} ignorePrefix ?
	 * @returns {string} ?
	 * @private
	 */
	function compile$1(template, helper, ignorePrefix) {
	    if (typeof template === 'function') {
	        return template;
	    }
	    else {
	        var argName = 'data';
	        var evalExpResult = evalExp(template, argName, helper, ignorePrefix);
	        // eslint-disable-next-line
	        var condtion = "var valueRegEx = (/value=\\'([A-Za-z0-9 _]*)((.)([\\w)(!-;?-\u25A0\\s]+)['])/g);\n        var hrefRegex = (/(?:href)([\\s='\"./]+)([\\w-./?=&\\\\#\"]+)((.)([\\w)(!-;/?-\u25A0\\s]+)['])/g);\n        if(str.match(valueRegEx)){\n            var check = str.match(valueRegEx);\n            var str1 = str;\n            for (var i=0; i < check.length; i++) {\n                var check1 = str.match(valueRegEx)[i].split('value=')[1];\n                var change = check1.match(/^'/) !== null ? check1.replace(/^'/, '\"') : check1;\n                change =change.match(/.$/)[0] === '\\'' ? change.replace(/.$/,'\"') : change;\n                str1 = str1.replace(check1, change);\n            }\n            str = str.replace(str, str1);\n        }\n        else if (str.match(/(?:href='')/) === null) {\n            if(str.match(hrefRegex)) {\n                var check = str.match(hrefRegex);\n                var str1 = str;\n                for (var i=0; i < check.length; i++) {\n                    var check1 = str.match(hrefRegex)[i].split('href=')[1];\n                    if (check1) {\n                        var change = check1.match(/^'/) !== null ? check1.replace(/^'/, '\"') : check1;\n                        change =change.match(/.$/)[0] === '\\'' ? change.replace(/.$/,'\"') : change;\n                        str1 = str1.replace(check1, change);\n                    }\n                }\n                str = str.replace(str, str1);\n            }\n        }\n        ";
	        var fnCode = 'var str=\"' + evalExpResult + '\";' + condtion + ' return str;';
	        var fn = new Function(argName, fnCode);
	        return fn.bind(helper);
	    }
	}
	/** function used to evaluate the function expression
	 *
	 * @param {string} str ?
	 * @param {string} nameSpace ?
	 * @param {Object} helper ?
	 * @param {boolean} ignorePrefix ?
	 * @returns {string} ?
	 */
	function evalExp(str, nameSpace, helper, ignorePrefix) {
	    var varCOunt = 0;
	    /**
	     * Variable containing Local Keys
	     */
	    var localKeys = [];
	    var isClass = str.match(/class="([^"]+|)\s{2}/g);
	    var singleSpace = '';
	    if (isClass) {
	        isClass.forEach(function (value) {
	            singleSpace = value.replace(/\s\s+/g, ' ');
	            str = str.replace(value, singleSpace);
	        });
	    }
	    return str.replace(LINES, '').replace(DBL_QUOTED_STR, '\'$1\'').replace(exp, 
	    // eslint-disable-next-line
	    function (match, cnt, offset, matchStr) {
	        var SPECIAL_CHAR = /@|#|\$/gm;
	        var matches = cnt.match(CALL_FUNCTION);
	        // matches to detect any function calls
	        if (matches) {
	            var rlStr = matches[1];
	            if (ELSEIF_STMT.test(cnt)) {
	                //handling else-if condition
	                cnt = '";} ' + cnt.replace(matches[1], rlStr.replace(WORD, function (str) {
	                    str = str.trim();
	                    return addNameSpace(str, !(QUOTES.test(str)) && (localKeys.indexOf(str) === -1), nameSpace, localKeys, ignorePrefix);
	                })) + '{ \n str = str + "';
	            }
	            else if (IF_STMT.test(cnt)) {
	                //handling if condition
	                cnt = '"; ' + cnt.replace(matches[1], rlStr.replace(WORDIF, function (strs) {
	                    return HandleSpecialCharArrObj(strs, nameSpace, localKeys, ignorePrefix);
	                })) + '{ \n str = str + "';
	            }
	            else if (FOR_STMT.test(cnt)) {
	                //handling for condition
	                var rlStr_1 = matches[1].split(' of ');
	                // replace for each into actual JavaScript
	                // eslint-disable-next-line
	                cnt = '"; ' + cnt.replace(matches[1], function (mtc) {
	                    localKeys.push(rlStr_1[0]);
	                    localKeys.push(rlStr_1[0] + 'Index');
	                    varCOunt = varCOunt + 1;
	                    // tslint:disable-next-line
	                    return 'var i' + varCOunt + '=0; i' + varCOunt + ' < ' + addNameSpace(rlStr_1[1], true, nameSpace, localKeys, ignorePrefix) + '.length; i' + varCOunt + '++';
	                }) + '{ \n ' + rlStr_1[0] + '= ' + addNameSpace(rlStr_1[1], true, nameSpace, localKeys, ignorePrefix)
	                    + '[i' + varCOunt + ']; \n var ' + rlStr_1[0] + 'Index=i' + varCOunt + '; \n str = str + "';
	            }
	            else {
	                //helper function handling
	                var fnStr = cnt.split('(');
	                // eslint-disable-next-line
	                var fNameSpace = (helper && helper.hasOwnProperty(fnStr[0]) ? 'this.' : 'global');
	                fNameSpace = (/\./.test(fnStr[0]) ? '' : fNameSpace);
	                var ftArray = matches[1].split(',');
	                if (matches[1].length !== 0 && !(/data/).test(ftArray[0]) && !(/window./).test(ftArray[0])) {
	                    matches[1] = (fNameSpace === 'global' ? nameSpace + '.' + matches[1] : matches[1]);
	                }
	                var splRegexp = /@|\$|#/gm;
	                var arrObj = /\]\./gm;
	                if (WINDOWFUNC.test(cnt) && arrObj.test(cnt) || splRegexp.test(cnt)) {
	                    var splArrRegexp = /@|\$|#|\]\./gm;
	                    if (splArrRegexp.test(cnt)) {
	                        // tslint:disable-next-line
	                        cnt = '"+ ' + (fNameSpace === 'global' ? '' : fNameSpace) + cnt.replace(matches[1], rlStr.replace(WORDFUNC, function (strs) {
	                            return HandleSpecialCharArrObj(strs, nameSpace, localKeys, ignorePrefix);
	                        })) + '+ "';
	                    }
	                }
	                else {
	                    cnt = '" + ' + (fNameSpace === 'global' ? '' : fNameSpace) +
	                        cnt.replace(rlStr, addNameSpace(matches[1].replace(/,( |)data.|,/gi, ',' + nameSpace + '.').replace(/,( |)data.window/gi, ',window'), (fNameSpace === 'global' ? false : true), nameSpace, localKeys, ignorePrefix)) +
	                        '+"';
	                }
	            }
	        }
	        else if (ELSE_STMT.test(cnt)) {
	            // handling else condition
	            cnt = '"; ' + cnt.replace(ELSE_STMT, '} else { \n str = str + "');
	            // eslint-disable-next-line
	        }
	        else if (!!cnt.match(IF_OR_FOR)) {
	            // close condition
	            cnt = cnt.replace(IF_OR_FOR, '"; \n } \n str = str + "');
	        }
	        else if (SPECIAL_CHAR.test(cnt)) {
	            // template string with double slash with special character
	            if (cnt.match(SINGLE_SLASH)) {
	                cnt = SlashReplace(cnt);
	            }
	            cnt = '"+' + NameSpaceForspecialChar(cnt, (localKeys.indexOf(cnt) === -1), nameSpace, localKeys) + '"]+"';
	        }
	        else {
	            // template string with double slash
	            if (cnt.match(SINGLE_SLASH)) {
	                cnt = SlashReplace(cnt);
	                cnt = '"+' + NameSpaceForspecialChar(cnt, (localKeys.indexOf(cnt) === -1), nameSpace, localKeys) + '"]+"';
	            }
	            else {
	                // evaluate normal expression
	                cnt = cnt !== '' ? '"+' + addNameSpace(cnt.replace(/,/gi, '+' + nameSpace + '.'), (localKeys.indexOf(cnt) === -1), nameSpace, localKeys, ignorePrefix) + '+"' : ' ';
	            }
	        }
	        return cnt;
	    });
	}
	/**
	 *
	 * @param {string} str ?
	 * @param {boolean} addNS ?
	 * @param {string} nameSpace ?
	 * @param {string[]} ignoreList ?
	 * @param {boolean} ignorePrefix ?
	 * @returns {string} ?
	 */
	function addNameSpace(str, addNS, nameSpace, ignoreList, ignorePrefix) {
	    return ((addNS && !(NOT_NUMBER.test(str)) && ignoreList.indexOf(str.split('.')[0]) === -1 && !ignorePrefix && str !== "true" && str !== "false") ? nameSpace + '.' + str : str);
	}
	/**
	 *
	 * @param {string} str ?
	 * @param {boolean} addNS ?
	 * @param {string} nameSpace ?
	 * @param {string[]} ignoreList ?
	 * @returns {string} ?
	 */
	function NameSpaceArrObj(str, addNS, nameSpace, ignoreList) {
	    var arrObjReg = /^\..*/gm;
	    return ((addNS && !(NOT_NUMBER.test(str)) &&
	        ignoreList.indexOf(str.split('.')[0]) === -1 && !(arrObjReg.test(str))) ? nameSpace + '.' + str : str);
	}
	// // Create hashCode for template string to storeCached function
	// function hashCode(str: string): string {
	//     return str.split('').reduce((a: number, b: string) => { a = ((a << 5) - a) + b.charCodeAt(0); return a & a; }, 0).toString();
	// }
	/**
	 *
	 * @param {string} str ?
	 * @param {boolean} addNS ?
	 * @param {string} nameSpace ?
	 * @param {string[]} ignoreList ?
	 * @returns {string} ?
	 */
	function NameSpaceForspecialChar(str, addNS, nameSpace, ignoreList) {
	    return ((addNS && !(NOT_NUMBER.test(str)) && ignoreList.indexOf(str.split('.')[0]) === -1) ? nameSpace + '["' + str : str);
	}
	// eslint-disable-next-line
	function SlashReplace(tempStr) {
	    var double = '\\\\';
	    if (tempStr.match(DOUBLE_SLASH)) {
	        // eslint-disable-next-line
	        tempStr = tempStr;
	    }
	    else {
	        tempStr = tempStr.replace(SINGLE_SLASH, double);
	    }
	    return tempStr;
	}
	/**
	 *
	 * @param {string} str ?
	 * @param {string} nameSpaceNew ?
	 * @param {string[]} keys ?
	 * @param {boolean} ignorePrefix ?
	 * @returns {string} ?
	 */
	function HandleSpecialCharArrObj(str, nameSpaceNew, keys, ignorePrefix) {
	    str = str.trim();
	    var windowFunc = /\window\./gm;
	    if (!windowFunc.test(str)) {
	        var quotes = /'|"/gm;
	        var splRegexp = /@|\$|#/gm;
	        if (splRegexp.test(str)) {
	            str = NameSpaceForspecialChar(str, (keys.indexOf(str) === -1), nameSpaceNew, keys) + '"]';
	        }
	        if (ARR_OBJ.test(str)) {
	            return NameSpaceArrObj(str, !(quotes.test(str)) && (keys.indexOf(str) === -1), nameSpaceNew, keys);
	        }
	        else {
	            return addNameSpace(str, !(quotes.test(str)) && (keys.indexOf(str) === -1), nameSpaceNew, keys, ignorePrefix);
	        }
	    }
	    else {
	        return str;
	    }
	}

	/**
	 * Template Engine Bridge
	 */
	var HAS_ROW = /^[\n\r.]+<tr|^<tr/;
	var HAS_SVG = /^[\n\r.]+<svg|^<path|^<g/;
	/**
	 * Compile the template string into template function.
	 *
	 * @param {string | Function} templateString - The template string which is going to convert.
	 * @param {Object} helper - Helper functions as an object.
	 * @param {boolean} ignorePrefix ?
	 * @returns {NodeList} ?
	 * @private
	 */
	// eslint-disable-next-line
	function compile(templateString, helper, ignorePrefix) {
	    var compiler = engineObj.compile(templateString, helper, ignorePrefix);
	    // eslint-disable-next-line
	    return function (data, component, propName, templateId, isStringTemplate, index, element, root) {
	        var result = compiler(data, component, propName, element, root);
	        if (typeof result === 'string') {
	            if (HAS_SVG.test(result)) {
	                var ele = createElement('svg', { innerHTML: result });
	                return ele.childNodes;
	            }
	            else {
	                var ele = createElement((HAS_ROW.test(result) ? 'table' : 'div'), { innerHTML: result });
	                return ele.childNodes;
	            }
	        }
	        else {
	            return result;
	        }
	    };
	}
	/**
	 *
	 * @param {string} templateId ?
	 * @param {string} templateName ?
	 * @param {string} comp ?
	 * @param {boolean} isEmpty ?
	 * @param {Function} callBack ?
	 * @returns {void} ?
	 */
	function updateBlazorTemplate(templateId, templateName, comp, isEmpty, callBack) {
	}
	/**
	 *
	 * @param {string} templateId ?
	 * @param {string} templateName ?
	 * @param {number} index ?
	 * @returns {void} ?
	 */
	function resetBlazorTemplate(templateId, templateName, index) {
	    var templateDiv = document.getElementById(templateId);
	    if (templateDiv) {
	        // eslint-disable-next-line
	        var innerTemplates = templateDiv.getElementsByClassName('blazor-inner-template');
	        for (var i = 0; i < innerTemplates.length; i++) {
	            var tempId = ' ';
	            if (!isNullOrUndefined(index)) {
	                tempId = innerTemplates[parseInt(index.toString(), 10)].getAttribute('data-templateId');
	            }
	            else {
	                tempId = innerTemplates[parseInt(i.toString(), 10)].getAttribute('data-templateId');
	            }
	            var tempElement = document.getElementById(tempId);
	            if (tempElement) {
	                var length_1 = tempElement.childNodes.length;
	                for (var j = 0; j < length_1; j++) {
	                    if (!isNullOrUndefined(index)) {
	                        innerTemplates[parseInt(index.toString(), 10)].appendChild(tempElement.childNodes[0]);
	                        i = innerTemplates.length;
	                    }
	                    else {
	                        innerTemplates[parseInt(i.toString(), 10)].appendChild(tempElement.childNodes[0]);
	                    }
	                }
	            }
	        }
	    }
	}
	//Default Engine Class
	var Engine = /** @class */ (function () {
	    function Engine() {
	    }
	    // eslint-disable-next-line
	    Engine.prototype.compile = function (templateString, helper, ignorePrefix) {
	        if (helper === void 0) { helper = {}; }
	        return compile$1(templateString, helper);
	    };
	    return Engine;
	}());
	var engineObj = { compile: new Engine().compile };

	/**
	 * SanitizeHtmlHelper for sanitize the value.
	 */
	var removeTags = [
	    'script',
	    'style',
	    'iframe[src]',
	    'link[href*="javascript:"]',
	    'object[type="text/x-scriptlet"]',
	    'object[data^="data:text/html;base64"]',
	    'img[src^="data:text/html;base64"]',
	    '[src^="javascript:"]',
	    '[dynsrc^="javascript:"]',
	    '[lowsrc^="javascript:"]',
	    '[type^="application/x-shockwave-flash"]'
	];
	var removeAttrs = [
	    { attribute: 'href', selector: '[href*="javascript:"]' },
	    { attribute: 'background', selector: '[background^="javascript:"]' },
	    { attribute: 'style', selector: '[style*="javascript:"]' },
	    { attribute: 'style', selector: '[style*="expression("]' },
	    { attribute: 'href', selector: 'a[href^="data:text/html;base64"]' }
	];
	var jsEvents = ['onchange',
	    'onclick',
	    'onmouseover',
	    'onmouseout',
	    'onkeydown',
	    'onload',
	    'onerror',
	    'onblur',
	    'onfocus',
	    'onbeforeload',
	    'onbeforeunload',
	    'onkeyup',
	    'onsubmit',
	    'onafterprint',
	    'onbeforeonload',
	    'onbeforeprint',
	    'oncanplay',
	    'oncanplaythrough',
	    'oncontextmenu',
	    'ondblclick',
	    'ondrag',
	    'ondragend',
	    'ondragenter',
	    'ondragleave',
	    'ondragover',
	    'ondragstart',
	    'ondrop',
	    'ondurationchange',
	    'onemptied',
	    'onended',
	    'onformchange',
	    'onforminput',
	    'onhaschange',
	    'oninput',
	    'oninvalid',
	    'onkeypress',
	    'onloadeddata',
	    'onloadedmetadata',
	    'onloadstart',
	    'onmessage',
	    'onmousedown',
	    'onmousemove',
	    'onmouseup',
	    'onmousewheel',
	    'onoffline',
	    'onoine',
	    'ononline',
	    'onpagehide',
	    'onpageshow',
	    'onpause',
	    'onplay',
	    'onplaying',
	    'onpopstate',
	    'onprogress',
	    'onratechange',
	    'onreadystatechange',
	    'onredo',
	    'onresize',
	    'onscroll',
	    'onseeked',
	    'onseeking',
	    'onselect',
	    'onstalled',
	    'onstorage',
	    'onsuspend',
	    'ontimeupdate',
	    'onundo',
	    'onunload',
	    'onvolumechange',
	    'onwaiting',
	    'onmouseenter',
	    'onmouseleave',
	    'onstart',
	    'onpropertychange',
	    'oncopy',
	    'ontoggle',
	    'onpointerout',
	    'onpointermove',
	    'onpointerleave',
	    'onpointerenter',
	    'onpointerrawupdate',
	    'onpointerover',
	    'onbeforecopy',
	    'onbeforecut',
	    'onbeforeinput'
	];
	var SanitizeHtmlHelper = /** @class */ (function () {
	    function SanitizeHtmlHelper() {
	    }
	    SanitizeHtmlHelper.beforeSanitize = function () {
	        return {
	            selectors: {
	                tags: removeTags,
	                attributes: removeAttrs
	            }
	        };
	    };
	    SanitizeHtmlHelper.sanitize = function (value) {
	        var item = this.beforeSanitize();
	        var output = this.serializeValue(item, value);
	        return output;
	    };
	    SanitizeHtmlHelper.serializeValue = function (item, value) {
	        this.removeAttrs = item.selectors.attributes;
	        this.removeTags = item.selectors.tags;
	        this.wrapElement = document.createElement('div');
	        this.wrapElement.innerHTML = this.sanitizeQuotes(value);
	        this.removeXssTags();
	        this.removeJsEvents();
	        this.removeXssAttrs();
	        var tempEleValue = this.wrapElement.innerHTML;
	        this.removeElement();
	        return tempEleValue.replace(/&amp;/g, '&');
	    };
	    SanitizeHtmlHelper.sanitizeQuotes = function (input) {
	        var sanityChars = [96, 39, 34];
	        var escape = 92;
	        var sanitizedValue = '';
	        var quoteCounts = {
	            96: 0,
	            39: 0,
	            34: 0
	        };
	        var isPreviousCharBackslash = false;
	        for (var i = 0; i < input.length; i++) {
	            var currentChar = input.charCodeAt(i);
	            if (sanityChars.indexOf(currentChar) !== -1 && !isPreviousCharBackslash) {
	                quoteCounts[currentChar + '']++;
	            }
	            isPreviousCharBackslash = currentChar === escape;
	        }
	        try {
	            // Replace the quotes which has total count is in odd number
	            // Previous char is not backslash, open parenthesis and
	            // Next is not close parenthesis
	            for (var i = 0; i < input.length; i++) {
	                var currentChar = input.charCodeAt(i);
	                var previousChar = i > 0 ? input.charCodeAt(i - 1) : null;
	                var nextChar = i < input.length - 1 ? input.charCodeAt(i + 1) : null;
	                if (sanityChars.indexOf(currentChar) !== -1 && previousChar !== escape) {
	                    if (quoteCounts[currentChar + ''] % 2 === 1 && previousChar !== 40 && nextChar !== 41) {
	                        sanitizedValue += String.fromCharCode(escape);
	                    }
	                    sanitizedValue += input[i + ''];
	                }
	                else {
	                    sanitizedValue += input[i + ''];
	                }
	            }
	            return sanitizedValue;
	        }
	        catch (error) {
	            return input;
	        }
	    };
	    SanitizeHtmlHelper.removeElement = function () {
	        // Removes an element's attibute to avoid html tag validation
	        var nodes = this.wrapElement.children;
	        for (var j = 0; j < nodes.length; j++) {
	            var attribute = nodes[parseInt(j.toString(), 10)].attributes;
	            for (var i = 0; i < attribute.length; i++) {
	                this.wrapElement.children[parseInt(j.toString(), 10)].removeAttribute(attribute[parseInt(i.toString(), 10)].localName);
	            }
	        }
	    };
	    SanitizeHtmlHelper.removeXssTags = function () {
	        var elements = this.wrapElement.querySelectorAll(this.removeTags.join(','));
	        if (elements.length > 0) {
	            elements.forEach(function (element) {
	                detach(element);
	            });
	        }
	        else {
	            return;
	        }
	    };
	    SanitizeHtmlHelper.removeJsEvents = function () {
	        var elements = this.wrapElement.querySelectorAll('[' + jsEvents.join('],[') + ']');
	        if (elements.length > 0) {
	            elements.forEach(function (element) {
	                jsEvents.forEach(function (attr) {
	                    if (element.hasAttribute(attr)) {
	                        element.removeAttribute(attr);
	                    }
	                });
	            });
	        }
	        else {
	            return;
	        }
	    };
	    SanitizeHtmlHelper.removeXssAttrs = function () {
	        var _this = this;
	        // eslint-disable-next-line
	        this.removeAttrs.forEach(function (item, index) {
	            var elements = _this.wrapElement.querySelectorAll(item.selector);
	            if (elements.length > 0) {
	                elements.forEach(function (element) {
	                    element.removeAttribute(item.attribute);
	                });
	            }
	        });
	    };
	    return SanitizeHtmlHelper;
	}());

	var __extends$H = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	//class constant defination.
	var OTHERMONTH$1 = 'e-other-month';
	var OTHERDECADE = 'e-other-year';
	var ROOT$1 = 'e-calendar';
	var DEVICE$1 = 'e-device';
	var HEADER$1 = 'e-header';
	var RTL$1 = 'e-rtl';
	var CONTENT$1 = 'e-content';
	var YEAR = 'e-year';
	var MONTH = 'e-month';
	var DECADE = 'e-decade';
	var ICON = 'e-icons';
	var PREVICON$1 = 'e-prev';
	var NEXTICON$1 = 'e-next';
	var PREVSPAN = 'e-date-icon-prev';
	var NEXTSPAN = 'e-date-icon-next ';
	var ICONCONTAINER$1 = 'e-icon-container';
	var DISABLED$1 = 'e-disabled';
	var OVERLAY$1 = 'e-overlay';
	var WEEKEND = 'e-weekend';
	var WEEKNUMBER$1 = 'e-week-number';
	var SELECTED$1 = 'e-selected';
	var FOCUSEDDATE = 'e-focused-date';
	var OTHERMONTHROW = 'e-month-hide';
	var TODAY$1 = 'e-today';
	var TITLE$1 = 'e-title';
	var LINK = 'e-day';
	var CELL = 'e-cell';
	var WEEKHEADER = 'e-week-header';
	var ZOOMIN$1 = 'e-zoomin';
	var FOOTER$1 = 'e-footer-container';
	var BTN = 'e-btn';
	var FLAT$1 = 'e-flat';
	var CSS$1 = 'e-css';
	var PRIMARY$1 = 'e-primary';
	var DAYHEADERLONG$1 = 'e-calendar-day-header-lg';
	var dayMilliSeconds = 86400000;
	var minutesMilliSeconds = 60000;
	/**
	 *
	 * @private
	 */
	var CalendarBase = /** @class */ (function (_super) {
	    __extends$H(CalendarBase, _super);
	    /**
	     * Initialized new instance of Calendar Class.
	     * Constructor for creating the widget
	     *
	     * @param {CalendarBaseModel} options - Specifies the CalendarBase model.
	     * @param {string | HTMLElement} element - Specifies the element to render as component.
	     * @private
	     */
	    function CalendarBase(options, element) {
	        var _this = _super.call(this, options, element) || this;
	        _this.effect = '';
	        _this.isPopupClicked = false;
	        _this.isDateSelected = true;
	        _this.isTodayClicked = false;
	        _this.preventChange = false;
	        _this.isAngular = false;
	        _this.previousDates = false;
	        return _this;
	    }
	    /**
	     * To Initialize the control rendering.
	     *
	     * @returns {void}
	     * @private
	     */
	    CalendarBase.prototype.render = function () {
	        this.rangeValidation(this.min, this.max);
	        this.calendarEleCopy = this.element.cloneNode(true);
	        if (this.calendarMode === 'Islamic') {
	            if (+(this.min.setSeconds(0)) === +new Date(1900, 0, 1, 0, 0, 0)) {
	                this.min = new Date(1944, 2, 18);
	            }
	            if (+this.max === +new Date(2099, 11, 31)) {
	                this.max = new Date(2069, 10, 16);
	            }
	        }
	        this.globalize = new Internationalization(this.locale);
	        if (isNullOrUndefined(this.firstDayOfWeek) || this.firstDayOfWeek > 6 || this.firstDayOfWeek < 0) {
	            this.setProperties({ firstDayOfWeek: this.globalize.getFirstDayOfWeek() }, true);
	        }
	        this.todayDisabled = false;
	        this.todayDate = new Date(new Date().setHours(0, 0, 0, 0));
	        if (this.getModuleName() === 'calendar') {
	            this.element.classList.add(ROOT$1);
	            if (this.enableRtl) {
	                this.element.classList.add(RTL$1);
	            }
	            if (Browser.isDevice) {
	                this.element.classList.add(DEVICE$1);
	            }
	            attributes(this.element, {
	                'data-role': 'calendar'
	            });
	            this.tabIndex = this.element.hasAttribute('tabindex') ? this.element.getAttribute('tabindex') : '0';
	            this.element.setAttribute('tabindex', this.tabIndex);
	        }
	        else {
	            this.calendarElement = this.createElement('div');
	            this.calendarElement.classList.add(ROOT$1);
	            if (this.enableRtl) {
	                this.calendarElement.classList.add(RTL$1);
	            }
	            if (Browser.isDevice) {
	                this.calendarElement.classList.add(DEVICE$1);
	            }
	            attributes(this.calendarElement, {
	                'data-role': 'calendar'
	            });
	        }
	        if (!isNullOrUndefined(closest(this.element, 'fieldset')) && closest(this.element, 'fieldset').disabled) {
	            this.enabled = false;
	        }
	        this.createHeader();
	        this.createContent();
	        this.wireEvents();
	    };
	    CalendarBase.prototype.rangeValidation = function (min, max) {
	        if (isNullOrUndefined(min)) {
	            this.setProperties({ min: new Date(1900, 0, 1) }, true);
	        }
	        if (isNullOrUndefined(max)) {
	            this.setProperties({ max: new Date(2099, 11, 31) }, true);
	        }
	    };
	    CalendarBase.prototype.getDefaultKeyConfig = function () {
	        this.defaultKeyConfigs = {
	            controlUp: 'ctrl+38',
	            controlDown: 'ctrl+40',
	            moveDown: 'downarrow',
	            moveUp: 'uparrow',
	            moveLeft: 'leftarrow',
	            moveRight: 'rightarrow',
	            select: 'enter',
	            home: 'home',
	            end: 'end',
	            pageUp: 'pageup',
	            pageDown: 'pagedown',
	            shiftPageUp: 'shift+pageup',
	            shiftPageDown: 'shift+pagedown',
	            controlHome: 'ctrl+home',
	            controlEnd: 'ctrl+end',
	            altUpArrow: 'alt+uparrow',
	            spacebar: 'space',
	            altRightArrow: 'alt+rightarrow',
	            altLeftArrow: 'alt+leftarrow'
	        };
	        return this.defaultKeyConfigs;
	    };
	    CalendarBase.prototype.validateDate = function (value) {
	        this.setProperties({ min: this.checkDateValue(new Date(this.checkValue(this.min))) }, true);
	        this.setProperties({ max: this.checkDateValue(new Date(this.checkValue(this.max))) }, true);
	        this.currentDate = this.currentDate ? this.currentDate : new Date(new Date().setHours(0, 0, 0, 0));
	        if (!isNullOrUndefined(value) && this.min <= this.max && value >= this.min && value <= this.max) {
	            this.currentDate = new Date(this.checkValue(value));
	        }
	    };
	    CalendarBase.prototype.setOverlayIndex = function (popupWrapper, popupElement, modal, isDevice) {
	        if (isDevice && !isNullOrUndefined(popupElement) && !isNullOrUndefined(modal) && !isNullOrUndefined(popupWrapper)) {
	            var index = parseInt(popupElement.style.zIndex, 10) ? parseInt(popupElement.style.zIndex, 10) : 1000;
	            modal.style.zIndex = (index - 1).toString();
	            popupWrapper.style.zIndex = index.toString();
	        }
	    };
	    CalendarBase.prototype.minMaxUpdate = function (value) {
	        if (!(+this.min <= +this.max)) {
	            this.setProperties({ min: this.min }, true);
	            addClass([this.element], OVERLAY$1);
	        }
	        else {
	            removeClass([this.element], OVERLAY$1);
	        }
	        this.min = isNullOrUndefined(this.min) || !(+this.min) ? this.min = new Date(1900, 0, 1) : this.min;
	        this.max = isNullOrUndefined(this.max) || !(+this.max) ? this.max = new Date(2099, 11, 31) : this.max;
	        if (+this.min <= +this.max && value && +value <= +this.max && +value >= +this.min) {
	            this.currentDate = new Date(this.checkValue(value));
	        }
	        else {
	            if (+this.min <= +this.max && !value && +this.currentDate > +this.max) {
	                this.currentDate = new Date(this.checkValue(this.max));
	            }
	            else {
	                if (+this.currentDate < +this.min) {
	                    this.currentDate = new Date(this.checkValue(this.min));
	                }
	            }
	        }
	    };
	    CalendarBase.prototype.createHeader = function () {
	        var ariaPrevAttrs = {
	            'aria-disabled': 'false',
	            'aria-label': 'previous month'
	        };
	        var ariaNextAttrs = {
	            'aria-disabled': 'false',
	            'aria-label': 'next month'
	        };
	        var ariaTitleAttrs = {
	            'aria-atomic': 'true', 'aria-live': 'assertive', 'aria-label': 'title'
	        };
	        this.headerElement = this.createElement('div', { className: HEADER$1 });
	        var iconContainer = this.createElement('div', { className: ICONCONTAINER$1 });
	        this.previousIcon = this.createElement('button', { className: '' + PREVICON$1, attrs: { type: 'button' } });
	        rippleEffect(this.previousIcon, {
	            duration: 400,
	            selector: '.e-prev',
	            isCenterRipple: true
	        });
	        attributes(this.previousIcon, ariaPrevAttrs);
	        this.nextIcon = this.createElement('button', { className: '' + NEXTICON$1, attrs: { type: 'button' } });
	        rippleEffect(this.nextIcon, {
	            selector: '.e-next',
	            duration: 400,
	            isCenterRipple: true
	        });
	        if (this.getModuleName() === 'daterangepicker') {
	            attributes(this.previousIcon, { tabIndex: '-1' });
	            attributes(this.nextIcon, { tabIndex: '-1' });
	        }
	        attributes(this.nextIcon, ariaNextAttrs);
	        this.headerTitleElement = this.createElement('div', { className: '' + LINK + ' ' + TITLE$1 });
	        attributes(this.headerTitleElement, ariaTitleAttrs);
	        this.headerElement.appendChild(this.headerTitleElement);
	        this.previousIcon.appendChild(this.createElement('span', { className: '' + PREVSPAN + ' ' + ICON }));
	        this.nextIcon.appendChild(this.createElement('span', { className: '' + NEXTSPAN + ' ' + ICON }));
	        iconContainer.appendChild(this.previousIcon);
	        iconContainer.appendChild(this.nextIcon);
	        this.headerElement.appendChild(iconContainer);
	        if (this.getModuleName() === 'calendar') {
	            this.element.appendChild(this.headerElement);
	        }
	        else {
	            this.calendarElement.appendChild(this.headerElement);
	        }
	        this.adjustLongHeaderSize();
	    };
	    CalendarBase.prototype.createContent = function () {
	        this.contentElement = this.createElement('div', { className: CONTENT$1 });
	        this.table = this.createElement('table', { attrs: { tabIndex: '0', 'role': 'grid', 'aria-activedescendant': '', 'aria-labelledby': this.element.id } });
	        if (this.getModuleName() === 'calendar') {
	            this.element.appendChild(this.contentElement);
	        }
	        else {
	            this.calendarElement.appendChild(this.contentElement);
	        }
	        this.contentElement.appendChild(this.table);
	        this.createContentHeader();
	        this.createContentBody();
	        if (this.showTodayButton) {
	            this.createContentFooter();
	        }
	    };
	    CalendarBase.prototype.getCultureValues = function () {
	        var culShortNames = [];
	        var cldrObj;
	        var dayFormat = 'days.stand-alone.' + this.dayHeaderFormat.toLowerCase();
	        if (this.locale === 'en' || this.locale === 'en-US') {
	            cldrObj = (getValue(dayFormat, getDefaultDateObject()));
	        }
	        else {
	            cldrObj = (this.getCultureObjects(cldrData, '' + this.locale));
	        }
	        if (!isNullOrUndefined(cldrObj)) {
	            for (var _i = 0, _a = Object.keys(cldrObj); _i < _a.length; _i++) {
	                var obj = _a[_i];
	                culShortNames.push(getValue(obj, cldrObj));
	            }
	        }
	        return culShortNames;
	    };
	    CalendarBase.prototype.toCapitalize = function (text) {
	        return !isNullOrUndefined(text) && text.length ? text[0].toUpperCase() + text.slice(1) : text;
	    };
	    CalendarBase.prototype.createContentHeader = function () {
	        if (this.getModuleName() === 'calendar') {
	            if (!isNullOrUndefined(this.element.querySelectorAll('.e-content .e-week-header')[0])) {
	                detach(this.element.querySelectorAll('.e-content .e-week-header')[0]);
	            }
	        }
	        else {
	            if (!isNullOrUndefined(this.calendarElement.querySelectorAll('.e-content .e-week-header')[0])) {
	                detach(this.calendarElement.querySelectorAll('.e-content .e-week-header')[0]);
	            }
	        }
	        var daysCount = 6;
	        var html = '';
	        if (this.firstDayOfWeek > 6 || this.firstDayOfWeek < 0) {
	            this.setProperties({ firstDayOfWeek: 0 }, true);
	        }
	        this.tableHeadElement = this.createElement('thead', { className: WEEKHEADER });
	        if (this.weekNumber) {
	            html += '<th class="e-week-number"></th>';
	            if (this.getModuleName() === 'calendar') {
	                addClass([this.element], '' + WEEKNUMBER$1);
	            }
	            else {
	                addClass([this.calendarElement], '' + WEEKNUMBER$1);
	            }
	        }
	        // eslint-disable-next-line max-len
	        var shortNames = this.getCultureValues().length > 0 && this.getCultureValues() ? this.shiftArray(((this.getCultureValues().length > 0 && this.getCultureValues())), this.firstDayOfWeek) : null;
	        if (!isNullOrUndefined(shortNames)) {
	            for (var days = 0; days <= daysCount; days++) {
	                html += '<th  class="">' + this.toCapitalize(shortNames[days]) + '</th>';
	            }
	        }
	        html = '<tr>' + html + '</tr>';
	        this.tableHeadElement.innerHTML = html;
	        this.table.appendChild(this.tableHeadElement);
	    };
	    CalendarBase.prototype.createContentBody = function () {
	        if (this.getModuleName() === 'calendar') {
	            if (!isNullOrUndefined(this.element.querySelectorAll('.e-content tbody')[0])) {
	                detach(this.element.querySelectorAll('.e-content tbody')[0]);
	            }
	        }
	        else {
	            if (!isNullOrUndefined(this.calendarElement.querySelectorAll('.e-content tbody')[0])) {
	                detach(this.calendarElement.querySelectorAll('.e-content tbody')[0]);
	            }
	        }
	        switch (this.start) {
	            case 'Year':
	                this.renderYears();
	                break;
	            case 'Decade':
	                this.renderDecades();
	                break;
	            default:
	                this.renderMonths();
	        }
	    };
	    CalendarBase.prototype.updateFooter = function () {
	        this.todayElement.textContent = this.l10.getConstant('today');
	        this.todayElement.setAttribute('aria-label', this.l10.getConstant('today'));
	    };
	    CalendarBase.prototype.createContentFooter = function () {
	        if (this.showTodayButton) {
	            var minimum = new Date(+this.min);
	            var maximum = new Date(+this.max);
	            var l10nLocale = { today: 'Today' };
	            this.globalize = new Internationalization(this.locale);
	            this.l10 = new L10n(this.getModuleName(), l10nLocale, this.locale);
	            this.todayElement = this.createElement('button', { attrs: { role: 'button' } });
	            rippleEffect(this.todayElement);
	            this.updateFooter();
	            addClass([this.todayElement], [BTN, TODAY$1, FLAT$1, PRIMARY$1, CSS$1]);
	            if ((!(+new Date(minimum.setHours(0, 0, 0, 0)) <= +this.todayDate &&
	                +this.todayDate <= +new Date(maximum.setHours(0, 0, 0, 0)))) || (this.todayDisabled)) {
	                addClass([this.todayElement], DISABLED$1);
	            }
	            this.footer = this.createElement('div', { className: FOOTER$1 });
	            this.footer.appendChild(this.todayElement);
	            if (this.getModuleName() === 'calendar') {
	                this.element.appendChild(this.footer);
	            }
	            if (this.getModuleName() === 'datepicker') {
	                this.calendarElement.appendChild(this.footer);
	            }
	            if (this.getModuleName() === 'datetimepicker') {
	                this.calendarElement.appendChild(this.footer);
	            }
	            if (!this.todayElement.classList.contains(DISABLED$1)) {
	                EventHandler.add(this.todayElement, 'click', this.todayButtonClick, this);
	            }
	        }
	    };
	    CalendarBase.prototype.wireEvents = function (id, ref, keyConfig, moduleName) {
	        EventHandler.add(this.headerTitleElement, 'click', this.navigateTitle, this);
	        this.defaultKeyConfigs = extend(this.defaultKeyConfigs, this.keyConfigs);
	        if (this.getModuleName() === 'calendar') {
	            this.keyboardModule = new KeyboardEvents(this.element, {
	                eventName: 'keydown',
	                keyAction: this.keyActionHandle.bind(this),
	                keyConfigs: this.defaultKeyConfigs
	            });
	        }
	        else {
	            this.keyboardModule = new KeyboardEvents(this.calendarElement, {
	                eventName: 'keydown',
	                keyAction: this.keyActionHandle.bind(this),
	                keyConfigs: this.defaultKeyConfigs
	            });
	        }
	    };
	    CalendarBase.prototype.dateWireEvents = function (id, ref, keyConfig, moduleName) {
	        this.defaultKeyConfigs = this.getDefaultKeyConfig();
	        this.defaultKeyConfigs = extend(this.defaultKeyConfigs, keyConfig);
	        this.serverModuleName = moduleName;
	    };
	    CalendarBase.prototype.todayButtonClick = function (e, value, isCustomDate) {
	        if (this.showTodayButton) {
	            if (this.currentView() === this.depth) {
	                this.effect = '';
	            }
	            else {
	                this.effect = 'e-zoomin';
	            }
	            if (this.getViewNumber(this.start) >= this.getViewNumber(this.depth)) {
	                this.navigateTo(this.depth, new Date(this.checkValue(value)), isCustomDate);
	            }
	            else {
	                this.navigateTo('Month', new Date(this.checkValue(value)), isCustomDate);
	            }
	        }
	    };
	    CalendarBase.prototype.resetCalendar = function () {
	        this.calendarElement && detach(this.calendarElement);
	        this.tableBodyElement && detach(this.tableBodyElement);
	        this.table && detach(this.table);
	        this.tableHeadElement && detach(this.tableHeadElement);
	        this.nextIcon && detach(this.nextIcon);
	        this.previousIcon && detach(this.previousIcon);
	        this.footer && detach(this.footer);
	        this.todayElement = null;
	        this.renderDayCellArgs = null;
	        this.calendarElement = this.tableBodyElement = this.footer = this.tableHeadElement =
	            this.nextIcon = this.previousIcon = this.table = null;
	    };
	    CalendarBase.prototype.keyActionHandle = function (e, value, multiSelection) {
	        var focusedDate = this.tableBodyElement.querySelector('tr td.e-focused-date');
	        var selectedDate;
	        if (multiSelection) {
	            if (!isNullOrUndefined(focusedDate) && +value === parseInt(focusedDate.getAttribute('id').split('_')[0], 10)) {
	                selectedDate = focusedDate;
	            }
	            else {
	                selectedDate = this.tableBodyElement.querySelector('tr td.e-selected');
	            }
	        }
	        else {
	            selectedDate = this.tableBodyElement.querySelector('tr td.e-selected');
	        }
	        var view = this.getViewNumber(this.currentView());
	        var depthValue = this.getViewNumber(this.depth);
	        var levelRestrict = (view === depthValue && this.getViewNumber(this.start) >= depthValue);
	        this.effect = '';
	        switch (e.action) {
	            case 'moveLeft':
	                this.keyboardNavigate(-1, view, e, this.max, this.min);
	                e.preventDefault();
	                break;
	            case 'moveRight':
	                this.keyboardNavigate(1, view, e, this.max, this.min);
	                e.preventDefault();
	                break;
	            case 'moveUp':
	                if (view === 0) {
	                    this.keyboardNavigate(-7, view, e, this.max, this.min); // move the current date to the previous seven days.
	                }
	                else {
	                    this.keyboardNavigate(-4, view, e, this.max, this.min); // move the current year to the previous four days.
	                }
	                e.preventDefault();
	                break;
	            case 'moveDown':
	                if (view === 0) {
	                    this.keyboardNavigate(7, view, e, this.max, this.min);
	                }
	                else {
	                    this.keyboardNavigate(4, view, e, this.max, this.min);
	                }
	                e.preventDefault();
	                break;
	            case 'select':
	                if (e.target === this.todayElement) {
	                    this.todayButtonClick(e, value);
	                }
	                else {
	                    var element = !isNullOrUndefined(focusedDate) ? focusedDate : selectedDate;
	                    if (!isNullOrUndefined(element) && !element.classList.contains(DISABLED$1)) {
	                        if (levelRestrict) {
	                            // eslint-disable-next-line radix
	                            var d = new Date(parseInt('' + (element).id, 0));
	                            this.selectDate(e, d, (element));
	                        }
	                        else {
	                            this.contentClick(null, --view, (element), value);
	                        }
	                    }
	                }
	                break;
	            case 'controlUp':
	                this.title();
	                e.preventDefault();
	                break;
	            case 'controlDown':
	                if (!isNullOrUndefined(focusedDate) && !levelRestrict || !isNullOrUndefined(selectedDate) && !levelRestrict) {
	                    this.contentClick(null, --view, (focusedDate || selectedDate), value);
	                }
	                e.preventDefault();
	                break;
	            case 'home':
	                this.currentDate = this.firstDay(this.currentDate);
	                detach(this.tableBodyElement);
	                if (view === 0) {
	                    this.renderMonths(e);
	                }
	                else if (view === 1) {
	                    this.renderYears(e);
	                }
	                else {
	                    this.renderDecades(e);
	                }
	                e.preventDefault();
	                break;
	            case 'end':
	                this.currentDate = this.lastDay(this.currentDate, view);
	                detach(this.tableBodyElement);
	                if (view === 0) {
	                    this.renderMonths(e);
	                }
	                else if (view === 1) {
	                    this.renderYears(e);
	                }
	                else {
	                    this.renderDecades(e);
	                }
	                e.preventDefault();
	                break;
	            case 'pageUp':
	                this.addMonths(this.currentDate, -1);
	                this.navigateTo('Month', this.currentDate);
	                e.preventDefault();
	                break;
	            case 'pageDown':
	                this.addMonths(this.currentDate, 1);
	                this.navigateTo('Month', this.currentDate);
	                e.preventDefault();
	                break;
	            case 'shiftPageUp':
	                this.addYears(this.currentDate, -1);
	                this.navigateTo('Month', this.currentDate);
	                e.preventDefault();
	                break;
	            case 'shiftPageDown':
	                this.addYears(this.currentDate, 1);
	                this.navigateTo('Month', this.currentDate);
	                e.preventDefault();
	                break;
	            case 'controlHome':
	                this.navigateTo('Month', new Date(this.currentDate.getFullYear(), 0, 1));
	                e.preventDefault();
	                break;
	            case 'controlEnd':
	                this.navigateTo('Month', new Date(this.currentDate.getFullYear(), 11, 31));
	                e.preventDefault();
	                break;
	        }
	        if (this.getModuleName() === 'calendar') {
	            this.table.focus();
	        }
	    };
	    CalendarBase.prototype.keyboardNavigate = function (number, currentView, e, max, min) {
	        var date = new Date(this.checkValue(this.currentDate));
	        switch (currentView) {
	            case 2:
	                this.addYears(this.currentDate, number);
	                if (this.isMonthYearRange(this.currentDate)) {
	                    detach(this.tableBodyElement);
	                    this.renderDecades(e);
	                }
	                else {
	                    this.currentDate = date;
	                }
	                break;
	            case 1:
	                this.addMonths(this.currentDate, number);
	                if (this.calendarMode === 'Gregorian') {
	                    if (this.isMonthYearRange(this.currentDate)) {
	                        detach(this.tableBodyElement);
	                        this.renderYears(e);
	                    }
	                    else {
	                        this.currentDate = date;
	                    }
	                }
	                else {
	                    if (this.isMonthYearRange(this.currentDate)) {
	                        detach(this.tableBodyElement);
	                        this.renderYears(e);
	                    }
	                    else {
	                        this.currentDate = date;
	                    }
	                }
	                break;
	            case 0:
	                this.addDay(this.currentDate, number, e, max, min);
	                if (this.isMinMaxRange(this.currentDate)) {
	                    detach(this.tableBodyElement);
	                    this.renderMonths(e);
	                }
	                else {
	                    this.currentDate = date;
	                }
	                break;
	        }
	    };
	    /**
	     * Initialize the event handler
	     *
	     * @param {Date} value - Specifies value of date.
	     * @returns {void}
	     * @private
	     */
	    // eslint-disable-next-line @typescript-eslint/no-unused-vars
	    CalendarBase.prototype.preRender = function (value) {
	        var _this = this;
	        this.navigatePreviousHandler = this.navigatePrevious.bind(this);
	        this.navigateNextHandler = this.navigateNext.bind(this);
	        this.defaultKeyConfigs = this.getDefaultKeyConfig();
	        this.navigateHandler = function (e) {
	            _this.triggerNavigate(e);
	        };
	    };
	    CalendarBase.prototype.minMaxDate = function (localDate) {
	        var currentDate = new Date(new Date(+localDate).setHours(0, 0, 0, 0));
	        var minDate = new Date(new Date(+this.min).setHours(0, 0, 0, 0));
	        var maxDate = new Date(new Date(+this.max).setHours(0, 0, 0, 0));
	        if (+currentDate === +minDate || +currentDate === +maxDate) {
	            if (+localDate < +this.min) {
	                localDate = new Date(+this.min);
	            }
	            if (+localDate > +this.max) {
	                localDate = new Date(+this.max);
	            }
	        }
	        return localDate;
	    };
	    CalendarBase.prototype.renderMonths = function (e, value, isCustomDate) {
	        var numCells = this.weekNumber ? 8 : 7;
	        var tdEles;
	        if (this.calendarMode === 'Gregorian') {
	            tdEles = this.renderDays(this.currentDate, value, null, null, isCustomDate, e);
	        }
	        else {
	            tdEles = this.islamicModule.islamicRenderDays(this.currentDate, value);
	        }
	        this.createContentHeader();
	        if (this.calendarMode === 'Gregorian') {
	            this.renderTemplate(tdEles, numCells, MONTH, e, value);
	        }
	        else {
	            this.islamicModule.islamicRenderTemplate(tdEles, numCells, MONTH, e, value);
	        }
	    };
	    CalendarBase.prototype.renderDays = function (currentDate, value, multiSelection, values, isTodayDate, e) {
	        var tdEles = [];
	        var cellsCount = 42;
	        var todayDate = isTodayDate ? new Date(+currentDate) : this.getDate(new Date(), this.timezone);
	        var localDate = new Date(this.checkValue(currentDate));
	        var minMaxDate;
	        var currentMonth = localDate.getMonth();
	        this.titleUpdate(currentDate, 'days');
	        var d = localDate;
	        localDate = new Date(d.getFullYear(), d.getMonth(), 0, d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
	        while (localDate.getDay() !== this.firstDayOfWeek) {
	            this.setStartDate(localDate, -1 * dayMilliSeconds);
	        }
	        for (var day = 0; day < cellsCount; ++day) {
	            var weekEle = this.createElement('td', { className: CELL });
	            var weekAnchor = this.createElement('span');
	            if (day % 7 === 0 && this.weekNumber) {
	                // 6 days are added to get Last day of the week and 3 days are added to get middle day of the week.
	                var numberOfDays = this.weekRule === 'FirstDay' ? 6 : (this.weekRule === 'FirstFourDayWeek' ? 3 : 0);
	                var finalDate = new Date(localDate.getFullYear(), localDate.getMonth(), (localDate.getDate() + numberOfDays));
	                weekAnchor.textContent = '' + this.getWeek(finalDate);
	                weekEle.appendChild(weekAnchor);
	                addClass([weekEle], '' + WEEKNUMBER$1);
	                tdEles.push(weekEle);
	            }
	            minMaxDate = new Date(+localDate);
	            localDate = this.minMaxDate(localDate);
	            var dateFormatOptions = { type: 'dateTime', skeleton: 'full' };
	            var date = this.globalize.parseDate(this.globalize.formatDate(localDate, dateFormatOptions), dateFormatOptions);
	            var tdEle = this.dayCell(localDate);
	            var title = this.globalize.formatDate(localDate, { type: 'date', skeleton: 'full' });
	            var dayLink = this.createElement('span');
	            dayLink.textContent = this.globalize.formatDate(localDate, { format: 'd', type: 'date', skeleton: 'yMd' });
	            var disabled = (this.min > localDate) || (this.max < localDate);
	            if (disabled) {
	                addClass([tdEle], DISABLED$1);
	                addClass([tdEle], OVERLAY$1);
	            }
	            else {
	                dayLink.setAttribute('title', '' + title);
	            }
	            if (currentMonth !== localDate.getMonth()) {
	                addClass([tdEle], OTHERMONTH$1);
	            }
	            if (localDate.getDay() === 0 || localDate.getDay() === 6) {
	                addClass([tdEle], WEEKEND);
	            }
	            tdEle.appendChild(dayLink);
	            this.renderDayCellArgs = {
	                date: localDate,
	                isDisabled: false,
	                element: tdEle,
	                isOutOfRange: disabled
	            };
	            var argument = this.renderDayCellArgs;
	            this.renderDayCellEvent(argument);
	            if (argument.isDisabled) {
	                var selectDate = new Date(this.checkValue(value));
	                var argsDate = new Date(this.checkValue(argument.date));
	                if (multiSelection) {
	                    if (!isNullOrUndefined(values) && values.length > 0) {
	                        for (var index = 0; index < values.length; index++) {
	                            var localDateString = +new Date(this.globalize.formatDate(argument.date, { type: 'date', skeleton: 'yMd' }));
	                            var tempDateString = +new Date(this.globalize.formatDate(values[index], { type: 'date', skeleton: 'yMd' }));
	                            if (localDateString === tempDateString) {
	                                values.splice(index, 1);
	                                index = -1;
	                            }
	                        }
	                    }
	                }
	                else if (selectDate && +selectDate === +argsDate) {
	                    this.setProperties({ value: null }, true);
	                }
	            }
	            if (this.renderDayCellArgs.isDisabled && !tdEle.classList.contains(SELECTED$1)) {
	                addClass([tdEle], DISABLED$1);
	                addClass([tdEle], OVERLAY$1);
	                if (+this.renderDayCellArgs.date === +this.todayDate) {
	                    this.todayDisabled = true;
	                }
	            }
	            var otherMnthBool = tdEle.classList.contains(OTHERMONTH$1);
	            var disabledCls = tdEle.classList.contains(DISABLED$1);
	            if (!disabledCls) {
	                EventHandler.add(tdEle, 'click', this.clickHandler, this);
	            }
	            // to set the value as null while setting the disabled date onProperty change.
	            // if (args.isDisabled && +this.value === +args.date) {
	            //     this.setProperties({ value: null }, true);
	            // }
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            var currentTarget = void 0;
	            if (!isNullOrUndefined(e) && e.type === 'click') {
	                currentTarget = e.currentTarget;
	            }
	            if (multiSelection && !isNullOrUndefined(values) && !disabledCls) {
	                for (var tempValue = 0; tempValue < values.length; tempValue++) {
	                    var type = (this.calendarMode === 'Gregorian') ? 'gregorian' : 'islamic';
	                    var formatOptions = { format: null, type: 'date', skeleton: 'short', calendar: type };
	                    var localDateString = this.globalize.formatDate(localDate, formatOptions);
	                    var tempDateString = this.globalize.formatDate(values[tempValue], formatOptions);
	                    if ((localDateString === tempDateString && this.getDateVal(localDate, values[tempValue]))
	                        || (this.getDateVal(localDate, value))) {
	                        addClass([tdEle], SELECTED$1);
	                    }
	                    if (!isNullOrUndefined(currentTarget) && currentTarget.innerText === tdEle.innerText &&
	                        this.previousDates && tdEle.classList.contains(SELECTED$1) && currentTarget.classList.contains(SELECTED$1)) {
	                        removeClass([tdEle], SELECTED$1);
	                        this.previousDates = false;
	                        var copyValues = this.copyValues(values);
	                        for (var i = 0; i < copyValues.length; i++) {
	                            var type_1 = (this.calendarMode === 'Gregorian') ? 'gregorian' : 'islamic';
	                            var formatOptions_1 = { format: null, type: 'date', skeleton: 'short', calendar: type_1 };
	                            var localDateString_1 = this.globalize.formatDate(date, formatOptions_1);
	                            var tempDateString_1 = this.globalize.formatDate(copyValues[i], formatOptions_1);
	                            if (localDateString_1 === tempDateString_1) {
	                                var index = copyValues.indexOf(copyValues[i]);
	                                copyValues.splice(index, 1);
	                                values.splice(index, 1);
	                            }
	                        }
	                        this.setProperties({ values: copyValues }, true);
	                    }
	                    else {
	                        this.updateFocus(otherMnthBool, disabledCls, localDate, tdEle, currentDate);
	                    }
	                }
	                if (values.length <= 0) {
	                    this.updateFocus(otherMnthBool, disabledCls, localDate, tdEle, currentDate);
	                }
	            }
	            else if (!disabledCls && this.getDateVal(localDate, value)) {
	                addClass([tdEle], SELECTED$1);
	            }
	            this.updateFocus(otherMnthBool, disabledCls, localDate, tdEle, currentDate);
	            if (!isNullOrUndefined(date) && date.getFullYear() === todayDate.getFullYear() && date.getMonth() === todayDate.getMonth()
	                && date.getDate() === todayDate.getDate()) {
	                addClass([tdEle], TODAY$1);
	            }
	            tdEles.push(this.renderDayCellArgs.element);
	            localDate = new Date(+minMaxDate);
	            this.addDay(localDate, 1, null, this.max, this.min);
	        }
	        return tdEles;
	    };
	    CalendarBase.prototype.updateFocus = function (otherMonth, disabled, localDate, tableElement, currentDate) {
	        if (currentDate.getDate() === localDate.getDate() && !otherMonth && !disabled) {
	            addClass([tableElement], FOCUSEDDATE);
	        }
	        else {
	            // eslint-disable-next-line radix
	            if (currentDate >= this.max && parseInt(tableElement.id, 0) === +this.max && !otherMonth && !disabled) {
	                addClass([tableElement], FOCUSEDDATE);
	            }
	            // eslint-disable-next-line radix
	            if (currentDate <= this.min && parseInt(tableElement.id, 0) === +this.min && !otherMonth && !disabled) {
	                addClass([tableElement], FOCUSEDDATE);
	            }
	        }
	    };
	    CalendarBase.prototype.renderYears = function (e, value) {
	        this.removeTableHeadElement();
	        var numCells = 4;
	        var tdEles = [];
	        var valueUtil = isNullOrUndefined(value);
	        var curDate = new Date(this.checkValue(this.currentDate));
	        var mon = curDate.getMonth();
	        var yr = curDate.getFullYear();
	        var localDate = curDate;
	        var curYrs = localDate.getFullYear();
	        var minYr = new Date(this.checkValue(this.min)).getFullYear();
	        var minMonth = new Date(this.checkValue(this.min)).getMonth();
	        var maxYr = new Date(this.checkValue(this.max)).getFullYear();
	        var maxMonth = new Date(this.checkValue(this.max)).getMonth();
	        localDate.setMonth(0);
	        this.titleUpdate(this.currentDate, 'months');
	        localDate.setDate(1);
	        for (var month = 0; month < 12; ++month) {
	            var tdEle = this.dayCell(localDate);
	            var dayLink = this.createElement('span');
	            var localMonth = (value && (value).getMonth() === localDate.getMonth());
	            var select = (value && (value).getFullYear() === yr && localMonth);
	            var title = this.globalize.formatDate(localDate, { type: 'date', format: 'MMM y' });
	            dayLink.textContent = this.toCapitalize(this.globalize.formatDate(localDate, {
	                format: null, type: 'dateTime', skeleton: 'MMM'
	            }));
	            if ((this.min && (curYrs < minYr || (month < minMonth && curYrs === minYr))) || (this.max && (curYrs > maxYr || (month > maxMonth && curYrs >= maxYr)))) {
	                addClass([tdEle], DISABLED$1);
	            }
	            else if (!valueUtil && select) {
	                addClass([tdEle], SELECTED$1);
	            }
	            else {
	                if (localDate.getMonth() === mon && this.currentDate.getMonth() === mon) {
	                    addClass([tdEle], FOCUSEDDATE);
	                }
	            }
	            localDate.setDate(1);
	            localDate.setMonth(localDate.getMonth() + 1);
	            if (!tdEle.classList.contains(DISABLED$1)) {
	                EventHandler.add(tdEle, 'click', this.clickHandler, this);
	                dayLink.setAttribute('title', '' + title);
	            }
	            tdEle.appendChild(dayLink);
	            tdEles.push(tdEle);
	        }
	        this.renderTemplate(tdEles, numCells, YEAR, e, value);
	    };
	    CalendarBase.prototype.renderDecades = function (e, value) {
	        this.removeTableHeadElement();
	        var numCells = 4;
	        var yearCell = 12;
	        var tdEles = [];
	        var localDate = new Date(this.checkValue(this.currentDate));
	        localDate.setMonth(0);
	        localDate.setDate(1);
	        var localYr = localDate.getFullYear();
	        var startYr = new Date(localDate.setFullYear((localYr - localYr % 10)));
	        var endYr = new Date(localDate.setFullYear((localYr - localYr % 10 + (10 - 1))));
	        var startFullYr = startYr.getFullYear();
	        var endFullYr = endYr.getFullYear();
	        var startHdrYr = this.globalize.formatDate(startYr, {
	            format: null, type: 'dateTime', skeleton: 'y'
	        });
	        var endHdrYr = this.globalize.formatDate(endYr, { format: null, type: 'dateTime', skeleton: 'y' });
	        this.headerTitleElement.textContent = startHdrYr + ' - ' + (endHdrYr);
	        var start = new Date(localYr - (localYr % 10) - 1, 0, 1);
	        var startYear = start.getFullYear();
	        for (var rowIterator = 0; rowIterator < yearCell; ++rowIterator) {
	            var year = startYear + rowIterator;
	            localDate.setFullYear(year);
	            var tdEle = this.dayCell(localDate);
	            var dayLink = this.createElement('span');
	            dayLink.textContent = this.globalize.formatDate(localDate, {
	                format: null, type: 'dateTime', skeleton: 'y'
	            });
	            if ((year < startFullYr) || (year > endFullYr)) {
	                addClass([tdEle], OTHERDECADE);
	                if (!isNullOrUndefined(value) && localDate.getFullYear() === (value).getFullYear()) {
	                    addClass([tdEle], SELECTED$1);
	                }
	                if (year < new Date(this.checkValue(this.min)).getFullYear() ||
	                    year > new Date(this.checkValue(this.max)).getFullYear()) {
	                    addClass([tdEle], DISABLED$1);
	                }
	            }
	            else if (year < new Date(this.checkValue(this.min)).getFullYear() ||
	                year > new Date(this.checkValue(this.max)).getFullYear()) {
	                addClass([tdEle], DISABLED$1);
	            }
	            else if (!isNullOrUndefined(value) && localDate.getFullYear() === (value).getFullYear()) {
	                addClass([tdEle], SELECTED$1);
	            }
	            else {
	                if (localDate.getFullYear() === this.currentDate.getFullYear() && !tdEle.classList.contains(DISABLED$1)) {
	                    addClass([tdEle], FOCUSEDDATE);
	                }
	            }
	            if (!tdEle.classList.contains(DISABLED$1)) {
	                EventHandler.add(tdEle, 'click', this.clickHandler, this);
	                dayLink.setAttribute('title', '' + dayLink.textContent);
	            }
	            tdEle.appendChild(dayLink);
	            tdEles.push(tdEle);
	        }
	        this.renderTemplate(tdEles, numCells, 'e-decade', e, value);
	    };
	    CalendarBase.prototype.dayCell = function (localDate) {
	        var type = (this.calendarMode === 'Gregorian') ? 'gregorian' : 'islamic';
	        var dateFormatOptions = { skeleton: 'full', type: 'dateTime', calendar: type };
	        var date = this.globalize.parseDate(this.globalize.formatDate(localDate, dateFormatOptions), dateFormatOptions);
	        var value;
	        if (!isNullOrUndefined(date)) {
	            value = date.valueOf();
	        }
	        var attrs = {
	            className: CELL, attrs: { 'id': '' + getUniqueID('' + value), 'aria-selected': 'false' }
	        };
	        return this.createElement('td', attrs);
	    };
	    CalendarBase.prototype.firstDay = function (date) {
	        var collection = this.currentView() !== 'Decade' ? this.tableBodyElement.querySelectorAll('td' + ':not(.' + OTHERMONTH$1 + '') :
	            this.tableBodyElement.querySelectorAll('td' + ':not(.' + OTHERDECADE + '');
	        if (collection.length) {
	            for (var i = 0; i < collection.length; i++) {
	                if (!collection[i].classList.contains(DISABLED$1)) {
	                    // eslint-disable-next-line radix
	                    date = new Date(parseInt(collection[i].id, 0));
	                    break;
	                }
	            }
	        }
	        return date;
	    };
	    CalendarBase.prototype.lastDay = function (date, view) {
	        var lastDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
	        if (view !== 2) {
	            var timeOffset = Math.abs(lastDate.getTimezoneOffset() - this.firstDay(date).getTimezoneOffset());
	            if (timeOffset) {
	                lastDate.setHours(this.firstDay(date).getHours() + (timeOffset / 60));
	            }
	            return this.findLastDay(lastDate);
	        }
	        else {
	            return this.findLastDay(this.firstDay(lastDate));
	        }
	    };
	    CalendarBase.prototype.checkDateValue = function (value) {
	        return (!isNullOrUndefined(value) && value instanceof Date && !isNaN(+value)) ? value : null;
	    };
	    CalendarBase.prototype.findLastDay = function (date) {
	        var collection = this.currentView() === 'Decade' ? this.tableBodyElement.querySelectorAll('td' + ':not(.' + OTHERDECADE + '') :
	            this.tableBodyElement.querySelectorAll('td' + ':not(.' + OTHERMONTH$1 + '');
	        if (collection.length) {
	            for (var i = collection.length - 1; i >= 0; i--) {
	                if (!collection[i].classList.contains(DISABLED$1)) {
	                    // eslint-disable-next-line radix
	                    date = new Date(parseInt(collection[i].id, 0));
	                    break;
	                }
	            }
	        }
	        return date;
	    };
	    CalendarBase.prototype.removeTableHeadElement = function () {
	        if (this.getModuleName() === 'calendar') {
	            if (!isNullOrUndefined(this.element.querySelectorAll('.e-content table thead')[0])) {
	                detach(this.tableHeadElement);
	            }
	        }
	        else {
	            if (!isNullOrUndefined(this.calendarElement.querySelectorAll('.e-content table thead')[0])) {
	                detach(this.tableHeadElement);
	            }
	        }
	    };
	    // eslint-disable-next-line @typescript-eslint/no-unused-vars
	    CalendarBase.prototype.renderTemplate = function (elements, count, classNm, e, value) {
	        var view = this.getViewNumber(this.currentView());
	        var trEle;
	        this.tableBodyElement = this.createElement('tbody');
	        this.table.appendChild(this.tableBodyElement);
	        removeClass([this.contentElement, this.headerElement], [MONTH, DECADE, YEAR]);
	        addClass([this.contentElement, this.headerElement], [classNm]);
	        var weekNumCell = 41;
	        var numberCell = 35;
	        var otherMonthCell = 6;
	        var row = count;
	        var rowIterator = 0;
	        for (var dayCell = 0; dayCell < elements.length / count; ++dayCell) {
	            trEle = this.createElement('tr');
	            for (rowIterator = 0 + rowIterator; rowIterator < row; rowIterator++) {
	                if (!elements[rowIterator].classList.contains('e-week-number') && !isNullOrUndefined(elements[rowIterator].children[0])) {
	                    addClass([elements[rowIterator].children[0]], [LINK]);
	                    rippleEffect(elements[rowIterator].children[0], {
	                        duration: 600,
	                        isCenterRipple: true
	                    });
	                }
	                trEle.appendChild(elements[rowIterator]);
	                if (this.weekNumber && rowIterator === otherMonthCell + 1 && elements[otherMonthCell + 1].classList.contains(OTHERMONTH$1)) {
	                    addClass([trEle], OTHERMONTHROW);
	                }
	                if (!this.weekNumber && rowIterator === otherMonthCell && elements[otherMonthCell].
	                    classList.contains(OTHERMONTH$1)) {
	                    addClass([trEle], OTHERMONTHROW);
	                }
	                if (this.weekNumber) {
	                    if (rowIterator === weekNumCell && elements[weekNumCell].classList.contains(OTHERMONTH$1)) {
	                        addClass([trEle], OTHERMONTHROW);
	                    }
	                }
	                else {
	                    if (rowIterator === numberCell && elements[numberCell].classList.contains(OTHERMONTH$1)) {
	                        addClass([trEle], OTHERMONTHROW);
	                    }
	                }
	            }
	            row = row + count;
	            rowIterator = rowIterator + 0;
	            this.tableBodyElement.appendChild(trEle);
	        }
	        this.table.querySelector('tbody').className = this.effect;
	        if (this.calendarMode === 'Gregorian') {
	            this.iconHandler();
	        }
	        else {
	            this.islamicModule.islamicIconHandler();
	        }
	        if (view !== this.getViewNumber(this.currentView()) || (view === 0 && view !== this.getViewNumber(this.currentView()))) {
	            this.navigateHandler(e);
	        }
	        this.setAriaActiveDescendant();
	    };
	    CalendarBase.prototype.clickHandler = function (e, value) {
	        this.clickEventEmitter(e);
	        var eve = e.currentTarget;
	        var view = this.getViewNumber(this.currentView());
	        if (eve.classList.contains(OTHERMONTH$1)) {
	            this.contentClick(e, 0, null, value);
	        }
	        else if (view === this.getViewNumber(this.depth) && this.getViewNumber(this.start) >= this.getViewNumber(this.depth)) {
	            this.contentClick(e, 1, null, value);
	        }
	        else if (2 === view) {
	            this.contentClick(e, 1, null, value);
	        }
	        else if (!eve.classList.contains(OTHERMONTH$1) && view === 0) {
	            this.selectDate(e, this.getIdValue(e, null), null);
	        }
	        else {
	            this.contentClick(e, 0, eve, value);
	        }
	        if (this.getModuleName() === 'calendar') {
	            this.table.focus();
	        }
	    };
	    // Content click event handler required for extended components
	    CalendarBase.prototype.clickEventEmitter = function (e) {
	        e.preventDefault();
	    };
	    // eslint-disable-next-line @typescript-eslint/no-unused-vars
	    CalendarBase.prototype.contentClick = function (e, view, element, value) {
	        var currentView = this.getViewNumber(this.currentView());
	        var d = this.getIdValue(e, element);
	        switch (view) {
	            case 0:
	                if (currentView === this.getViewNumber(this.depth) && this.getViewNumber(this.start) >= this.getViewNumber(this.depth)) {
	                    detach(this.tableBodyElement);
	                    this.currentDate = d;
	                    this.effect = ZOOMIN$1;
	                    this.renderMonths(e);
	                }
	                else {
	                    if (this.calendarMode === 'Gregorian') {
	                        this.currentDate.setMonth(d.getMonth());
	                        if (d.getMonth() > 0 && this.currentDate.getMonth() !== d.getMonth()) {
	                            this.currentDate.setDate(0);
	                        }
	                        this.currentDate.setFullYear(d.getFullYear());
	                    }
	                    else {
	                        this.currentDate = d;
	                    }
	                    this.effect = ZOOMIN$1;
	                    detach(this.tableBodyElement);
	                    this.renderMonths(e);
	                }
	                break;
	            case 1:
	                if (currentView === this.getViewNumber(this.depth) && this.getViewNumber(this.start) >= this.getViewNumber(this.depth)) {
	                    this.selectDate(e, d, null);
	                }
	                else {
	                    if (this.calendarMode === 'Gregorian') {
	                        this.currentDate.setFullYear(d.getFullYear());
	                    }
	                    else {
	                        this.islamicPreviousHeader = this.headerElement.textContent;
	                        var islamicDate = this.islamicModule.getIslamicDate(d);
	                        this.currentDate = this.islamicModule.toGregorian(islamicDate.year, islamicDate.month, 1);
	                    }
	                    this.effect = ZOOMIN$1;
	                    detach(this.tableBodyElement);
	                    this.renderYears(e);
	                }
	        }
	    };
	    CalendarBase.prototype.switchView = function (view, e, multiSelection, isCustomDate) {
	        switch (view) {
	            case 0:
	                detach(this.tableBodyElement);
	                this.renderMonths(e, null, isCustomDate);
	                break;
	            case 1:
	                detach(this.tableBodyElement);
	                this.renderYears(e);
	                break;
	            case 2:
	                detach(this.tableBodyElement);
	                this.renderDecades(e);
	        }
	    };
	    /**
	     * To get component name
	     *
	     * @returns {string} Returns the component name.
	     * @private
	     */
	    CalendarBase.prototype.getModuleName = function () {
	        return 'calendar';
	    };
	    /**
	     *
	     * @returns {void}

	     */
	    CalendarBase.prototype.requiredModules = function () {
	        var modules = [];
	        if (this) {
	            modules.push({ args: [this], member: 'islamic' });
	        }
	        return modules;
	    };
	    /* eslint-disable valid-jsdoc, jsdoc/require-returns-description */
	    /**
	     * Gets the properties to be maintained upon browser refresh.
	     *
	     * @returns {string}
	     */
	    CalendarBase.prototype.getPersistData = function () {
	        var keyEntity = ['value'];
	        return this.addOnPersist(keyEntity);
	    };
	    /* eslint-enable valid-jsdoc, jsdoc/require-returns-description */
	    /**
	     * Called internally if any of the property value changed.
	     *
	     * @param {CalendarBaseModel} newProp - Returns the dynamic property value of the component.
	     * @param {CalendarBaseModel} oldProp - Returns the previous property value of the component.
	     * @param {boolean} multiSelection - - Specifies whether multiple date selection is enabled or not.
	     * @param {Date[]} values - Specifies the dates.
	     * @returns {void}
	     * @private
	     */
	    CalendarBase.prototype.onPropertyChanged = function (newProp, oldProp, multiSelection, values) {
	        this.effect = '';
	        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
	            var prop = _a[_i];
	            switch (prop) {
	                case 'enableRtl':
	                    if (newProp.enableRtl) {
	                        if (this.getModuleName() === 'calendar') {
	                            this.element.classList.add('e-rtl');
	                        }
	                        else {
	                            this.calendarElement.classList.add('e-rtl');
	                        }
	                    }
	                    else {
	                        if (this.getModuleName() === 'calendar') {
	                            this.element.classList.remove('e-rtl');
	                        }
	                        else {
	                            this.calendarElement.classList.remove('e-rtl');
	                        }
	                    }
	                    break;
	                case 'dayHeaderFormat':
	                    this.getCultureValues();
	                    if (this.getModuleName() !== 'datepicker') {
	                        this.createContentHeader();
	                    }
	                    else if (this.calendarElement) {
	                        this.createContentHeader();
	                    }
	                    this.adjustLongHeaderSize();
	                    break;
	                case 'min':
	                case 'max':
	                    this.rangeValidation(this.min, this.max);
	                    if (prop === 'min') {
	                        this.setProperties({ min: this.checkDateValue(new Date(this.checkValue(newProp.min))) }, true);
	                    }
	                    else {
	                        this.setProperties({ max: this.checkDateValue(new Date(this.checkValue(newProp.max))) }, true);
	                    }
	                    this.setProperties({ start: this.currentView() }, true);
	                    if (this.tableBodyElement) {
	                        detach(this.tableBodyElement);
	                    }
	                    this.minMaxUpdate();
	                    if (multiSelection) {
	                        this.validateValues(multiSelection, values);
	                    }
	                    if (this.getModuleName() !== 'datepicker') {
	                        this.createContentBody();
	                    }
	                    else if (this.calendarElement) {
	                        this.createContentBody();
	                    }
	                    if ((this.todayDate < this.min || this.max < this.todayDate) && (this.footer) && (this.todayElement)) {
	                        detach(this.todayElement);
	                        detach(this.footer);
	                        this.todayElement = this.footer = null;
	                        this.createContentFooter();
	                    }
	                    else {
	                        if ((this.footer) && (this.todayElement) && this.todayElement.classList.contains('e-disabled')) {
	                            removeClass([this.todayElement], DISABLED$1);
	                            detach(this.todayElement);
	                            detach(this.footer);
	                            this.todayElement = this.footer = null;
	                            this.createContentFooter();
	                        }
	                    }
	                    break;
	                case 'start':
	                case 'depth':
	                case 'weekNumber':
	                case 'firstDayOfWeek':
	                case 'weekRule':
	                    this.checkView();
	                    if (this.getModuleName() !== 'datepicker') {
	                        this.createContentHeader();
	                        this.createContentBody();
	                    }
	                    else if (this.calendarElement) {
	                        this.createContentHeader();
	                        this.createContentBody();
	                    }
	                    break;
	                case 'locale':
	                    this.globalize = new Internationalization(this.locale);
	                    if (this.getModuleName() !== 'datepicker') {
	                        this.createContentHeader();
	                        this.createContentBody();
	                    }
	                    else if (this.calendarElement) {
	                        this.createContentHeader();
	                        this.createContentBody();
	                    }
	                    this.l10.setLocale(this.locale);
	                    this.updateFooter();
	                    break;
	                case 'showTodayButton':
	                    if (newProp.showTodayButton) {
	                        this.createContentFooter();
	                    }
	                    else {
	                        if (!isNullOrUndefined(this.todayElement) && !isNullOrUndefined(this.footer)) {
	                            detach(this.todayElement);
	                            detach(this.footer);
	                            this.todayElement = this.footer = undefined;
	                        }
	                    }
	                    this.setProperties({ showTodayButton: newProp.showTodayButton }, true);
	                    break;
	            }
	        }
	    };
	    /**
	     * values property updated with considered disabled dates of the calendar.
	     *
	     * @param {boolean} multiSelection - Specifies whether multiple date selection is enabled.
	     * @param {Date[]} values - Specifies the dates to validate.
	     * @returns {void}
	     */
	    CalendarBase.prototype.validateValues = function (multiSelection, values) {
	        if (multiSelection && !isNullOrUndefined(values) && values.length > 0) {
	            var copyValues = this.copyValues(values);
	            for (var skipIndex = 0; skipIndex < copyValues.length; skipIndex++) {
	                var tempValue = copyValues[skipIndex];
	                var type = (this.calendarMode === 'Gregorian') ? 'gregorian' : 'islamic';
	                var tempValueString = void 0;
	                if (this.calendarMode === 'Gregorian') {
	                    tempValueString = this.globalize.formatDate(tempValue, { type: 'date', skeleton: 'yMd' });
	                }
	                else {
	                    tempValueString = this.globalize.formatDate(tempValue, { type: 'dateTime', skeleton: 'full', calendar: 'islamic' });
	                }
	                var minFormatOption = { type: 'date', skeleton: 'yMd', calendar: type };
	                var minStringValue = this.globalize.formatDate(this.min, minFormatOption);
	                var minString = minStringValue;
	                var maxFormatOption = { type: 'date', skeleton: 'yMd', calendar: type };
	                var maxStringValue = this.globalize.formatDate(this.max, maxFormatOption);
	                var maxString = maxStringValue;
	                if (+new Date(tempValueString) < +new Date(minString) ||
	                    +new Date(tempValueString) > +new Date(maxString)) {
	                    copyValues.splice(skipIndex, 1);
	                    skipIndex = -1;
	                }
	            }
	            this.setProperties({ values: copyValues }, true);
	        }
	    };
	    CalendarBase.prototype.setValueUpdate = function () {
	        if (!isNullOrUndefined(this.tableBodyElement)) {
	            detach(this.tableBodyElement);
	            this.setProperties({ start: this.currentView() }, true);
	            this.createContentBody();
	        }
	    };
	    CalendarBase.prototype.copyValues = function (values) {
	        var copyValues = [];
	        if (!isNullOrUndefined(values) && values.length > 0) {
	            for (var index = 0; index < values.length; index++) {
	                copyValues.push(new Date(+values[index]));
	            }
	        }
	        return copyValues;
	    };
	    CalendarBase.prototype.titleUpdate = function (date, view) {
	        var globalize = new Internationalization(this.locale);
	        var dayFormatOptions;
	        var monthFormatOptions;
	        var type = (this.calendarMode === 'Gregorian') ? 'gregorian' : 'islamic';
	        if (this.calendarMode === 'Gregorian') {
	            dayFormatOptions = globalize.formatDate(date, { type: 'dateTime', skeleton: 'yMMMM', calendar: type });
	            monthFormatOptions = globalize.formatDate(date, {
	                format: null, type: 'dateTime', skeleton: 'y', calendar: type
	            });
	        }
	        else {
	            dayFormatOptions = globalize.formatDate(date, { type: 'dateTime', format: 'MMMM y', calendar: type });
	            monthFormatOptions = globalize.formatDate(date, { type: 'dateTime', format: 'y', calendar: type });
	        }
	        switch (view) {
	            case 'days':
	                this.headerTitleElement.textContent = this.toCapitalize(dayFormatOptions);
	                break;
	            case 'months':
	                this.headerTitleElement.textContent = monthFormatOptions;
	        }
	    };
	    CalendarBase.prototype.setActiveDescendant = function () {
	        var id;
	        var focusedEle = this.tableBodyElement.querySelector('tr td.e-focused-date');
	        var selectedEle = this.tableBodyElement.querySelector('tr td.e-selected');
	        var type = (this.calendarMode === 'Gregorian') ? 'gregorian' : 'islamic';
	        var title;
	        var view = this.currentView();
	        if (view === 'Month') {
	            title = this.globalize.formatDate(this.currentDate, { type: 'date', skeleton: 'full', calendar: type });
	        }
	        else if (view === 'Year') {
	            if (type !== 'islamic') {
	                title = this.globalize.formatDate(this.currentDate, { type: 'date', skeleton: 'yMMMM', calendar: type });
	            }
	            else {
	                title = this.globalize.formatDate(this.currentDate, { type: 'date', skeleton: 'GyMMM', calendar: type });
	            }
	        }
	        else {
	            title = this.globalize.formatDate(this.currentDate, {
	                format: null, type: 'date', skeleton: 'y', calendar: type
	            });
	        }
	        if (selectedEle || focusedEle) {
	            if (!isNullOrUndefined(selectedEle)) {
	                selectedEle.setAttribute('aria-selected', 'true');
	            }
	            (focusedEle || selectedEle).setAttribute('aria-label', title);
	            id = (focusedEle || selectedEle).getAttribute('id');
	        }
	        return id;
	    };
	    CalendarBase.prototype.iconHandler = function () {
	        new Date(this.checkValue(this.currentDate)).setDate(1);
	        switch (this.currentView()) {
	            case 'Month':
	                this.previousIconHandler(this.compareMonth(new Date(this.checkValue(this.currentDate)), this.min) < 1);
	                this.nextIconHandler(this.compareMonth(new Date(this.checkValue(this.currentDate)), this.max) > -1);
	                break;
	            case 'Year':
	                this.previousIconHandler(this.compareYear(new Date(this.checkValue(this.currentDate)), this.min) < 1);
	                this.nextIconHandler(this.compareYear(new Date(this.checkValue(this.currentDate)), this.max) > -1);
	                break;
	            case 'Decade':
	                this.previousIconHandler(this.compareDecade(new Date(this.checkValue(this.currentDate)), this.min) < 1);
	                this.nextIconHandler(this.compareDecade(new Date(this.checkValue(this.currentDate)), this.max) > -1);
	        }
	    };
	    /**
	     * Destroys the widget.
	     *
	     * @returns {void}
	     */
	    CalendarBase.prototype.destroy = function () {
	        if (this.getModuleName() === 'calendar' && this.element) {
	            removeClass([this.element], [ROOT$1]);
	        }
	        else {
	            if (this.calendarElement && this.element) {
	                removeClass([this.element], [ROOT$1]);
	            }
	        }
	        if (this.getModuleName() === 'calendar' && this.element) {
	            if (!isNullOrUndefined(this.headerTitleElement)) {
	                EventHandler.remove(this.headerTitleElement, 'click', this.navigateTitle);
	            }
	            if (this.todayElement) {
	                EventHandler.remove(this.todayElement, 'click', this.todayButtonClick);
	            }
	            this.previousIconHandler(true);
	            this.nextIconHandler(true);
	            this.keyboardModule.destroy();
	            this.element.removeAttribute('data-role');
	            if (!isNullOrUndefined(this.calendarEleCopy.getAttribute('tabindex'))) {
	                this.element.setAttribute('tabindex', this.tabIndex);
	            }
	            else {
	                this.element.removeAttribute('tabindex');
	            }
	        }
	        if (this.element) {
	            this.element.innerHTML = '';
	        }
	        this.todayElement = null;
	        this.tableBodyElement = null;
	        this.todayButtonEvent = null;
	        this.renderDayCellArgs = null;
	        this.headerElement = null;
	        this.nextIcon = null;
	        this.table = null;
	        this.tableHeadElement = null;
	        this.previousIcon = null;
	        this.headerTitleElement = null;
	        this.footer = null;
	        this.contentElement = null;
	        _super.prototype.destroy.call(this);
	    };
	    CalendarBase.prototype.title = function (e) {
	        var currentView = this.getViewNumber(this.currentView());
	        this.effect = ZOOMIN$1;
	        this.switchView(++currentView, e);
	    };
	    CalendarBase.prototype.getViewNumber = function (stringVal) {
	        if (stringVal === 'Month') {
	            return 0;
	        }
	        else if (stringVal === 'Year') {
	            return 1;
	        }
	        else {
	            return 2;
	        }
	    };
	    CalendarBase.prototype.navigateTitle = function (e) {
	        e.preventDefault();
	        this.title(e);
	        if (this.getModuleName() === 'calendar') {
	            this.table.focus();
	        }
	    };
	    CalendarBase.prototype.previous = function () {
	        this.effect = '';
	        var currentView = this.getViewNumber(this.currentView());
	        switch (this.currentView()) {
	            case 'Month':
	                this.addMonths(this.currentDate, -1);
	                this.switchView(currentView);
	                break;
	            case 'Year':
	                this.addYears(this.currentDate, -1);
	                this.switchView(currentView);
	                break;
	            case 'Decade':
	                this.addYears(this.currentDate, -10);
	                this.switchView(currentView);
	                break;
	        }
	    };
	    CalendarBase.prototype.navigatePrevious = function (e) {
	        !Browser.isDevice && e.preventDefault();
	        if (this.calendarMode === 'Gregorian') {
	            this.previous();
	        }
	        else {
	            this.islamicModule.islamicPrevious();
	        }
	        this.triggerNavigate(e);
	        if (this.getModuleName() === 'calendar') {
	            this.table.focus();
	        }
	    };
	    CalendarBase.prototype.next = function () {
	        this.effect = '';
	        var currentView = this.getViewNumber(this.currentView());
	        switch (this.currentView()) {
	            case 'Month':
	                this.addMonths(this.currentDate, 1);
	                this.switchView(currentView);
	                break;
	            case 'Year':
	                this.addYears(this.currentDate, 1);
	                this.switchView(currentView);
	                break;
	            case 'Decade':
	                this.addYears(this.currentDate, 10);
	                this.switchView(currentView);
	                break;
	        }
	    };
	    CalendarBase.prototype.navigateNext = function (eve) {
	        !Browser.isDevice && eve.preventDefault();
	        if (this.calendarMode === 'Gregorian') {
	            this.next();
	        }
	        else {
	            this.islamicModule.islamicNext();
	        }
	        this.triggerNavigate(eve);
	        if (this.getModuleName() === 'calendar') {
	            this.table.focus();
	        }
	    };
	    /**
	     * This method is used to navigate to the month/year/decade view of the Calendar.
	     *
	     * @param {string} view - Specifies the view of the Calendar.
	     * @param {Date} date - Specifies the focused date in a view.
	     * @param {boolean} isCustomDate - Specifies whether the calendar is rendered with custom today date or not.
	     * @returns {void}
	     */
	    CalendarBase.prototype.navigateTo = function (view, date, isCustomDate) {
	        if (+date >= +this.min && +date <= +this.max) {
	            this.currentDate = date;
	        }
	        if (+date <= +this.min) {
	            this.currentDate = new Date(this.checkValue(this.min));
	        }
	        if (+date >= +this.max) {
	            this.currentDate = new Date(this.checkValue(this.max));
	        }
	        if ((this.getViewNumber(this.depth) >= this.getViewNumber(view))) {
	            if ((this.getViewNumber(this.depth) <= this.getViewNumber(this.start))
	                || this.getViewNumber(this.depth) === this.getViewNumber(view)) {
	                view = this.depth;
	            }
	        }
	        this.switchView(this.getViewNumber(view), null, null, isCustomDate);
	    };
	    /* eslint-disable valid-jsdoc, jsdoc/require-returns-description */
	    /**
	     * Gets the current view of the Calendar.
	     *
	     * @returns {string}
	     */
	    CalendarBase.prototype.currentView = function () {
	        if (!isNullOrUndefined(this.contentElement) && this.contentElement.classList.contains(YEAR)) {
	            return 'Year';
	        }
	        else if (!isNullOrUndefined(this.contentElement) && this.contentElement.classList.contains(DECADE)) {
	            return 'Decade';
	        }
	        else {
	            return 'Month';
	        }
	    };
	    /* eslint-enable valid-jsdoc, jsdoc/require-returns-description */
	    CalendarBase.prototype.getDateVal = function (date, value) {
	        return (!isNullOrUndefined(value) && date.getDate() === (value).getDate()
	            && date.getMonth() === (value).getMonth() && date.getFullYear() === (value).getFullYear());
	    };
	    // eslint-disable-next-line @typescript-eslint/no-unused-vars
	    CalendarBase.prototype.getCultureObjects = function (ld, c) {
	        var gregorianFormat = '.dates.calendars.gregorian.days.format.' + this.dayHeaderFormat.toLowerCase();
	        var islamicFormat = '.dates.calendars.islamic.days.format.' + this.dayHeaderFormat.toLowerCase();
	        var mainVal = 'main.';
	        if (this.calendarMode === 'Gregorian') {
	            return getValue(mainVal + '' + this.locale + gregorianFormat, ld);
	        }
	        else {
	            return getValue('main.' + '' + this.locale + islamicFormat, ld);
	        }
	    };
	    CalendarBase.prototype.getWeek = function (d) {
	        var currentDate = new Date(this.checkValue(d)).valueOf();
	        var date = new Date(d.getFullYear(), 0, 1).valueOf();
	        return Math.ceil((((currentDate - date) + dayMilliSeconds) / dayMilliSeconds) / 7);
	    };
	    CalendarBase.prototype.setStartDate = function (date, time) {
	        var tzOffset = date.getTimezoneOffset();
	        var d = new Date(date.getTime() + time);
	        var tzOffsetDiff = d.getTimezoneOffset() - tzOffset;
	        date.setTime(d.getTime() + tzOffsetDiff * minutesMilliSeconds);
	    };
	    CalendarBase.prototype.addMonths = function (date, i) {
	        if (this.calendarMode === 'Gregorian') {
	            var day = date.getDate();
	            date.setDate(1);
	            date.setMonth(date.getMonth() + i);
	            date.setDate(Math.min(day, this.getMaxDays(date)));
	        }
	        else {
	            var islamicDate = this.islamicModule.getIslamicDate(date);
	            this.currentDate = this.islamicModule.toGregorian(islamicDate.year, (islamicDate.month) + i, 1);
	        }
	    };
	    CalendarBase.prototype.addYears = function (date, i) {
	        if (this.calendarMode === 'Gregorian') {
	            var day = date.getDate();
	            date.setDate(1);
	            date.setFullYear(date.getFullYear() + i);
	            date.setDate(Math.min(day, this.getMaxDays(date)));
	        }
	        else {
	            var islamicDate = this.islamicModule.getIslamicDate(date);
	            this.currentDate = this.islamicModule.toGregorian(islamicDate.year + i, (islamicDate.month), 1);
	        }
	    };
	    CalendarBase.prototype.getIdValue = function (e, element) {
	        var eve;
	        if (e) {
	            eve = e.currentTarget;
	        }
	        else {
	            eve = element;
	        }
	        var type = (this.calendarMode === 'Gregorian') ? 'gregorian' : 'islamic';
	        var dateFormatOptions = { type: 'dateTime', skeleton: 'full', calendar: type };
	        // eslint-disable-next-line radix
	        var dateString = this.globalize.formatDate(new Date(parseInt('' + eve.getAttribute('id'), 0)), dateFormatOptions);
	        var date = this.globalize.parseDate(dateString, dateFormatOptions);
	        var value = date.valueOf() - date.valueOf() % 1000;
	        return new Date(value);
	        //return this.globalize.parseDate(dateString, dateFormatOptions);
	    };
	    CalendarBase.prototype.adjustLongHeaderSize = function () {
	        removeClass([this.element], DAYHEADERLONG$1);
	        if (this.dayHeaderFormat === 'Wide') {
	            addClass([this.getModuleName() === 'calendar' ? this.element : this.calendarElement], DAYHEADERLONG$1);
	        }
	    };
	    CalendarBase.prototype.selectDate = function (e, date, node, multiSelection, values) {
	        var element = node || e.currentTarget;
	        this.isDateSelected = false;
	        if (this.currentView() === 'Decade') {
	            this.setDateDecade(this.currentDate, date.getFullYear());
	        }
	        else if (this.currentView() === 'Year') {
	            this.setDateYear(this.currentDate, date);
	        }
	        else {
	            if (multiSelection && !this.checkPresentDate(date, values)) {
	                var copyValues = this.copyValues(values);
	                if (!isNullOrUndefined(values) && copyValues.length > 0) {
	                    copyValues.push(new Date(this.checkValue(date)));
	                    this.setProperties({ values: copyValues }, true);
	                    this.setProperties({ value: values[values.length - 1] }, true);
	                }
	                else {
	                    this.setProperties({ values: [new Date(this.checkValue(date))] }, true);
	                }
	            }
	            else {
	                this.setProperties({ value: new Date(this.checkValue(date)) }, true);
	            }
	            this.currentDate = new Date(this.checkValue(date));
	        }
	        var tableBodyElement = closest(element, '.' + ROOT$1);
	        if (isNullOrUndefined(tableBodyElement)) {
	            tableBodyElement = this.tableBodyElement;
	        }
	        if (!multiSelection && !isNullOrUndefined(tableBodyElement.querySelector('.' + SELECTED$1))) {
	            removeClass([tableBodyElement.querySelector('.' + SELECTED$1)], SELECTED$1);
	        }
	        if (!multiSelection && !isNullOrUndefined(tableBodyElement.querySelector('.' + FOCUSEDDATE))) {
	            removeClass([tableBodyElement.querySelector('.' + FOCUSEDDATE)], FOCUSEDDATE);
	        }
	        if (multiSelection) {
	            var copyValues = this.copyValues(values);
	            var collection = Array.prototype.slice.call(this.tableBodyElement.querySelectorAll('td'));
	            for (var index = 0; index < collection.length; index++) {
	                var tempElement = tableBodyElement.querySelectorAll('td' + '.' + FOCUSEDDATE)[0];
	                var selectedElement = tableBodyElement.querySelectorAll('td' + '.' + SELECTED$1)[0];
	                if (collection[index] === tempElement) {
	                    removeClass([collection[index]], FOCUSEDDATE);
	                }
	                if (collection[index] === selectedElement &&
	                    !this.checkPresentDate(new Date(parseInt(selectedElement.getAttribute('id').split('_')[0], 10)), values)) {
	                    removeClass([collection[index]], SELECTED$1);
	                }
	            }
	            if (element.classList.contains(SELECTED$1)) {
	                removeClass([element], SELECTED$1);
	                for (var i = 0; i < copyValues.length; i++) {
	                    var type = (this.calendarMode === 'Gregorian') ? 'gregorian' : 'islamic';
	                    var formatOptions = { format: null, type: 'date', skeleton: 'short', calendar: type };
	                    var localDateString = this.globalize.formatDate(date, formatOptions);
	                    var tempDateString = this.globalize.formatDate(copyValues[i], formatOptions);
	                    if (localDateString === tempDateString) {
	                        var index = copyValues.indexOf(copyValues[i]);
	                        copyValues.splice(index, 1);
	                        addClass([element], FOCUSEDDATE);
	                    }
	                }
	                this.setProperties({ values: copyValues }, true);
	            }
	            else {
	                addClass([element], SELECTED$1);
	            }
	        }
	        else {
	            addClass([element], SELECTED$1);
	        }
	        this.isDateSelected = true;
	    };
	    CalendarBase.prototype.checkPresentDate = function (dates, values) {
	        var previousValue = false;
	        if (!isNullOrUndefined(values)) {
	            for (var checkPrevious = 0; checkPrevious < values.length; checkPrevious++) {
	                var type = (this.calendarMode === 'Gregorian') ? 'gregorian' : 'islamic';
	                var localDateString = this.globalize.formatDate(dates, {
	                    format: null, type: 'date', skeleton: 'short', calendar: type
	                });
	                var tempDateString = this.globalize.formatDate(values[checkPrevious], {
	                    format: null, type: 'date', skeleton: 'short', calendar: type
	                });
	                if (localDateString === tempDateString) {
	                    previousValue = true;
	                }
	            }
	        }
	        return previousValue;
	    };
	    CalendarBase.prototype.setAriaActiveDescendant = function () {
	        attributes(this.table, {
	            'aria-activedescendant': '' + this.setActiveDescendant()
	        });
	    };
	    CalendarBase.prototype.previousIconHandler = function (disabled) {
	        if (disabled) {
	            if (!isNullOrUndefined(this.previousIcon)) {
	                EventHandler.remove(this.previousIcon, 'click', this.navigatePreviousHandler);
	                addClass([this.previousIcon], '' + DISABLED$1);
	                addClass([this.previousIcon], '' + OVERLAY$1);
	                this.previousIcon.setAttribute('aria-disabled', 'true');
	            }
	        }
	        else {
	            EventHandler.add(this.previousIcon, 'click', this.navigatePreviousHandler);
	            removeClass([this.previousIcon], '' + DISABLED$1);
	            removeClass([this.previousIcon], '' + OVERLAY$1);
	            this.previousIcon.setAttribute('aria-disabled', 'false');
	        }
	    };
	    CalendarBase.prototype.renderDayCellEvent = function (args) {
	        extend(this.renderDayCellArgs, { name: 'renderDayCell' });
	        this.trigger('renderDayCell', args);
	    };
	    CalendarBase.prototype.navigatedEvent = function (eve) {
	        extend(this.navigatedArgs, { name: 'navigated', event: eve });
	        this.trigger('navigated', this.navigatedArgs);
	    };
	    CalendarBase.prototype.triggerNavigate = function (event) {
	        this.navigatedArgs = { view: this.currentView(), date: this.currentDate };
	        this.navigatedEvent(event);
	    };
	    CalendarBase.prototype.nextIconHandler = function (disabled) {
	        if (disabled) {
	            if (!isNullOrUndefined(this.previousIcon)) {
	                EventHandler.remove(this.nextIcon, 'click', this.navigateNextHandler);
	                addClass([this.nextIcon], DISABLED$1);
	                addClass([this.nextIcon], OVERLAY$1);
	                this.nextIcon.setAttribute('aria-disabled', 'true');
	            }
	        }
	        else {
	            EventHandler.add(this.nextIcon, 'click', this.navigateNextHandler);
	            removeClass([this.nextIcon], DISABLED$1);
	            removeClass([this.nextIcon], OVERLAY$1);
	            this.nextIcon.setAttribute('aria-disabled', 'false');
	        }
	    };
	    CalendarBase.prototype.compare = function (startDate, endDate, modifier) {
	        var start = endDate.getFullYear();
	        var end;
	        var result;
	        end = start;
	        result = 0;
	        if (modifier) {
	            start = start - start % modifier;
	            end = start - start % modifier + modifier - 1;
	        }
	        if (startDate.getFullYear() > end) {
	            result = 1;
	        }
	        else if (startDate.getFullYear() < start) {
	            result = -1;
	        }
	        return result;
	    };
	    CalendarBase.prototype.isMinMaxRange = function (date) {
	        return +date >= +this.min && +date <= +this.max;
	    };
	    CalendarBase.prototype.isMonthYearRange = function (date) {
	        if (this.calendarMode === 'Gregorian') {
	            return date.getMonth() >= this.min.getMonth()
	                && date.getFullYear() >= this.min.getFullYear()
	                && date.getMonth() <= this.max.getMonth()
	                && date.getFullYear() <= this.max.getFullYear();
	        }
	        else {
	            var islamicDate = this.islamicModule.getIslamicDate(date);
	            return islamicDate.month >= (this.islamicModule.getIslamicDate(new Date(1944, 1, 18))).month
	                && islamicDate.year >= (this.islamicModule.getIslamicDate(new Date(1944, 1, 18))).year
	                && islamicDate.month <= (this.islamicModule.getIslamicDate(new Date(2069, 1, 16))).month
	                && islamicDate.year <= (this.islamicModule.getIslamicDate(new Date(2069, 1, 16))).year;
	        }
	    };
	    CalendarBase.prototype.compareYear = function (start, end) {
	        return this.compare(start, end, 0);
	    };
	    CalendarBase.prototype.compareDecade = function (start, end) {
	        return this.compare(start, end, 10);
	    };
	    CalendarBase.prototype.shiftArray = function (array, i) {
	        return array.slice(i).concat(array.slice(0, i));
	    };
	    CalendarBase.prototype.addDay = function (date, i, e, max, min) {
	        var column = i;
	        var value = new Date(+date);
	        if (!isNullOrUndefined(this.tableBodyElement) && !isNullOrUndefined(e)) {
	            while (this.findNextTD(new Date(+date), column, max, min)) {
	                column += i;
	            }
	            var rangeValue = new Date(value.setDate(value.getDate() + column));
	            column = (+rangeValue > +max || +rangeValue < +min) ? column === i ? i - i : i : column;
	        }
	        date.setDate(date.getDate() + column);
	    };
	    CalendarBase.prototype.findNextTD = function (date, column, max, min) {
	        var value = new Date(date.setDate(date.getDate() + column));
	        var collection = [];
	        var isDisabled = false;
	        if ((!isNullOrUndefined(value) && value.getMonth()) === (!isNullOrUndefined(this.currentDate) && this.currentDate.getMonth())) {
	            var tdEles = void 0;
	            if (this.calendarMode === 'Gregorian') {
	                tdEles = this.renderDays(value);
	            }
	            else {
	                tdEles = this.islamicModule.islamicRenderDays(this.currentDate, value);
	            }
	            collection = tdEles.filter(function (element) {
	                return element.classList.contains(DISABLED$1);
	            });
	        }
	        else {
	            collection = this.tableBodyElement.querySelectorAll('td.' + DISABLED$1);
	        }
	        if (+value <= (+(max)) && +value >= (+(min))) {
	            if (collection.length) {
	                for (var i = 0; i < collection.length; i++) {
	                    // eslint-disable-next-line radix
	                    isDisabled = (+value === +new Date(parseInt(collection[i].id, 0))) ? true : false;
	                    if (isDisabled) {
	                        break;
	                    }
	                }
	            }
	        }
	        return isDisabled;
	    };
	    CalendarBase.prototype.getMaxDays = function (d) {
	        var date;
	        var tmpDate = new Date(this.checkValue(d));
	        date = 28;
	        var month = tmpDate.getMonth();
	        while (tmpDate.getMonth() === month) {
	            ++date;
	            tmpDate.setDate(date);
	        }
	        return date - 1;
	    };
	    CalendarBase.prototype.setDateDecade = function (date, year) {
	        date.setFullYear(year);
	        this.setProperties({ value: new Date(this.checkValue(date)) }, true);
	    };
	    CalendarBase.prototype.setDateYear = function (date, value) {
	        date.setFullYear(value.getFullYear(), value.getMonth(), date.getDate());
	        if (value.getMonth() !== date.getMonth()) {
	            date.setDate(0);
	            this.currentDate = new Date(this.checkValue(value));
	        }
	        this.setProperties({ value: new Date(this.checkValue(date)) }, true);
	    };
	    CalendarBase.prototype.compareMonth = function (start, end) {
	        var result;
	        if (start.getFullYear() > end.getFullYear()) {
	            result = 1;
	        }
	        else if (start.getFullYear() < end.getFullYear()) {
	            result = -1;
	        }
	        else {
	            result = start.getMonth() === end.getMonth() ? 0 : start.getMonth() > end.getMonth() ? 1 : -1;
	        }
	        return result;
	    };
	    CalendarBase.prototype.checkValue = function (inValue) {
	        if (inValue instanceof Date) {
	            return (inValue.toUTCString());
	        }
	        else {
	            return ('' + inValue);
	        }
	    };
	    CalendarBase.prototype.checkView = function () {
	        if (this.start !== 'Decade' && this.start !== 'Year') {
	            this.setProperties({ start: 'Month' }, true);
	        }
	        if (this.depth !== 'Decade' && this.depth !== 'Year') {
	            this.setProperties({ depth: 'Month' }, true);
	        }
	        if (this.getViewNumber(this.depth) > this.getViewNumber(this.start)) {
	            this.setProperties({ depth: 'Month' }, true);
	        }
	    };
	    CalendarBase.prototype.getDate = function (date, timezone) {
	        if (timezone) {
	            date = new Date(date.toLocaleString('en-US', { timeZone: timezone }));
	        }
	        return date;
	    };
	    __decorate$b([
	        Property(new Date(1900, 0, 1))
	    ], CalendarBase.prototype, "min", void 0);
	    __decorate$b([
	        Property(true)
	    ], CalendarBase.prototype, "enabled", void 0);
	    __decorate$b([
	        Property(null)
	    ], CalendarBase.prototype, "cssClass", void 0);
	    __decorate$b([
	        Property(new Date(2099, 11, 31))
	    ], CalendarBase.prototype, "max", void 0);
	    __decorate$b([
	        Property(null)
	    ], CalendarBase.prototype, "firstDayOfWeek", void 0);
	    __decorate$b([
	        Property('Gregorian')
	    ], CalendarBase.prototype, "calendarMode", void 0);
	    __decorate$b([
	        Property('Month')
	    ], CalendarBase.prototype, "start", void 0);
	    __decorate$b([
	        Property('Month')
	    ], CalendarBase.prototype, "depth", void 0);
	    __decorate$b([
	        Property(false)
	    ], CalendarBase.prototype, "weekNumber", void 0);
	    __decorate$b([
	        Property('FirstDay')
	    ], CalendarBase.prototype, "weekRule", void 0);
	    __decorate$b([
	        Property(true)
	    ], CalendarBase.prototype, "showTodayButton", void 0);
	    __decorate$b([
	        Property('Short')
	    ], CalendarBase.prototype, "dayHeaderFormat", void 0);
	    __decorate$b([
	        Property(false)
	    ], CalendarBase.prototype, "enablePersistence", void 0);
	    __decorate$b([
	        Property(null)
	    ], CalendarBase.prototype, "keyConfigs", void 0);
	    __decorate$b([
	        Property(null)
	    ], CalendarBase.prototype, "serverTimezoneOffset", void 0);
	    __decorate$b([
	        Event()
	    ], CalendarBase.prototype, "created", void 0);
	    __decorate$b([
	        Event()
	    ], CalendarBase.prototype, "destroyed", void 0);
	    __decorate$b([
	        Event()
	    ], CalendarBase.prototype, "navigated", void 0);
	    __decorate$b([
	        Event()
	    ], CalendarBase.prototype, "renderDayCell", void 0);
	    CalendarBase = __decorate$b([
	        NotifyPropertyChanges
	    ], CalendarBase);
	    return CalendarBase;
	}(Component));
	/**
	 * Represents the Calendar component that allows the user to select a date.
	 * ```html
	 * <div id="calendar"/>
	 * ```
	 * ```typescript
	 * <script>
	 *   var calendarObj = new Calendar({ value: new Date() });
	 *   calendarObj.appendTo("#calendar");
	 * </script>
	 * ```
	 */
	/** @class */ ((function (_super) {
	    __extends$H(Calendar, _super);
	    /**
	     * Initialized new instance of Calendar Class.
	     * Constructor for creating the widget
	     *
	     * @param {CalendarModel} options - Specifies the Calendar model.
	     * @param {string | HTMLElement} element - Specifies the element to render as component.
	     * @private
	     */
	    function Calendar(options, element) {
	        return _super.call(this, options, element) || this;
	    }
	    /**
	     * To Initialize the control rendering.
	     *
	     * @returns {void}
	     * @private
	     */
	    Calendar.prototype.render = function () {
	        if (this.calendarMode === 'Islamic' && this.islamicModule === undefined) {
	            throwError('Requires the injectable Islamic modules to render Calendar in Islamic mode');
	        }
	        if (this.isMultiSelection && typeof this.values === 'object' && !isNullOrUndefined(this.values) && this.values.length > 0) {
	            var tempValues = [];
	            var copyValues = [];
	            for (var limit = 0; limit < this.values.length; limit++) {
	                if (tempValues.indexOf(+this.values[limit]) === -1) {
	                    tempValues.push(+this.values[limit]);
	                    copyValues.push(this.values[limit]);
	                }
	            }
	            this.setProperties({ values: copyValues }, true);
	            for (var index = 0; index < this.values.length; index++) {
	                if (!this.checkDateValue(this.values[index])) {
	                    if (typeof (this.values[index]) === 'string' && this.checkDateValue(new Date(this.checkValue(this.values[index])))) {
	                        var copyDate = new Date(this.checkValue(this.values[index]));
	                        this.values.splice(index, 1);
	                        this.values.splice(index, 0, copyDate);
	                    }
	                    else {
	                        this.values.splice(index, 1);
	                    }
	                }
	            }
	            this.setProperties({ value: this.values[this.values.length - 1] }, true);
	            this.previousValues = this.values.length;
	        }
	        this.validateDate();
	        this.minMaxUpdate();
	        if (this.getModuleName() === 'calendar') {
	            this.setEnable(this.enabled);
	            this.setClass(this.cssClass);
	        }
	        _super.prototype.render.call(this);
	        if (this.getModuleName() === 'calendar') {
	            var form = closest(this.element, 'form');
	            if (form) {
	                EventHandler.add(form, 'reset', this.formResetHandler.bind(this));
	            }
	            this.setTimeZone(this.serverTimezoneOffset);
	        }
	        this.renderComplete();
	    };
	    Calendar.prototype.setEnable = function (enable) {
	        if (!enable) {
	            addClass([this.element], DISABLED$1);
	        }
	        else {
	            removeClass([this.element], DISABLED$1);
	        }
	    };
	    Calendar.prototype.setClass = function (newCssClass, oldCssClass) {
	        if (!isNullOrUndefined(oldCssClass)) {
	            oldCssClass = (oldCssClass.replace(/\s+/g, ' ')).trim();
	        }
	        if (!isNullOrUndefined(newCssClass)) {
	            newCssClass = (newCssClass.replace(/\s+/g, ' ')).trim();
	        }
	        if (!isNullOrUndefined(oldCssClass) && oldCssClass !== '') {
	            removeClass([this.element], oldCssClass.split(' '));
	        }
	        if (!isNullOrUndefined(newCssClass)) {
	            addClass([this.element], newCssClass.split(' '));
	        }
	    };
	    Calendar.prototype.isDayLightSaving = function () {
	        var secondOffset = new Date(this.value.getFullYear(), 6, 1).getTimezoneOffset();
	        var firstOffset = new Date(this.value.getFullYear(), 0, 1).getTimezoneOffset();
	        return (this.value.getTimezoneOffset() < Math.max(firstOffset, secondOffset));
	    };
	    Calendar.prototype.setTimeZone = function (offsetValue) {
	        if (!isNullOrUndefined(this.serverTimezoneOffset) && this.value) {
	            var serverTimezoneDiff = offsetValue;
	            var clientTimeZoneDiff = new Date().getTimezoneOffset() / 60;
	            var timeZoneDiff = serverTimezoneDiff + clientTimeZoneDiff;
	            timeZoneDiff = this.isDayLightSaving() ? timeZoneDiff-- : timeZoneDiff;
	            this.value = new Date(this.value.getTime() + (timeZoneDiff * 60 * 60 * 1000));
	        }
	    };
	    Calendar.prototype.formResetHandler = function () {
	        this.setProperties({ value: null }, true);
	    };
	    Calendar.prototype.validateDate = function () {
	        if (typeof this.value === 'string') {
	            this.setProperties({ value: this.checkDateValue(new Date(this.checkValue(this.value))) }, true); // persist the value property.
	        }
	        _super.prototype.validateDate.call(this, this.value);
	        if (!isNullOrUndefined(this.value) && this.min <= this.max && this.value >= this.min && this.value <= this.max) {
	            this.currentDate = new Date(this.checkValue(this.value));
	        }
	        if (isNaN(+this.value)) {
	            this.setProperties({ value: null }, true);
	        }
	    };
	    Calendar.prototype.minMaxUpdate = function () {
	        if (this.getModuleName() === 'calendar') {
	            if (!isNullOrUndefined(this.value) && this.value <= this.min && this.min <= this.max) {
	                this.setProperties({ value: this.min }, true);
	                this.changedArgs = { value: this.value };
	            }
	            else {
	                if (!isNullOrUndefined(this.value) && this.value >= this.max && this.min <= this.max) {
	                    this.setProperties({ value: this.max }, true);
	                    this.changedArgs = { value: this.value };
	                }
	            }
	        }
	        if (this.getModuleName() !== 'calendar' && !isNullOrUndefined(this.value)) {
	            if (!isNullOrUndefined(this.value) && this.value < this.min && this.min <= this.max) {
	                _super.prototype.minMaxUpdate.call(this, this.min);
	            }
	            else {
	                if (!isNullOrUndefined(this.value) && this.value > this.max && this.min <= this.max) {
	                    _super.prototype.minMaxUpdate.call(this, this.max);
	                }
	            }
	        }
	        else {
	            _super.prototype.minMaxUpdate.call(this, this.value);
	        }
	    };
	    Calendar.prototype.generateTodayVal = function (value) {
	        var tempValue = new Date();
	        if (!isNullOrUndefined(this.timezone)) {
	            tempValue = _super.prototype.getDate.call(this, tempValue, this.timezone);
	        }
	        if (value && isNullOrUndefined(this.timezone)) {
	            tempValue.setHours(value.getHours());
	            tempValue.setMinutes(value.getMinutes());
	            tempValue.setSeconds(value.getSeconds());
	            tempValue.setMilliseconds(value.getMilliseconds());
	        }
	        else {
	            tempValue = new Date(tempValue.getFullYear(), tempValue.getMonth(), tempValue.getDate(), 0, 0, 0, 0);
	        }
	        return tempValue;
	    };
	    Calendar.prototype.todayButtonClick = function (e) {
	        if (this.showTodayButton) {
	            var tempValue = this.generateTodayVal(this.value);
	            this.setProperties({ value: tempValue }, true);
	            this.isTodayClicked = true;
	            this.todayButtonEvent = e;
	            if (this.isMultiSelection) {
	                var copyValues = this.copyValues(this.values);
	                if (!_super.prototype.checkPresentDate.call(this, tempValue, this.values)) {
	                    copyValues.push(tempValue);
	                    this.setProperties({ values: copyValues });
	                }
	            }
	            _super.prototype.todayButtonClick.call(this, e, new Date(+this.value));
	        }
	    };
	    Calendar.prototype.keyActionHandle = function (e) {
	        _super.prototype.keyActionHandle.call(this, e, this.value, this.isMultiSelection);
	    };
	    /**
	     * Initialize the event handler
	     *
	     * @returns {void}
	     * @private
	     */
	    Calendar.prototype.preRender = function () {
	        var _this = this;
	        this.changeHandler = function (e) {
	            _this.triggerChange(e);
	        };
	        this.checkView();
	        _super.prototype.preRender.call(this, this.value);
	    };
	    /**
	     * @returns {void}

	     */
	    Calendar.prototype.createContent = function () {
	        this.previousDate = this.value;
	        this.previousDateTime = this.value;
	        _super.prototype.createContent.call(this);
	    };
	    Calendar.prototype.minMaxDate = function (localDate) {
	        return _super.prototype.minMaxDate.call(this, localDate);
	    };
	    Calendar.prototype.renderMonths = function (e, value, isCustomDate) {
	        _super.prototype.renderMonths.call(this, e, this.value, isCustomDate);
	    };
	    Calendar.prototype.renderDays = function (currentDate, value, isMultiSelect, values, isCustomDate, e) {
	        var tempDays = _super.prototype.renderDays.call(this, currentDate, this.value, this.isMultiSelection, this.values, isCustomDate, e);
	        if (this.isMultiSelection) {
	            _super.prototype.validateValues.call(this, this.isMultiSelection, this.values);
	        }
	        return tempDays;
	    };
	    Calendar.prototype.renderYears = function (e) {
	        if (this.calendarMode === 'Gregorian') {
	            _super.prototype.renderYears.call(this, e, this.value);
	        }
	        else {
	            this.islamicModule.islamicRenderYears(e, this.value);
	        }
	    };
	    Calendar.prototype.renderDecades = function (e) {
	        if (this.calendarMode === 'Gregorian') {
	            _super.prototype.renderDecades.call(this, e, this.value);
	        }
	        else {
	            this.islamicModule.islamicRenderDecade(e, this.value);
	        }
	    };
	    Calendar.prototype.renderTemplate = function (elements, count, classNm, e) {
	        if (this.calendarMode === 'Gregorian') {
	            _super.prototype.renderTemplate.call(this, elements, count, classNm, e, this.value);
	        }
	        else {
	            this.islamicModule.islamicRenderTemplate(elements, count, classNm, e, this.value);
	        }
	        this.changedArgs = { value: this.value, values: this.values };
	        e && e.type === 'click' && e.currentTarget.classList.contains(OTHERMONTH$1) ? this.changeHandler(e) : this.changeHandler();
	    };
	    Calendar.prototype.clickHandler = function (e) {
	        var eve = e.currentTarget;
	        this.isPopupClicked = true;
	        if (eve.classList.contains(OTHERMONTH$1)) {
	            if (this.isMultiSelection) {
	                var copyValues = this.copyValues(this.values);
	                if (copyValues.toString().indexOf(this.getIdValue(e, null).toString()) === -1) {
	                    copyValues.push(this.getIdValue(e, null));
	                    this.setProperties({ values: copyValues }, true);
	                    this.setProperties({ value: this.values[this.values.length - 1] }, true);
	                }
	                else {
	                    this.previousDates = true;
	                }
	            }
	            else {
	                this.setProperties({ value: this.getIdValue(e, null) }, true);
	            }
	        }
	        var storeView = this.currentView();
	        _super.prototype.clickHandler.call(this, e, this.value);
	        if (this.isMultiSelection && this.currentDate !== this.value &&
	            !isNullOrUndefined(this.tableBodyElement.querySelectorAll('.' + FOCUSEDDATE)[0]) && storeView === 'Year') {
	            this.tableBodyElement.querySelectorAll('.' + FOCUSEDDATE)[0].classList.remove(FOCUSEDDATE);
	        }
	    };
	    Calendar.prototype.switchView = function (view, e, isMultiSelection, isCustomDate) {
	        _super.prototype.switchView.call(this, view, e, this.isMultiSelection, isCustomDate);
	    };
	    /**
	     * To get component name
	     *
	     * @returns {string} Return the component name.
	     * @private
	     */
	    Calendar.prototype.getModuleName = function () {
	        _super.prototype.getModuleName.call(this);
	        return 'calendar';
	    };
	    /* eslint-disable valid-jsdoc, jsdoc/require-returns-description */
	    /**
	     * Gets the properties to be maintained upon browser refresh.
	     *
	     * @returns {string}
	     */
	    Calendar.prototype.getPersistData = function () {
	        _super.prototype.getPersistData.call(this);
	        var keyEntity = ['value', 'values'];
	        return this.addOnPersist(keyEntity);
	    };
	    /* eslint-enable valid-jsdoc, jsdoc/require-returns-description */
	    /**
	     * Called internally if any of the property value changed.
	     *
	     * @param {CalendarModel} newProp - Returns the dynamic property value of the component.
	     * @param {CalendarModel} oldProp - Returns the previous property value of the component.
	     * @returns {void}
	     * @private
	     */
	    Calendar.prototype.onPropertyChanged = function (newProp, oldProp) {
	        this.effect = '';
	        this.rangeValidation(this.min, this.max);
	        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
	            var prop = _a[_i];
	            switch (prop) {
	                case 'value':
	                    if (this.isDateSelected) {
	                        if (typeof newProp.value === 'string') {
	                            this.setProperties({ value: new Date(this.checkValue(newProp.value)) }, true);
	                        }
	                        else {
	                            newProp.value = new Date(this.checkValue(newProp.value));
	                        }
	                        if (isNaN(+this.value)) {
	                            this.setProperties({ value: oldProp.value }, true);
	                        }
	                        this.update();
	                    }
	                    break;
	                case 'values':
	                    if (this.isDateSelected) {
	                        if (typeof newProp.values === 'string' || typeof newProp.values === 'number') {
	                            this.setProperties({ values: null }, true);
	                        }
	                        else {
	                            var copyValues = this.copyValues(this.values);
	                            for (var index = 0; index < copyValues.length; index++) {
	                                var tempDate = copyValues[index];
	                                if (this.checkDateValue(tempDate) && !_super.prototype.checkPresentDate.call(this, tempDate, copyValues)) {
	                                    copyValues.push(tempDate);
	                                }
	                            }
	                            this.setProperties({ values: copyValues }, true);
	                            if (this.values.length > 0) {
	                                this.setProperties({ value: newProp.values[newProp.values.length - 1] }, true);
	                            }
	                        }
	                        this.validateValues(this.isMultiSelection, this.values);
	                        this.update();
	                    }
	                    break;
	                case 'isMultiSelection':
	                    if (this.isDateSelected) {
	                        this.setProperties({ isMultiSelection: newProp.isMultiSelection }, true);
	                        this.update();
	                    }
	                    break;
	                case 'enabled':
	                    this.setEnable(this.enabled);
	                    break;
	                case 'cssClass':
	                    if (this.getModuleName() === 'calendar') {
	                        this.setClass(newProp.cssClass, oldProp.cssClass);
	                    }
	                    break;
	                default:
	                    _super.prototype.onPropertyChanged.call(this, newProp, oldProp, this.isMultiSelection, this.values);
	            }
	        }
	        this.preventChange = this.isAngular && this.preventChange ? !this.preventChange : this.preventChange;
	    };
	    /**
	     * Destroys the widget.
	     *
	     * @returns {void}
	     */
	    Calendar.prototype.destroy = function () {
	        _super.prototype.destroy.call(this);
	        if (this.getModuleName() === 'calendar') {
	            this.changedArgs = null;
	            var form = closest(this.element, 'form');
	            if (form) {
	                EventHandler.remove(form, 'reset', this.formResetHandler.bind(this));
	            }
	        }
	    };
	    /**
	     * This method is used to navigate to the month/year/decade view of the Calendar.
	     *
	     * @param {string} view - Specifies the view of the Calendar.
	     * @param {Date} date - Specifies the focused date in a view.
	     * @param {boolean} isCustomDate - Specifies whether the calendar is rendered with custom today date or not.
	     * @returns {void}

	     */
	    Calendar.prototype.navigateTo = function (view, date, isCustomDate) {
	        this.minMaxUpdate();
	        _super.prototype.navigateTo.call(this, view, date, isCustomDate);
	    };
	    /* eslint-disable valid-jsdoc, jsdoc/require-returns-description */
	    /**
	     * Gets the current view of the Calendar.
	     *
	     * @returns {string}

	     */
	    Calendar.prototype.currentView = function () {
	        return _super.prototype.currentView.call(this);
	    };
	    /* eslint-enable valid-jsdoc, jsdoc/require-returns-description */
	    /**
	     * This method is used to add the single or multiple dates to the values property of the Calendar.
	     *
	     * @param {Date | Date[]} dates - Specifies the date or dates to be added to the values property of the Calendar.
	     * @returns {void}

	     */
	    Calendar.prototype.addDate = function (dates) {
	        if (typeof dates !== 'string' && typeof dates !== 'number') {
	            var copyValues = this.copyValues(this.values);
	            if (typeof dates === 'object' && (dates).length > 0) {
	                var tempDates = dates;
	                for (var i = 0; i < tempDates.length; i++) {
	                    if (this.checkDateValue(tempDates[i]) && !_super.prototype.checkPresentDate.call(this, tempDates[i], copyValues)) {
	                        if (!isNullOrUndefined(copyValues) && copyValues.length > 0) {
	                            copyValues.push(tempDates[i]);
	                        }
	                        else {
	                            copyValues = [new Date(+tempDates[i])];
	                        }
	                    }
	                }
	            }
	            else {
	                if (this.checkDateValue(dates) && !_super.prototype.checkPresentDate.call(this, dates, copyValues)) {
	                    if (!isNullOrUndefined(copyValues) && copyValues.length > 0) {
	                        copyValues.push((dates));
	                    }
	                    else {
	                        copyValues = [new Date(+dates)];
	                    }
	                }
	            }
	            this.setProperties({ values: copyValues }, true);
	            if (this.isMultiSelection) {
	                this.setProperties({ value: this.values[this.values.length - 1] }, true);
	            }
	            this.validateValues(this.isMultiSelection, copyValues);
	            this.update();
	            this.changedArgs = { value: this.value, values: this.values };
	            this.changeHandler();
	        }
	    };
	    /**
	     * This method is used to remove the single or multiple dates from the values property of the Calendar.
	     *
	     * @param {Date | Date[]} dates - Specifies the date or dates which need to be removed from the values property of the Calendar.
	     * @returns {void}

	     */
	    Calendar.prototype.removeDate = function (dates) {
	        if (typeof dates !== 'string' && typeof dates !== 'number' && !isNullOrUndefined(this.values) && this.values.length > 0) {
	            var copyValues = this.copyValues(this.values);
	            if (typeof dates === 'object' && ((dates).length > 0)) {
	                var tempDates = dates;
	                for (var index = 0; index < tempDates.length; index++) {
	                    for (var i = 0; i < copyValues.length; i++) {
	                        if (+copyValues[i] === +tempDates[index]) {
	                            copyValues.splice(i, 1);
	                        }
	                    }
	                }
	            }
	            else {
	                for (var i = 0; i < copyValues.length; i++) {
	                    if (+copyValues[i] === +dates) {
	                        copyValues.splice(i, 1);
	                    }
	                }
	            }
	            this.setProperties({ values: copyValues }, false);
	            this.update();
	            if (this.isMultiSelection) {
	                this.setProperties({ value: this.values[this.values.length - 1] }, true);
	            }
	            this.changedArgs = { value: this.value, values: this.values };
	            this.changeHandler();
	        }
	    };
	    /**
	     * To set custom today date in calendar
	     *
	     * @param {Date} date - Specifies date value to be set.
	     * @private
	     * @returns {void}
	     */
	    Calendar.prototype.setTodayDate = function (date) {
	        var todayDate = new Date(+date);
	        this.setProperties({ value: todayDate }, true);
	        _super.prototype.todayButtonClick.call(this, null, todayDate, true);
	    };
	    Calendar.prototype.update = function () {
	        this.validateDate();
	        this.minMaxUpdate();
	        _super.prototype.setValueUpdate.call(this);
	    };
	    Calendar.prototype.selectDate = function (e, date, element) {
	        _super.prototype.selectDate.call(this, e, date, element, this.isMultiSelection, this.values);
	        if (this.isMultiSelection && !isNullOrUndefined(this.values) && this.values.length > 0) {
	            this.setProperties({ value: this.values[this.values.length - 1] }, true);
	        }
	        this.changedArgs = { value: this.value, values: this.values };
	        this.changeHandler(e);
	    };
	    // eslint-disable-next-line @typescript-eslint/no-unused-vars
	    Calendar.prototype.changeEvent = function (e) {
	        if ((this.value && this.value.valueOf()) !== (this.previousDate && +this.previousDate.valueOf())
	            || this.isMultiSelection) {
	            if (this.isAngular && this.preventChange) {
	                this.preventChange = false;
	            }
	            else {
	                this.trigger('change', this.changedArgs);
	            }
	            this.previousDate = new Date(+this.value);
	        }
	    };
	    Calendar.prototype.triggerChange = function (e) {
	        if (!isNullOrUndefined(this.todayButtonEvent) && this.isTodayClicked) {
	            e = this.todayButtonEvent;
	            this.isTodayClicked = false;
	        }
	        this.changedArgs.event = e || null;
	        this.changedArgs.isInteracted = !isNullOrUndefined(e);
	        if (!isNullOrUndefined(this.value)) {
	            this.setProperties({ value: this.value }, true);
	        }
	        // eslint-disable-next-line use-isnan
	        if (!this.isMultiSelection && +this.value !== Number.NaN && (!isNullOrUndefined(this.value) &&
	            !isNullOrUndefined(this.previousDate) || this.previousDate === null
	            && !isNaN(+this.value))) {
	            this.changeEvent(e);
	        }
	        else if (!isNullOrUndefined(this.values) && this.previousValues !== this.values.length) {
	            this.changeEvent(e);
	            this.previousValues = this.values.length;
	        }
	    };
	    __decorate$b([
	        Property(null)
	    ], Calendar.prototype, "value", void 0);
	    __decorate$b([
	        Property(null)
	    ], Calendar.prototype, "values", void 0);
	    __decorate$b([
	        Property(false)
	    ], Calendar.prototype, "isMultiSelection", void 0);
	    __decorate$b([
	        Event()
	    ], Calendar.prototype, "change", void 0);
	    Calendar = __decorate$b([
	        NotifyPropertyChanges
	    ], Calendar);
	    return Calendar;
	})(CalendarBase));

	/**
	 * Position library
	 */
	var elementRect;
	var popupRect;
	var element;
	var parentDocument$1;
	var fixedParent = false;
	/**
	 *
	 * @param {HTMLElement} anchor - specifies the element
	 * @param {HTMLElement} element - specifies the element
	 * @returns {OffsetPosition} - returns the value
	 */
	function calculateRelativeBasedPosition(anchor, element) {
	    var fixedElement = false;
	    var anchorPos = { left: 0, top: 0 };
	    var tempAnchor = anchor;
	    if (!anchor || !element) {
	        return anchorPos;
	    }
	    if (isNullOrUndefined(element.offsetParent) && element.style.position === 'fixed') {
	        fixedElement = true;
	    }
	    while ((element.offsetParent || fixedElement) && anchor && element.offsetParent !== anchor) {
	        anchorPos.left += anchor.offsetLeft;
	        anchorPos.top += anchor.offsetTop;
	        anchor = anchor.offsetParent;
	    }
	    anchor = tempAnchor;
	    while ((element.offsetParent || fixedElement) && anchor && element.offsetParent !== anchor) {
	        anchorPos.left -= anchor.scrollLeft;
	        anchorPos.top -= anchor.scrollTop;
	        anchor = anchor.parentElement;
	    }
	    return anchorPos;
	}
	/**
	 *
	 * @param {Element} currentElement - specifies the element
	 * @param {string} positionX - specifies the position
	 * @param {string} positionY - specifies the position
	 * @param {boolean} parentElement - specifies the boolean
	 * @param {ClientRect} targetValues - specifies the client
	 * @returns {OffsetPosition} - returns the position
	 */
	function calculatePosition(currentElement, positionX, positionY, parentElement, targetValues) {
	    popupRect = undefined;
	    popupRect = targetValues;
	    fixedParent = parentElement ? true : false;
	    if (!currentElement) {
	        return { left: 0, top: 0 };
	    }
	    if (!positionX) {
	        positionX = 'left';
	    }
	    if (!positionY) {
	        positionY = 'top';
	    }
	    parentDocument$1 = currentElement.ownerDocument;
	    element = currentElement;
	    var pos = { left: 0, top: 0 };
	    return updatePosition(positionX.toLowerCase(), positionY.toLowerCase(), pos);
	}
	/**
	 *
	 * @param {number} value - specifies the number
	 * @param {OffsetPosition} pos - specifies the position
	 * @returns {void}
	 */
	function setPosx(value, pos) {
	    pos.left = value;
	}
	/**
	 *
	 * @param {number} value - specifies the number
	 * @param {OffsetPosition} pos - specifies the position
	 * @returns {void}
	 */
	function setPosy(value, pos) {
	    pos.top = value;
	}
	/**
	 *
	 * @param {string} posX - specifies the position
	 * @param {string} posY - specifies the position
	 * @param {OffsetPosition} pos - specifies the position
	 * @returns {OffsetPosition} - returns the postion
	 */
	function updatePosition(posX, posY, pos) {
	    elementRect = element.getBoundingClientRect();
	    switch (posY + posX) {
	        case 'topcenter':
	            setPosx(getElementHCenter(), pos);
	            setPosy(getElementTop(), pos);
	            break;
	        case 'topright':
	            setPosx(getElementRight(), pos);
	            setPosy(getElementTop(), pos);
	            break;
	        case 'centercenter':
	            setPosx(getElementHCenter(), pos);
	            setPosy(getElementVCenter(), pos);
	            break;
	        case 'centerright':
	            setPosx(getElementRight(), pos);
	            setPosy(getElementVCenter(), pos);
	            break;
	        case 'centerleft':
	            setPosx(getElementLeft(), pos);
	            setPosy(getElementVCenter(), pos);
	            break;
	        case 'bottomcenter':
	            setPosx(getElementHCenter(), pos);
	            setPosy(getElementBottom(), pos);
	            break;
	        case 'bottomright':
	            setPosx(getElementRight(), pos);
	            setPosy(getElementBottom(), pos);
	            break;
	        case 'bottomleft':
	            setPosx(getElementLeft(), pos);
	            setPosy(getElementBottom(), pos);
	            break;
	        default:
	        case 'topleft':
	            setPosx(getElementLeft(), pos);
	            setPosy(getElementTop(), pos);
	            break;
	    }
	    element = null;
	    return pos;
	}
	/**
	 * @returns {number} - specifies the number value
	 */
	function getBodyScrollTop$1() {
	    return parentDocument$1.documentElement.scrollTop || parentDocument$1.body.scrollTop;
	}
	/**
	 * @returns {number} - specifies the number value
	 */
	function getBodyScrollLeft$1() {
	    return parentDocument$1.documentElement.scrollLeft || parentDocument$1.body.scrollLeft;
	}
	/**
	 * @returns {number} - specifies the number value
	 */
	function getElementBottom() {
	    return fixedParent ? elementRect.bottom : elementRect.bottom + getBodyScrollTop$1();
	}
	/**
	 * @returns {number} - specifies the number value
	 */
	function getElementVCenter() {
	    return getElementTop() + (elementRect.height / 2);
	}
	/**
	 * @returns {number} - specifies the number value
	 */
	function getElementTop() {
	    return fixedParent ? elementRect.top : elementRect.top + getBodyScrollTop$1();
	}
	/**
	 * @returns {number} - specifies the number value
	 */
	function getElementLeft() {
	    return elementRect.left + getBodyScrollLeft$1();
	}
	/**
	 * @returns {number} - specifies the number value
	 */
	function getElementRight() {
	    var popupWidth = (element && (element.classList.contains('e-date-wrapper') || element.classList.contains('e-datetime-wrapper') || element.classList.contains('e-date-range-wrapper') || element.classList.contains('e-ddl') || element.classList.contains('e-multiselect'))) ? (popupRect ? popupRect.width : 0) :
	        (popupRect && (elementRect.width >= popupRect.width) ? popupRect.width : 0);
	    return elementRect.right + getBodyScrollLeft$1() - popupWidth;
	}
	/**
	 * @returns {number} - specifies the number value
	 */
	function getElementHCenter() {
	    return getElementLeft() + (elementRect.width / 2);
	}

	/**
	 * Collision module.
	 */
	var parentDocument;
	var targetContainer;
	/**
	 *
	 * @param {HTMLElement} element - specifies the element
	 * @param {HTMLElement} viewPortElement - specifies the element
	 * @param {CollisionCoordinates} axis - specifies the collision coordinates
	 * @param {OffsetPosition} position - specifies the position
	 * @returns {void}
	 */
	function fit(element, viewPortElement, axis, position) {
	    if (viewPortElement === void 0) { viewPortElement = null; }
	    if (axis === void 0) { axis = { X: false, Y: false }; }
	    if (!axis.Y && !axis.X) {
	        return { left: 0, top: 0 };
	    }
	    var elemData = element.getBoundingClientRect();
	    targetContainer = viewPortElement;
	    parentDocument = element.ownerDocument;
	    if (!position) {
	        position = calculatePosition(element, 'left', 'top');
	    }
	    if (axis.X) {
	        var containerWidth = targetContainer ? getTargetContainerWidth() : getViewPortWidth();
	        var containerLeft = ContainerLeft();
	        var containerRight = ContainerRight();
	        var overLeft = containerLeft - position.left;
	        var overRight = position.left + elemData.width - containerRight;
	        if (elemData.width > containerWidth) {
	            if (overLeft > 0 && overRight <= 0) {
	                position.left = containerRight - elemData.width;
	            }
	            else if (overRight > 0 && overLeft <= 0) {
	                position.left = containerLeft;
	            }
	            else {
	                position.left = overLeft > overRight ? (containerRight - elemData.width) : containerLeft;
	            }
	        }
	        else if (overLeft > 0) {
	            position.left += overLeft;
	        }
	        else if (overRight > 0) {
	            position.left -= overRight;
	        }
	    }
	    if (axis.Y) {
	        var containerHeight = targetContainer ? getTargetContainerHeight() : getViewPortHeight();
	        var containerTop = ContainerTop();
	        var containerBottom = ContainerBottom();
	        var overTop = containerTop - position.top;
	        var overBottom = position.top + elemData.height - containerBottom;
	        if (elemData.height > containerHeight) {
	            if (overTop > 0 && overBottom <= 0) {
	                position.top = containerBottom - elemData.height;
	            }
	            else if (overBottom > 0 && overTop <= 0) {
	                position.top = containerTop;
	            }
	            else {
	                position.top = overTop > overBottom ? (containerBottom - elemData.height) : containerTop;
	            }
	        }
	        else if (overTop > 0) {
	            position.top += overTop;
	        }
	        else if (overBottom > 0) {
	            position.top -= overBottom;
	        }
	    }
	    return position;
	}
	/**
	 *
	 * @param {HTMLElement} element - specifies the html element
	 * @param {HTMLElement} viewPortElement - specifies the html element
	 * @param {number} x - specifies the number
	 * @param {number} y - specifies the number
	 * @returns {string[]} - returns the string value
	 */
	function isCollide$1(element, viewPortElement, x, y) {
	    if (viewPortElement === void 0) { viewPortElement = null; }
	    var elemOffset = calculatePosition(element, 'left', 'top');
	    if (x) {
	        elemOffset.left = x;
	    }
	    if (y) {
	        elemOffset.top = y;
	    }
	    var data = [];
	    targetContainer = viewPortElement;
	    parentDocument = element.ownerDocument;
	    var elementRect = element.getBoundingClientRect();
	    var top = elemOffset.top;
	    var left = elemOffset.left;
	    var right = elemOffset.left + elementRect.width;
	    var bottom = elemOffset.top + elementRect.height;
	    var yAxis = topCollideCheck(top, bottom);
	    var xAxis = leftCollideCheck(left, right);
	    if (yAxis.topSide) {
	        data.push('top');
	    }
	    if (xAxis.rightSide) {
	        data.push('right');
	    }
	    if (xAxis.leftSide) {
	        data.push('left');
	    }
	    if (yAxis.bottomSide) {
	        data.push('bottom');
	    }
	    return data;
	}
	/**
	 *
	 * @param {HTMLElement} element - specifies the element
	 * @param {HTMLElement} target - specifies the element
	 * @param {number} offsetX - specifies the number
	 * @param {number} offsetY - specifies the number
	 * @param {string} positionX - specifies the string value
	 * @param {string} positionY - specifies the string value
	 * @param {HTMLElement} viewPortElement - specifies the element
	 * @param {CollisionCoordinates} axis - specifies the collision axis
	 * @param {boolean} fixedParent - specifies the boolean
	 * @returns {void}
	 */
	function flip(element, target, offsetX, offsetY, positionX, positionY, viewPortElement, 
	/* eslint-disable */
	axis, fixedParent) {
	    if (viewPortElement === void 0) { viewPortElement = null; }
	    if (axis === void 0) { axis = { X: true, Y: true }; }
	    if (!target || !element || !positionX || !positionY || (!axis.X && !axis.Y)) {
	        return;
	    }
	    var tEdge = { TL: null,
	        TR: null,
	        BL: null,
	        BR: null
	    }, eEdge = {
	        TL: null,
	        TR: null,
	        BL: null,
	        BR: null
	        /* eslint-enable */
	    };
	    var elementRect;
	    if (window.getComputedStyle(element).display === 'none') {
	        var oldVisibility = element.style.visibility;
	        element.style.visibility = 'hidden';
	        element.style.display = 'block';
	        elementRect = element.getBoundingClientRect();
	        element.style.removeProperty('display');
	        element.style.visibility = oldVisibility;
	    }
	    else {
	        elementRect = element.getBoundingClientRect();
	    }
	    var pos = {
	        posX: positionX, posY: positionY, offsetX: offsetX, offsetY: offsetY, position: { left: 0, top: 0 }
	    };
	    targetContainer = viewPortElement;
	    parentDocument = target.ownerDocument;
	    updateElementData(target, tEdge, pos, fixedParent, elementRect);
	    setPosition(eEdge, pos, elementRect);
	    if (axis.X) {
	        leftFlip(target, eEdge, tEdge, pos, elementRect, true);
	    }
	    if (axis.Y && tEdge.TL.top > -1) {
	        topFlip(target, eEdge, tEdge, pos, elementRect, true);
	    }
	    setPopup(element, pos, elementRect);
	}
	/**
	 *
	 * @param {HTMLElement} element - specifies the element
	 * @param {PositionLocation} pos - specifies the location
	 * @param {ClientRect} elementRect - specifies the client rect
	 * @returns {void}
	 */
	function setPopup(element, pos, elementRect) {
	    //eslint-disable-next-line
	    var left = 0, top = 0;
	    if (element.offsetParent != null
	        && (getComputedStyle(element.offsetParent).position === 'absolute' ||
	            getComputedStyle(element.offsetParent).position === 'relative')) {
	        var data = calculatePosition(element.offsetParent, 'left', 'top', false, elementRect);
	        left = data.left;
	        top = data.top;
	    }
	    var scaleX = 1;
	    var scaleY = 1;
	    if (element.offsetParent) {
	        var transformStyle = getComputedStyle(element.offsetParent).transform;
	        if (transformStyle !== 'none') {
	            var matrix = new DOMMatrix(transformStyle);
	            scaleX = matrix.a;
	            scaleY = matrix.d;
	        }
	    }
	    element.style.top = ((pos.position.top / scaleY) + pos.offsetY - (top)) + 'px';
	    element.style.left = ((pos.position.left / scaleX) + pos.offsetX - (left)) + 'px';
	}
	/**
	 *
	 * @param {HTMLElement} target - specifies the element
	 * @param {EdgeOffset} edge - specifies the offset
	 * @param {PositionLocation} pos - specifies theloaction
	 * @param {boolean} fixedParent - specifies the boolean
	 * @param {ClientRect} elementRect - specifies the client rect
	 * @returns {void}
	 */
	function updateElementData(target, edge, pos, fixedParent, elementRect) {
	    pos.position = calculatePosition(target, pos.posX, pos.posY, fixedParent, elementRect);
	    edge.TL = calculatePosition(target, 'left', 'top', fixedParent, elementRect);
	    edge.TR = calculatePosition(target, 'right', 'top', fixedParent, elementRect);
	    edge.BR = calculatePosition(target, 'left', 'bottom', fixedParent, elementRect);
	    edge.BL = calculatePosition(target, 'right', 'bottom', fixedParent, elementRect);
	}
	/**
	 *
	 * @param {EdgeOffset} eStatus - specifies the status
	 * @param {PositionLocation} pos - specifies the location
	 * @param {ClientRect} elementRect - specifies the client
	 * @returns {void}
	 */
	function setPosition(eStatus, pos, elementRect) {
	    eStatus.TL = { top: pos.position.top + pos.offsetY, left: pos.position.left + pos.offsetX };
	    eStatus.TR = { top: eStatus.TL.top, left: eStatus.TL.left + elementRect.width };
	    eStatus.BL = { top: eStatus.TL.top + elementRect.height,
	        left: eStatus.TL.left };
	    eStatus.BR = { top: eStatus.TL.top + elementRect.height,
	        left: eStatus.TL.left + elementRect.width };
	}
	/**
	 *
	 * @param {number} left - specifies the  number
	 * @param {number} right - specifies the number
	 * @returns {LeftCorners} - returns the value
	 */
	function leftCollideCheck(left, right) {
	    //eslint-disable-next-line
	    var leftSide = false, rightSide = false;
	    if (((left - getBodyScrollLeft()) < ContainerLeft())) {
	        leftSide = true;
	    }
	    if (right > ContainerRight()) {
	        rightSide = true;
	    }
	    return { leftSide: leftSide, rightSide: rightSide };
	}
	/**
	 *
	 * @param {HTMLElement} target - specifies the element
	 * @param {EdgeOffset} edge - specifes the element
	 * @param {EdgeOffset} tEdge - specifies the edge offset
	 * @param {PositionLocation} pos - specifes the location
	 * @param {ClientRect} elementRect - specifies the client
	 * @param {boolean} deepCheck - specifies the boolean value
	 * @returns {void}
	 */
	function leftFlip(target, edge, tEdge, pos, elementRect, deepCheck) {
	    var collideSide = leftCollideCheck(edge.TL.left, edge.TR.left);
	    if ((tEdge.TL.left - getBodyScrollLeft()) <= ContainerLeft()) {
	        collideSide.leftSide = false;
	    }
	    if (tEdge.TR.left > ContainerRight()) {
	        collideSide.rightSide = false;
	    }
	    if ((collideSide.leftSide && !collideSide.rightSide) || (!collideSide.leftSide && collideSide.rightSide)) {
	        if (pos.posX === 'right') {
	            pos.posX = 'left';
	        }
	        else {
	            pos.posX = 'right';
	        }
	        pos.offsetX = pos.offsetX + elementRect.width;
	        pos.offsetX = -1 * pos.offsetX;
	        pos.position = calculatePosition(target, pos.posX, pos.posY, false);
	        setPosition(edge, pos, elementRect);
	        if (deepCheck) {
	            leftFlip(target, edge, tEdge, pos, elementRect, false);
	        }
	    }
	}
	/**
	 *
	 * @param {HTMLElement} target - specifies the element
	 * @param {EdgeOffset} edge - specifies the offset
	 * @param {EdgeOffset} tEdge - specifies the offset
	 * @param {PositionLocation} pos - specifies the location
	 * @param {ClientRect} elementRect - specifies the client rect
	 * @param {boolean} deepCheck - specifies the boolean
	 * @returns {void}
	 */
	function topFlip(target, edge, tEdge, pos, elementRect, deepCheck) {
	    var collideSide = topCollideCheck(edge.TL.top, edge.BL.top);
	    if ((tEdge.TL.top - getBodyScrollTop()) <= ContainerTop()) {
	        collideSide.topSide = false;
	    }
	    if (tEdge.BL.top >= ContainerBottom() && target.getBoundingClientRect().bottom < window.innerHeight) {
	        collideSide.bottomSide = false;
	    }
	    if ((collideSide.topSide && !collideSide.bottomSide) || (!collideSide.topSide && collideSide.bottomSide)) {
	        if (pos.posY === 'top') {
	            pos.posY = 'bottom';
	        }
	        else {
	            pos.posY = 'top';
	        }
	        pos.offsetY = pos.offsetY + elementRect.height;
	        pos.offsetY = -1 * pos.offsetY;
	        pos.position = calculatePosition(target, pos.posX, pos.posY, false, elementRect);
	        setPosition(edge, pos, elementRect);
	        if (deepCheck) {
	            topFlip(target, edge, tEdge, pos, elementRect, false);
	        }
	    }
	}
	/**
	 *
	 * @param {number} top - specifies the number
	 * @param {number} bottom - specifies the number
	 * @returns {TopCorners} - retyrns the value
	 */
	function topCollideCheck(top, bottom) {
	    //eslint-disable-next-line
	    var topSide = false, bottomSide = false;
	    if ((top - getBodyScrollTop()) < ContainerTop()) {
	        topSide = true;
	    }
	    if (bottom > ContainerBottom()) {
	        bottomSide = true;
	    }
	    return { topSide: topSide, bottomSide: bottomSide };
	}
	/**
	 * @returns {void}
	 */
	function getTargetContainerWidth() {
	    return targetContainer.getBoundingClientRect().width;
	}
	/**
	 * @returns {void}
	 */
	function getTargetContainerHeight() {
	    return targetContainer.getBoundingClientRect().height;
	}
	/**
	 * @returns {void}
	 */
	function getTargetContainerLeft() {
	    return targetContainer.getBoundingClientRect().left;
	}
	/**
	 * @returns {void}
	 */
	function getTargetContainerTop() {
	    return targetContainer.getBoundingClientRect().top;
	}
	//eslint-disable-next-line
	function ContainerTop() {
	    if (targetContainer) {
	        return getTargetContainerTop();
	    }
	    return 0;
	}
	//eslint-disable-next-line
	function ContainerLeft() {
	    if (targetContainer) {
	        return getTargetContainerLeft();
	    }
	    return 0;
	}
	//eslint-disable-next-line
	function ContainerRight() {
	    if (targetContainer) {
	        return (getBodyScrollLeft() + getTargetContainerLeft() + getTargetContainerWidth());
	    }
	    return (getBodyScrollLeft() + getViewPortWidth());
	}
	//eslint-disable-next-line
	function ContainerBottom() {
	    if (targetContainer) {
	        return (getBodyScrollTop() + getTargetContainerTop() + getTargetContainerHeight());
	    }
	    return (getBodyScrollTop() + getViewPortHeight());
	}
	/**
	 * @returns {void}
	 */
	function getBodyScrollTop() {
	    // if(targetContainer)
	    //     return targetContainer.scrollTop;
	    return parentDocument.documentElement.scrollTop || parentDocument.body.scrollTop;
	}
	/**
	 * @returns {void}
	 */
	function getBodyScrollLeft() {
	    // if(targetContainer)
	    //     return targetContainer.scrollLeft;
	    return parentDocument.documentElement.scrollLeft || parentDocument.body.scrollLeft;
	}
	/**
	 * @returns {void}
	 */
	function getViewPortHeight() {
	    return window.innerHeight;
	}
	/**
	 * @returns {void}
	 */
	function getViewPortWidth() {
	    var windowWidth = window.innerWidth;
	    var documentReact = document.documentElement.getBoundingClientRect();
	    var offsetWidth = (isNullOrUndefined(document.documentElement)) ? 0 : documentReact.width;
	    return windowWidth - (windowWidth - offsetWidth);
	}

	var __extends$G = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	/**
	 * Specifies the offset position values.
	 */
	var PositionData = /** @class */ (function (_super) {
	    __extends$G(PositionData, _super);
	    function PositionData() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$a([
	        Property('left')
	    ], PositionData.prototype, "X", void 0);
	    __decorate$a([
	        Property('top')
	    ], PositionData.prototype, "Y", void 0);
	    return PositionData;
	}(ChildProperty));
	// don't use space in classNames
	var CLASSNAMES$1 = {
	    ROOT: 'e-popup',
	    RTL: 'e-rtl',
	    OPEN: 'e-popup-open',
	    CLOSE: 'e-popup-close'
	};
	/**
	 * Represents the Popup Component
	 * ```html
	 * <div id="popup" style="position:absolute;height:100px;width:100px;">
	 * <div style="margin:35px 25px;">Popup Content</div></div>
	 * ```
	 * ```typescript
	 * <script>
	 *   var popupObj = new Popup();
	 *   popupObj.appendTo("#popup");
	 * </script>
	 * ```
	 */
	var Popup = /** @class */ (function (_super) {
	    __extends$G(Popup, _super);
	    function Popup(element, options) {
	        return _super.call(this, options, element) || this;
	    }
	    /**
	     * Called internally if any of the property value changed.
	     *
	     * @param {PopupModel} newProp - specifies the new property
	     * @param {PopupModel} oldProp - specifies the old property
	     * @private
	     * @returns {void}
	     */
	    Popup.prototype.onPropertyChanged = function (newProp, oldProp) {
	        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
	            var prop = _a[_i];
	            switch (prop) {
	                case 'width':
	                    setStyleAttribute(this.element, { 'width': formatUnit(newProp.width) });
	                    break;
	                case 'height':
	                    setStyleAttribute(this.element, { 'height': formatUnit(newProp.height) });
	                    break;
	                case 'zIndex':
	                    setStyleAttribute(this.element, { 'zIndex': newProp.zIndex });
	                    break;
	                case 'enableRtl':
	                    this.setEnableRtl();
	                    break;
	                case 'position':
	                case 'relateTo':
	                    this.refreshPosition();
	                    break;
	                case 'offsetX':
	                    // eslint-disable-next-line
	                    var x = newProp.offsetX - oldProp.offsetX;
	                    this.element.style.left = (parseInt(this.element.style.left, 10) + (x)).toString() + 'px';
	                    break;
	                case 'offsetY':
	                    // eslint-disable-next-line
	                    var y = newProp.offsetY - oldProp.offsetY;
	                    this.element.style.top = (parseInt(this.element.style.top, 10) + (y)).toString() + 'px';
	                    break;
	                case 'content':
	                    this.setContent();
	                    break;
	                case 'actionOnScroll':
	                    if (newProp.actionOnScroll !== 'none') {
	                        this.wireScrollEvents();
	                    }
	                    else {
	                        this.unwireScrollEvents();
	                    }
	                    break;
	            }
	        }
	    };
	    /**
	     * gets the Component module name.
	     *
	     * @returns {void}
	     * @private
	     */
	    Popup.prototype.getModuleName = function () {
	        return 'popup';
	    };
	    /**
	     * To resolve if any collision occurs.
	     *
	     * @returns {void}
	     */
	    Popup.prototype.resolveCollision = function () {
	        this.checkCollision();
	    };
	    /**
	     * gets the persisted state properties of the Component.
	     *
	     * @returns {void}
	     */
	    Popup.prototype.getPersistData = function () {
	        return this.addOnPersist([]);
	    };
	    /**
	     * To destroy the control.
	     *
	     * @returns {void}
	     */
	    Popup.prototype.destroy = function () {
	        if (this.element.classList.contains('e-popup-open')) {
	            this.unwireEvents();
	        }
	        this.element.classList.remove(CLASSNAMES$1.ROOT, CLASSNAMES$1.RTL, CLASSNAMES$1.OPEN, CLASSNAMES$1.CLOSE);
	        this.content = null;
	        this.relateTo = null;
	        _super.prototype.destroy.call(this);
	    };
	    /**
	     * To Initialize the control rendering
	     *
	     * @returns {void}
	     * @private
	     */
	    Popup.prototype.render = function () {
	        this.element.classList.add(CLASSNAMES$1.ROOT);
	        var styles = {};
	        if (this.zIndex !== 1000) {
	            styles.zIndex = this.zIndex;
	        }
	        if (this.width !== 'auto') {
	            styles.width = formatUnit(this.width);
	        }
	        if (this.height !== 'auto') {
	            styles.height = formatUnit(this.height);
	        }
	        setStyleAttribute(this.element, styles);
	        this.fixedParent = false;
	        this.setEnableRtl();
	        this.setContent();
	    };
	    Popup.prototype.wireEvents = function () {
	        if (Browser.isDevice) {
	            EventHandler.add(window, 'orientationchange', this.orientationOnChange, this);
	        }
	        if (this.actionOnScroll !== 'none') {
	            this.wireScrollEvents();
	        }
	    };
	    Popup.prototype.wireScrollEvents = function () {
	        if (this.getRelateToElement()) {
	            for (var _i = 0, _a = this.getScrollableParent(this.getRelateToElement()); _i < _a.length; _i++) {
	                var parent_1 = _a[_i];
	                EventHandler.add(parent_1, 'scroll', this.scrollRefresh, this);
	            }
	        }
	    };
	    Popup.prototype.unwireEvents = function () {
	        if (Browser.isDevice) {
	            EventHandler.remove(window, 'orientationchange', this.orientationOnChange);
	        }
	        if (this.actionOnScroll !== 'none') {
	            this.unwireScrollEvents();
	        }
	    };
	    Popup.prototype.unwireScrollEvents = function () {
	        if (this.getRelateToElement()) {
	            for (var _i = 0, _a = this.getScrollableParent(this.getRelateToElement()); _i < _a.length; _i++) {
	                var parent_2 = _a[_i];
	                EventHandler.remove(parent_2, 'scroll', this.scrollRefresh);
	            }
	        }
	    };
	    Popup.prototype.getRelateToElement = function () {
	        var relateToElement = this.relateTo === '' || isNullOrUndefined(this.relateTo) ?
	            document.body : this.relateTo;
	        this.setProperties({ relateTo: relateToElement }, true);
	        return ((typeof this.relateTo) === 'string') ?
	            document.querySelector(this.relateTo) : this.relateTo;
	    };
	    Popup.prototype.scrollRefresh = function (e) {
	        if (this.actionOnScroll === 'reposition') {
	            if (!isNullOrUndefined(this.element) && !(this.element.offsetParent === e.target ||
	                (this.element.offsetParent && this.element.offsetParent.tagName === 'BODY' &&
	                    e.target.parentElement == null))) {
	                this.refreshPosition();
	            }
	        }
	        else if (this.actionOnScroll === 'hide') {
	            this.hide();
	        }
	        if (this.actionOnScroll !== 'none') {
	            if (this.getRelateToElement()) {
	                var targetVisible = this.isElementOnViewport(this.getRelateToElement(), e.target);
	                if (!targetVisible && !this.targetInvisibleStatus) {
	                    this.trigger('targetExitViewport');
	                    this.targetInvisibleStatus = true;
	                }
	                else if (targetVisible) {
	                    this.targetInvisibleStatus = false;
	                }
	            }
	        }
	    };
	    /**
	     * This method is to get the element visibility on viewport when scroll
	     * the page. This method will returns true even though 1 px of element
	     * part is in visible.
	     *
	     * @param {HTMLElement} relateToElement - specifies the element
	     * @param {HTMLElement} scrollElement - specifies the scroll element
	     * @returns {boolean} - retruns the boolean
	     */
	    // eslint-disable-next-line
	    Popup.prototype.isElementOnViewport = function (relateToElement, scrollElement) {
	        var scrollParents = this.getScrollableParent(relateToElement);
	        for (var parent_3 = 0; parent_3 < scrollParents.length; parent_3++) {
	            if (this.isElementVisible(relateToElement, scrollParents[parent_3])) {
	                continue;
	            }
	            else {
	                return false;
	            }
	        }
	        return true;
	    };
	    Popup.prototype.isElementVisible = function (relateToElement, scrollElement) {
	        var rect = this.checkGetBoundingClientRect(relateToElement);
	        if (!rect.height || !rect.width) {
	            return false;
	        }
	        if (!isNullOrUndefined(this.checkGetBoundingClientRect(scrollElement))) {
	            var parent_4 = scrollElement.getBoundingClientRect();
	            return !(rect.bottom < parent_4.top) &&
	                (!(rect.bottom > parent_4.bottom) &&
	                    (!(rect.right > parent_4.right) &&
	                        !(rect.left < parent_4.left)));
	        }
	        else {
	            var win = window;
	            var windowView = {
	                top: win.scrollY,
	                left: win.scrollX,
	                right: win.scrollX + win.outerWidth,
	                bottom: win.scrollY + win.outerHeight
	            };
	            var off = calculatePosition(relateToElement);
	            var ele = {
	                top: off.top,
	                left: off.left,
	                right: off.left + rect.width,
	                bottom: off.top + rect.height
	            };
	            var elementView = {
	                top: windowView.bottom - ele.top,
	                left: windowView.right - ele.left,
	                bottom: ele.bottom - windowView.top,
	                right: ele.right - windowView.left
	            };
	            return elementView.top > 0
	                && elementView.left > 0
	                && elementView.right > 0
	                && elementView.bottom > 0;
	        }
	    };
	    /**
	     * Initialize the event handler
	     *
	     * @returns {void}
	     * @private
	     */
	    Popup.prototype.preRender = function () {
	        //There is no event handler
	    };
	    Popup.prototype.setEnableRtl = function () {
	        this.reposition();
	        // eslint-disable-next-line
	        this.enableRtl ? this.element.classList.add(CLASSNAMES$1.RTL) : this.element.classList.remove(CLASSNAMES$1.RTL);
	    };
	    Popup.prototype.setContent = function () {
	        if (!isNullOrUndefined(this.content)) {
	            this.element.innerHTML = '';
	            if (typeof (this.content) === 'string') {
	                this.element.textContent = this.content;
	            }
	            else {
	                var relateToElem = this.getRelateToElement();
	                // eslint-disable-next-line
	                var props = this.content.props;
	                if (!relateToElem.classList.contains('e-dropdown-btn') || isNullOrUndefined(props)) {
	                    this.element.appendChild(this.content);
	                }
	            }
	        }
	    };
	    Popup.prototype.orientationOnChange = function () {
	        var _this = this;
	        setTimeout(function () {
	            _this.refreshPosition();
	        }, 200);
	    };
	    // eslint-disable-next-line
	    /**
	     * Based on the `relative` element and `offset` values, `Popup` element position will refreshed.
	     *
	     * @returns {void}
	     */
	    Popup.prototype.refreshPosition = function (target, collision) {
	        if (!isNullOrUndefined(target)) {
	            this.checkFixedParent(target);
	        }
	        this.reposition();
	        if (!collision) {
	            this.checkCollision();
	        }
	    };
	    Popup.prototype.reposition = function () {
	        var pos;
	        var position;
	        var relateToElement = this.getRelateToElement();
	        if (typeof this.position.X === 'number' && typeof this.position.Y === 'number') {
	            pos = { left: this.position.X, top: this.position.Y };
	        }
	        else if ((typeof this.position.X === 'string' && typeof this.position.Y === 'number') ||
	            (typeof this.position.X === 'number' && typeof this.position.Y === 'string')) {
	            var parentDisplay = void 0;
	            var display = this.element.style.display;
	            this.element.style.display = 'block';
	            if (this.element.classList.contains('e-dlg-modal')) {
	                parentDisplay = this.element.parentElement.style.display;
	                this.element.parentElement.style.display = 'block';
	            }
	            position = this.getAnchorPosition(relateToElement, this.element, this.position, this.offsetX, this.offsetY);
	            if (typeof this.position.X === 'string') {
	                pos = { left: position.left, top: this.position.Y };
	            }
	            else {
	                pos = { left: this.position.X, top: position.top };
	            }
	            this.element.style.display = display;
	            if (this.element.classList.contains('e-dlg-modal')) {
	                this.element.parentElement.style.display = parentDisplay;
	            }
	        }
	        else if (relateToElement) {
	            var height = this.element.clientHeight;
	            var display = this.element.style.display;
	            this.element.style.display = 'block';
	            pos = this.getAnchorPosition(relateToElement, this.element, this.position, this.offsetX, this.offsetY, height);
	            this.element.style.display = display;
	        }
	        else {
	            pos = { left: 0, top: 0 };
	        }
	        if (!isNullOrUndefined(pos)) {
	            this.element.style.left = pos.left + 'px';
	            this.element.style.top = pos.top + 'px';
	        }
	    };
	    Popup.prototype.checkGetBoundingClientRect = function (ele) {
	        var eleRect;
	        try {
	            eleRect = ele.getBoundingClientRect();
	            return eleRect;
	        }
	        catch (error) {
	            return null;
	        }
	    };
	    Popup.prototype.getAnchorPosition = function (anchorEle, ele, position, offsetX, offsetY, height) {
	        if (height === void 0) { height = 0; }
	        var eleRect = this.checkGetBoundingClientRect(ele);
	        var anchorRect = this.checkGetBoundingClientRect(anchorEle);
	        if (isNullOrUndefined(eleRect) || isNullOrUndefined(anchorRect)) {
	            return null;
	        }
	        var anchor = anchorEle;
	        var anchorPos = { left: 0, top: 0 };
	        if (ele.offsetParent && ele.offsetParent.tagName === 'BODY' && anchorEle.tagName === 'BODY') {
	            anchorPos = calculatePosition(anchorEle);
	        }
	        else {
	            if ((ele.classList.contains('e-dlg-modal') && anchor.tagName !== 'BODY')) {
	                ele = ele.parentElement;
	            }
	            anchorPos = calculateRelativeBasedPosition(anchor, ele);
	        }
	        switch (position.X) {
	            default:
	            case 'left':
	                break;
	            case 'center':
	                if ((ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container')) {
	                    anchorPos.left += (window.innerWidth / 2 - eleRect.width / 2);
	                }
	                else if (this.targetType === 'container') {
	                    anchorPos.left += (anchorRect.width / 2 - eleRect.width / 2);
	                }
	                else {
	                    anchorPos.left += (anchorRect.width / 2);
	                }
	                break;
	            case 'right':
	                if ((ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container')) {
	                    anchorPos.left += (window.innerWidth - eleRect.width);
	                }
	                else if (this.targetType === 'container') {
	                    anchorPos.left += (anchorRect.width - eleRect.width);
	                }
	                else {
	                    anchorPos.left += (anchorRect.width);
	                }
	                break;
	        }
	        switch (position.Y) {
	            default:
	            case 'top':
	                break;
	            case 'center':
	                if ((ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container')) {
	                    anchorPos.top += (window.innerHeight / 2 - eleRect.height / 2);
	                }
	                else if (this.targetType === 'container') {
	                    anchorPos.top += (anchorRect.height / 2 - eleRect.height / 2);
	                }
	                else {
	                    anchorPos.top += (anchorRect.height / 2);
	                }
	                break;
	            case 'bottom':
	                if ((ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container')) {
	                    anchorPos.top += (window.innerHeight - eleRect.height);
	                }
	                else if (this.targetType === 'container' && !ele.classList.contains('e-dialog')) {
	                    anchorPos.top += (anchorRect.height - eleRect.height);
	                }
	                else if (this.targetType === 'container' && ele.classList.contains('e-dialog')) {
	                    anchorPos.top += (anchorRect.height - height);
	                }
	                else {
	                    anchorPos.top += (anchorRect.height);
	                }
	                break;
	        }
	        anchorPos.left += offsetX;
	        anchorPos.top += offsetY;
	        return anchorPos;
	    };
	    Popup.prototype.callFlip = function (param) {
	        var relateToElement = this.getRelateToElement();
	        flip(this.element, relateToElement, this.offsetX, this.offsetY, this.position.X, this.position.Y, this.viewPortElement, param, this.fixedParent);
	    };
	    Popup.prototype.callFit = function (param) {
	        if (isCollide$1(this.element, this.viewPortElement).length !== 0) {
	            if (isNullOrUndefined(this.viewPortElement)) {
	                var data = fit(this.element, this.viewPortElement, param);
	                if (param.X) {
	                    this.element.style.left = data.left + 'px';
	                }
	                if (param.Y) {
	                    this.element.style.top = data.top + 'px';
	                }
	            }
	            else {
	                var elementRect = this.checkGetBoundingClientRect(this.element);
	                var viewPortRect = this.checkGetBoundingClientRect(this.viewPortElement);
	                if (isNullOrUndefined(elementRect) || isNullOrUndefined(viewPortRect)) {
	                    return null;
	                }
	                if (param && param.Y === true) {
	                    if (viewPortRect.top > elementRect.top) {
	                        this.element.style.top = '0px';
	                    }
	                    else if (viewPortRect.bottom < elementRect.bottom) {
	                        this.element.style.top = parseInt(this.element.style.top, 10) - (elementRect.bottom - viewPortRect.bottom) + 'px';
	                    }
	                }
	                if (param && param.X === true) {
	                    if (viewPortRect.right < elementRect.right) {
	                        this.element.style.left = parseInt(this.element.style.left, 10) - (elementRect.right - viewPortRect.right) + 'px';
	                    }
	                    else if (viewPortRect.left > elementRect.left) {
	                        this.element.style.left = parseInt(this.element.style.left, 10) + (viewPortRect.left - elementRect.left) + 'px';
	                    }
	                }
	            }
	        }
	    };
	    Popup.prototype.checkCollision = function () {
	        var horz = this.collision.X;
	        var vert = this.collision.Y;
	        if (horz === 'none' && vert === 'none') {
	            return;
	        }
	        if (horz === 'flip' && vert === 'flip') {
	            this.callFlip({ X: true, Y: true });
	        }
	        else if (horz === 'fit' && vert === 'fit') {
	            this.callFit({ X: true, Y: true });
	        }
	        else {
	            if (horz === 'flip') {
	                this.callFlip({ X: true, Y: false });
	            }
	            else if (vert === 'flip') {
	                this.callFlip({ Y: true, X: false });
	            }
	            if (horz === 'fit') {
	                this.callFit({ X: true, Y: false });
	            }
	            else if (vert === 'fit') {
	                this.callFit({ X: false, Y: true });
	            }
	        }
	    };
	    /**
	     * Shows the popup element from screen.
	     *
	     * @returns {void}
	     * @param {AnimationModel} animationOptions - specifies the model
	     * @param { HTMLElement } relativeElement - To calculate the zIndex value dynamically.
	     */
	    Popup.prototype.show = function (animationOptions, relativeElement) {
	        var _this = this;
	        var relateToElement = this.getRelateToElement();
	        if (relateToElement.classList.contains('e-filemanager')) {
	            this.fmDialogContainer = this.element.getElementsByClassName('e-file-select-wrap')[0];
	        }
	        this.wireEvents();
	        if (!isNullOrUndefined(this.fmDialogContainer) && Browser.isIos) {
	            this.fmDialogContainer.style.display = 'block';
	        }
	        if (this.zIndex === 1000 || !isNullOrUndefined(relativeElement)) {
	            var zIndexElement = (isNullOrUndefined(relativeElement)) ? this.element : relativeElement;
	            this.zIndex = getZindexPartial(zIndexElement);
	            setStyleAttribute(this.element, { 'zIndex': this.zIndex });
	        }
	        animationOptions = (!isNullOrUndefined(animationOptions) && typeof animationOptions === 'object') ?
	            animationOptions : this.showAnimation;
	        if (this.collision.X !== 'none' || this.collision.Y !== 'none') {
	            removeClass([this.element], CLASSNAMES$1.CLOSE);
	            addClass([this.element], CLASSNAMES$1.OPEN);
	            this.checkCollision();
	            removeClass([this.element], CLASSNAMES$1.OPEN);
	            addClass([this.element], CLASSNAMES$1.CLOSE);
	        }
	        if (!isNullOrUndefined(animationOptions)) {
	            animationOptions.begin = function () {
	                if (!_this.isDestroyed) {
	                    removeClass([_this.element], CLASSNAMES$1.CLOSE);
	                    addClass([_this.element], CLASSNAMES$1.OPEN);
	                }
	            };
	            animationOptions.end = function () {
	                if (!_this.isDestroyed) {
	                    _this.trigger('open');
	                }
	            };
	            new Animation$1(animationOptions).animate(this.element);
	        }
	        else {
	            removeClass([this.element], CLASSNAMES$1.CLOSE);
	            addClass([this.element], CLASSNAMES$1.OPEN);
	            this.trigger('open');
	        }
	    };
	    /**
	     * Hides the popup element from screen.
	     *
	     * @param {AnimationModel} animationOptions - To give the animation options.
	     * @returns {void}
	     */
	    Popup.prototype.hide = function (animationOptions) {
	        var _this = this;
	        animationOptions = (!isNullOrUndefined(animationOptions) && typeof animationOptions === 'object') ?
	            animationOptions : this.hideAnimation;
	        if (!isNullOrUndefined(animationOptions)) {
	            animationOptions.end = function () {
	                if (!_this.isDestroyed) {
	                    removeClass([_this.element], CLASSNAMES$1.OPEN);
	                    addClass([_this.element], CLASSNAMES$1.CLOSE);
	                    _this.trigger('close');
	                }
	            };
	            new Animation$1(animationOptions).animate(this.element);
	        }
	        else {
	            removeClass([this.element], CLASSNAMES$1.OPEN);
	            addClass([this.element], CLASSNAMES$1.CLOSE);
	            this.trigger('close');
	        }
	        this.unwireEvents();
	    };
	    /**
	     * Gets scrollable parent elements for the given element.
	     *
	     * @returns {void}
	     * @param { HTMLElement } element - Specify the element to get the scrollable parents of it.
	     */
	    Popup.prototype.getScrollableParent = function (element) {
	        this.checkFixedParent(element);
	        return getScrollableParent(element, this.fixedParent);
	    };
	    Popup.prototype.checkFixedParent = function (element) {
	        var parent = element.parentElement;
	        while (parent && parent.tagName !== 'HTML') {
	            var parentStyle = getComputedStyle(parent);
	            if (parentStyle.position === 'fixed' && !isNullOrUndefined(this.element) && this.element.offsetParent &&
	                this.element.offsetParent.tagName === 'BODY' && getComputedStyle(this.element.offsetParent).overflow !== 'hidden') {
	                this.element.style.top = window.scrollY > parseInt(this.element.style.top, 10) ?
	                    formatUnit(window.scrollY - parseInt(this.element.style.top, 10))
	                    : formatUnit(parseInt(this.element.style.top, 10) - window.scrollY);
	                this.element.style.position = 'fixed';
	                this.fixedParent = true;
	            }
	            parent = parent.parentElement;
	            if (!isNullOrUndefined(this.element) && isNullOrUndefined(this.element.offsetParent) && parentStyle.position === 'fixed'
	                && this.element.style.position === 'fixed') {
	                this.fixedParent = true;
	            }
	        }
	    };
	    __decorate$a([
	        Property('auto')
	    ], Popup.prototype, "height", void 0);
	    __decorate$a([
	        Property('auto')
	    ], Popup.prototype, "width", void 0);
	    __decorate$a([
	        Property(null)
	    ], Popup.prototype, "content", void 0);
	    __decorate$a([
	        Property('container')
	    ], Popup.prototype, "targetType", void 0);
	    __decorate$a([
	        Property(null)
	    ], Popup.prototype, "viewPortElement", void 0);
	    __decorate$a([
	        Property({ X: 'none', Y: 'none' })
	    ], Popup.prototype, "collision", void 0);
	    __decorate$a([
	        Property('')
	    ], Popup.prototype, "relateTo", void 0);
	    __decorate$a([
	        Complex({}, PositionData)
	    ], Popup.prototype, "position", void 0);
	    __decorate$a([
	        Property(0)
	    ], Popup.prototype, "offsetX", void 0);
	    __decorate$a([
	        Property(0)
	    ], Popup.prototype, "offsetY", void 0);
	    __decorate$a([
	        Property(1000)
	    ], Popup.prototype, "zIndex", void 0);
	    __decorate$a([
	        Property(false)
	    ], Popup.prototype, "enableRtl", void 0);
	    __decorate$a([
	        Property('reposition')
	    ], Popup.prototype, "actionOnScroll", void 0);
	    __decorate$a([
	        Property(null)
	    ], Popup.prototype, "showAnimation", void 0);
	    __decorate$a([
	        Property(null)
	    ], Popup.prototype, "hideAnimation", void 0);
	    __decorate$a([
	        Event()
	    ], Popup.prototype, "open", void 0);
	    __decorate$a([
	        Event()
	    ], Popup.prototype, "close", void 0);
	    __decorate$a([
	        Event()
	    ], Popup.prototype, "targetExitViewport", void 0);
	    Popup = __decorate$a([
	        NotifyPropertyChanges
	    ], Popup);
	    return Popup;
	}(Component));
	/**
	 * Gets scrollable parent elements for the given element.
	 *
	 * @param { HTMLElement } element - Specify the element to get the scrollable parents of it.
	 * @param {boolean} fixedParent - specifies the parent element
	 * @private
	 * @returns {void}
	 */
	function getScrollableParent(element, fixedParent) {
	    var eleStyle = getComputedStyle(element);
	    var scrollParents = [];
	    var overflowRegex = /(auto|scroll)/;
	    var parent = element.parentElement;
	    while (parent && parent.tagName !== 'HTML') {
	        var parentStyle = getComputedStyle(parent);
	        if (!(eleStyle.position === 'absolute' && parentStyle.position === 'static')
	            && overflowRegex.test(parentStyle.overflow + parentStyle.overflowY + parentStyle.overflowX)) {
	            scrollParents.push(parent);
	        }
	        parent = parent.parentElement;
	    }
	    if (!fixedParent) {
	        scrollParents.push(document);
	    }
	    return scrollParents;
	}
	/**
	 * Gets the maximum z-index of the given element.
	 *
	 * @returns {void}
	 * @param { HTMLElement } element - Specify the element to get the maximum z-index of it.
	 * @private
	 */
	function getZindexPartial(element) {
	    // upto body traversal
	    var parent = element.parentElement;
	    var parentZindex = [];
	    while (parent) {
	        if (parent.tagName !== 'BODY') {
	            var index = document.defaultView.getComputedStyle(parent, null).getPropertyValue('z-index');
	            var position = document.defaultView.getComputedStyle(parent, null).getPropertyValue('position');
	            if (index !== 'auto' && position !== 'static') {
	                parentZindex.push(index);
	            }
	            parent = parent.parentElement;
	        }
	        else {
	            break;
	        }
	    }
	    var childrenZindex = [];
	    for (var i = 0; i < document.body.children.length; i++) {
	        if (!element.isEqualNode(document.body.children[i])) {
	            var index = document.defaultView.getComputedStyle(document.body.children[i], null).getPropertyValue('z-index');
	            var position = document.defaultView.getComputedStyle(document.body.children[i], null).getPropertyValue('position');
	            if (index !== 'auto' && position !== 'static') {
	                childrenZindex.push(index);
	            }
	        }
	    }
	    childrenZindex.push('999');
	    var siblingsZindex = [];
	    if (!isNullOrUndefined(element.parentElement) && element.parentElement.tagName !== 'BODY') {
	        var childNodes = [].slice.call(element.parentElement.children);
	        for (var i = 0; i < childNodes.length; i++) {
	            if (!element.isEqualNode(childNodes[i])) {
	                var index = document.defaultView.getComputedStyle(childNodes[i], null).getPropertyValue('z-index');
	                var position = document.defaultView.getComputedStyle(childNodes[i], null).getPropertyValue('position');
	                if (index !== 'auto' && position !== 'static') {
	                    siblingsZindex.push(index);
	                }
	            }
	        }
	    }
	    var finalValue = parentZindex.concat(childrenZindex, siblingsZindex);
	    // eslint-disable-next-line
	    var currentZindexValue = Math.max.apply(Math, finalValue) + 1;
	    return currentZindexValue > 2147483647 ? 2147483647 : currentZindexValue;
	}

	/**
	 * Get the text node.
	 *
	 * @param {HTMLElement} element - Specifies html element
	 * @private
	 * @returns {Node} - Text node.
	 */
	function getTextNode(element) {
	    var node;
	    var childnode = element.childNodes;
	    for (var i = 0; i < childnode.length; i++) {
	        node = childnode[i];
	        if (node.nodeType === 3) {
	            return node;
	        }
	    }
	    return null;
	}

	var __extends$F = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	/**
	 * Defines the icon position of button.
	 */
	var IconPosition;
	(function (IconPosition) {
	    /**
	     * Positions the Icon at the left of the text content in the Button.
	     */
	    IconPosition["Left"] = "Left";
	    /**
	     * Positions the Icon at the right of the text content in the Button.
	     */
	    IconPosition["Right"] = "Right";
	    /**
	     * Positions the Icon at the top of the text content in the Button.
	     */
	    IconPosition["Top"] = "Top";
	    /**
	     * Positions the Icon at the bottom of the text content in the Button.
	     */
	    IconPosition["Bottom"] = "Bottom";
	})(IconPosition || (IconPosition = {}));
	var cssClassName = {
	    RTL: 'e-rtl',
	    BUTTON: 'e-btn',
	    PRIMARY: 'e-primary',
	    ICONBTN: 'e-icon-btn'
	};
	/**
	 * The Button is a graphical user interface element that triggers an event on its click action. It can contain a text, an image, or both.
	 * ```html
	 * <button id="button">Button</button>
	 * ```
	 * ```typescript
	 * <script>
	 * var btnObj = new Button();
	 * btnObj.appendTo("#button");
	 * </script>
	 * ```
	 */
	var Button = /** @class */ (function (_super) {
	    __extends$F(Button, _super);
	    /**
	     * Constructor for creating the widget
	     *
	     * @param  {ButtonModel} options - Specifies the button model
	     * @param  {string|HTMLButtonElement} element - Specifies the target element
	     */
	    function Button(options, element) {
	        return _super.call(this, options, element) || this;
	    }
	    Button.prototype.preRender = function () {
	        // pre render code snippets
	    };
	    /**
	     * Initialize the control rendering
	     *
	     * @returns {void}
	     * @private
	     */
	    Button.prototype.render = function () {
	        this.initialize();
	        this.removeRippleEffect = rippleEffect(this.element, { selector: '.' + cssClassName.BUTTON });
	        this.renderComplete();
	    };
	    Button.prototype.initialize = function () {
	        if (this.cssClass) {
	            addClass([this.element], this.cssClass.replace(/\s+/g, ' ').trim().split(' '));
	        }
	        if (this.isPrimary) {
	            this.element.classList.add(cssClassName.PRIMARY);
	        }
	        {
	            if (this.content) {
	                var tempContent = (this.enableHtmlSanitizer) ? SanitizeHtmlHelper.sanitize(this.content) : this.content;
	                this.element.innerHTML = tempContent;
	            }
	            this.setIconCss();
	        }
	        if (this.enableRtl) {
	            this.element.classList.add(cssClassName.RTL);
	        }
	        if (this.disabled) {
	            this.controlStatus(this.disabled);
	        }
	        else {
	            this.wireEvents();
	        }
	    };
	    Button.prototype.controlStatus = function (disabled) {
	        this.element.disabled = disabled;
	    };
	    Button.prototype.setIconCss = function () {
	        if (this.iconCss) {
	            var span = this.createElement('span', { className: 'e-btn-icon ' + this.iconCss });
	            if (!this.element.textContent.trim()) {
	                this.element.classList.add(cssClassName.ICONBTN);
	            }
	            else {
	                span.classList.add('e-icon-' + this.iconPosition.toLowerCase());
	                if (this.iconPosition === 'Top' || this.iconPosition === 'Bottom') {
	                    this.element.classList.add('e-' + this.iconPosition.toLowerCase() + '-icon-btn');
	                }
	            }
	            var node = this.element.childNodes[0];
	            if (node && (this.iconPosition === 'Left' || this.iconPosition === 'Top')) {
	                this.element.insertBefore(span, node);
	            }
	            else {
	                this.element.appendChild(span);
	            }
	        }
	    };
	    Button.prototype.wireEvents = function () {
	        if (this.isToggle) {
	            EventHandler.add(this.element, 'click', this.btnClickHandler, this);
	        }
	    };
	    Button.prototype.unWireEvents = function () {
	        if (this.isToggle) {
	            EventHandler.remove(this.element, 'click', this.btnClickHandler);
	        }
	    };
	    Button.prototype.btnClickHandler = function () {
	        if (this.element.classList.contains('e-active')) {
	            this.element.classList.remove('e-active');
	        }
	        else {
	            this.element.classList.add('e-active');
	        }
	    };
	    /**
	     * Destroys the widget.
	     *
	     * @returns {void}
	     */
	    Button.prototype.destroy = function () {
	        var classList = [cssClassName.PRIMARY, cssClassName.RTL, cssClassName.ICONBTN, 'e-success', 'e-info', 'e-danger',
	            'e-warning', 'e-flat', 'e-outline', 'e-small', 'e-bigger', 'e-active', 'e-round',
	            'e-top-icon-btn', 'e-bottom-icon-btn'];
	        if (this.cssClass) {
	            classList = classList.concat(this.cssClass.split(' '));
	        }
	        _super.prototype.destroy.call(this);
	        removeClass([this.element], classList);
	        if (!this.element.getAttribute('class')) {
	            this.element.removeAttribute('class');
	        }
	        if (this.disabled) {
	            this.element.removeAttribute('disabled');
	        }
	        if (this.content) {
	            this.element.innerHTML = this.element.innerHTML.replace(this.content, '');
	        }
	        var span = this.element.querySelector('span.e-btn-icon');
	        if (span) {
	            detach(span);
	        }
	        this.unWireEvents();
	    };
	    /**
	     * Get component name.
	     *
	     * @returns {string} - Module name
	     * @private
	     */
	    Button.prototype.getModuleName = function () {
	        return 'btn';
	    };
	    /**
	     * Get the properties to be maintained in the persisted state.
	     *
	     * @returns {string} - Persist Data
	     * @private
	     */
	    Button.prototype.getPersistData = function () {
	        return this.addOnPersist([]);
	    };
	    /**
	     * Dynamically injects the required modules to the component.
	     *
	     * @private
	     * @returns {void}
	     */
	    Button.Inject = function () {
	        // Inject code snippets
	    };
	    /**
	     * Called internally if any of the property value changed.
	     *
	     * @param  {ButtonModel} newProp - Specifies new properties
	     * @param  {ButtonModel} oldProp - Specifies old properties
	     * @returns {void}
	     * @private
	     */
	    Button.prototype.onPropertyChanged = function (newProp, oldProp) {
	        var span = this.element.querySelector('span.e-btn-icon');
	        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
	            var prop = _a[_i];
	            switch (prop) {
	                case 'isPrimary':
	                    if (newProp.isPrimary) {
	                        this.element.classList.add(cssClassName.PRIMARY);
	                    }
	                    else {
	                        this.element.classList.remove(cssClassName.PRIMARY);
	                    }
	                    break;
	                case 'disabled':
	                    this.controlStatus(newProp.disabled);
	                    break;
	                case 'iconCss': {
	                    if (span) {
	                        if (newProp.iconCss) {
	                            span.className = 'e-btn-icon ' + newProp.iconCss;
	                            if (this.element.textContent.trim()) {
	                                if (this.iconPosition === 'Left') {
	                                    span.classList.add('e-icon-left');
	                                }
	                                else {
	                                    span.classList.add('e-icon-right');
	                                }
	                            }
	                        }
	                        else {
	                            detach(span);
	                        }
	                    }
	                    else {
	                        this.setIconCss();
	                    }
	                    break;
	                }
	                case 'iconPosition':
	                    removeClass([this.element], ['e-top-icon-btn', 'e-bottom-icon-btn']);
	                    span = this.element.querySelector('span.e-btn-icon');
	                    if (span) {
	                        detach(span);
	                    }
	                    this.setIconCss();
	                    break;
	                case 'cssClass':
	                    if (oldProp.cssClass) {
	                        removeClass([this.element], oldProp.cssClass.split(' '));
	                    }
	                    if (newProp.cssClass) {
	                        addClass([this.element], newProp.cssClass.replace(/\s+/g, ' ').trim().split(' '));
	                    }
	                    break;
	                case 'enableRtl':
	                    if (newProp.enableRtl) {
	                        this.element.classList.add(cssClassName.RTL);
	                    }
	                    else {
	                        this.element.classList.remove(cssClassName.RTL);
	                    }
	                    break;
	                case 'content': {
	                    var node = getTextNode(this.element);
	                    if (!node) {
	                        this.element.classList.remove(cssClassName.ICONBTN);
	                    }
	                    {
	                        if (this.enableHtmlSanitizer) {
	                            newProp.content = SanitizeHtmlHelper.sanitize(newProp.content);
	                        }
	                        this.element.innerHTML = newProp.content;
	                        this.setIconCss();
	                    }
	                    break;
	                }
	                case 'isToggle':
	                    if (newProp.isToggle) {
	                        EventHandler.add(this.element, 'click', this.btnClickHandler, this);
	                    }
	                    else {
	                        EventHandler.remove(this.element, 'click', this.btnClickHandler);
	                        removeClass([this.element], ['e-active']);
	                    }
	                    break;
	            }
	        }
	    };
	    /**
	     * Click the button element
	     * its native method
	     *
	     * @public
	     * @returns {void}
	     */
	    Button.prototype.click = function () {
	        this.element.click();
	    };
	    /**
	     * Sets the focus to Button
	     * its native method
	     *
	     * @public
	     * @returns {void}
	     */
	    Button.prototype.focusIn = function () {
	        this.element.focus();
	    };
	    __decorate$9([
	        Property('Left')
	    ], Button.prototype, "iconPosition", void 0);
	    __decorate$9([
	        Property('')
	    ], Button.prototype, "iconCss", void 0);
	    __decorate$9([
	        Property(false)
	    ], Button.prototype, "disabled", void 0);
	    __decorate$9([
	        Property(false)
	    ], Button.prototype, "isPrimary", void 0);
	    __decorate$9([
	        Property('')
	    ], Button.prototype, "cssClass", void 0);
	    __decorate$9([
	        Property('')
	    ], Button.prototype, "content", void 0);
	    __decorate$9([
	        Property(false)
	    ], Button.prototype, "isToggle", void 0);
	    __decorate$9([
	        Property()
	    ], Button.prototype, "locale", void 0);
	    __decorate$9([
	        Property(false)
	    ], Button.prototype, "enableHtmlSanitizer", void 0);
	    __decorate$9([
	        Event()
	    ], Button.prototype, "created", void 0);
	    Button = __decorate$9([
	        NotifyPropertyChanges
	    ], Button);
	    return Button;
	}(Component));

	/* eslint-disable valid-jsdoc, jsdoc/require-jsdoc, jsdoc/require-returns, jsdoc/require-param */
	var CLASSNAMES = {
	    RTL: 'e-rtl',
	    DISABLE: 'e-disabled',
	    INPUT: 'e-input',
	    TEXTAREA: 'e-multi-line-input',
	    INPUTGROUP: 'e-input-group',
	    FLOATINPUT: 'e-float-input',
	    FLOATLINE: 'e-float-line',
	    FLOATTEXT: 'e-float-text',
	    FLOATTEXTCONTENT: 'e-float-text-content',
	    CLEARICON: 'e-clear-icon',
	    CLEARICONHIDE: 'e-clear-icon-hide',
	    LABELTOP: 'e-label-top',
	    LABELBOTTOM: 'e-label-bottom',
	    NOFLOATLABEL: 'e-no-float-label',
	    INPUTCUSTOMTAG: 'e-input-custom-tag',
	    FLOATCUSTOMTAG: 'e-float-custom-tag'
	};
	/**
	 * Base for Input creation through util methods.
	 */
	// eslint-disable-next-line @typescript-eslint/no-namespace
	var Input;
	(function (Input) {
	    var floatType;
	    var isBindClearAction = true;
	    /**
	     * Create a wrapper to input element with multiple span elements and set the basic properties to input based components.
	     * ```
	     * E.g : Input.createInput({ element: element, floatLabelType : "Auto", properties: { placeholder: 'Search' } });
	     * ```
	     *
	     */
	    function createInput(args, internalCreateElement) {
	        var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
	        var inputObject = { container: null, buttons: [], clearButton: null };
	        floatType = args.floatLabelType;
	        isBindClearAction = args.bindClearAction;
	        if (isNullOrUndefined(args.floatLabelType) || args.floatLabelType === 'Never') {
	            inputObject.container = createInputContainer(args, CLASSNAMES.INPUTGROUP, CLASSNAMES.INPUTCUSTOMTAG, 'span', makeElement);
	            args.element.parentNode.insertBefore(inputObject.container, args.element);
	            addClass([args.element], CLASSNAMES.INPUT);
	            inputObject.container.appendChild(args.element);
	        }
	        else {
	            createFloatingInput(args, inputObject, makeElement);
	        }
	        bindInitialEvent(args);
	        if (!isNullOrUndefined(args.properties) && !isNullOrUndefined(args.properties.showClearButton) &&
	            args.properties.showClearButton) {
	            setClearButton(args.properties.showClearButton, args.element, inputObject, true, makeElement);
	            inputObject.clearButton.setAttribute('role', 'button');
	            if (inputObject.container.classList.contains(CLASSNAMES.FLOATINPUT)) {
	                addClass([inputObject.container], CLASSNAMES.INPUTGROUP);
	            }
	        }
	        if (!isNullOrUndefined(args.buttons)) {
	            for (var i = 0; i < args.buttons.length; i++) {
	                inputObject.buttons.push(appendSpan(args.buttons[i], inputObject.container, makeElement));
	            }
	        }
	        if (!isNullOrUndefined(args.element) && args.element.tagName === 'TEXTAREA') {
	            addClass([inputObject.container], CLASSNAMES.TEXTAREA);
	        }
	        validateInputType(inputObject.container, args.element);
	        inputObject = setPropertyValue(args, inputObject);
	        createSpanElement(inputObject.container, makeElement);
	        return inputObject;
	    }
	    Input.createInput = createInput;
	    function bindInitialEvent(args) {
	        checkInputValue(args.floatLabelType, args.element);
	        args.element.addEventListener('focus', function () {
	            var parent = getParentNode(this);
	            if (parent.classList.contains('e-input-group') || parent.classList.contains('e-outline')
	                || parent.classList.contains('e-filled')) {
	                parent.classList.add('e-input-focus');
	            }
	            if (args.floatLabelType === 'Auto') {
	                setTimeout(function () {
	                    Input.calculateWidth(args.element, parent);
	                }, 80);
	            }
	        });
	        args.element.addEventListener('blur', function () {
	            var parent = getParentNode(this);
	            if (parent.classList.contains('e-input-group') || parent.classList.contains('e-outline')
	                || parent.classList.contains('e-filled')) {
	                parent.classList.remove('e-input-focus');
	            }
	            if (args.floatLabelType === 'Auto' && args.element.value === '') {
	                setTimeout(function () {
	                    Input.calculateWidth(args.element, parent);
	                }, 80);
	            }
	        });
	        args.element.addEventListener('input', function () {
	            checkInputValue(floatType, args.element);
	        });
	    }
	    Input.bindInitialEvent = bindInitialEvent;
	    function checkInputValue(floatLabelType, inputElement) {
	        var inputValue = inputElement.value;
	        var inputParent = inputElement.parentElement;
	        var grandParent = inputParent.parentElement;
	        if (inputValue !== '' && !isNullOrUndefined(inputValue)) {
	            if (inputParent && inputParent.classList.contains('e-input-group')) {
	                inputParent.classList.add('e-valid-input');
	            }
	            else if (grandParent && grandParent.classList.contains('e-input-group')) {
	                grandParent.classList.add('e-valid-input');
	            }
	        }
	        else if (floatLabelType !== 'Always') {
	            if (inputParent && inputParent.classList.contains('e-input-group')) {
	                inputParent.classList.remove('e-valid-input');
	            }
	            else if (grandParent && grandParent.classList.contains('e-input-group')) {
	                grandParent.classList.remove('e-valid-input');
	            }
	        }
	    }
	    function _focusFn() {
	        var label = getParentNode(this).getElementsByClassName('e-float-text')[0];
	        if (!isNullOrUndefined(label)) {
	            addClass([label], CLASSNAMES.LABELTOP);
	            if (label.classList.contains(CLASSNAMES.LABELBOTTOM)) {
	                removeClass([label], CLASSNAMES.LABELBOTTOM);
	            }
	        }
	    }
	    function _blurFn() {
	        var parent = getParentNode(this);
	        if ((parent.getElementsByTagName('textarea')[0]) ? parent.getElementsByTagName('textarea')[0].value === '' :
	            parent.getElementsByTagName('input')[0].value === '') {
	            var label = parent.getElementsByClassName('e-float-text')[0];
	            if (!isNullOrUndefined(label)) {
	                if (label.classList.contains(CLASSNAMES.LABELTOP)) {
	                    removeClass([label], CLASSNAMES.LABELTOP);
	                }
	                addClass([label], CLASSNAMES.LABELBOTTOM);
	            }
	        }
	    }
	    function wireFloatingEvents(element) {
	        element.addEventListener('focus', _focusFn);
	        element.addEventListener('blur', _blurFn);
	    }
	    Input.wireFloatingEvents = wireFloatingEvents;
	    function unwireFloatingEvents(element) {
	        element.removeEventListener('focus', _focusFn);
	        element.removeEventListener('blur', _blurFn);
	    }
	    function createFloatingInput(args, inputObject, internalCreateElement) {
	        var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
	        if (args.floatLabelType === 'Auto') {
	            wireFloatingEvents(args.element);
	        }
	        if (isNullOrUndefined(inputObject.container)) {
	            inputObject.container = createInputContainer(args, CLASSNAMES.FLOATINPUT, CLASSNAMES.FLOATCUSTOMTAG, 'div', makeElement);
	            inputObject.container.classList.add(CLASSNAMES.INPUTGROUP);
	            if (args.element.parentNode) {
	                args.element.parentNode.insertBefore(inputObject.container, args.element);
	            }
	        }
	        else {
	            if (!isNullOrUndefined(args.customTag)) {
	                inputObject.container.classList.add(CLASSNAMES.FLOATCUSTOMTAG);
	            }
	            inputObject.container.classList.add(CLASSNAMES.FLOATINPUT);
	        }
	        var floatLinelement = makeElement('span', { className: CLASSNAMES.FLOATLINE });
	        var floatLabelElement = makeElement('label', { className: CLASSNAMES.FLOATTEXT });
	        if (!isNullOrUndefined(args.element.id) && args.element.id !== '') {
	            floatLabelElement.id = 'label_' + args.element.id.replace(/ /g, '_');
	            attributes(args.element, { 'aria-labelledby': floatLabelElement.id });
	        }
	        if (!isNullOrUndefined(args.element.placeholder) && args.element.placeholder !== '') {
	            floatLabelElement.innerText = encodePlaceHolder(args.element.placeholder);
	            args.element.removeAttribute('placeholder');
	        }
	        if (!isNullOrUndefined(args.properties) && !isNullOrUndefined(args.properties.placeholder) &&
	            args.properties.placeholder !== '') {
	            floatLabelElement.innerText = encodePlaceHolder(args.properties.placeholder);
	        }
	        if (!floatLabelElement.innerText) {
	            inputObject.container.classList.add(CLASSNAMES.NOFLOATLABEL);
	        }
	        if (inputObject.container.classList.contains('e-float-icon-left')) {
	            var inputWrap = inputObject.container.querySelector('.e-input-in-wrap');
	            inputWrap.appendChild(args.element);
	            inputWrap.appendChild(floatLinelement);
	            inputWrap.appendChild(floatLabelElement);
	        }
	        else {
	            inputObject.container.appendChild(args.element);
	            inputObject.container.appendChild(floatLinelement);
	            inputObject.container.appendChild(floatLabelElement);
	        }
	        updateLabelState(args.element.value, floatLabelElement);
	        if (args.floatLabelType === 'Always') {
	            if (floatLabelElement.classList.contains(CLASSNAMES.LABELBOTTOM)) {
	                removeClass([floatLabelElement], CLASSNAMES.LABELBOTTOM);
	            }
	            addClass([floatLabelElement], CLASSNAMES.LABELTOP);
	        }
	        if (args.floatLabelType === 'Auto') {
	            // eslint-disable-next-line @typescript-eslint/no-unused-vars
	            args.element.addEventListener('input', function (event) {
	                updateLabelState(args.element.value, floatLabelElement, args.element);
	            });
	            // eslint-disable-next-line @typescript-eslint/no-unused-vars
	            args.element.addEventListener('blur', function (event) {
	                updateLabelState(args.element.value, floatLabelElement);
	            });
	        }
	        if (!isNullOrUndefined(args.element.getAttribute('id'))) {
	            floatLabelElement.setAttribute('for', args.element.getAttribute('id'));
	        }
	    }
	    function checkFloatLabelType(type, container) {
	        if (type === 'Always' && container.classList.contains('e-outline')) {
	            container.classList.add('e-valid-input');
	        }
	    }
	    function setPropertyValue(args, inputObject) {
	        if (!isNullOrUndefined(args.properties)) {
	            for (var _i = 0, _a = Object.keys(args.properties); _i < _a.length; _i++) {
	                var prop = _a[_i];
	                switch (prop) {
	                    case 'cssClass':
	                        setCssClass(args.properties.cssClass, [inputObject.container]);
	                        checkFloatLabelType(args.floatLabelType, inputObject.container);
	                        break;
	                    case 'enabled':
	                        setEnabled(args.properties.enabled, args.element, args.floatLabelType, inputObject.container);
	                        break;
	                    case 'enableRtl':
	                        setEnableRtl(args.properties.enableRtl, [inputObject.container]);
	                        break;
	                    case 'placeholder':
	                        setPlaceholder(args.properties.placeholder, args.element);
	                        break;
	                    case 'readonly':
	                        setReadonly(args.properties.readonly, args.element);
	                        break;
	                }
	            }
	        }
	        return inputObject;
	    }
	    function updateIconState(value, button, readonly) {
	        if (!isNullOrUndefined(button)) {
	            if (value && !readonly) {
	                removeClass([button], CLASSNAMES.CLEARICONHIDE);
	            }
	            else {
	                addClass([button], CLASSNAMES.CLEARICONHIDE);
	            }
	        }
	    }
	    function updateLabelState(value, label, element) {
	        if (element === void 0) { element = null; }
	        if (value) {
	            addClass([label], CLASSNAMES.LABELTOP);
	            if (label.classList.contains(CLASSNAMES.LABELBOTTOM)) {
	                removeClass([label], CLASSNAMES.LABELBOTTOM);
	            }
	        }
	        else {
	            var isNotFocused = element != null ? element !== document.activeElement : true;
	            if (isNotFocused) {
	                if (label.classList.contains(CLASSNAMES.LABELTOP)) {
	                    removeClass([label], CLASSNAMES.LABELTOP);
	                }
	                addClass([label], CLASSNAMES.LABELBOTTOM);
	            }
	        }
	    }
	    function getParentNode(element) {
	        var parentNode = isNullOrUndefined(element.parentNode) ? element
	            : element.parentNode;
	        if (parentNode && parentNode.classList.contains('e-input-in-wrap')) {
	            parentNode = parentNode.parentNode;
	        }
	        return parentNode;
	    }
	    /**
	     * To create clear button.
	     */
	    function createClearButton(element, inputObject, initial, internalCreateElement) {
	        var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
	        var button = makeElement('span', { className: CLASSNAMES.CLEARICON });
	        var container = inputObject.container;
	        if (!isNullOrUndefined(initial)) {
	            container.appendChild(button);
	        }
	        else {
	            var baseElement = inputObject.container.classList.contains(CLASSNAMES.FLOATINPUT) ?
	                inputObject.container.querySelector('.' + CLASSNAMES.FLOATTEXT) : element;
	            baseElement.insertAdjacentElement('afterend', button);
	        }
	        addClass([button], CLASSNAMES.CLEARICONHIDE);
	        wireClearBtnEvents(element, button);
	        button.setAttribute('aria-label', 'close');
	        return button;
	    }
	    // eslint-disable-next-line @typescript-eslint/no-unused-vars
	    function wireClearBtnEvents(element, button, container) {
	        if (isBindClearAction === undefined || isBindClearAction) {
	            button.addEventListener('click', function (event) {
	                if (!(element.classList.contains(CLASSNAMES.DISABLE) || element.readOnly)) {
	                    event.preventDefault();
	                    if (element !== document.activeElement) {
	                        element.focus();
	                    }
	                    element.value = '';
	                    addClass([button], CLASSNAMES.CLEARICONHIDE);
	                }
	            });
	        }
	        // eslint-disable-next-line @typescript-eslint/no-unused-vars
	        element.addEventListener('input', function (event) {
	            updateIconState(element.value, button);
	        });
	        // eslint-disable-next-line @typescript-eslint/no-unused-vars
	        element.addEventListener('focus', function (event) {
	            updateIconState(element.value, button, element.readOnly);
	        });
	        // eslint-disable-next-line @typescript-eslint/no-unused-vars
	        element.addEventListener('blur', function (event) {
	            setTimeout(function () {
	                if (!isNullOrUndefined(button)) {
	                    addClass([button], CLASSNAMES.CLEARICONHIDE);
	                    button = !isNullOrUndefined(element) && element.classList.contains('e-combobox') ? null : button;
	                }
	            }, 200);
	        });
	    }
	    Input.wireClearBtnEvents = wireClearBtnEvents;
	    function destroy() {
	    }
	    Input.destroy = destroy;
	    function validateLabel(element, floatLabelType) {
	        var parent = getParentNode(element);
	        if (parent.classList.contains(CLASSNAMES.FLOATINPUT) && floatLabelType === 'Auto') {
	            var label = getParentNode(element).getElementsByClassName('e-float-text')[0];
	            updateLabelState(element.value, label, element);
	        }
	    }
	    /**
	     * To create input box contianer.
	     */
	    function createInputContainer(args, className, tagClass, tag, internalCreateElement) {
	        var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
	        var container;
	        if (!isNullOrUndefined(args.customTag)) {
	            container = makeElement(args.customTag, { className: className });
	            container.classList.add(tagClass);
	        }
	        else {
	            container = makeElement(tag, { className: className });
	        }
	        container.classList.add('e-control-wrapper');
	        return container;
	    }
	    function encodePlaceHolder(placeholder) {
	        var result = '';
	        if (!isNullOrUndefined(placeholder) && placeholder !== '') {
	            var spanEle = document.createElement('span');
	            spanEle.innerHTML = '<input  placeholder="' + placeholder + '"/>';
	            var hiddenInput = (spanEle.children[0]);
	            result = hiddenInput.placeholder;
	        }
	        return result;
	    }
	    /**
	     * Sets the value to the input element.
	     * ```
	     * E.g : Input.setValue('content', element, "Auto", true );
	     * ```
	     *
	     * @param {string} value - Specify the value of the input element.
	     * @param {HTMLInputElement | HTMLTextAreaElement} element - The element on which the specified value is updated.
	     * @param {string} floatLabelType - Specify the float label type of the input element.
	     * @param {boolean} clearButton - Boolean value to specify whether the clear icon is enabled / disabled on the input.
	     */
	    function setValue(value, element, floatLabelType, clearButton) {
	        element.value = value;
	        if (floatLabelType === 'Auto' && value === '') {
	            calculateWidth(element, element.parentElement);
	        }
	        if ((!isNullOrUndefined(floatLabelType)) && floatLabelType === 'Auto') {
	            validateLabel(element, floatLabelType);
	        }
	        if (!isNullOrUndefined(clearButton) && clearButton) {
	            var parentElement = getParentNode(element);
	            if (!isNullOrUndefined(parentElement)) {
	                var button = parentElement.getElementsByClassName(CLASSNAMES.CLEARICON)[0];
	                if (!isNullOrUndefined(button)) {
	                    if (element.value && !isNullOrUndefined(parentElement) && parentElement.classList.contains('e-input-focus')) {
	                        removeClass([button], CLASSNAMES.CLEARICONHIDE);
	                    }
	                    else {
	                        addClass([button], CLASSNAMES.CLEARICONHIDE);
	                    }
	                }
	            }
	        }
	        checkInputValue(floatLabelType, element);
	    }
	    Input.setValue = setValue;
	    /**
	     * Sets the single or multiple cssClass to wrapper of input element.
	     * ```
	     * E.g : Input.setCssClass('e-custom-class', [element]);
	     * ```
	     *
	     * @param {string} cssClass - Css class names which are needed to add.
	     * @param {Element[] | NodeList} elements - The elements which are needed to add / remove classes.
	     * @param {string} oldClass
	     * - Css class names which are needed to remove. If old classes are need to remove, can give this optional parameter.
	     */
	    function setCssClass(cssClass, elements, oldClass) {
	        if (!isNullOrUndefined(oldClass) && oldClass !== '') {
	            removeClass(elements, oldClass.split(' '));
	        }
	        if (!isNullOrUndefined(cssClass) && cssClass !== '') {
	            addClass(elements, cssClass.split(' '));
	        }
	    }
	    Input.setCssClass = setCssClass;
	    /**
	     * Set the width to the placeholder when it overflows on the button such as spinbutton, clearbutton, icon etc
	     * ```
	     * E.g : Input.calculateWidth(element, container);
	     * ```
	     *
	     * @param {any} element - Input element which is need to add.
	     * @param {HTMLElement} container - The parent element which is need to get the label span to calculate width
	     */
	    function calculateWidth(element, container, moduleName) {
	        var elementWidth = moduleName === 'multiselect' ? element : element.clientWidth - parseInt(getComputedStyle(element, null).getPropertyValue('padding-left'), 10);
	        if (!isNullOrUndefined(container.getElementsByClassName('e-float-text-content')[0])) {
	            if (container.getElementsByClassName('e-float-text-content')[0].classList.contains('e-float-text-overflow')) {
	                container.getElementsByClassName('e-float-text-content')[0].classList.remove('e-float-text-overflow');
	            }
	            if (elementWidth < container.getElementsByClassName('e-float-text-content')[0].clientWidth || elementWidth === container.getElementsByClassName('e-float-text-content')[0].clientWidth) {
	                container.getElementsByClassName('e-float-text-content')[0].classList.add('e-float-text-overflow');
	            }
	        }
	    }
	    Input.calculateWidth = calculateWidth;
	    /**
	     * Set the width to the wrapper of input element.
	     * ```
	     * E.g : Input.setWidth('200px', container);
	     * ```
	     *
	     * @param {number | string} width - Width value which is need to add.
	     * @param {HTMLElement} container - The element on which the width is need to add.
	     */
	    function setWidth(width, container) {
	        if (typeof width === 'number') {
	            container.style.width = formatUnit(width);
	        }
	        else if (typeof width === 'string') {
	            container.style.width = (width.match(/px|%|em/)) ? (width) : (formatUnit(width));
	        }
	        calculateWidth(container.firstChild, container);
	    }
	    Input.setWidth = setWidth;
	    /**
	     * Set the placeholder attribute to the input element.
	     * ```
	     * E.g : Input.setPlaceholder('Search here', element);
	     * ```
	     *
	     * @param {string} placeholder - Placeholder value which is need to add.
	     * @param {HTMLInputElement | HTMLTextAreaElement} element - The element on which the placeholder is need to add.
	     */
	    function setPlaceholder(placeholder, element) {
	        placeholder = encodePlaceHolder(placeholder);
	        var parentElement = getParentNode(element);
	        if (parentElement.classList.contains(CLASSNAMES.FLOATINPUT)) {
	            if (!isNullOrUndefined(placeholder) && placeholder !== '') {
	                parentElement.getElementsByClassName('e-float-text-content')[0] ? parentElement.getElementsByClassName(CLASSNAMES.FLOATTEXT)[0].children[0].textContent = placeholder : parentElement.getElementsByClassName(CLASSNAMES.FLOATTEXT)[0].textContent = placeholder;
	                parentElement.classList.remove(CLASSNAMES.NOFLOATLABEL);
	                element.removeAttribute('placeholder');
	            }
	            else {
	                parentElement.classList.add(CLASSNAMES.NOFLOATLABEL);
	                parentElement.getElementsByClassName('e-float-text-content')[0] ? parentElement.getElementsByClassName(CLASSNAMES.FLOATTEXT)[0].children[0].textContent = '' : parentElement.getElementsByClassName(CLASSNAMES.FLOATTEXT)[0].textContent = '';
	            }
	        }
	        else {
	            if (!isNullOrUndefined(placeholder) && placeholder !== '') {
	                attributes(element, { 'placeholder': placeholder });
	            }
	            else {
	                element.removeAttribute('placeholder');
	            }
	        }
	    }
	    Input.setPlaceholder = setPlaceholder;
	    /**
	     * Set the read only attribute to the input element
	     * ```
	     * E.g : Input.setReadonly(true, element);
	     * ```
	     *
	     * @param {boolean} isReadonly
	     * - Boolean value to specify whether to set read only. Setting "True" value enables read only.
	     * @param {HTMLInputElement | HTMLTextAreaElement} element
	     * - The element which is need to enable read only.
	     */
	    function setReadonly(isReadonly, element, floatLabelType) {
	        if (isReadonly) {
	            attributes(element, { readonly: '' });
	        }
	        else {
	            element.removeAttribute('readonly');
	        }
	        if (!isNullOrUndefined(floatLabelType)) {
	            validateLabel(element, floatLabelType);
	        }
	    }
	    Input.setReadonly = setReadonly;
	    /**
	     * Displays the element direction from right to left when its enabled.
	     * ```
	     * E.g : Input.setEnableRtl(true, [inputObj.container]);
	     * ```
	     *
	     * @param {boolean} isRtl
	     * - Boolean value to specify whether to set RTL. Setting "True" value enables the RTL mode.
	     * @param {Element[] | NodeList} elements
	     * - The elements that are needed to enable/disable RTL.
	     */
	    function setEnableRtl(isRtl, elements) {
	        if (isRtl) {
	            addClass(elements, CLASSNAMES.RTL);
	        }
	        else {
	            removeClass(elements, CLASSNAMES.RTL);
	        }
	    }
	    Input.setEnableRtl = setEnableRtl;
	    /**
	     * Enables or disables the given input element.
	     * ```
	     * E.g : Input.setEnabled(false, element);
	     * ```
	     *
	     * @param {boolean} isEnable
	     * - Boolean value to specify whether to enable or disable.
	     * @param {HTMLInputElement | HTMLTextAreaElement} element
	     * - Element to be enabled or disabled.
	     */
	    function setEnabled(isEnable, element, floatLabelType, inputContainer) {
	        var disabledAttrs = { 'disabled': 'disabled', 'aria-disabled': 'true' };
	        var considerWrapper = isNullOrUndefined(inputContainer) ? false : true;
	        if (isEnable) {
	            element.classList.remove(CLASSNAMES.DISABLE);
	            removeAttributes(disabledAttrs, element);
	            if (considerWrapper) {
	                removeClass([inputContainer], CLASSNAMES.DISABLE);
	            }
	        }
	        else {
	            element.classList.add(CLASSNAMES.DISABLE);
	            addAttributes(disabledAttrs, element);
	            if (considerWrapper) {
	                addClass([inputContainer], CLASSNAMES.DISABLE);
	            }
	        }
	        if (!isNullOrUndefined(floatLabelType)) {
	            validateLabel(element, floatLabelType);
	        }
	    }
	    Input.setEnabled = setEnabled;
	    function setClearButton(isClear, element, inputObject, initial, internalCreateElement) {
	        var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
	        if (isClear) {
	            inputObject.clearButton = createClearButton(element, inputObject, initial, makeElement);
	        }
	        else {
	            remove(inputObject.clearButton);
	            inputObject.clearButton = null;
	        }
	    }
	    Input.setClearButton = setClearButton;
	    /**
	     * Removing the multiple attributes from the given element such as "disabled","id" , etc.
	     * ```
	     * E.g : Input.removeAttributes({ 'disabled': 'disabled', 'aria-disabled': 'true' }, element);
	     * ```
	     *
	     * @param {string} attrs
	     * - Array of attributes which are need to removed from the element.
	     * @param {HTMLInputElement | HTMLElement} element
	     * - Element on which the attributes are needed to be removed.
	     */
	    function removeAttributes(attrs, element) {
	        for (var _i = 0, _a = Object.keys(attrs); _i < _a.length; _i++) {
	            var key = _a[_i];
	            var parentElement = getParentNode(element);
	            if (key === 'disabled') {
	                element.classList.remove(CLASSNAMES.DISABLE);
	            }
	            if (key === 'disabled' && parentElement.classList.contains(CLASSNAMES.INPUTGROUP)) {
	                parentElement.classList.remove(CLASSNAMES.DISABLE);
	            }
	            if (key === 'placeholder' && parentElement.classList.contains(CLASSNAMES.FLOATINPUT)) {
	                parentElement.getElementsByClassName(CLASSNAMES.FLOATTEXT)[0].textContent = '';
	            }
	            else {
	                element.removeAttribute(key);
	            }
	        }
	    }
	    Input.removeAttributes = removeAttributes;
	    /**
	     * Adding the multiple attributes to the given element such as "disabled","id" , etc.
	     * ```
	     * E.g : Input.addAttributes({ 'id': 'inputpopup' }, element);
	     * ```
	     *
	     * @param {string} attrs
	     * - Array of attributes which is added to element.
	     * @param {HTMLInputElement | HTMLElement} element
	     * - Element on which the attributes are needed to be added.
	     */
	    function addAttributes(attrs, element) {
	        for (var _i = 0, _a = Object.keys(attrs); _i < _a.length; _i++) {
	            var key = _a[_i];
	            var parentElement = getParentNode(element);
	            if (key === 'disabled') {
	                element.classList.add(CLASSNAMES.DISABLE);
	            }
	            if (key === 'disabled' && parentElement.classList.contains(CLASSNAMES.INPUTGROUP)) {
	                parentElement.classList.add(CLASSNAMES.DISABLE);
	            }
	            if (key === 'placeholder' && parentElement.classList.contains(CLASSNAMES.FLOATINPUT)) {
	                parentElement.getElementsByClassName(CLASSNAMES.FLOATTEXT)[0].textContent = attrs["" + key];
	            }
	            else {
	                element.setAttribute(key, attrs["" + key]);
	            }
	        }
	    }
	    Input.addAttributes = addAttributes;
	    function removeFloating(input) {
	        var container = input.container;
	        if (!isNullOrUndefined(container) && container.classList.contains(CLASSNAMES.FLOATINPUT)) {
	            var inputEle = container.querySelector('textarea') ? container.querySelector('textarea') :
	                container.querySelector('input');
	            var placeholder = container.querySelector('.' + CLASSNAMES.FLOATTEXT).textContent;
	            var clearButton = container.querySelector('.e-clear-icon') !== null;
	            detach(container.querySelector('.' + CLASSNAMES.FLOATLINE));
	            detach(container.querySelector('.' + CLASSNAMES.FLOATTEXT));
	            classList(container, [CLASSNAMES.INPUTGROUP], [CLASSNAMES.FLOATINPUT]);
	            unwireFloatingEvents(inputEle);
	            attributes(inputEle, { 'placeholder': placeholder });
	            inputEle.classList.add(CLASSNAMES.INPUT);
	            if (!clearButton && inputEle.tagName === 'INPUT') {
	                inputEle.removeAttribute('required');
	            }
	        }
	    }
	    Input.removeFloating = removeFloating;
	    function addFloating(input, type, placeholder, internalCreateElement) {
	        var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
	        var container = closest(input, '.' + CLASSNAMES.INPUTGROUP);
	        floatType = type;
	        if (type !== 'Never') {
	            var customTag = container.tagName;
	            customTag = customTag !== 'DIV' && customTag !== 'SPAN' ? customTag : null;
	            var args = { element: input, floatLabelType: type,
	                customTag: customTag, properties: { placeholder: placeholder } };
	            var iconEle = container.querySelector('.e-clear-icon');
	            var inputObj = { container: container };
	            input.classList.remove(CLASSNAMES.INPUT);
	            createFloatingInput(args, inputObj, makeElement);
	            createSpanElement(inputObj.container, makeElement);
	            calculateWidth(args.element, inputObj.container);
	            var isPrependIcon = container.classList.contains('e-float-icon-left');
	            if (isNullOrUndefined(iconEle)) {
	                if (isPrependIcon) {
	                    var inputWrap = container.querySelector('.e-input-in-wrap');
	                    iconEle = inputWrap.querySelector('.e-input-group-icon');
	                }
	                else {
	                    iconEle = container.querySelector('.e-input-group-icon');
	                }
	            }
	            if (isNullOrUndefined(iconEle)) {
	                if (isPrependIcon) {
	                    iconEle = container.querySelector('.e-input-group-icon');
	                }
	            }
	            else {
	                var floatLine = container.querySelector('.' + CLASSNAMES.FLOATLINE);
	                var floatText = container.querySelector('.' + CLASSNAMES.FLOATTEXT);
	                var wrapper = isPrependIcon ? container.querySelector('.e-input-in-wrap') : container;
	                wrapper.insertBefore(input, iconEle);
	                wrapper.insertBefore(floatLine, iconEle);
	                wrapper.insertBefore(floatText, iconEle);
	            }
	        }
	        checkFloatLabelType(type, input.parentElement);
	    }
	    Input.addFloating = addFloating;
	    /**
	     * Create the span inside the label and add the label text into the span textcontent
	     * ```
	     * E.g : Input.createSpanElement(inputObject, makeElement);
	     * ```
	     *
	     * @param {InputObject} inputObject
	     * - Element which is need to get the label
	     * @param {createElementParams} makeElement
	     * - Element which is need to create the span
	     */
	    function createSpanElement(inputObject, makeElement) {
	        if (inputObject.classList.contains('e-outline') && inputObject.getElementsByClassName('e-float-text')[0]) {
	            var labelSpanElement = makeElement('span', { className: CLASSNAMES.FLOATTEXTCONTENT });
	            labelSpanElement.innerHTML = inputObject.getElementsByClassName('e-float-text')[0].innerHTML;
	            inputObject.getElementsByClassName('e-float-text')[0].innerHTML = '';
	            inputObject.getElementsByClassName('e-float-text')[0].appendChild(labelSpanElement);
	        }
	    }
	    Input.createSpanElement = createSpanElement;
	    /**
	     * Enable or Disable the ripple effect on the icons inside the Input. Ripple effect is only applicable for material theme.
	     * ```
	     * E.g : Input.setRipple(true, [inputObjects]);
	     * ```
	     *
	     * @param {boolean} isRipple
	     * - Boolean value to specify whether to enable the ripple effect.
	     * @param {InputObject[]} inputObj
	     * - Specify the collection of input objects.
	     */
	    function setRipple(isRipple, inputObj) {
	        for (var i = 0; i < inputObj.length; i++) {
	            _internalRipple(isRipple, inputObj[parseInt(i.toString())].container);
	        }
	    }
	    Input.setRipple = setRipple;
	    function _internalRipple(isRipple, container, button) {
	        var argsButton = [];
	        argsButton.push(button);
	        var buttons = isNullOrUndefined(button) ?
	            container.querySelectorAll('.e-input-group-icon') : argsButton;
	        if (isRipple && buttons.length > 0) {
	            for (var index = 0; index < buttons.length; index++) {
	                buttons[parseInt(index.toString())].addEventListener('mousedown', _onMouseDownRipple, false);
	                buttons[parseInt(index.toString())].addEventListener('mouseup', _onMouseUpRipple, false);
	            }
	        }
	        else if (buttons.length > 0) {
	            for (var index = 0; index < buttons.length; index++) {
	                buttons[parseInt(index.toString())].removeEventListener('mousedown', _onMouseDownRipple, this);
	                buttons[parseInt(index.toString())].removeEventListener('mouseup', _onMouseUpRipple, this);
	            }
	        }
	    }
	    function _onMouseRipple(container, button) {
	        if (!container.classList.contains('e-disabled') && !container.querySelector('input').readOnly) {
	            button.classList.add('e-input-btn-ripple');
	        }
	    }
	    function _onMouseDownRipple() {
	        // eslint-disable-next-line @typescript-eslint/no-this-alias
	        var ele = this;
	        var parentEle = this.parentElement;
	        while (!parentEle.classList.contains('e-input-group')) {
	            parentEle = parentEle.parentElement;
	        }
	        _onMouseRipple(parentEle, ele);
	    }
	    function _onMouseUpRipple() {
	        // eslint-disable-next-line @typescript-eslint/no-this-alias
	        var ele = this;
	        setTimeout(function () {
	            ele.classList.remove('e-input-btn-ripple');
	        }, 500);
	    }
	    function createIconEle(iconClass, makeElement) {
	        var button = makeElement('span', { className: iconClass });
	        button.classList.add('e-input-group-icon');
	        return button;
	    }
	    /**
	     * Creates a new span element with the given icons added and append it in container element.
	     * ```
	     * E.g : Input.addIcon('append', 'e-icon-spin', inputObj.container, inputElement);
	     * ```
	     *
	     * @param {string} position - Specify the icon placement on the input.Possible values are append and prepend.
	     * @param {string | string[]} icons - Icon classes which are need to add to the span element which is going to created.
	     * Span element acts as icon or button element for input.
	     * @param {HTMLElement} container - The container on which created span element is going to append.
	     * @param {HTMLElement} input - The inputElement on which created span element is going to prepend.
	     */
	    /* eslint-disable @typescript-eslint/indent */
	    function addIcon(position, icons, container, input, internalCreate) {
	        /* eslint-enable @typescript-eslint/indent */
	        var result = typeof (icons) === 'string' ? icons.split(',')
	            : icons;
	        if (position.toLowerCase() === 'append') {
	            for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
	                var icon = result_1[_i];
	                appendSpan(icon, container, internalCreate);
	            }
	        }
	        else {
	            for (var _a = 0, result_2 = result; _a < result_2.length; _a++) {
	                var icon = result_2[_a];
	                prependSpan(icon, container, input, internalCreate);
	            }
	        }
	        if (container.getElementsByClassName('e-input-group-icon')[0] && container.getElementsByClassName('e-float-text-overflow')[0]) {
	            container.getElementsByClassName('e-float-text-overflow')[0].classList.add('e-icon');
	        }
	    }
	    Input.addIcon = addIcon;
	    /**
	     * Creates a new span element with the given icons added and prepend it in input element.
	     * ```
	     * E.g : Input.prependSpan('e-icon-spin', inputObj.container, inputElement);
	     * ```
	     *
	     * @param {string} iconClass - Icon classes which are need to add to the span element which is going to created.
	     * Span element acts as icon or button element for input.
	     * @param {HTMLElement} container - The container on which created span element is going to append.
	     * @param {HTMLElement} inputElement - The inputElement on which created span element is going to prepend.
	     */
	    /* eslint-disable @typescript-eslint/indent */
	    function prependSpan(iconClass, container, inputElement, internalCreateElement) {
	        /* eslint-enable @typescript-eslint/indent */
	        var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
	        var button = createIconEle(iconClass, makeElement);
	        container.classList.add('e-float-icon-left');
	        var innerWrapper = container.querySelector('.e-input-in-wrap');
	        if (isNullOrUndefined(innerWrapper)) {
	            innerWrapper = makeElement('span', { className: 'e-input-in-wrap' });
	            inputElement.parentNode.insertBefore(innerWrapper, inputElement);
	            var result = container.querySelectorAll(inputElement.tagName + ' ~ *');
	            innerWrapper.appendChild(inputElement);
	            for (var i = 0; i < result.length; i++) {
	                var element = result[parseInt(i.toString())];
	                var parentElement = innerWrapper.parentElement;
	                if (!(element.classList.contains('e-float-line')) || (!(parentElement && parentElement.classList.contains('e-filled')) && parentElement)) {
	                    innerWrapper.appendChild(element);
	                }
	            }
	        }
	        innerWrapper.parentNode.insertBefore(button, innerWrapper);
	        _internalRipple(true, container, button);
	        return button;
	    }
	    Input.prependSpan = prependSpan;
	    /**
	     * Creates a new span element with the given icons added and append it in container element.
	     * ```
	     * E.g : Input.appendSpan('e-icon-spin', inputObj.container);
	     * ```
	     *
	     * @param {string} iconClass - Icon classes which are need to add to the span element which is going to created.
	     * Span element acts as icon or button element for input.
	     * @param {HTMLElement} container - The container on which created span element is going to append.
	     */
	    function appendSpan(iconClass, container, internalCreateElement) {
	        var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
	        var button = createIconEle(iconClass, makeElement);
	        var wrap = (container.classList.contains('e-float-icon-left')) ? container.querySelector('.e-input-in-wrap') :
	            container;
	        wrap.appendChild(button);
	        _internalRipple(true, container, button);
	        return button;
	    }
	    Input.appendSpan = appendSpan;
	    function validateInputType(containerElement, input) {
	        if (input.type === 'hidden') {
	            containerElement.classList.add('e-hidden');
	        }
	        else if (containerElement.classList.contains('e-hidden')) {
	            containerElement.classList.remove('e-hidden');
	        }
	    }
	    Input.validateInputType = validateInputType;
	})(Input || (Input = {}));
	/* eslint-enable valid-jsdoc, jsdoc/require-jsdoc, jsdoc/require-returns, jsdoc/require-param */

	/* eslint-disable valid-jsdoc */
	/* eslint-disable security/detect-object-injection */
	/**
	 * Query class is used to build query which is used by the DataManager to communicate with datasource.
	 */
	var Query = /** @class */ (function () {
	    /**
	     * Constructor for Query class.
	     *
	     * @param {string|string[]} from?
	     * @param from
	     * @hidden
	     */
	    function Query(from) {
	        /** @hidden */
	        this.subQuery = null;
	        /** @hidden */
	        this.isChild = false;
	        /** @hidden */
	        this.distincts = [];
	        this.queries = [];
	        this.key = '';
	        this.fKey = '';
	        if (typeof from === 'string') {
	            this.fromTable = from;
	        }
	        else if (from && from instanceof Array) {
	            this.lookups = from;
	        }
	        this.expands = [];
	        this.sortedColumns = [];
	        this.groupedColumns = [];
	        this.subQuery = null;
	        this.isChild = false;
	        this.params = [];
	        this.lazyLoad = [];
	        return this;
	    }
	    /**
	     * Sets the primary key.
	     *
	     * @param  {string} field - Defines the column field.
	     */
	    Query.prototype.setKey = function (field) {
	        this.key = field;
	        return this;
	    };
	    /**
	     * Sets default DataManager to execute query.
	     *
	     * @param  {DataManager} dataManager - Defines the DataManager.
	     */
	    Query.prototype.using = function (dataManager) {
	        this.dataManager = dataManager;
	        return this;
	    };
	    /**
	     * Executes query with the given DataManager.
	     *
	     * @param  {DataManager} dataManager - Defines the DataManager.
	     * @param  {Function} done - Defines the success callback.
	     * @param  {Function} fail - Defines the failure callback.
	     * @param  {Function} always - Defines the callback which will be invoked on either success or failure.
	     *
	     * <pre>
	     * let dataManager: DataManager = new DataManager([{ ID: '10' }, { ID: '2' }, { ID: '1' }, { ID: '20' }]);
	     * let query: Query = new Query();
	     * query.sortBy('ID', (x: string, y: string): number => { return parseInt(x, 10) - parseInt(y, 10) });
	     * let promise: Promise< Object > = query.execute(dataManager);
	     * promise.then((e: { result: Object }) => { });
	     * </pre>
	     */
	    Query.prototype.execute = function (dataManager, done, fail, always) {
	        dataManager = dataManager || this.dataManager;
	        if (dataManager) {
	            return dataManager.executeQuery(this, done, fail, always);
	        }
	        return DataUtil.throwError('Query - execute() : dataManager needs to be is set using "using" function or should be passed as argument');
	    };
	    /**
	     * Executes query with the local datasource.
	     *
	     * @param  {DataManager} dataManager - Defines the DataManager.
	     */
	    Query.prototype.executeLocal = function (dataManager) {
	        dataManager = dataManager || this.dataManager;
	        if (dataManager) {
	            return dataManager.executeLocal(this);
	        }
	        return DataUtil.throwError('Query - executeLocal() : dataManager needs to be is set using "using" function or should be passed as argument');
	    };
	    /**
	     * Creates deep copy of the Query object.
	     */
	    Query.prototype.clone = function () {
	        var cloned = new Query();
	        cloned.queries = this.queries.slice(0);
	        cloned.key = this.key;
	        cloned.isChild = this.isChild;
	        cloned.dataManager = this.dataManager;
	        cloned.fromTable = this.fromTable;
	        cloned.params = this.params.slice(0);
	        cloned.expands = this.expands.slice(0);
	        cloned.sortedColumns = this.sortedColumns.slice(0);
	        cloned.groupedColumns = this.groupedColumns.slice(0);
	        cloned.subQuerySelector = this.subQuerySelector;
	        cloned.subQuery = this.subQuery;
	        cloned.fKey = this.fKey;
	        cloned.isCountRequired = this.isCountRequired;
	        cloned.distincts = this.distincts.slice(0);
	        cloned.lazyLoad = this.lazyLoad.slice(0);
	        return cloned;
	    };
	    /**
	     * Specifies the name of table to retrieve data in query execution.
	     *
	     * @param  {string} tableName - Defines the table name.
	     */
	    Query.prototype.from = function (tableName) {
	        this.fromTable = tableName;
	        return this;
	    };
	    /**
	     * Adds additional parameter which will be sent along with the request which will be generated while DataManager execute.
	     *
	     * @param  {string} key - Defines the key of additional parameter.
	     * @param  {Function|string} value - Defines the value for the key.
	     */
	    Query.prototype.addParams = function (key, value) {
	        if (typeof value === 'function') {
	            this.params.push({ key: key, fn: value });
	        }
	        else {
	            this.params.push({ key: key, value: value });
	        }
	        return this;
	    };
	    /**
	     * @param fields
	     * @hidden
	     */
	    Query.prototype.distinct = function (fields) {
	        if (typeof fields === 'string') {
	            this.distincts = [].slice.call([fields], 0);
	        }
	        else {
	            this.distincts = fields.slice(0);
	        }
	        return this;
	    };
	    /**
	     * Expands the related table.
	     *
	     * @param  {string|Object[]} tables
	     */
	    Query.prototype.expand = function (tables) {
	        if (typeof tables === 'string') {
	            this.expands = [].slice.call([tables], 0);
	        }
	        else {
	            this.expands = tables.slice(0);
	        }
	        return this;
	    };
	    /**
	     * Filter data with given filter criteria.
	     *
	     * @param {string|Predicate} fieldName - Defines the column field or Predicate.
	     * @param {string} operator - Defines the operator how to filter data.
	     * @param {string|number|boolean} value - Defines the values to match with data.
	     * @param {boolean} ignoreCase - If ignore case set to false, then filter data with exact match or else
	     * filter data with case insensitive.
	     * @param ignoreAccent
	     * @param matchCase
	     */
	    Query.prototype.where = function (fieldName, operator, value, ignoreCase, ignoreAccent, matchCase) {
	        operator = operator ? (operator).toLowerCase() : null;
	        var predicate = null;
	        if (typeof fieldName === 'string') {
	            predicate = new Predicate(fieldName, operator, value, ignoreCase, ignoreAccent, matchCase);
	        }
	        else if (fieldName instanceof Predicate) {
	            predicate = fieldName;
	        }
	        this.queries.push({
	            fn: 'onWhere',
	            e: predicate
	        });
	        return this;
	    };
	    /**
	     * Search data with given search criteria.
	     *
	     * @param {string|number|boolean} searchKey - Defines the search key.
	     * @param {string|string[]} fieldNames - Defines the collection of column fields.
	     * @param {string} operator - Defines the operator how to search data.
	     * @param {boolean} ignoreCase - If ignore case set to false, then filter data with exact match or else
	     * filter data with case insensitive.
	     * @param ignoreAccent
	     */
	    Query.prototype.search = function (searchKey, fieldNames, operator, ignoreCase, ignoreAccent) {
	        if (typeof fieldNames === 'string') {
	            fieldNames = [fieldNames];
	        }
	        if (!operator || operator === 'none') {
	            operator = 'contains';
	        }
	        var comparer = DataUtil.fnOperators[operator];
	        this.queries.push({
	            fn: 'onSearch',
	            e: {
	                fieldNames: fieldNames,
	                operator: operator,
	                searchKey: searchKey,
	                ignoreCase: ignoreCase,
	                ignoreAccent: ignoreAccent,
	                comparer: comparer
	            }
	        });
	        return this;
	    };
	    /**
	     * Sort the data with given sort criteria.
	     * By default, sort direction is ascending.
	     *
	     * @param {string|string[]} fieldName - Defines the single or collection of column fields.
	     * @param {string|Function} comparer - Defines the sort direction or custom sort comparer function.
	     * @param isFromGroup
	     */
	    Query.prototype.sortBy = function (fieldName, comparer, isFromGroup) {
	        return this.sortByForeignKey(fieldName, comparer, isFromGroup);
	    };
	    /**
	     * Sort the data with given sort criteria.
	     * By default, sort direction is ascending.
	     *
	     * @param {string|string[]} fieldName - Defines the single or collection of column fields.
	     * @param {string|Function} comparer - Defines the sort direction or custom sort comparer function.
	     * @param isFromGroup
	     * @param {string} direction - Defines the sort direction .
	     */
	    Query.prototype.sortByForeignKey = function (fieldName, comparer, isFromGroup, direction) {
	        var order = !isNullOrUndefined(direction) ? direction : 'ascending';
	        var sorts;
	        var temp;
	        if (typeof fieldName === 'string' && DataUtil.endsWith(fieldName.toLowerCase(), ' desc')) {
	            fieldName = fieldName.replace(/ desc$/i, '');
	            comparer = 'descending';
	        }
	        if (!comparer || typeof comparer === 'string') {
	            order = comparer ? comparer.toLowerCase() : 'ascending';
	            comparer = DataUtil.fnSort(comparer);
	        }
	        if (isFromGroup) {
	            sorts = Query.filterQueries(this.queries, 'onSortBy');
	            for (var i = 0; i < sorts.length; i++) {
	                temp = sorts[i].e.fieldName;
	                if (typeof temp === 'string') {
	                    if (temp === fieldName) {
	                        return this;
	                    }
	                }
	                else if (temp instanceof Array) {
	                    for (var j = 0; j < temp.length; j++) {
	                        if (temp[j] === fieldName || fieldName.toLowerCase() === temp[j] + ' desc') {
	                            return this;
	                        }
	                    }
	                }
	            }
	        }
	        this.queries.push({
	            fn: 'onSortBy',
	            e: {
	                fieldName: fieldName,
	                comparer: comparer,
	                direction: order
	            }
	        });
	        return this;
	    };
	    /**
	     * Sorts data in descending order.
	     *
	     * @param  {string} fieldName - Defines the column field.
	     */
	    Query.prototype.sortByDesc = function (fieldName) {
	        return this.sortBy(fieldName, 'descending');
	    };
	    /**
	     * Groups data with the given field name.
	     *
	     * @param {string} fieldName - Defines the column field.
	     * @param fn
	     * @param format
	     */
	    Query.prototype.group = function (fieldName, fn, format) {
	        this.sortBy(fieldName, null, true);
	        this.queries.push({
	            fn: 'onGroup',
	            e: {
	                fieldName: fieldName,
	                comparer: fn ? fn : null,
	                format: format ? format : null
	            }
	        });
	        return this;
	    };
	    /**
	     * Gets data based on the given page index and size.
	     *
	     * @param  {number} pageIndex - Defines the current page index.
	     * @param  {number} pageSize - Defines the no of records per page.
	     */
	    Query.prototype.page = function (pageIndex, pageSize) {
	        this.queries.push({
	            fn: 'onPage',
	            e: {
	                pageIndex: pageIndex,
	                pageSize: pageSize
	            }
	        });
	        return this;
	    };
	    /**
	     * Gets data based on the given start and end index.
	     *
	     * @param  {number} start - Defines the start index of the datasource.
	     * @param  {number} end - Defines the end index of the datasource.
	     */
	    Query.prototype.range = function (start, end) {
	        this.queries.push({
	            fn: 'onRange',
	            e: {
	                start: start,
	                end: end
	            }
	        });
	        return this;
	    };
	    /**
	     * Gets data from the top of the data source based on given number of records count.
	     *
	     * @param  {number} nos - Defines the no of records to retrieve from datasource.
	     */
	    Query.prototype.take = function (nos) {
	        this.queries.push({
	            fn: 'onTake',
	            e: {
	                nos: nos
	            }
	        });
	        return this;
	    };
	    /**
	     * Skips data with given number of records count from the top of the data source.
	     *
	     * @param  {number} nos - Defines the no of records skip in the datasource.
	     */
	    Query.prototype.skip = function (nos) {
	        this.queries.push({
	            fn: 'onSkip',
	            e: { nos: nos }
	        });
	        return this;
	    };
	    /**
	     * Selects specified columns from the data source.
	     *
	     * @param  {string|string[]} fieldNames - Defines the collection of column fields.
	     */
	    Query.prototype.select = function (fieldNames) {
	        if (typeof fieldNames === 'string') {
	            fieldNames = [].slice.call([fieldNames], 0);
	        }
	        this.queries.push({
	            fn: 'onSelect',
	            e: { fieldNames: fieldNames }
	        });
	        return this;
	    };
	    /**
	     * Gets the records in hierarchical relationship from two tables. It requires the foreign key to relate two tables.
	     *
	     * @param  {Query} query - Defines the query to relate two tables.
	     * @param  {Function} selectorFn - Defines the custom function to select records.
	     */
	    Query.prototype.hierarchy = function (query, selectorFn) {
	        this.subQuerySelector = selectorFn;
	        this.subQuery = query;
	        return this;
	    };
	    /**
	     * Sets the foreign key which is used to get data from the related table.
	     *
	     * @param  {string} key - Defines the foreign key.
	     */
	    Query.prototype.foreignKey = function (key) {
	        this.fKey = key;
	        return this;
	    };
	    /**
	     * It is used to get total number of records in the DataManager execution result.
	     */
	    Query.prototype.requiresCount = function () {
	        this.isCountRequired = true;
	        return this;
	    };
	    //type - sum, avg, min, max
	    /**
	     * Aggregate the data with given type and field name.
	     *
	     * @param  {string} type - Defines the aggregate type.
	     * @param  {string} field - Defines the column field to aggregate.
	     */
	    Query.prototype.aggregate = function (type, field) {
	        this.queries.push({
	            fn: 'onAggregates',
	            e: { field: field, type: type }
	        });
	        return this;
	    };
	    /**
	     * Pass array of filterColumn query for performing filter operation.
	     *
	     * @param  {QueryOptions[]} queries
	     * @param  {string} name
	     * @hidden
	     */
	    Query.filterQueries = function (queries, name) {
	        return queries.filter(function (q) {
	            return q.fn === name;
	        });
	    };
	    /**
	     * To get the list of queries which is already filtered in current data source.
	     *
	     * @param  {Object[]} queries
	     * @param  {string[]} singles
	     * @hidden
	     */
	    Query.filterQueryLists = function (queries, singles) {
	        var filtered = queries.filter(function (q) {
	            return singles.indexOf(q.fn) !== -1;
	        });
	        var res = {};
	        for (var i = 0; i < filtered.length; i++) {
	            if (!res[filtered[i].fn]) {
	                res[filtered[i].fn] = filtered[i].e;
	            }
	        }
	        return res;
	    };
	    return Query;
	}());
	/**
	 * Predicate class is used to generate complex filter criteria.
	 * This will be used by DataManager to perform multiple filtering operation.
	 */
	var Predicate = /** @class */ (function () {
	    /**
	     * Constructor for Predicate class.
	     *
	     * @param {string|Predicate} field
	     * @param {string} operator
	     * @param {string|number|boolean|Predicate|Predicate[]} value
	     * @param {boolean=false} ignoreCase
	     * @param ignoreAccent
	     * @param {boolean} matchCase
	     * @hidden
	     */
	    function Predicate(field, operator, value, ignoreCase, ignoreAccent, matchCase) {
	        if (ignoreCase === void 0) { ignoreCase = false; }
	        /** @hidden */
	        this.ignoreAccent = false;
	        /** @hidden */
	        this.isComplex = false;
	        if (typeof field === 'string') {
	            this.field = field;
	            this.operator = operator.toLowerCase();
	            this.value = value;
	            this.matchCase = matchCase;
	            this.ignoreCase = ignoreCase;
	            this.ignoreAccent = ignoreAccent;
	            this.isComplex = false;
	            this.comparer = DataUtil.fnOperators.processOperator(this.operator);
	        }
	        else if (field instanceof Predicate && value instanceof Predicate || value instanceof Array) {
	            this.isComplex = true;
	            this.condition = operator.toLowerCase();
	            this.predicates = [field];
	            this.matchCase = field.matchCase;
	            this.ignoreCase = field.ignoreCase;
	            this.ignoreAccent = field.ignoreAccent;
	            if (value instanceof Array) {
	                [].push.apply(this.predicates, value);
	            }
	            else {
	                this.predicates.push(value);
	            }
	        }
	        return this;
	    }
	    /**
	     * Adds n-number of new predicates on existing predicate with “and” condition.
	     *
	     * @param  {Object[]} args - Defines the collection of predicates.
	     */
	    Predicate.and = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return Predicate.combinePredicates([].slice.call(args, 0), 'and');
	    };
	    /**
	     * Adds new predicate on existing predicate with “and” condition.
	     *
	     * @param {string} field - Defines the column field.
	     * @param {string} operator - Defines the operator how to filter data.
	     * @param {string} value - Defines the values to match with data.
	     * @param {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else
	     * filter data with case insensitive.
	     * @param ignoreCase
	     * @param ignoreAccent
	     */
	    Predicate.prototype.and = function (field, operator, value, ignoreCase, ignoreAccent) {
	        return Predicate.combine(this, field, operator, value, 'and', ignoreCase, ignoreAccent);
	    };
	    /**
	     * Adds n-number of new predicates on existing predicate with “or” condition.
	     *
	     * @param  {Object[]} args - Defines the collection of predicates.
	     */
	    Predicate.or = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return Predicate.combinePredicates([].slice.call(args, 0), 'or');
	    };
	    /**
	     * Adds new predicate on existing predicate with “or” condition.
	     *
	     * @param {string} field - Defines the column field.
	     * @param {string} operator - Defines the operator how to filter data.
	     * @param {string} value - Defines the values to match with data.
	     * @param {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else
	     * filter data with case insensitive.
	     * @param ignoreCase
	     * @param ignoreAccent
	     */
	    Predicate.prototype.or = function (field, operator, value, ignoreCase, ignoreAccent) {
	        return Predicate.combine(this, field, operator, value, 'or', ignoreCase, ignoreAccent);
	    };
	    /**
	     * Adds n-number of new predicates on existing predicate with “and not” condition.
	     *
	     * @param  {Object[]} args - Defines the collection of predicates.
	     */
	    Predicate.ornot = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return Predicate.combinePredicates([].slice.call(args, 0), 'or not');
	    };
	    /**
	     * Adds new predicate on existing predicate with “and not” condition.
	     *
	     * @param {string} field - Defines the column field.
	     * @param {string} operator - Defines the operator how to filter data.
	     * @param {string} value - Defines the values to match with data.
	     * @param {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else
	     * filter data with case insensitive.
	     * @param ignoreCase
	     * @param ignoreAccent
	     */
	    Predicate.prototype.ornot = function (field, operator, value, ignoreCase, ignoreAccent) {
	        return Predicate.combine(this, field, operator, value, 'ornot', ignoreCase, ignoreAccent);
	    };
	    /**
	     * Adds n-number of new predicates on existing predicate with “and not” condition.
	     *
	     * @param  {Object[]} args - Defines the collection of predicates.
	     */
	    Predicate.andnot = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return Predicate.combinePredicates([].slice.call(args, 0), 'and not');
	    };
	    /**
	     * Adds new predicate on existing predicate with “and not” condition.
	     *
	     * @param {string} field - Defines the column field.
	     * @param {string} operator - Defines the operator how to filter data.
	     * @param {string} value - Defines the values to match with data.
	     * @param {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else
	     * filter data with case insensitive.
	     * @param ignoreCase
	     * @param ignoreAccent
	     */
	    Predicate.prototype.andnot = function (field, operator, value, ignoreCase, ignoreAccent) {
	        return Predicate.combine(this, field, operator, value, 'andnot', ignoreCase, ignoreAccent);
	    };
	    /**
	     * Converts plain JavaScript object to Predicate object.
	     *
	     * @param  {Predicate[]|Predicate} json - Defines single or collection of Predicate.
	     */
	    Predicate.fromJson = function (json) {
	        if (json instanceof Array) {
	            var res = [];
	            for (var i = 0, len = json.length; i < len; i++) {
	                res.push(this.fromJSONData(json[i]));
	            }
	            return res;
	        }
	        var pred = json;
	        return this.fromJSONData(pred);
	    };
	    /**
	     * Validate the record based on the predicates.
	     *
	     * @param  {Object} record - Defines the datasource record.
	     */
	    Predicate.prototype.validate = function (record) {
	        var predicate = this.predicates ? this.predicates : [];
	        var ret;
	        var isAnd;
	        if (!this.isComplex && this.comparer) {
	            if (this.condition && this.condition.indexOf('not') !== -1) {
	                this.condition = this.condition.split('not')[0] === '' ? undefined : this.condition.split('not')[0];
	                return !this.comparer.call(this, DataUtil.getObject(this.field, record), this.value, this.ignoreCase, this.ignoreAccent);
	            }
	            else {
	                return this.comparer.call(this, DataUtil.getObject(this.field, record), this.value, this.ignoreCase, this.ignoreAccent);
	            }
	        }
	        if (this.condition && this.condition.indexOf('not') !== -1) {
	            isAnd = this.condition.indexOf('and') !== -1;
	        }
	        else {
	            isAnd = this.condition === 'and';
	        }
	        for (var i = 0; i < predicate.length; i++) {
	            if (i > 0 && this.condition && this.condition.indexOf('not') !== -1) {
	                predicate[i].condition = predicate[i].condition ? predicate[i].condition + 'not' : 'not';
	            }
	            ret = predicate[i].validate(record);
	            if (isAnd) {
	                if (!ret) {
	                    return false;
	                }
	            }
	            else {
	                if (ret) {
	                    return true;
	                }
	            }
	        }
	        return isAnd;
	    };
	    /**
	     * Converts predicates to plain JavaScript.
	     * This method is uses Json stringify when serializing Predicate object.
	     */
	    Predicate.prototype.toJson = function () {
	        var predicates;
	        var p;
	        if (this.isComplex) {
	            predicates = [];
	            p = this.predicates;
	            for (var i = 0; i < p.length; i++) {
	                predicates.push(p[i].toJson());
	            }
	        }
	        return {
	            isComplex: this.isComplex,
	            field: this.field,
	            operator: this.operator,
	            value: this.value,
	            ignoreCase: this.ignoreCase,
	            ignoreAccent: this.ignoreAccent,
	            condition: this.condition,
	            predicates: predicates,
	            matchCase: this.matchCase
	        };
	    };
	    Predicate.combinePredicates = function (predicates, operator) {
	        if (predicates.length === 1) {
	            if (!(predicates[0] instanceof Array)) {
	                return predicates[0];
	            }
	            predicates = predicates[0];
	        }
	        return new Predicate(predicates[0], operator, predicates.slice(1));
	    };
	    Predicate.combine = function (pred, field, operator, value, condition, ignoreCase, ignoreAccent) {
	        if (field instanceof Predicate) {
	            return Predicate[condition](pred, field);
	        }
	        if (typeof field === 'string') {
	            return Predicate[condition](pred, new Predicate(field, operator, value, ignoreCase, ignoreAccent));
	        }
	        return DataUtil.throwError('Predicate - ' + condition + ' : invalid arguments');
	    };
	    Predicate.fromJSONData = function (json) {
	        var preds = json.predicates || [];
	        var len = preds.length;
	        var predicates = [];
	        var result;
	        for (var i = 0; i < len; i++) {
	            predicates.push(this.fromJSONData(preds[i]));
	        }
	        if (!json.isComplex) {
	            result = new Predicate(json.field, json.operator, json.value, json.ignoreCase, json.ignoreAccent);
	        }
	        else {
	            result = new Predicate(predicates[0], json.condition, predicates.slice(1));
	        }
	        return result;
	    };
	    return Predicate;
	}());

	/* eslint-disable valid-jsdoc */
	/* eslint-disable security/detect-object-injection */
	var consts$1 = { GroupGuid: '{271bbba0-1ee7}' };
	/**
	 * Data manager common utility methods.
	 *
	 * @hidden
	 */
	var DataUtil = /** @class */ (function () {
	    function DataUtil() {
	    }
	    /**
	     * Returns the value by invoking the provided parameter function.
	     * If the paramater is not of type function then it will be returned as it is.
	     *
	     * @param {Function|string|string[]|number} value
	     * @param {Object} inst?
	     * @param inst
	     * @hidden
	     */
	    DataUtil.getValue = function (value, inst) {
	        if (typeof value === 'function') {
	            return value.call(inst || {});
	        }
	        return value;
	    };
	    /**
	     * Returns true if the input string ends with given string.
	     *
	     * @param  {string} input
	     * @param  {string} substr
	     */
	    DataUtil.endsWith = function (input, substr) {
	        return input.slice && input.slice(-substr.length) === substr;
	    };
	    /**
	     * Returns true if the input string not ends with given string.
	     *
	     * @param  {string} input
	     * @param  {string} substr
	     */
	    DataUtil.notEndsWith = function (input, substr) {
	        return input.slice && input.slice(-substr.length) !== substr;
	    };
	    /**
	     * Returns true if the input string starts with given string.
	     *
	     * @param {string} str
	     * @param {string} startstr
	     * @param input
	     * @param start
	     */
	    DataUtil.startsWith = function (input, start) {
	        return input.slice(0, start.length) === start;
	    };
	    /**
	     * Returns true if the input string not starts with given string.
	     *
	     * @param {string} str
	     * @param {string} startstr
	     * @param input
	     * @param start
	     */
	    DataUtil.notStartsWith = function (input, start) {
	        return input.slice(0, start.length) !== start;
	    };
	    /**
	     * Returns true if the input string pattern(wildcard) matches with given string.
	     *
	     * @param {string} str
	     * @param {string} startstr
	     * @param input
	     * @param pattern
	     */
	    DataUtil.wildCard = function (input, pattern) {
	        var asteriskSplit;
	        var optionalSplit;
	        // special character allowed search
	        if (pattern.indexOf('[') !== -1) {
	            pattern = pattern.split('[').join('[[]');
	        }
	        if (pattern.indexOf('(') !== -1) {
	            pattern = pattern.split('(').join('[(]');
	        }
	        if (pattern.indexOf(')') !== -1) {
	            pattern = pattern.split(')').join('[)]');
	        }
	        if (pattern.indexOf('\\') !== -1) {
	            pattern = pattern.split('\\').join('[\\\\]');
	        }
	        if (pattern.indexOf('*') !== -1) {
	            if (pattern.charAt(0) !== '*') {
	                pattern = '^' + pattern;
	            }
	            if (pattern.charAt(pattern.length - 1) !== '*') {
	                pattern = pattern + '$';
	            }
	            asteriskSplit = pattern.split('*');
	            for (var i = 0; i < asteriskSplit.length; i++) {
	                if (asteriskSplit[i].indexOf('.') === -1) {
	                    asteriskSplit[i] = asteriskSplit[i] + '.*';
	                }
	                else {
	                    asteriskSplit[i] = asteriskSplit[i] + '*';
	                }
	            }
	            pattern = asteriskSplit.join('');
	        }
	        if (pattern.indexOf('%3f') !== -1 || pattern.indexOf('?') !== -1) {
	            optionalSplit = pattern.indexOf('%3f') !== -1 ? pattern.split('%3f') : pattern.split('?');
	            pattern = optionalSplit.join('.');
	        }
	        // eslint-disable-next-line security/detect-non-literal-regexp
	        var regexPattern = new RegExp(pattern, 'g');
	        return regexPattern.test(input);
	    };
	    /**
	     * Returns true if the input string pattern(like) matches with given string.
	     *
	     * @param {string} str
	     * @param {string} startstr
	     * @param input
	     * @param pattern
	     */
	    DataUtil.like = function (input, pattern) {
	        if (pattern.indexOf('%') !== -1) {
	            if (pattern.charAt(0) === '%' && pattern.lastIndexOf('%') < 2) {
	                pattern = pattern.substring(1, pattern.length);
	                return DataUtil.startsWith(DataUtil.toLowerCase(input), DataUtil.toLowerCase(pattern));
	            }
	            else if (pattern.charAt(pattern.length - 1) === '%' && pattern.indexOf('%') > pattern.length - 3) {
	                pattern = pattern.substring(0, pattern.length - 1);
	                return DataUtil.endsWith(DataUtil.toLowerCase(input), DataUtil.toLowerCase(pattern));
	            }
	            else if (pattern.lastIndexOf('%') !== pattern.indexOf('%') && pattern.lastIndexOf('%') > pattern.indexOf('%') + 1) {
	                pattern = pattern.substring(pattern.indexOf('%') + 1, pattern.lastIndexOf('%'));
	                return input.indexOf(pattern) !== -1;
	            }
	            else {
	                return input.indexOf(pattern) !== -1;
	            }
	        }
	        else {
	            return false;
	        }
	    };
	    /**
	     * To return the sorting function based on the string.
	     *
	     * @param  {string} order
	     * @hidden
	     */
	    DataUtil.fnSort = function (order) {
	        order = order ? DataUtil.toLowerCase(order) : 'ascending';
	        if (order === 'ascending') {
	            return this.fnAscending;
	        }
	        return this.fnDescending;
	    };
	    /**
	     * Comparer function which is used to sort the data in ascending order.
	     *
	     * @param  {string|number} x
	     * @param  {string|number} y
	     * @returns number
	     */
	    DataUtil.fnAscending = function (x, y) {
	        if (isNullOrUndefined(x) && isNullOrUndefined(y)) {
	            return -1;
	        }
	        if (y === null || y === undefined) {
	            return -1;
	        }
	        if (typeof x === 'string') {
	            return x.localeCompare(y);
	        }
	        if (x === null || x === undefined) {
	            return 1;
	        }
	        return x - y;
	    };
	    /**
	     * Comparer function which is used to sort the data in descending order.
	     *
	     * @param  {string|number} x
	     * @param  {string|number} y
	     * @returns number
	     */
	    DataUtil.fnDescending = function (x, y) {
	        if (isNullOrUndefined(x) && isNullOrUndefined(y)) {
	            return -1;
	        }
	        if (y === null || y === undefined) {
	            return 1;
	        }
	        if (typeof x === 'string') {
	            return x.localeCompare(y) * -1;
	        }
	        if (x === null || x === undefined) {
	            return -1;
	        }
	        return y - x;
	    };
	    DataUtil.extractFields = function (obj, fields) {
	        var newObj = {};
	        for (var i = 0; i < fields.length; i++) {
	            newObj = this.setValue(fields[i], this.getObject(fields[i], obj), newObj);
	        }
	        return newObj;
	    };
	    /**
	     * Select objects by given fields from jsonArray.
	     *
	     * @param  {Object[]} jsonArray
	     * @param  {string[]} fields
	     */
	    DataUtil.select = function (jsonArray, fields) {
	        var newData = [];
	        for (var i = 0; i < jsonArray.length; i++) {
	            newData.push(this.extractFields(jsonArray[i], fields));
	        }
	        return newData;
	    };
	    /**
	     * Group the input data based on the field name.
	     * It also performs aggregation of the grouped records based on the aggregates paramater.
	     *
	     * @param {Object[]} jsonArray
	     * @param {string} field?
	     * @param {Object[]} agg?
	     * @param {number} level?
	     * @param {Object[]} groupDs?
	     * @param field
	     * @param aggregates
	     * @param level
	     * @param groupDs
	     * @param format
	     * @param isLazyLoad
	     */
	    DataUtil.group = function (jsonArray, field, aggregates, level, groupDs, format, isLazyLoad) {
	        level = level || 1;
	        var jsonData = jsonArray;
	        var guid = 'GroupGuid';
	        if (jsonData.GroupGuid === consts$1[guid]) {
	            var _loop_1 = function (j) {
	                if (!isNullOrUndefined(groupDs)) {
	                    var indx = -1;
	                    var temp = groupDs.filter(function (e) { return e.key === jsonData[j].key; });
	                    indx = groupDs.indexOf(temp[0]);
	                    jsonData[j].items = this_1.group(jsonData[j].items, field, aggregates, jsonData.level + 1, groupDs[indx].items, format, isLazyLoad);
	                    jsonData[j].count = groupDs[indx].count;
	                }
	                else {
	                    jsonData[j].items = this_1.group(jsonData[j].items, field, aggregates, jsonData.level + 1, null, format, isLazyLoad);
	                    jsonData[j].count = jsonData[j].items.length;
	                }
	            };
	            var this_1 = this;
	            for (var j = 0; j < jsonData.length; j++) {
	                _loop_1(j);
	            }
	            jsonData.childLevels += 1;
	            return jsonData;
	        }
	        var grouped = {};
	        var groupedArray = [];
	        groupedArray.GroupGuid = consts$1[guid];
	        groupedArray.level = level;
	        groupedArray.childLevels = 0;
	        groupedArray.records = jsonData;
	        var _loop_2 = function (i) {
	            var val = this_2.getVal(jsonData, i, field);
	            if (!isNullOrUndefined(format)) {
	                val = format(val, field);
	            }
	            if (!grouped[val]) {
	                grouped[val] = {
	                    key: val,
	                    count: 0,
	                    items: [],
	                    aggregates: {},
	                    field: field
	                };
	                groupedArray.push(grouped[val]);
	                if (!isNullOrUndefined(groupDs)) {
	                    var tempObj = groupDs.filter(function (e) { return e.key === grouped[val].key; });
	                    grouped[val].count = tempObj[0].count;
	                }
	            }
	            grouped[val].count = !isNullOrUndefined(groupDs) ? grouped[val].count : grouped[val].count += 1;
	            if (!isLazyLoad || (isLazyLoad && aggregates.length)) {
	                grouped[val].items.push(jsonData[i]);
	            }
	        };
	        var this_2 = this;
	        for (var i = 0; i < jsonData.length; i++) {
	            _loop_2(i);
	        }
	        if (aggregates && aggregates.length) {
	            var _loop_3 = function (i) {
	                var res = {};
	                var fn = void 0;
	                var aggs = aggregates;
	                for (var j = 0; j < aggregates.length; j++) {
	                    fn = DataUtil.aggregates[aggregates[j].type];
	                    if (!isNullOrUndefined(groupDs)) {
	                        var temp = groupDs.filter(function (e) { return e.key === groupedArray[i].key; });
	                        if (fn) {
	                            res[aggs[j].field + ' - ' + aggs[j].type] = fn(temp[0].items, aggs[j].field);
	                        }
	                    }
	                    else {
	                        if (fn) {
	                            res[aggs[j].field + ' - ' + aggs[j].type] = fn(groupedArray[i].items, aggs[j].field);
	                        }
	                    }
	                }
	                groupedArray[i].aggregates = res;
	            };
	            for (var i = 0; i < groupedArray.length; i++) {
	                _loop_3(i);
	            }
	        }
	        if (isLazyLoad && groupedArray.length && aggregates.length) {
	            for (var i = 0; i < groupedArray.length; i++) {
	                groupedArray[i].items = [];
	            }
	        }
	        return jsonData.length && groupedArray || jsonData;
	    };
	    /**
	     * It is used to categorize the multiple items based on a specific field in jsonArray.
	     * The hierarchical queries are commonly required when you use foreign key binding.
	     *
	     * @param {string} fKey
	     * @param {string} from
	     * @param {Object[]} source
	     * @param {Group} lookup?
	     * @param {string} pKey?
	     * @param lookup
	     * @param pKey
	     * @hidden
	     */
	    DataUtil.buildHierarchy = function (fKey, from, source, lookup, pKey) {
	        var i;
	        var grp = {};
	        var temp;
	        if (lookup.result) {
	            lookup = lookup.result;
	        }
	        if (lookup.GroupGuid) {
	            this.throwError('DataManager: Do not have support Grouping in hierarchy');
	        }
	        for (i = 0; i < lookup.length; i++) {
	            var fKeyData = this.getObject(fKey, lookup[i]);
	            temp = grp[fKeyData] || (grp[fKeyData] = []);
	            temp.push(lookup[i]);
	        }
	        for (i = 0; i < source.length; i++) {
	            var fKeyData = this.getObject(pKey || fKey, source[i]);
	            source[i][from] = grp[fKeyData];
	        }
	    };
	    /**
	     * The method used to get the field names which started with specified characters.
	     *
	     * @param {Object} obj
	     * @param {string[]} fields?
	     * @param {string} prefix?
	     * @param fields
	     * @param prefix
	     * @hidden
	     */
	    DataUtil.getFieldList = function (obj, fields, prefix) {
	        if (prefix === undefined) {
	            prefix = '';
	        }
	        if (fields === undefined || fields === null) {
	            return this.getFieldList(obj, [], prefix);
	        }
	        var copyObj = obj;
	        var keys = Object.keys(obj);
	        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
	            var prop = keys_1[_i];
	            if (typeof copyObj[prop] === 'object' && !(copyObj[prop] instanceof Array)) {
	                this.getFieldList(copyObj[prop], fields, prefix + prop + '.');
	            }
	            else {
	                fields.push(prefix + prop);
	            }
	        }
	        return fields;
	    };
	    /**
	     * Gets the value of the property in the given object.
	     * The complex object can be accessed by providing the field names concatenated with dot(.).
	     *
	     * @param  {string} nameSpace - The name of the property to be accessed.
	     * @param  {Object} from - Defines the source object.
	     */
	    DataUtil.getObject = function (nameSpace, from) {
	        if (!nameSpace) {
	            return from;
	        }
	        if (!from) {
	            return undefined;
	        }
	        if (nameSpace.indexOf('.') === -1) {
	            var lowerCaseNameSpace = nameSpace.charAt(0).toLowerCase() + nameSpace.slice(1);
	            var upperCaseNameSpace = nameSpace.charAt(0).toUpperCase() + nameSpace.slice(1);
	            if (!isNullOrUndefined(from[nameSpace])) {
	                return from[nameSpace];
	            }
	            else {
	                if (!isNullOrUndefined(from[lowerCaseNameSpace])) {
	                    return from[lowerCaseNameSpace];
	                }
	                else if (!isNullOrUndefined(from[upperCaseNameSpace])) {
	                    return from[upperCaseNameSpace];
	                }
	                else {
	                    return null;
	                }
	            }
	        }
	        var value = from;
	        var splits = nameSpace.split('.');
	        for (var i = 0; i < splits.length; i++) {
	            if (value == null) {
	                break;
	            }
	            value = value[splits[i]];
	            if (value === undefined) {
	                var casing = splits[i].charAt(0).toUpperCase() + splits[i].slice(1);
	                value = from[casing] || from[casing.charAt(0).toLowerCase() + casing.slice(1)] || null;
	            }
	            from = value;
	        }
	        return value;
	    };
	    /**
	     * To set value for the nameSpace in desired object.
	     *
	     * @param {string} nameSpace - String value to the get the inner object.
	     * @param {Object} value - Value that you need to set.
	     * @param {Object} obj - Object to get the inner object value.
	     * @return { [key: string]: Object; } | Object
	     * @hidden
	     */
	    DataUtil.setValue = function (nameSpace, value, obj) {
	        var keys = nameSpace.toString().split('.');
	        var start = obj || {};
	        var fromObj = start;
	        var i;
	        var length = keys.length;
	        var key;
	        for (i = 0; i < length; i++) {
	            key = keys[i];
	            if (i + 1 === length) {
	                fromObj[key] = value === undefined ? undefined : value;
	            }
	            else if (isNullOrUndefined(fromObj[key])) {
	                fromObj[key] = {};
	            }
	            fromObj = fromObj[key];
	        }
	        return start;
	    };
	    /**
	     * Sort the given data based on the field and comparer.
	     *
	     * @param  {Object[]} ds - Defines the input data.
	     * @param  {string} field - Defines the field to be sorted.
	     * @param  {Function} comparer - Defines the comparer function used to sort the records.
	     */
	    DataUtil.sort = function (ds, field, comparer) {
	        if (ds.length <= 1) {
	            return ds;
	        }
	        var middle = parseInt((ds.length / 2).toString(), 10);
	        var left = ds.slice(0, middle);
	        var right = ds.slice(middle);
	        left = this.sort(left, field, comparer);
	        right = this.sort(right, field, comparer);
	        return this.merge(left, right, field, comparer);
	    };
	    DataUtil.ignoreDiacritics = function (value) {
	        if (typeof value !== 'string') {
	            return value;
	        }
	        var result = value.split('');
	        var newValue = result.map(function (temp) { return temp in DataUtil.diacritics ? DataUtil.diacritics[temp] : temp; });
	        return newValue.join('');
	    };
	    DataUtil.merge = function (left, right, fieldName, comparer) {
	        var result = [];
	        var current;
	        while (left.length > 0 || right.length > 0) {
	            if (left.length > 0 && right.length > 0) {
	                if (comparer) {
	                    current = comparer(this.getVal(left, 0, fieldName), this.getVal(right, 0, fieldName), left[0], right[0]) <= 0 ? left : right;
	                }
	                else {
	                    current = left[0][fieldName] < left[0][fieldName] ? left : right;
	                }
	            }
	            else {
	                current = left.length > 0 ? left : right;
	            }
	            result.push(current.shift());
	        }
	        return result;
	    };
	    DataUtil.getVal = function (array, index, field) {
	        return field ? this.getObject(field, array[index]) : array[index];
	    };
	    DataUtil.toLowerCase = function (val) {
	        return val ? typeof val === 'string' ? val.toLowerCase() : val.toString() : (val === 0 || val === false) ? val.toString() : '';
	    };
	    /**
	     * To perform the filter operation with specified adaptor and returns the result.
	     *
	     * @param {Object} adaptor
	     * @param {string} fnName
	     * @param {Object} param1?
	     * @param {Object} param2?
	     * @param param1
	     * @param param2
	     * @hidden
	     */
	    DataUtil.callAdaptorFunction = function (adaptor, fnName, param1, param2) {
	        if (fnName in adaptor) {
	            var res = adaptor[fnName](param1, param2);
	            if (!isNullOrUndefined(res)) {
	                param1 = res;
	            }
	        }
	        return param1;
	    };
	    DataUtil.getAddParams = function (adp, dm, query) {
	        var req = {};
	        DataUtil.callAdaptorFunction(adp, 'addParams', {
	            dm: dm,
	            query: query,
	            params: query.params,
	            reqParams: req
	        });
	        return req;
	    };
	    /**
	     * Checks wheather the given input is a plain object or not.
	     *
	     * @param  {Object|Object[]} obj
	     */
	    DataUtil.isPlainObject = function (obj) {
	        return (!!obj) && (obj.constructor === Object);
	    };
	    /**
	     * Returns true when the browser cross origin request.
	     */
	    DataUtil.isCors = function () {
	        var xhr = null;
	        var request = 'XMLHttpRequest';
	        try {
	            xhr = new window[request]();
	        }
	        catch (e) {
	            // No exception handling
	        }
	        return !!xhr && ('withCredentials' in xhr);
	    };
	    /**
	     * Generate random GUID value which will be prefixed with the given value.
	     *
	     * @param  {string} prefix
	     */
	    DataUtil.getGuid = function (prefix) {
	        var hexs = '0123456789abcdef';
	        var rand;
	        return (prefix || '') + '00000000-0000-4000-0000-000000000000'.replace(/0/g, function (val, i) {
	            if ('crypto' in window && 'getRandomValues' in crypto) {
	                var arr = new Uint8Array(1);
	                window.crypto.getRandomValues(arr);
	                rand = arr[0] % 16 | 0;
	            }
	            else {
	                rand = Math.random() * 16 | 0;
	            }
	            return hexs[i === 19 ? rand & 0x3 | 0x8 : rand];
	        });
	    };
	    /**
	     * Checks wheather the given value is null or not.
	     *
	     * @param  {string|Object} val
	     * @returns boolean
	     */
	    DataUtil.isNull = function (val) {
	        return val === undefined || val === null;
	    };
	    /**
	     * To get the required items from collection of objects.
	     *
	     * @param  {Object[]} array
	     * @param  {string} field
	     * @param  {Function} comparer
	     * @returns Object
	     * @hidden
	     */
	    DataUtil.getItemFromComparer = function (array, field, comparer) {
	        var keyVal;
	        var current;
	        var key;
	        var i = 0;
	        var castRequired = typeof DataUtil.getVal(array, 0, field) === 'string';
	        if (array.length) {
	            while (isNullOrUndefined(keyVal) && i < array.length) {
	                keyVal = DataUtil.getVal(array, i, field);
	                key = array[i++];
	            }
	        }
	        for (; i < array.length; i++) {
	            current = DataUtil.getVal(array, i, field);
	            if (isNullOrUndefined(current)) {
	                continue;
	            }
	            if (castRequired) {
	                keyVal = +keyVal;
	                current = +current;
	            }
	            if (comparer(keyVal, current) > 0) {
	                keyVal = current;
	                key = array[i];
	            }
	        }
	        return key;
	    };
	    /**
	     * To get distinct values of Array or Array of Objects.
	     *
	     * @param {Object[]} json
	     * @param {string} field
	     * @param fieldName
	     * @param {boolean} requiresCompleteRecord
	     * @returns Object[]
	     * * distinct array of objects is return when requiresCompleteRecord set as true.
	     * @hidden
	     */
	    DataUtil.distinct = function (json, fieldName, requiresCompleteRecord) {
	        requiresCompleteRecord = isNullOrUndefined(requiresCompleteRecord) ? false : requiresCompleteRecord;
	        var result = [];
	        var val;
	        var tmp = {};
	        json.forEach(function (data, index) {
	            val = typeof (json[index]) === 'object' ? DataUtil.getVal(json, index, fieldName) : json[index];
	            if (!(val in tmp)) {
	                result.push(!requiresCompleteRecord ? val : json[index]);
	                tmp[val] = 1;
	            }
	        });
	        return result;
	    };
	    /**
	     * Process the given records based on the datamanager string.
	     *
	     * @param {string} datamanager
	     * @param dm
	     * @param {Object[]} records
	     */
	    DataUtil.processData = function (dm, records) {
	        var query = this.prepareQuery(dm);
	        var sampledata = new DataManager(records);
	        if (dm.requiresCounts) {
	            query.requiresCount();
	        }
	        /* eslint-disable @typescript-eslint/no-explicit-any */
	        // tslint:disable-next-line:no-any
	        var result = sampledata.executeLocal(query);
	        /* eslint-enable @typescript-eslint/no-explicit-any */
	        var returnValue = {
	            result: dm.requiresCounts ? result.result : result,
	            count: result.count,
	            aggregates: JSON.stringify(result.aggregates)
	        };
	        return dm.requiresCounts ? returnValue : result;
	    };
	    DataUtil.prepareQuery = function (dm) {
	        var _this = this;
	        var query = new Query();
	        if (dm.select) {
	            query.select(dm.select);
	        }
	        if (dm.where) {
	            var where = DataUtil.parse.parseJson(dm.where);
	            where.filter(function (pred) {
	                if (isNullOrUndefined(pred.condition)) {
	                    query.where(pred.field, pred.operator, pred.value, pred.ignoreCase, pred.ignoreAccent);
	                }
	                else {
	                    var predicateList = [];
	                    if (pred.field) {
	                        predicateList.push(new Predicate(pred.field, pred.operator, pred.value, pred.ignoreCase, pred.ignoreAccent));
	                    }
	                    else {
	                        predicateList = predicateList.concat(_this.getPredicate(pred.predicates));
	                    }
	                    if (pred.condition === 'or') {
	                        query.where(Predicate.or(predicateList));
	                    }
	                    else if (pred.condition === 'and') {
	                        query.where(Predicate.and(predicateList));
	                    }
	                }
	            });
	        }
	        if (dm.search) {
	            var search = DataUtil.parse.parseJson(dm.search);
	            // tslint:disable-next-line:no-string-literal
	            search.filter(function (e) { return query.search(e.key, e.fields, e['operator'], 
	            // tslint:disable-next-line:no-string-literal
	            e['ignoreCase'], e['ignoreAccent']); });
	        }
	        if (dm.aggregates) {
	            dm.aggregates.filter(function (e) { return query.aggregate(e.type, e.field); });
	        }
	        if (dm.sorted) {
	            dm.sorted.filter(function (e) { return query.sortBy(e.name, e.direction); });
	        }
	        if (dm.skip) {
	            query.skip(dm.skip);
	        }
	        if (dm.take) {
	            query.take(dm.take);
	        }
	        if (dm.group) {
	            dm.group.filter(function (grp) { return query.group(grp); });
	        }
	        return query;
	    };
	    DataUtil.getPredicate = function (pred) {
	        var mainPred = [];
	        for (var i = 0; i < pred.length; i++) {
	            var e = pred[i];
	            if (e.field) {
	                mainPred.push(new Predicate(e.field, e.operator, e.value, e.ignoreCase, e.ignoreAccent));
	            }
	            else {
	                var childPred = [];
	                // tslint:disable-next-line:typedef
	                var cpre = this.getPredicate(e.predicates);
	                for (var _i = 0, _a = Object.keys(cpre); _i < _a.length; _i++) {
	                    var prop = _a[_i];
	                    childPred.push(cpre[prop]);
	                }
	                mainPred.push(e.condition === 'or' ? Predicate.or(childPred) : Predicate.and(childPred));
	            }
	        }
	        return mainPred;
	    };
	    /**
	     * Specifies the value which will be used to adjust the date value to server timezone.
	     *
	     * @default null
	     */
	    DataUtil.serverTimezoneOffset = null;
	    /**
	     * Species whether are not to be parsed with serverTimezoneOffset value.
	     *
	     * @hidden
	     */
	    DataUtil.timeZoneHandling = true;
	    /**
	     * Throw error with the given string as message.
	     *
	     * @param {string} er
	     * @param error
	     */
	    DataUtil.throwError = function (error) {
	        try {
	            throw new Error(error);
	        }
	        catch (e) {
	            // eslint-disable-next-line no-throw-literal
	            throw e.message + '\n' + e.stack;
	        }
	    };
	    DataUtil.aggregates = {
	        /**
	         * Calculate sum of the given field in the data.
	         *
	         * @param  {Object[]} ds
	         * @param  {string} field
	         */
	        sum: function (ds, field) {
	            var result = 0;
	            var val;
	            var castRequired = typeof DataUtil.getVal(ds, 0, field) !== 'number';
	            for (var i = 0; i < ds.length; i++) {
	                val = DataUtil.getVal(ds, i, field);
	                if (!isNaN(val) && val !== null) {
	                    if (castRequired) {
	                        val = +val;
	                    }
	                    result += val;
	                }
	            }
	            return result;
	        },
	        /**
	         * Calculate average value of the given field in the data.
	         *
	         * @param  {Object[]} ds
	         * @param  {string} field
	         */
	        average: function (ds, field) {
	            return DataUtil.aggregates.sum(ds, field) / ds.length;
	        },
	        /**
	         * Returns the min value of the data based on the field.
	         *
	         * @param  {Object[]} ds
	         * @param  {string|Function} field
	         */
	        min: function (ds, field) {
	            var comparer;
	            if (typeof field === 'function') {
	                comparer = field;
	                field = null;
	            }
	            return DataUtil.getObject(field, DataUtil.getItemFromComparer(ds, field, comparer || DataUtil.fnAscending));
	        },
	        /**
	         * Returns the max value of the data based on the field.
	         *
	         * @param  {Object[]} ds
	         * @param  {string} field
	         * @returns number
	         */
	        max: function (ds, field) {
	            var comparer;
	            if (typeof field === 'function') {
	                comparer = field;
	                field = null;
	            }
	            return DataUtil.getObject(field, DataUtil.getItemFromComparer(ds, field, comparer || DataUtil.fnDescending));
	        },
	        /**
	         * Returns the total number of true value present in the data based on the given boolean field name.
	         *
	         * @param  {Object[]} ds
	         * @param  {string} field
	         */
	        truecount: function (ds, field) {
	            return new DataManager(ds).executeLocal(new Query().where(field, 'equal', true, true)).length;
	        },
	        /**
	         * Returns the total number of false value present in the data based on the given boolean field name.
	         *
	         * @param  {Object[]} ds
	         * @param  {string} field
	         */
	        falsecount: function (ds, field) {
	            return new DataManager(ds).executeLocal(new Query().where(field, 'equal', false, true)).length;
	        },
	        /**
	         * Returns the length of the given data.
	         *
	         * @param {Object[]} ds
	         * @param {string} field?
	         * @param field
	         * @returns number
	         */
	        count: function (ds, field) {
	            return ds.length;
	        }
	    };
	    /**
	     * Specifies the Object with filter operators.
	     */
	    DataUtil.operatorSymbols = {
	        '<': 'lessthan',
	        '>': 'greaterthan',
	        '<=': 'lessthanorequal',
	        '>=': 'greaterthanorequal',
	        '==': 'equal',
	        '!=': 'notequal',
	        '*=': 'contains',
	        '$=': 'endswith',
	        '^=': 'startswith'
	    };
	    /**
	     * Specifies the Object with filter operators which will be used for OData filter query generation.
	     * * It will be used for date/number type filter query.
	     */
	    DataUtil.odBiOperator = {
	        '<': ' lt ',
	        '>': ' gt ',
	        '<=': ' le ',
	        '>=': ' ge ',
	        '==': ' eq ',
	        '!=': ' ne ',
	        'lessthan': ' lt ',
	        'lessthanorequal': ' le ',
	        'greaterthan': ' gt ',
	        'greaterthanorequal': ' ge ',
	        'equal': ' eq ',
	        'notequal': ' ne '
	    };
	    /**
	     * Specifies the Object with filter operators which will be used for OData filter query generation.
	     * It will be used for string type filter query.
	     */
	    DataUtil.odUniOperator = {
	        '$=': 'endswith',
	        '^=': 'startswith',
	        '*=': 'substringof',
	        'endswith': 'endswith',
	        'startswith': 'startswith',
	        'contains': 'substringof',
	        'doesnotendwith': 'not endswith',
	        'doesnotstartwith': 'not startswith',
	        'doesnotcontain': 'not substringof',
	        'wildcard': 'wildcard',
	        'like': 'like'
	    };
	    /**
	     * Specifies the Object with filter operators which will be used for ODataV4 filter query generation.
	     * It will be used for string type filter query.
	     */
	    DataUtil.odv4UniOperator = {
	        '$=': 'endswith',
	        '^=': 'startswith',
	        '*=': 'contains',
	        'endswith': 'endswith',
	        'startswith': 'startswith',
	        'contains': 'contains',
	        'doesnotendwith': 'not endswith',
	        'doesnotstartwith': 'not startswith',
	        'doesnotcontain': 'not contains',
	        'wildcard': 'wildcard',
	        'like': 'like'
	    };
	    DataUtil.diacritics = {
	        '\u24B6': 'A',
	        '\uFF21': 'A',
	        '\u00C0': 'A',
	        '\u00C1': 'A',
	        '\u00C2': 'A',
	        '\u1EA6': 'A',
	        '\u1EA4': 'A',
	        '\u1EAA': 'A',
	        '\u1EA8': 'A',
	        '\u00C3': 'A',
	        '\u0100': 'A',
	        '\u0102': 'A',
	        '\u1EB0': 'A',
	        '\u1EAE': 'A',
	        '\u1EB4': 'A',
	        '\u1EB2': 'A',
	        '\u0226': 'A',
	        '\u01E0': 'A',
	        '\u00C4': 'A',
	        '\u01DE': 'A',
	        '\u1EA2': 'A',
	        '\u00C5': 'A',
	        '\u01FA': 'A',
	        '\u01CD': 'A',
	        '\u0200': 'A',
	        '\u0202': 'A',
	        '\u1EA0': 'A',
	        '\u1EAC': 'A',
	        '\u1EB6': 'A',
	        '\u1E00': 'A',
	        '\u0104': 'A',
	        '\u023A': 'A',
	        '\u2C6F': 'A',
	        '\uA732': 'AA',
	        '\u00C6': 'AE',
	        '\u01FC': 'AE',
	        '\u01E2': 'AE',
	        '\uA734': 'AO',
	        '\uA736': 'AU',
	        '\uA738': 'AV',
	        '\uA73A': 'AV',
	        '\uA73C': 'AY',
	        '\u24B7': 'B',
	        '\uFF22': 'B',
	        '\u1E02': 'B',
	        '\u1E04': 'B',
	        '\u1E06': 'B',
	        '\u0243': 'B',
	        '\u0182': 'B',
	        '\u0181': 'B',
	        '\u24B8': 'C',
	        '\uFF23': 'C',
	        '\u0106': 'C',
	        '\u0108': 'C',
	        '\u010A': 'C',
	        '\u010C': 'C',
	        '\u00C7': 'C',
	        '\u1E08': 'C',
	        '\u0187': 'C',
	        '\u023B': 'C',
	        '\uA73E': 'C',
	        '\u24B9': 'D',
	        '\uFF24': 'D',
	        '\u1E0A': 'D',
	        '\u010E': 'D',
	        '\u1E0C': 'D',
	        '\u1E10': 'D',
	        '\u1E12': 'D',
	        '\u1E0E': 'D',
	        '\u0110': 'D',
	        '\u018B': 'D',
	        '\u018A': 'D',
	        '\u0189': 'D',
	        '\uA779': 'D',
	        '\u01F1': 'DZ',
	        '\u01C4': 'DZ',
	        '\u01F2': 'Dz',
	        '\u01C5': 'Dz',
	        '\u24BA': 'E',
	        '\uFF25': 'E',
	        '\u00C8': 'E',
	        '\u00C9': 'E',
	        '\u00CA': 'E',
	        '\u1EC0': 'E',
	        '\u1EBE': 'E',
	        '\u1EC4': 'E',
	        '\u1EC2': 'E',
	        '\u1EBC': 'E',
	        '\u0112': 'E',
	        '\u1E14': 'E',
	        '\u1E16': 'E',
	        '\u0114': 'E',
	        '\u0116': 'E',
	        '\u00CB': 'E',
	        '\u1EBA': 'E',
	        '\u011A': 'E',
	        '\u0204': 'E',
	        '\u0206': 'E',
	        '\u1EB8': 'E',
	        '\u1EC6': 'E',
	        '\u0228': 'E',
	        '\u1E1C': 'E',
	        '\u0118': 'E',
	        '\u1E18': 'E',
	        '\u1E1A': 'E',
	        '\u0190': 'E',
	        '\u018E': 'E',
	        '\u24BB': 'F',
	        '\uFF26': 'F',
	        '\u1E1E': 'F',
	        '\u0191': 'F',
	        '\uA77B': 'F',
	        '\u24BC': 'G',
	        '\uFF27': 'G',
	        '\u01F4': 'G',
	        '\u011C': 'G',
	        '\u1E20': 'G',
	        '\u011E': 'G',
	        '\u0120': 'G',
	        '\u01E6': 'G',
	        '\u0122': 'G',
	        '\u01E4': 'G',
	        '\u0193': 'G',
	        '\uA7A0': 'G',
	        '\uA77D': 'G',
	        '\uA77E': 'G',
	        '\u24BD': 'H',
	        '\uFF28': 'H',
	        '\u0124': 'H',
	        '\u1E22': 'H',
	        '\u1E26': 'H',
	        '\u021E': 'H',
	        '\u1E24': 'H',
	        '\u1E28': 'H',
	        '\u1E2A': 'H',
	        '\u0126': 'H',
	        '\u2C67': 'H',
	        '\u2C75': 'H',
	        '\uA78D': 'H',
	        '\u24BE': 'I',
	        '\uFF29': 'I',
	        '\u00CC': 'I',
	        '\u00CD': 'I',
	        '\u00CE': 'I',
	        '\u0128': 'I',
	        '\u012A': 'I',
	        '\u012C': 'I',
	        '\u0130': 'I',
	        '\u00CF': 'I',
	        '\u1E2E': 'I',
	        '\u1EC8': 'I',
	        '\u01CF': 'I',
	        '\u0208': 'I',
	        '\u020A': 'I',
	        '\u1ECA': 'I',
	        '\u012E': 'I',
	        '\u1E2C': 'I',
	        '\u0197': 'I',
	        '\u24BF': 'J',
	        '\uFF2A': 'J',
	        '\u0134': 'J',
	        '\u0248': 'J',
	        '\u24C0': 'K',
	        '\uFF2B': 'K',
	        '\u1E30': 'K',
	        '\u01E8': 'K',
	        '\u1E32': 'K',
	        '\u0136': 'K',
	        '\u1E34': 'K',
	        '\u0198': 'K',
	        '\u2C69': 'K',
	        '\uA740': 'K',
	        '\uA742': 'K',
	        '\uA744': 'K',
	        '\uA7A2': 'K',
	        '\u24C1': 'L',
	        '\uFF2C': 'L',
	        '\u013F': 'L',
	        '\u0139': 'L',
	        '\u013D': 'L',
	        '\u1E36': 'L',
	        '\u1E38': 'L',
	        '\u013B': 'L',
	        '\u1E3C': 'L',
	        '\u1E3A': 'L',
	        '\u0141': 'L',
	        '\u023D': 'L',
	        '\u2C62': 'L',
	        '\u2C60': 'L',
	        '\uA748': 'L',
	        '\uA746': 'L',
	        '\uA780': 'L',
	        '\u01C7': 'LJ',
	        '\u01C8': 'Lj',
	        '\u24C2': 'M',
	        '\uFF2D': 'M',
	        '\u1E3E': 'M',
	        '\u1E40': 'M',
	        '\u1E42': 'M',
	        '\u2C6E': 'M',
	        '\u019C': 'M',
	        '\u24C3': 'N',
	        '\uFF2E': 'N',
	        '\u01F8': 'N',
	        '\u0143': 'N',
	        '\u00D1': 'N',
	        '\u1E44': 'N',
	        '\u0147': 'N',
	        '\u1E46': 'N',
	        '\u0145': 'N',
	        '\u1E4A': 'N',
	        '\u1E48': 'N',
	        '\u0220': 'N',
	        '\u019D': 'N',
	        '\uA790': 'N',
	        '\uA7A4': 'N',
	        '\u01CA': 'NJ',
	        '\u01CB': 'Nj',
	        '\u24C4': 'O',
	        '\uFF2F': 'O',
	        '\u00D2': 'O',
	        '\u00D3': 'O',
	        '\u00D4': 'O',
	        '\u1ED2': 'O',
	        '\u1ED0': 'O',
	        '\u1ED6': 'O',
	        '\u1ED4': 'O',
	        '\u00D5': 'O',
	        '\u1E4C': 'O',
	        '\u022C': 'O',
	        '\u1E4E': 'O',
	        '\u014C': 'O',
	        '\u1E50': 'O',
	        '\u1E52': 'O',
	        '\u014E': 'O',
	        '\u022E': 'O',
	        '\u0230': 'O',
	        '\u00D6': 'O',
	        '\u022A': 'O',
	        '\u1ECE': 'O',
	        '\u0150': 'O',
	        '\u01D1': 'O',
	        '\u020C': 'O',
	        '\u020E': 'O',
	        '\u01A0': 'O',
	        '\u1EDC': 'O',
	        '\u1EDA': 'O',
	        '\u1EE0': 'O',
	        '\u1EDE': 'O',
	        '\u1EE2': 'O',
	        '\u1ECC': 'O',
	        '\u1ED8': 'O',
	        '\u01EA': 'O',
	        '\u01EC': 'O',
	        '\u00D8': 'O',
	        '\u01FE': 'O',
	        '\u0186': 'O',
	        '\u019F': 'O',
	        '\uA74A': 'O',
	        '\uA74C': 'O',
	        '\u01A2': 'OI',
	        '\uA74E': 'OO',
	        '\u0222': 'OU',
	        '\u24C5': 'P',
	        '\uFF30': 'P',
	        '\u1E54': 'P',
	        '\u1E56': 'P',
	        '\u01A4': 'P',
	        '\u2C63': 'P',
	        '\uA750': 'P',
	        '\uA752': 'P',
	        '\uA754': 'P',
	        '\u24C6': 'Q',
	        '\uFF31': 'Q',
	        '\uA756': 'Q',
	        '\uA758': 'Q',
	        '\u024A': 'Q',
	        '\u24C7': 'R',
	        '\uFF32': 'R',
	        '\u0154': 'R',
	        '\u1E58': 'R',
	        '\u0158': 'R',
	        '\u0210': 'R',
	        '\u0212': 'R',
	        '\u1E5A': 'R',
	        '\u1E5C': 'R',
	        '\u0156': 'R',
	        '\u1E5E': 'R',
	        '\u024C': 'R',
	        '\u2C64': 'R',
	        '\uA75A': 'R',
	        '\uA7A6': 'R',
	        '\uA782': 'R',
	        '\u24C8': 'S',
	        '\uFF33': 'S',
	        '\u1E9E': 'S',
	        '\u015A': 'S',
	        '\u1E64': 'S',
	        '\u015C': 'S',
	        '\u1E60': 'S',
	        '\u0160': 'S',
	        '\u1E66': 'S',
	        '\u1E62': 'S',
	        '\u1E68': 'S',
	        '\u0218': 'S',
	        '\u015E': 'S',
	        '\u2C7E': 'S',
	        '\uA7A8': 'S',
	        '\uA784': 'S',
	        '\u24C9': 'T',
	        '\uFF34': 'T',
	        '\u1E6A': 'T',
	        '\u0164': 'T',
	        '\u1E6C': 'T',
	        '\u021A': 'T',
	        '\u0162': 'T',
	        '\u1E70': 'T',
	        '\u1E6E': 'T',
	        '\u0166': 'T',
	        '\u01AC': 'T',
	        '\u01AE': 'T',
	        '\u023E': 'T',
	        '\uA786': 'T',
	        '\uA728': 'TZ',
	        '\u24CA': 'U',
	        '\uFF35': 'U',
	        '\u00D9': 'U',
	        '\u00DA': 'U',
	        '\u00DB': 'U',
	        '\u0168': 'U',
	        '\u1E78': 'U',
	        '\u016A': 'U',
	        '\u1E7A': 'U',
	        '\u016C': 'U',
	        '\u00DC': 'U',
	        '\u01DB': 'U',
	        '\u01D7': 'U',
	        '\u01D5': 'U',
	        '\u01D9': 'U',
	        '\u1EE6': 'U',
	        '\u016E': 'U',
	        '\u0170': 'U',
	        '\u01D3': 'U',
	        '\u0214': 'U',
	        '\u0216': 'U',
	        '\u01AF': 'U',
	        '\u1EEA': 'U',
	        '\u1EE8': 'U',
	        '\u1EEE': 'U',
	        '\u1EEC': 'U',
	        '\u1EF0': 'U',
	        '\u1EE4': 'U',
	        '\u1E72': 'U',
	        '\u0172': 'U',
	        '\u1E76': 'U',
	        '\u1E74': 'U',
	        '\u0244': 'U',
	        '\u24CB': 'V',
	        '\uFF36': 'V',
	        '\u1E7C': 'V',
	        '\u1E7E': 'V',
	        '\u01B2': 'V',
	        '\uA75E': 'V',
	        '\u0245': 'V',
	        '\uA760': 'VY',
	        '\u24CC': 'W',
	        '\uFF37': 'W',
	        '\u1E80': 'W',
	        '\u1E82': 'W',
	        '\u0174': 'W',
	        '\u1E86': 'W',
	        '\u1E84': 'W',
	        '\u1E88': 'W',
	        '\u2C72': 'W',
	        '\u24CD': 'X',
	        '\uFF38': 'X',
	        '\u1E8A': 'X',
	        '\u1E8C': 'X',
	        '\u24CE': 'Y',
	        '\uFF39': 'Y',
	        '\u1EF2': 'Y',
	        '\u00DD': 'Y',
	        '\u0176': 'Y',
	        '\u1EF8': 'Y',
	        '\u0232': 'Y',
	        '\u1E8E': 'Y',
	        '\u0178': 'Y',
	        '\u1EF6': 'Y',
	        '\u1EF4': 'Y',
	        '\u01B3': 'Y',
	        '\u024E': 'Y',
	        '\u1EFE': 'Y',
	        '\u24CF': 'Z',
	        '\uFF3A': 'Z',
	        '\u0179': 'Z',
	        '\u1E90': 'Z',
	        '\u017B': 'Z',
	        '\u017D': 'Z',
	        '\u1E92': 'Z',
	        '\u1E94': 'Z',
	        '\u01B5': 'Z',
	        '\u0224': 'Z',
	        '\u2C7F': 'Z',
	        '\u2C6B': 'Z',
	        '\uA762': 'Z',
	        '\u24D0': 'a',
	        '\uFF41': 'a',
	        '\u1E9A': 'a',
	        '\u00E0': 'a',
	        '\u00E1': 'a',
	        '\u00E2': 'a',
	        '\u1EA7': 'a',
	        '\u1EA5': 'a',
	        '\u1EAB': 'a',
	        '\u1EA9': 'a',
	        '\u00E3': 'a',
	        '\u0101': 'a',
	        '\u0103': 'a',
	        '\u1EB1': 'a',
	        '\u1EAF': 'a',
	        '\u1EB5': 'a',
	        '\u1EB3': 'a',
	        '\u0227': 'a',
	        '\u01E1': 'a',
	        '\u00E4': 'a',
	        '\u01DF': 'a',
	        '\u1EA3': 'a',
	        '\u00E5': 'a',
	        '\u01FB': 'a',
	        '\u01CE': 'a',
	        '\u0201': 'a',
	        '\u0203': 'a',
	        '\u1EA1': 'a',
	        '\u1EAD': 'a',
	        '\u1EB7': 'a',
	        '\u1E01': 'a',
	        '\u0105': 'a',
	        '\u2C65': 'a',
	        '\u0250': 'a',
	        '\uA733': 'aa',
	        '\u00E6': 'ae',
	        '\u01FD': 'ae',
	        '\u01E3': 'ae',
	        '\uA735': 'ao',
	        '\uA737': 'au',
	        '\uA739': 'av',
	        '\uA73B': 'av',
	        '\uA73D': 'ay',
	        '\u24D1': 'b',
	        '\uFF42': 'b',
	        '\u1E03': 'b',
	        '\u1E05': 'b',
	        '\u1E07': 'b',
	        '\u0180': 'b',
	        '\u0183': 'b',
	        '\u0253': 'b',
	        '\u24D2': 'c',
	        '\uFF43': 'c',
	        '\u0107': 'c',
	        '\u0109': 'c',
	        '\u010B': 'c',
	        '\u010D': 'c',
	        '\u00E7': 'c',
	        '\u1E09': 'c',
	        '\u0188': 'c',
	        '\u023C': 'c',
	        '\uA73F': 'c',
	        '\u2184': 'c',
	        '\u24D3': 'd',
	        '\uFF44': 'd',
	        '\u1E0B': 'd',
	        '\u010F': 'd',
	        '\u1E0D': 'd',
	        '\u1E11': 'd',
	        '\u1E13': 'd',
	        '\u1E0F': 'd',
	        '\u0111': 'd',
	        '\u018C': 'd',
	        '\u0256': 'd',
	        '\u0257': 'd',
	        '\uA77A': 'd',
	        '\u01F3': 'dz',
	        '\u01C6': 'dz',
	        '\u24D4': 'e',
	        '\uFF45': 'e',
	        '\u00E8': 'e',
	        '\u00E9': 'e',
	        '\u00EA': 'e',
	        '\u1EC1': 'e',
	        '\u1EBF': 'e',
	        '\u1EC5': 'e',
	        '\u1EC3': 'e',
	        '\u1EBD': 'e',
	        '\u0113': 'e',
	        '\u1E15': 'e',
	        '\u1E17': 'e',
	        '\u0115': 'e',
	        '\u0117': 'e',
	        '\u00EB': 'e',
	        '\u1EBB': 'e',
	        '\u011B': 'e',
	        '\u0205': 'e',
	        '\u0207': 'e',
	        '\u1EB9': 'e',
	        '\u1EC7': 'e',
	        '\u0229': 'e',
	        '\u1E1D': 'e',
	        '\u0119': 'e',
	        '\u1E19': 'e',
	        '\u1E1B': 'e',
	        '\u0247': 'e',
	        '\u025B': 'e',
	        '\u01DD': 'e',
	        '\u24D5': 'f',
	        '\uFF46': 'f',
	        '\u1E1F': 'f',
	        '\u0192': 'f',
	        '\uA77C': 'f',
	        '\u24D6': 'g',
	        '\uFF47': 'g',
	        '\u01F5': 'g',
	        '\u011D': 'g',
	        '\u1E21': 'g',
	        '\u011F': 'g',
	        '\u0121': 'g',
	        '\u01E7': 'g',
	        '\u0123': 'g',
	        '\u01E5': 'g',
	        '\u0260': 'g',
	        '\uA7A1': 'g',
	        '\u1D79': 'g',
	        '\uA77F': 'g',
	        '\u24D7': 'h',
	        '\uFF48': 'h',
	        '\u0125': 'h',
	        '\u1E23': 'h',
	        '\u1E27': 'h',
	        '\u021F': 'h',
	        '\u1E25': 'h',
	        '\u1E29': 'h',
	        '\u1E2B': 'h',
	        '\u1E96': 'h',
	        '\u0127': 'h',
	        '\u2C68': 'h',
	        '\u2C76': 'h',
	        '\u0265': 'h',
	        '\u0195': 'hv',
	        '\u24D8': 'i',
	        '\uFF49': 'i',
	        '\u00EC': 'i',
	        '\u00ED': 'i',
	        '\u00EE': 'i',
	        '\u0129': 'i',
	        '\u012B': 'i',
	        '\u012D': 'i',
	        '\u00EF': 'i',
	        '\u1E2F': 'i',
	        '\u1EC9': 'i',
	        '\u01D0': 'i',
	        '\u0209': 'i',
	        '\u020B': 'i',
	        '\u1ECB': 'i',
	        '\u012F': 'i',
	        '\u1E2D': 'i',
	        '\u0268': 'i',
	        '\u0131': 'i',
	        '\u24D9': 'j',
	        '\uFF4A': 'j',
	        '\u0135': 'j',
	        '\u01F0': 'j',
	        '\u0249': 'j',
	        '\u24DA': 'k',
	        '\uFF4B': 'k',
	        '\u1E31': 'k',
	        '\u01E9': 'k',
	        '\u1E33': 'k',
	        '\u0137': 'k',
	        '\u1E35': 'k',
	        '\u0199': 'k',
	        '\u2C6A': 'k',
	        '\uA741': 'k',
	        '\uA743': 'k',
	        '\uA745': 'k',
	        '\uA7A3': 'k',
	        '\u24DB': 'l',
	        '\uFF4C': 'l',
	        '\u0140': 'l',
	        '\u013A': 'l',
	        '\u013E': 'l',
	        '\u1E37': 'l',
	        '\u1E39': 'l',
	        '\u013C': 'l',
	        '\u1E3D': 'l',
	        '\u1E3B': 'l',
	        '\u017F': 'l',
	        '\u0142': 'l',
	        '\u019A': 'l',
	        '\u026B': 'l',
	        '\u2C61': 'l',
	        '\uA749': 'l',
	        '\uA781': 'l',
	        '\uA747': 'l',
	        '\u01C9': 'lj',
	        '\u24DC': 'm',
	        '\uFF4D': 'm',
	        '\u1E3F': 'm',
	        '\u1E41': 'm',
	        '\u1E43': 'm',
	        '\u0271': 'm',
	        '\u026F': 'm',
	        '\u24DD': 'n',
	        '\uFF4E': 'n',
	        '\u01F9': 'n',
	        '\u0144': 'n',
	        '\u00F1': 'n',
	        '\u1E45': 'n',
	        '\u0148': 'n',
	        '\u1E47': 'n',
	        '\u0146': 'n',
	        '\u1E4B': 'n',
	        '\u1E49': 'n',
	        '\u019E': 'n',
	        '\u0272': 'n',
	        '\u0149': 'n',
	        '\uA791': 'n',
	        '\uA7A5': 'n',
	        '\u01CC': 'nj',
	        '\u24DE': 'o',
	        '\uFF4F': 'o',
	        '\u00F2': 'o',
	        '\u00F3': 'o',
	        '\u00F4': 'o',
	        '\u1ED3': 'o',
	        '\u1ED1': 'o',
	        '\u1ED7': 'o',
	        '\u1ED5': 'o',
	        '\u00F5': 'o',
	        '\u1E4D': 'o',
	        '\u022D': 'o',
	        '\u1E4F': 'o',
	        '\u014D': 'o',
	        '\u1E51': 'o',
	        '\u1E53': 'o',
	        '\u014F': 'o',
	        '\u022F': 'o',
	        '\u0231': 'o',
	        '\u00F6': 'o',
	        '\u022B': 'o',
	        '\u1ECF': 'o',
	        '\u0151': 'o',
	        '\u01D2': 'o',
	        '\u020D': 'o',
	        '\u020F': 'o',
	        '\u01A1': 'o',
	        '\u1EDD': 'o',
	        '\u1EDB': 'o',
	        '\u1EE1': 'o',
	        '\u1EDF': 'o',
	        '\u1EE3': 'o',
	        '\u1ECD': 'o',
	        '\u1ED9': 'o',
	        '\u01EB': 'o',
	        '\u01ED': 'o',
	        '\u00F8': 'o',
	        '\u01FF': 'o',
	        '\u0254': 'o',
	        '\uA74B': 'o',
	        '\uA74D': 'o',
	        '\u0275': 'o',
	        '\u01A3': 'oi',
	        '\u0223': 'ou',
	        '\uA74F': 'oo',
	        '\u24DF': 'p',
	        '\uFF50': 'p',
	        '\u1E55': 'p',
	        '\u1E57': 'p',
	        '\u01A5': 'p',
	        '\u1D7D': 'p',
	        '\uA751': 'p',
	        '\uA753': 'p',
	        '\uA755': 'p',
	        '\u24E0': 'q',
	        '\uFF51': 'q',
	        '\u024B': 'q',
	        '\uA757': 'q',
	        '\uA759': 'q',
	        '\u24E1': 'r',
	        '\uFF52': 'r',
	        '\u0155': 'r',
	        '\u1E59': 'r',
	        '\u0159': 'r',
	        '\u0211': 'r',
	        '\u0213': 'r',
	        '\u1E5B': 'r',
	        '\u1E5D': 'r',
	        '\u0157': 'r',
	        '\u1E5F': 'r',
	        '\u024D': 'r',
	        '\u027D': 'r',
	        '\uA75B': 'r',
	        '\uA7A7': 'r',
	        '\uA783': 'r',
	        '\u24E2': 's',
	        '\uFF53': 's',
	        '\u00DF': 's',
	        '\u015B': 's',
	        '\u1E65': 's',
	        '\u015D': 's',
	        '\u1E61': 's',
	        '\u0161': 's',
	        '\u1E67': 's',
	        '\u1E63': 's',
	        '\u1E69': 's',
	        '\u0219': 's',
	        '\u015F': 's',
	        '\u023F': 's',
	        '\uA7A9': 's',
	        '\uA785': 's',
	        '\u1E9B': 's',
	        '\u24E3': 't',
	        '\uFF54': 't',
	        '\u1E6B': 't',
	        '\u1E97': 't',
	        '\u0165': 't',
	        '\u1E6D': 't',
	        '\u021B': 't',
	        '\u0163': 't',
	        '\u1E71': 't',
	        '\u1E6F': 't',
	        '\u0167': 't',
	        '\u01AD': 't',
	        '\u0288': 't',
	        '\u2C66': 't',
	        '\uA787': 't',
	        '\uA729': 'tz',
	        '\u24E4': 'u',
	        '\uFF55': 'u',
	        '\u00F9': 'u',
	        '\u00FA': 'u',
	        '\u00FB': 'u',
	        '\u0169': 'u',
	        '\u1E79': 'u',
	        '\u016B': 'u',
	        '\u1E7B': 'u',
	        '\u016D': 'u',
	        '\u00FC': 'u',
	        '\u01DC': 'u',
	        '\u01D8': 'u',
	        '\u01D6': 'u',
	        '\u01DA': 'u',
	        '\u1EE7': 'u',
	        '\u016F': 'u',
	        '\u0171': 'u',
	        '\u01D4': 'u',
	        '\u0215': 'u',
	        '\u0217': 'u',
	        '\u01B0': 'u',
	        '\u1EEB': 'u',
	        '\u1EE9': 'u',
	        '\u1EEF': 'u',
	        '\u1EED': 'u',
	        '\u1EF1': 'u',
	        '\u1EE5': 'u',
	        '\u1E73': 'u',
	        '\u0173': 'u',
	        '\u1E77': 'u',
	        '\u1E75': 'u',
	        '\u0289': 'u',
	        '\u24E5': 'v',
	        '\uFF56': 'v',
	        '\u1E7D': 'v',
	        '\u1E7F': 'v',
	        '\u028B': 'v',
	        '\uA75F': 'v',
	        '\u028C': 'v',
	        '\uA761': 'vy',
	        '\u24E6': 'w',
	        '\uFF57': 'w',
	        '\u1E81': 'w',
	        '\u1E83': 'w',
	        '\u0175': 'w',
	        '\u1E87': 'w',
	        '\u1E85': 'w',
	        '\u1E98': 'w',
	        '\u1E89': 'w',
	        '\u2C73': 'w',
	        '\u24E7': 'x',
	        '\uFF58': 'x',
	        '\u1E8B': 'x',
	        '\u1E8D': 'x',
	        '\u24E8': 'y',
	        '\uFF59': 'y',
	        '\u1EF3': 'y',
	        '\u00FD': 'y',
	        '\u0177': 'y',
	        '\u1EF9': 'y',
	        '\u0233': 'y',
	        '\u1E8F': 'y',
	        '\u00FF': 'y',
	        '\u1EF7': 'y',
	        '\u1E99': 'y',
	        '\u1EF5': 'y',
	        '\u01B4': 'y',
	        '\u024F': 'y',
	        '\u1EFF': 'y',
	        '\u24E9': 'z',
	        '\uFF5A': 'z',
	        '\u017A': 'z',
	        '\u1E91': 'z',
	        '\u017C': 'z',
	        '\u017E': 'z',
	        '\u1E93': 'z',
	        '\u1E95': 'z',
	        '\u01B6': 'z',
	        '\u0225': 'z',
	        '\u0240': 'z',
	        '\u2C6C': 'z',
	        '\uA763': 'z',
	        '\u0386': '\u0391',
	        '\u0388': '\u0395',
	        '\u0389': '\u0397',
	        '\u038A': '\u0399',
	        '\u03AA': '\u0399',
	        '\u038C': '\u039F',
	        '\u038E': '\u03A5',
	        '\u03AB': '\u03A5',
	        '\u038F': '\u03A9',
	        '\u03AC': '\u03B1',
	        '\u03AD': '\u03B5',
	        '\u03AE': '\u03B7',
	        '\u03AF': '\u03B9',
	        '\u03CA': '\u03B9',
	        '\u0390': '\u03B9',
	        '\u03CC': '\u03BF',
	        '\u03CD': '\u03C5',
	        '\u03CB': '\u03C5',
	        '\u03B0': '\u03C5',
	        '\u03C9': '\u03C9',
	        '\u03C2': '\u03C3'
	    };
	    DataUtil.fnOperators = {
	        /**
	         * Returns true when the actual input is equal to the given input.
	         *
	         * @param {string|number|boolean} actual
	         * @param {string|number|boolean} expected
	         * @param {boolean} ignoreCase?
	         * @param {boolean} ignoreAccent?
	         * @param ignoreCase
	         * @param ignoreAccent
	         */
	        equal: function (actual, expected, ignoreCase, ignoreAccent) {
	            if (ignoreAccent) {
	                actual = DataUtil.ignoreDiacritics(actual);
	                expected = DataUtil.ignoreDiacritics(expected);
	            }
	            if (ignoreCase) {
	                return DataUtil.toLowerCase(actual) === DataUtil.toLowerCase(expected);
	            }
	            return actual === expected;
	        },
	        /**
	         * Returns true when the actual input is not equal to the given input.
	         *
	         * @param {string|number|boolean} actual
	         * @param {string|number|boolean} expected
	         * @param {boolean} ignoreCase?
	         * @param ignoreCase
	         * @param ignoreAccent
	         */
	        notequal: function (actual, expected, ignoreCase, ignoreAccent) {
	            if (ignoreAccent) {
	                actual = DataUtil.ignoreDiacritics(actual);
	                expected = DataUtil.ignoreDiacritics(expected);
	            }
	            return !DataUtil.fnOperators.equal(actual, expected, ignoreCase);
	        },
	        /**
	         * Returns true when the actual input is less than to the given input.
	         *
	         * @param {string|number|boolean} actual
	         * @param {string|number|boolean} expected
	         * @param {boolean} ignoreCase?
	         * @param ignoreCase
	         */
	        lessthan: function (actual, expected, ignoreCase) {
	            if (ignoreCase) {
	                return DataUtil.toLowerCase(actual) < DataUtil.toLowerCase(expected);
	            }
	            if (isNullOrUndefined(actual)) {
	                actual = undefined;
	            }
	            return actual < expected;
	        },
	        /**
	         * Returns true when the actual input is greater than to the given input.
	         *
	         * @param {string|number|boolean} actual
	         * @param {string|number|boolean} expected
	         * @param {boolean} ignoreCase?
	         * @param ignoreCase
	         */
	        greaterthan: function (actual, expected, ignoreCase) {
	            if (ignoreCase) {
	                return DataUtil.toLowerCase(actual) > DataUtil.toLowerCase(expected);
	            }
	            return actual > expected;
	        },
	        /**
	         * Returns true when the actual input is less than or equal to the given input.
	         *
	         * @param {string|number|boolean} actual
	         * @param {string|number|boolean} expected
	         * @param {boolean} ignoreCase?
	         * @param ignoreCase
	         */
	        lessthanorequal: function (actual, expected, ignoreCase) {
	            if (ignoreCase) {
	                return DataUtil.toLowerCase(actual) <= DataUtil.toLowerCase(expected);
	            }
	            if (isNullOrUndefined(actual)) {
	                actual = undefined;
	            }
	            return actual <= expected;
	        },
	        /**
	         * Returns true when the actual input is greater than or equal to the given input.
	         *
	         * @param {string|number|boolean} actual
	         * @param {string|number|boolean} expected
	         * @param {boolean} ignoreCase?
	         * @param ignoreCase
	         */
	        greaterthanorequal: function (actual, expected, ignoreCase) {
	            if (ignoreCase) {
	                return DataUtil.toLowerCase(actual) >= DataUtil.toLowerCase(expected);
	            }
	            return actual >= expected;
	        },
	        /**
	         * Returns true when the actual input contains the given string.
	         *
	         * @param {string|number} actual
	         * @param {string|number} expected
	         * @param {boolean} ignoreCase?
	         * @param ignoreCase
	         * @param ignoreAccent
	         */
	        contains: function (actual, expected, ignoreCase, ignoreAccent) {
	            if (ignoreAccent) {
	                actual = DataUtil.ignoreDiacritics(actual);
	                expected = DataUtil.ignoreDiacritics(expected);
	            }
	            if (ignoreCase) {
	                return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) &&
	                    DataUtil.toLowerCase(actual).indexOf(DataUtil.toLowerCase(expected)) !== -1;
	            }
	            return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) &&
	                actual.toString().indexOf(expected) !== -1;
	        },
	        /**
	         * Returns true when the actual input not contains the given string.
	         *
	         * @param  {string|number} actual
	         * @param  {string|number} expected
	         * @param  {boolean} ignoreCase?
	         */
	        doesnotcontain: function (actual, expected, ignoreCase, ignoreAccent) {
	            if (ignoreAccent) {
	                actual = DataUtil.ignoreDiacritics(actual);
	                expected = DataUtil.ignoreDiacritics(expected);
	            }
	            if (ignoreCase) {
	                return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) &&
	                    DataUtil.toLowerCase(actual).indexOf(DataUtil.toLowerCase(expected)) === -1;
	            }
	            return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) &&
	                actual.toString().indexOf(expected) === -1;
	        },
	        /**
	         * Returns true when the given input value is not null.
	         *
	         * @param  {string|number} actual
	         * @returns boolean
	         */
	        isnotnull: function (actual) {
	            return actual !== null && actual !== undefined;
	        },
	        /**
	         * Returns true when the given input value is null.
	         *
	         * @param  {string|number} actual
	         * @returns boolean
	         */
	        isnull: function (actual) {
	            return actual === null || actual === undefined;
	        },
	        /**
	         * Returns true when the actual input starts with the given string
	         *
	         * @param {string} actual
	         * @param {string} expected
	         * @param {boolean} ignoreCase?
	         * @param ignoreCase
	         * @param ignoreAccent
	         */
	        startswith: function (actual, expected, ignoreCase, ignoreAccent) {
	            if (ignoreAccent) {
	                actual = DataUtil.ignoreDiacritics(actual);
	                expected = DataUtil.ignoreDiacritics(expected);
	            }
	            if (ignoreCase) {
	                return actual && expected && DataUtil.startsWith(DataUtil.toLowerCase(actual), DataUtil.toLowerCase(expected));
	            }
	            return actual && expected && DataUtil.startsWith(actual, expected);
	        },
	        /**
	         * Returns true when the actual input not starts with the given string
	         *
	         * @param  {string} actual
	         * @param  {string} expected
	         * @param  {boolean} ignoreCase?
	         */
	        doesnotstartwith: function (actual, expected, ignoreCase, ignoreAccent) {
	            if (ignoreAccent) {
	                actual = DataUtil.ignoreDiacritics(actual);
	                expected = DataUtil.ignoreDiacritics(expected);
	            }
	            if (ignoreCase) {
	                return actual && expected && DataUtil.notStartsWith(DataUtil.toLowerCase(actual), DataUtil.toLowerCase(expected));
	            }
	            return actual && expected && DataUtil.notStartsWith(actual, expected);
	        },
	        /**
	         * Returns true when the actual input like with the given string.
	         *
	         * @param  {string} actual
	         * @param  {string} expected
	         * @param  {boolean} ignoreCase?
	         */
	        like: function (actual, expected, ignoreCase, ignoreAccent) {
	            if (ignoreAccent) {
	                actual = DataUtil.ignoreDiacritics(actual);
	                expected = DataUtil.ignoreDiacritics(expected);
	            }
	            if (ignoreCase) {
	                return actual && expected && DataUtil.like(DataUtil.toLowerCase(actual), DataUtil.toLowerCase(expected));
	            }
	            return actual && expected && DataUtil.like(actual, expected);
	        },
	        /**
	         * Returns true when the given input value is empty.
	         *
	         * @param  {string|number} actual
	         * @returns boolean
	         */
	        isempty: function (actual) {
	            return actual === undefined || actual === '';
	        },
	        /**
	         * Returns true when the given input value is not empty.
	         *
	         * @param  {string|number} actual
	         * @returns boolean
	         */
	        isnotempty: function (actual) {
	            return actual !== undefined && actual !== '';
	        },
	        /**
	         * Returns true when the actual input pattern(wildcard) matches with the given string.
	         *
	         * @param  {string|Date} actual
	         * @param  {string} expected
	         * @param  {boolean} ignoreCase?
	         */
	        wildcard: function (actual, expected, ignoreCase, ignoreAccent) {
	            if (ignoreAccent) {
	                actual = DataUtil.ignoreDiacritics(actual);
	                expected = DataUtil.ignoreDiacritics(expected);
	            }
	            if (ignoreCase) {
	                return (actual || typeof actual === 'boolean') && expected && typeof actual !== 'object' &&
	                    DataUtil.wildCard(DataUtil.toLowerCase(actual), DataUtil.toLowerCase(expected));
	            }
	            return (actual || typeof actual === 'boolean') && expected && DataUtil.wildCard(actual, expected);
	        },
	        /**
	         * Returns true when the actual input ends with the given string.
	         *
	         * @param {string} actual
	         * @param {string} expected
	         * @param {boolean} ignoreCase?
	         * @param ignoreCase
	         * @param ignoreAccent
	         */
	        endswith: function (actual, expected, ignoreCase, ignoreAccent) {
	            if (ignoreAccent) {
	                actual = DataUtil.ignoreDiacritics(actual);
	                expected = DataUtil.ignoreDiacritics(expected);
	            }
	            if (ignoreCase) {
	                return actual && expected && DataUtil.endsWith(DataUtil.toLowerCase(actual), DataUtil.toLowerCase(expected));
	            }
	            return actual && expected && DataUtil.endsWith(actual, expected);
	        },
	        /**
	         * Returns true when the actual input not ends with the given string.
	         *
	         * @param  {string} actual
	         * @param  {string} expected
	         * @param  {boolean} ignoreCase?
	         */
	        doesnotendwith: function (actual, expected, ignoreCase, ignoreAccent) {
	            if (ignoreAccent) {
	                actual = DataUtil.ignoreDiacritics(actual);
	                expected = DataUtil.ignoreDiacritics(expected);
	            }
	            if (ignoreCase) {
	                return actual && expected && DataUtil.notEndsWith(DataUtil.toLowerCase(actual), DataUtil.toLowerCase(expected));
	            }
	            return actual && expected && DataUtil.notEndsWith(actual, expected);
	        },
	        /**
	         * It will return the filter operator based on the filter symbol.
	         *
	         * @param  {string} operator
	         * @hidden
	         */
	        processSymbols: function (operator) {
	            var fnName = DataUtil.operatorSymbols[operator];
	            if (fnName) {
	                var fn = DataUtil.fnOperators[fnName];
	                return fn;
	            }
	            return DataUtil.throwError('Query - Process Operator : Invalid operator');
	        },
	        /**
	         * It will return the valid filter operator based on the specified operators.
	         *
	         * @param  {string} operator
	         * @hidden
	         */
	        processOperator: function (operator) {
	            var fn = DataUtil.fnOperators[operator];
	            if (fn) {
	                return fn;
	            }
	            return DataUtil.fnOperators.processSymbols(operator);
	        }
	    };
	    /**
	     * To perform the parse operation on JSON data, like convert to string from JSON or convert to JSON from string.
	     */
	    DataUtil.parse = {
	        /**
	         * Parse the given string to the plain JavaScript object.
	         *
	         * @param  {string|Object|Object[]} jsonText
	         */
	        parseJson: function (jsonText) {
	            if (typeof jsonText === 'string') {
	                jsonText = JSON.parse(jsonText, DataUtil.parse.jsonReviver);
	            }
	            else if (jsonText instanceof Array) {
	                DataUtil.parse.iterateAndReviveArray(jsonText);
	            }
	            else if (typeof jsonText === 'object' && jsonText !== null) {
	                DataUtil.parse.iterateAndReviveJson(jsonText);
	            }
	            return jsonText;
	        },
	        /**
	         * It will perform on array of values.
	         *
	         * @param  {string[]|Object[]} array
	         * @hidden
	         */
	        iterateAndReviveArray: function (array) {
	            for (var i = 0; i < array.length; i++) {
	                if (typeof array[i] === 'object' && array[i] !== null) {
	                    DataUtil.parse.iterateAndReviveJson(array[i]);
	                    // eslint-disable-next-line no-useless-escape
	                }
	                else if (typeof array[i] === 'string' && !/^[\s]*\[|^[\s]*\{(.)+:|\"/g.test(array[i])) {
	                    array[i] = DataUtil.parse.jsonReviver('', array[i]);
	                }
	                else {
	                    array[i] = DataUtil.parse.parseJson(array[i]);
	                }
	            }
	        },
	        /**
	         * It will perform on JSON values
	         *
	         * @param  {JSON} json
	         * @hidden
	         */
	        iterateAndReviveJson: function (json) {
	            var value;
	            var keys = Object.keys(json);
	            for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
	                var prop = keys_2[_i];
	                if (DataUtil.startsWith(prop, '__')) {
	                    continue;
	                }
	                value = json[prop];
	                if (typeof value === 'object') {
	                    if (value instanceof Array) {
	                        DataUtil.parse.iterateAndReviveArray(value);
	                    }
	                    else if (value) {
	                        DataUtil.parse.iterateAndReviveJson(value);
	                    }
	                }
	                else {
	                    json[prop] = DataUtil.parse.jsonReviver(json[prop], value);
	                }
	            }
	        },
	        /**
	         * It will perform on JSON values
	         *
	         * @param  {string} field
	         * @param  {string|Date} value
	         * @hidden
	         */
	        jsonReviver: function (field, value) {
	            if (typeof value === 'string') {
	                // eslint-disable-next-line security/detect-unsafe-regex
	                var ms = /^\/Date\(([+-]?[0-9]+)([+-][0-9]{4})?\)\/$/.exec(value);
	                var offSet = DataUtil.timeZoneHandling ? DataUtil.serverTimezoneOffset : null;
	                if (ms) {
	                    return DataUtil.dateParse.toTimeZone(new Date(parseInt(ms[1], 10)), offSet, true);
	                    // eslint-disable-next-line no-useless-escape, security/detect-unsafe-regex
	                }
	                else if (/^(\d{4}\-\d\d\-\d\d([tT][\d:\.]*){1})([zZ]|([+\-])(\d\d):?(\d\d))?$/.test(value)) {
	                    var isUTC = value.indexOf('Z') > -1 || value.indexOf('z') > -1;
	                    var arr = value.split(/[^0-9.]/);
	                    if (isUTC) {
	                        if (arr[5].indexOf('.') > -1) {
	                            var secondsMs = arr[5].split('.');
	                            arr[5] = secondsMs[0];
	                            arr[6] = new Date(value).getUTCMilliseconds().toString();
	                        }
	                        else {
	                            arr[6] = '00';
	                        }
	                        value = DataUtil.dateParse
	                            .toTimeZone(new Date(parseInt(arr[0], 10), parseInt(arr[1], 10) - 1, parseInt(arr[2], 10), parseInt(arr[3], 10), parseInt(arr[4], 10), parseInt(arr[5] ? arr[5] : '00', 10), parseInt(arr[6], 10)), DataUtil.serverTimezoneOffset, false);
	                    }
	                    else {
	                        var utcFormat = new Date(parseInt(arr[0], 10), parseInt(arr[1], 10) - 1, parseInt(arr[2], 10), parseInt(arr[3], 10), parseInt(arr[4], 10), parseInt(arr[5] ? arr[5] : '00', 10));
	                        var hrs = parseInt(arr[6], 10);
	                        var mins = parseInt(arr[7], 10);
	                        if (isNaN(hrs) && isNaN(mins)) {
	                            return utcFormat;
	                        }
	                        if (value.indexOf('+') > -1) {
	                            utcFormat.setHours(utcFormat.getHours() - hrs, utcFormat.getMinutes() - mins);
	                        }
	                        else {
	                            utcFormat.setHours(utcFormat.getHours() + hrs, utcFormat.getMinutes() + mins);
	                        }
	                        value = DataUtil.dateParse
	                            .toTimeZone(utcFormat, DataUtil.serverTimezoneOffset, false);
	                    }
	                    if (DataUtil.serverTimezoneOffset == null) {
	                        value = DataUtil.dateParse.addSelfOffset(value);
	                    }
	                }
	                else if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
	                    var arr = value.split(/[^0-9.]/);
	                    return new Date(parseInt(arr[0], 10), parseInt(arr[1], 10) - 1, parseInt(arr[2], 10));
	                }
	            }
	            return value;
	        },
	        /**
	         * Check wheather the given value is JSON or not.
	         *
	         * @param  {Object[]} jsonData
	         */
	        isJson: function (jsonData) {
	            if (typeof jsonData[0] === 'string') {
	                return jsonData;
	            }
	            return DataUtil.parse.parseJson(jsonData);
	        },
	        /**
	         * Checks wheather the given value is GUID or not.
	         *
	         * @param  {string} value
	         */
	        isGuid: function (value) {
	            // eslint-disable-next-line security/detect-unsafe-regex
	            var regex = /[A-Fa-f0-9]{8}(?:-[A-Fa-f0-9]{4}){3}-[A-Fa-f0-9]{12}/i;
	            var match = regex.exec(value);
	            return match != null;
	        },
	        /**
	         * The method used to replace the value based on the type.
	         *
	         * @param  {Object} value
	         * @param  {boolean} stringify
	         * @hidden
	         */
	        replacer: function (value, stringify) {
	            if (DataUtil.isPlainObject(value)) {
	                return DataUtil.parse.jsonReplacer(value, stringify);
	            }
	            if (value instanceof Array) {
	                return DataUtil.parse.arrayReplacer(value);
	            }
	            if (value instanceof Date) {
	                return DataUtil.parse.jsonReplacer({ val: value }, stringify).val;
	            }
	            return value;
	        },
	        /**
	         * It will replace the JSON value.
	         *
	         * @param {string} key
	         * @param {Object} val
	         * @param stringify
	         * @hidden
	         */
	        jsonReplacer: function (val, stringify) {
	            var value;
	            var keys = Object.keys(val);
	            for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {
	                var prop = keys_3[_i];
	                value = val[prop];
	                if (!(value instanceof Date)) {
	                    continue;
	                }
	                var d = value;
	                if (DataUtil.serverTimezoneOffset == null) {
	                    val[prop] = DataUtil.dateParse.toTimeZone(d, null).toJSON();
	                }
	                else {
	                    d = new Date(+d + DataUtil.serverTimezoneOffset * 3600000);
	                    val[prop] = DataUtil.dateParse.toTimeZone(DataUtil.dateParse.addSelfOffset(d), null).toJSON();
	                }
	            }
	            return val;
	        },
	        /**
	         * It will replace the Array of value.
	         *
	         * @param  {string} key
	         * @param  {Object[]} val
	         * @hidden
	         */
	        arrayReplacer: function (val) {
	            for (var i = 0; i < val.length; i++) {
	                if (DataUtil.isPlainObject(val[i])) {
	                    val[i] = DataUtil.parse.jsonReplacer(val[i]);
	                }
	                else if (val[i] instanceof Date) {
	                    val[i] = DataUtil.parse.jsonReplacer({ date: val[i] }).date;
	                }
	            }
	            return val;
	        },
	        /**
	         * It will replace the Date object with respective to UTC format value.
	         *
	         * @param  {string} key
	         * @param  {any} value
	         * @hidden
	         */
	        /* eslint-disable @typescript-eslint/no-explicit-any */
	        /* tslint:disable-next-line:no-any */
	        jsonDateReplacer: function (key, value) {
	            /* eslint-enable @typescript-eslint/no-explicit-any */
	            if (key === 'value' && value) {
	                if (typeof value === 'string') {
	                    // eslint-disable-next-line security/detect-unsafe-regex
	                    var ms = /^\/Date\(([+-]?[0-9]+)([+-][0-9]{4})?\)\/$/.exec(value);
	                    if (ms) {
	                        value = DataUtil.dateParse.toTimeZone(new Date(parseInt(ms[1], 10)), null, true);
	                        // eslint-disable-next-line no-useless-escape, security/detect-unsafe-regex
	                    }
	                    else if (/^(\d{4}\-\d\d\-\d\d([tT][\d:\.]*){1})([zZ]|([+\-])(\d\d):?(\d\d))?$/.test(value)) {
	                        var arr = value.split(/[^0-9]/);
	                        value = DataUtil.dateParse
	                            .toTimeZone(new Date(parseInt(arr[0], 10), parseInt(arr[1], 10) - 1, parseInt(arr[2], 10), parseInt(arr[3], 10), parseInt(arr[4], 10), parseInt(arr[5], 10)), null, true);
	                    }
	                }
	                if (value instanceof Date) {
	                    value = DataUtil.dateParse.addSelfOffset(value);
	                    if (DataUtil.serverTimezoneOffset === null) {
	                        return DataUtil.dateParse.toTimeZone(DataUtil.dateParse.addSelfOffset(value), null).toJSON();
	                    }
	                    else {
	                        value = DataUtil.dateParse.toTimeZone(value, (((value.getTimezoneOffset() / 60) * 2)
	                            - DataUtil.serverTimezoneOffset), false);
	                        return value.toJSON();
	                    }
	                }
	            }
	            return value;
	        }
	    };
	    /**
	     * @hidden
	     */
	    DataUtil.dateParse = {
	        addSelfOffset: function (input) {
	            return new Date(+input - (input.getTimezoneOffset() * 60000));
	        },
	        toUTC: function (input) {
	            return new Date(+input + (input.getTimezoneOffset() * 60000));
	        },
	        toTimeZone: function (input, offset, utc) {
	            if (offset === null) {
	                return input;
	            }
	            var unix = utc ? DataUtil.dateParse.toUTC(input) : input;
	            return new Date(+unix - (offset * 3600000));
	        },
	        toLocalTime: function (input) {
	            var datefn = input;
	            var timeZone = -datefn.getTimezoneOffset();
	            var differenceString = timeZone >= 0 ? '+' : '-';
	            var localtimefn = function (num) {
	                var norm = Math.floor(Math.abs(num));
	                return (norm < 10 ? '0' : '') + norm;
	            };
	            var val = datefn.getFullYear() + '-' + localtimefn(datefn.getMonth() + 1) + '-' + localtimefn(datefn.getDate()) +
	                'T' + localtimefn(datefn.getHours()) +
	                ':' + localtimefn(datefn.getMinutes()) +
	                ':' + localtimefn(datefn.getSeconds()) +
	                differenceString + localtimefn(timeZone / 60) +
	                ':' + localtimefn(timeZone % 60);
	            return val;
	        }
	    };
	    return DataUtil;
	}());

	var __extends$E = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var consts = { GroupGuid: '{271bbba0-1ee7}' };
	/**
	 * Adaptors are specific data source type aware interfaces that are used by DataManager to communicate with DataSource.
	 * This is the base adaptor class that other adaptors can extend.
	 *
	 * @hidden
	 */
	var Adaptor = /** @class */ (function () {
	    /**
	     * Constructor for Adaptor class
	     *
	     * @param {DataOptions} ds?
	     * @param ds
	     * @hidden
	     * @returns aggregates
	     */
	    function Adaptor(ds) {
	        // common options for all the adaptors
	        this.options = {
	            from: 'table',
	            requestType: 'json',
	            sortBy: 'sorted',
	            select: 'select',
	            skip: 'skip',
	            group: 'group',
	            take: 'take',
	            search: 'search',
	            count: 'requiresCounts',
	            where: 'where',
	            aggregates: 'aggregates',
	            expand: 'expand'
	        };
	        /**
	         * Specifies the type of adaptor.
	         *
	         * @default Adaptor
	         */
	        this.type = Adaptor;
	        this.dataSource = ds;
	        this.pvt = {};
	    }
	    /**
	     * Returns the data from the query processing.
	     *
	     * @param {Object} data
	     * @param {DataOptions} ds?
	     * @param {Query} query?
	     * @param {Request} xhr?
	     * @param ds
	     * @param query
	     * @param xhr
	     * @returns Object
	     */
	    Adaptor.prototype.processResponse = function (data, ds, query, xhr) {
	        return data;
	    };
	    return Adaptor;
	}());
	/**
	 * JsonAdaptor is used to process JSON data. It contains methods to process the given JSON data based on the queries.
	 *
	 * @hidden
	 */
	var JsonAdaptor = /** @class */ (function (_super) {
	    __extends$E(JsonAdaptor, _super);
	    function JsonAdaptor() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * Process the JSON data based on the provided queries.
	     *
	     * @param  {DataManager} dataManager
	     * @param  {Query} query
	     * @returns Object
	     */
	    JsonAdaptor.prototype.processQuery = function (dataManager, query) {
	        var result = dataManager.dataSource.json.slice(0);
	        var count = result.length;
	        var countFlg = true;
	        var ret;
	        var key;
	        var lazyLoad = {};
	        var keyCount = 0;
	        var group = [];
	        var page;
	        for (var i = 0; i < query.lazyLoad.length; i++) {
	            keyCount++;
	            lazyLoad[query.lazyLoad[i].key] = query.lazyLoad[i].value;
	        }
	        var agg = {};
	        for (var i = 0; i < query.queries.length; i++) {
	            key = query.queries[i];
	            if ((key.fn === 'onPage' || key.fn === 'onGroup') && query.lazyLoad.length) {
	                if (key.fn === 'onGroup') {
	                    group.push(key.e);
	                }
	                if (key.fn === 'onPage') {
	                    page = key.e;
	                }
	                continue;
	            }
	            ret = this[key.fn].call(this, result, key.e, query);
	            if (key.fn === 'onAggregates') {
	                agg[key.e.field + ' - ' + key.e.type] = ret;
	            }
	            else {
	                result = ret !== undefined ? ret : result;
	            }
	            if (key.fn === 'onPage' || key.fn === 'onSkip' || key.fn === 'onTake' || key.fn === 'onRange') {
	                countFlg = false;
	            }
	            if (countFlg) {
	                count = result.length;
	            }
	        }
	        if (keyCount) {
	            var args = {
	                query: query, lazyLoad: lazyLoad, result: result, group: group, page: page
	            };
	            var lazyLoadData = this.lazyLoadGroup(args);
	            result = lazyLoadData.result;
	            count = lazyLoadData.count;
	        }
	        if (query.isCountRequired) {
	            result = {
	                result: result,
	                count: count,
	                aggregates: agg
	            };
	        }
	        return result;
	    };
	    /**
	     * Perform lazy load grouping in JSON array based on the given query and lazy load details.
	     *
	     * @param  {LazyLoadGroupArgs} args
	     */
	    JsonAdaptor.prototype.lazyLoadGroup = function (args) {
	        var count = 0;
	        var agg = this.getAggregate(args.query);
	        var result = args.result;
	        if (!isNullOrUndefined(args.lazyLoad.onDemandGroupInfo)) {
	            var req = args.lazyLoad.onDemandGroupInfo;
	            for (var i = req.where.length - 1; i >= 0; i--) {
	                result = this.onWhere(result, req.where[i]);
	            }
	            if (args.group.length !== req.level) {
	                var field = args.group[req.level].fieldName;
	                result = DataUtil.group(result, field, agg, null, null, args.group[0].comparer, true);
	            }
	            count = result.length;
	            var data = result;
	            result = result.slice(req.skip);
	            result = result.slice(0, req.take);
	            if (args.group.length !== req.level) {
	                this.formGroupResult(result, data);
	            }
	        }
	        else {
	            var field = args.group[0].fieldName;
	            result = DataUtil.group(result, field, agg, null, null, args.group[0].comparer, true);
	            count = result.length;
	            var data = result;
	            if (args.page) {
	                result = this.onPage(result, args.page, args.query);
	            }
	            this.formGroupResult(result, data);
	        }
	        return { result: result, count: count };
	    };
	    JsonAdaptor.prototype.formGroupResult = function (result, data) {
	        if (result.length && data.length) {
	            var uid = 'GroupGuid';
	            var childLevel = 'childLevels';
	            var level = 'level';
	            var records = 'records';
	            result[uid] = data[uid];
	            result[childLevel] = data[childLevel];
	            result[level] = data[level];
	            result[records] = data[records];
	        }
	        return result;
	    };
	    /**
	     * Separate the aggregate query from the given queries
	     *
	     * @param  {Query} query
	     */
	    JsonAdaptor.prototype.getAggregate = function (query) {
	        var aggQuery = Query.filterQueries(query.queries, 'onAggregates');
	        var agg = [];
	        if (aggQuery.length) {
	            var tmp = void 0;
	            for (var i = 0; i < aggQuery.length; i++) {
	                tmp = aggQuery[i].e;
	                agg.push({ type: tmp.type, field: DataUtil.getValue(tmp.field, query) });
	            }
	        }
	        return agg;
	    };
	    /**
	     * Performs batch update in the JSON array which add, remove and update records.
	     *
	     * @param  {DataManager} dm
	     * @param  {CrudOptions} changes
	     * @param  {RemoteArgs} e
	     */
	    JsonAdaptor.prototype.batchRequest = function (dm, changes, e) {
	        var i;
	        var deletedRecordsLen = changes.deletedRecords.length;
	        for (i = 0; i < changes.addedRecords.length; i++) {
	            this.insert(dm, changes.addedRecords[i]);
	        }
	        for (i = 0; i < changes.changedRecords.length; i++) {
	            this.update(dm, e.key, changes.changedRecords[i]);
	        }
	        for (i = 0; i < deletedRecordsLen; i++) {
	            this.remove(dm, e.key, changes.deletedRecords[i]);
	        }
	        return changes;
	    };
	    /**
	     * Performs filter operation with the given data and where query.
	     *
	     * @param {Object[]} ds
	     * @param {{validate:Function}} e
	     * @param e.validate
	     */
	    JsonAdaptor.prototype.onWhere = function (ds, e) {
	        if (!ds || !ds.length) {
	            return ds;
	        }
	        return ds.filter(function (obj) {
	            if (e) {
	                return e.validate(obj);
	            }
	        });
	    };
	    /**
	     * Returns aggregate function based on the aggregate type.
	     *
	     * @param {Object[]} ds
	     * @param e
	     * @param {string} } type
	     * @param e.field
	     * @param e.type
	     */
	    JsonAdaptor.prototype.onAggregates = function (ds, e) {
	        var fn = DataUtil.aggregates[e.type];
	        if (!ds || !fn || ds.length === 0) {
	            return null;
	        }
	        return fn(ds, e.field);
	    };
	    /**
	     * Performs search operation based on the given query.
	     *
	     * @param  {Object[]} ds
	     * @param  {QueryOptions} e
	     */
	    JsonAdaptor.prototype.onSearch = function (ds, e) {
	        if (!ds || !ds.length) {
	            return ds;
	        }
	        if (e.fieldNames.length === 0) {
	            DataUtil.getFieldList(ds[0], e.fieldNames);
	        }
	        return ds.filter(function (obj) {
	            for (var j = 0; j < e.fieldNames.length; j++) {
	                if (e.comparer.call(obj, DataUtil.getObject(e.fieldNames[j], obj), e.searchKey, e.ignoreCase, e.ignoreAccent)) {
	                    return true;
	                }
	            }
	            return false;
	        });
	    };
	    /**
	     * Sort the data with given direction and field.
	     *
	     * @param {Object[]} ds
	     * @param e
	     * @param {Object} b
	     * @param e.comparer
	     * @param e.fieldName
	     * @param query
	     */
	    JsonAdaptor.prototype.onSortBy = function (ds, e, query) {
	        if (!ds || !ds.length) {
	            return ds;
	        }
	        var fnCompare;
	        var field = DataUtil.getValue(e.fieldName, query);
	        if (!field) {
	            return ds.sort(e.comparer);
	        }
	        if (field instanceof Array) {
	            field = field.slice(0);
	            for (var i = field.length - 1; i >= 0; i--) {
	                if (!field[i]) {
	                    continue;
	                }
	                fnCompare = e.comparer;
	                if (DataUtil.endsWith(field[i], ' desc')) {
	                    fnCompare = DataUtil.fnSort('descending');
	                    field[i] = field[i].replace(' desc', '');
	                }
	                ds = DataUtil.sort(ds, field[i], fnCompare);
	            }
	            return ds;
	        }
	        return DataUtil.sort(ds, field, e.comparer);
	    };
	    /**
	     * Group the data based on the given query.
	     *
	     * @param  {Object[]} ds
	     * @param  {QueryOptions} e
	     * @param  {Query} query
	     */
	    JsonAdaptor.prototype.onGroup = function (ds, e, query) {
	        if (!ds || !ds.length) {
	            return ds;
	        }
	        var agg = this.getAggregate(query);
	        return DataUtil.group(ds, DataUtil.getValue(e.fieldName, query), agg, null, null, e.comparer);
	    };
	    /**
	     * Retrieves records based on the given page index and size.
	     *
	     * @param {Object[]} ds
	     * @param e
	     * @param {number} } pageIndex
	     * @param e.pageSize
	     * @param {Query} query
	     * @param e.pageIndex
	     */
	    JsonAdaptor.prototype.onPage = function (ds, e, query) {
	        var size = DataUtil.getValue(e.pageSize, query);
	        var start = (DataUtil.getValue(e.pageIndex, query) - 1) * size;
	        var end = start + size;
	        if (!ds || !ds.length) {
	            return ds;
	        }
	        return ds.slice(start, end);
	    };
	    /**
	     * Retrieves records based on the given start and end index from query.
	     *
	     * @param {Object[]} ds
	     * @param e
	     * @param {number} } end
	     * @param e.start
	     * @param e.end
	     */
	    JsonAdaptor.prototype.onRange = function (ds, e) {
	        if (!ds || !ds.length) {
	            return ds;
	        }
	        return ds.slice(DataUtil.getValue(e.start), DataUtil.getValue(e.end));
	    };
	    /**
	     * Picks the given count of records from the top of the datasource.
	     *
	     * @param {Object[]} ds
	     * @param {{nos:number}} e
	     * @param e.nos
	     */
	    JsonAdaptor.prototype.onTake = function (ds, e) {
	        if (!ds || !ds.length) {
	            return ds;
	        }
	        return ds.slice(0, DataUtil.getValue(e.nos));
	    };
	    /**
	     * Skips the given count of records from the data source.
	     *
	     * @param {Object[]} ds
	     * @param {{nos:number}} e
	     * @param e.nos
	     */
	    JsonAdaptor.prototype.onSkip = function (ds, e) {
	        if (!ds || !ds.length) {
	            return ds;
	        }
	        return ds.slice(DataUtil.getValue(e.nos));
	    };
	    /**
	     * Selects specified columns from the data source.
	     *
	     * @param {Object[]} ds
	     * @param {{fieldNames:string}} e
	     * @param e.fieldNames
	     */
	    JsonAdaptor.prototype.onSelect = function (ds, e) {
	        if (!ds || !ds.length) {
	            return ds;
	        }
	        return DataUtil.select(ds, DataUtil.getValue(e.fieldNames));
	    };
	    /**
	     * Inserts new record in the table.
	     *
	     * @param {DataManager} dm
	     * @param {Object} data
	     * @param tableName
	     * @param query
	     * @param {number} position
	     */
	    JsonAdaptor.prototype.insert = function (dm, data, tableName, query, position) {
	        if (isNullOrUndefined(position)) {
	            return dm.dataSource.json.push(data);
	        }
	        else {
	            return dm.dataSource.json.splice(position, 0, data);
	        }
	    };
	    /**
	     * Remove the data from the dataSource based on the key field value.
	     *
	     * @param {DataManager} dm
	     * @param {string} keyField
	     * @param {Object} value
	     * @param {string} tableName?
	     * @param tableName
	     * @returns null
	     */
	    JsonAdaptor.prototype.remove = function (dm, keyField, value, tableName) {
	        var ds = dm.dataSource.json;
	        var i;
	        if (typeof value === 'object' && !(value instanceof Date)) {
	            value = DataUtil.getObject(keyField, value);
	        }
	        for (i = 0; i < ds.length; i++) {
	            if (DataUtil.getObject(keyField, ds[i]) === value) {
	                break;
	            }
	        }
	        return i !== ds.length ? ds.splice(i, 1) : null;
	    };
	    /**
	     * Updates existing record and saves the changes to the table.
	     *
	     * @param {DataManager} dm
	     * @param {string} keyField
	     * @param {Object} value
	     * @param {string} tableName?
	     * @param tableName
	     * @returns null
	     */
	    JsonAdaptor.prototype.update = function (dm, keyField, value, tableName) {
	        var ds = dm.dataSource.json;
	        var i;
	        var key;
	        if (!isNullOrUndefined(keyField)) {
	            key = getValue(keyField, value);
	        }
	        for (i = 0; i < ds.length; i++) {
	            if (!isNullOrUndefined(keyField) && (getValue(keyField, ds[i])) === key) {
	                break;
	            }
	        }
	        return i < ds.length ? merge(ds[i], value) : null;
	    };
	    return JsonAdaptor;
	}(Adaptor));
	/**
	 * URL Adaptor of DataManager can be used when you are required to use remote service to retrieve data.
	 * It interacts with server-side for all DataManager Queries and CRUD operations.
	 *
	 * @hidden
	 */
	var UrlAdaptor = /** @class */ (function (_super) {
	    __extends$E(UrlAdaptor, _super);
	    function UrlAdaptor() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * Process the query to generate request body.
	     *
	     * @param {DataManager} dm
	     * @param {Query} query
	     * @param {Object[]} hierarchyFilters?
	     * @param hierarchyFilters
	     * @returns p
	     */
	    // tslint:disable-next-line:max-func-body-length
	    UrlAdaptor.prototype.processQuery = function (dm, query, hierarchyFilters) {
	        var queries = this.getQueryRequest(query);
	        var singles = Query.filterQueryLists(query.queries, ['onSelect', 'onPage', 'onSkip', 'onTake', 'onRange']);
	        var params = query.params;
	        var url = dm.dataSource.url;
	        var temp;
	        var skip;
	        var take = null;
	        var options = this.options;
	        var request = { sorts: [], groups: [], filters: [], searches: [], aggregates: [] };
	        // calc Paging & Range
	        if ('onPage' in singles) {
	            temp = singles.onPage;
	            skip = DataUtil.getValue(temp.pageIndex, query);
	            take = DataUtil.getValue(temp.pageSize, query);
	            skip = (skip - 1) * take;
	        }
	        else if ('onRange' in singles) {
	            temp = singles.onRange;
	            skip = temp.start;
	            take = temp.end - temp.start;
	        }
	        // Sorting
	        for (var i = 0; i < queries.sorts.length; i++) {
	            temp = DataUtil.getValue(queries.sorts[i].e.fieldName, query);
	            request.sorts.push(DataUtil.callAdaptorFunction(this, 'onEachSort', { name: temp, direction: queries.sorts[i].e.direction }, query));
	        }
	        // hierarchy
	        if (hierarchyFilters) {
	            temp = this.getFiltersFrom(hierarchyFilters, query);
	            if (temp) {
	                request.filters.push(DataUtil.callAdaptorFunction(this, 'onEachWhere', temp.toJson(), query));
	            }
	        }
	        // Filters
	        for (var i = 0; i < queries.filters.length; i++) {
	            var res = DataUtil.callAdaptorFunction(this, 'onEachWhere', queries.filters[i].e.toJson(), query);
	            if ((this.getModuleName &&
	                this.getModuleName() === 'ODataV4Adaptor') &&
	                !isNullOrUndefined(queries.filters[i].e.key) && queries.filters.length > 1) {
	                res = '(' + res + ')';
	            }
	            request.filters.push(res);
	            var keys_3 = typeof request.filters[i] === 'object' ? Object.keys(request.filters[i]) : [];
	            for (var _i = 0, keys_1 = keys_3; _i < keys_1.length; _i++) {
	                var prop = keys_1[_i];
	                if (DataUtil.isNull((request)[prop])) {
	                    delete request[prop];
	                }
	            }
	        }
	        // Searches
	        for (var i = 0; i < queries.searches.length; i++) {
	            temp = queries.searches[i].e;
	            request.searches.push(DataUtil.callAdaptorFunction(this, 'onEachSearch', {
	                fields: temp.fieldNames,
	                operator: temp.operator,
	                key: temp.searchKey,
	                ignoreCase: temp.ignoreCase
	            }, query));
	        }
	        // Grouping
	        for (var i = 0; i < queries.groups.length; i++) {
	            request.groups.push(DataUtil.getValue(queries.groups[i].e.fieldName, query));
	        }
	        // aggregates
	        for (var i = 0; i < queries.aggregates.length; i++) {
	            temp = queries.aggregates[i].e;
	            request.aggregates.push({ type: temp.type, field: DataUtil.getValue(temp.field, query) });
	        }
	        var req = {};
	        this.getRequestQuery(options, query, singles, request, req);
	        // Params
	        DataUtil.callAdaptorFunction(this, 'addParams', { dm: dm, query: query, params: params, reqParams: req });
	        if (query.lazyLoad.length) {
	            for (var i = 0; i < query.lazyLoad.length; i++) {
	                req[query.lazyLoad[i].key] = query.lazyLoad[i].value;
	            }
	        }
	        // cleanup
	        var keys = Object.keys(req);
	        for (var _a = 0, keys_2 = keys; _a < keys_2.length; _a++) {
	            var prop = keys_2[_a];
	            if (DataUtil.isNull(req[prop]) || req[prop] === '' || req[prop].length === 0) {
	                delete req[prop];
	            }
	        }
	        if (!(options.skip in req && options.take in req) && take !== null) {
	            req[options.skip] = DataUtil.callAdaptorFunction(this, 'onSkip', skip, query);
	            req[options.take] = DataUtil.callAdaptorFunction(this, 'onTake', take, query);
	        }
	        var p = this.pvt;
	        this.pvt = {};
	        if (this.options.requestType === 'json') {
	            return {
	                data: JSON.stringify(req, DataUtil.parse.jsonDateReplacer),
	                url: url,
	                pvtData: p,
	                type: 'POST',
	                contentType: 'application/json; charset=utf-8'
	            };
	        }
	        temp = this.convertToQueryString(req, query, dm);
	        temp = (dm.dataSource.url.indexOf('?') !== -1 ? '&' : '/') + temp;
	        return {
	            type: 'GET', url: temp.length ? url.replace(/\/*$/, temp) : url, pvtData: p
	        };
	    };
	    UrlAdaptor.prototype.getRequestQuery = function (options, query, singles, request, request1) {
	        var param = 'param';
	        var req = request1;
	        req[options.from] = query.fromTable;
	        if (options.apply && query.distincts.length) {
	            req[options.apply] = 'onDistinct' in this ? DataUtil.callAdaptorFunction(this, 'onDistinct', query.distincts) : '';
	        }
	        if (!query.distincts.length && options.expand) {
	            req[options.expand] = 'onExpand' in this && 'onSelect' in singles ?
	                DataUtil.callAdaptorFunction(this, 'onExpand', { selects: DataUtil.getValue(singles.onSelect.fieldNames, query), expands: query.expands }, query) : query.expands;
	        }
	        req[options.select] = 'onSelect' in singles && !query.distincts.length ?
	            DataUtil.callAdaptorFunction(this, 'onSelect', DataUtil.getValue(singles.onSelect.fieldNames, query), query) : '';
	        req[options.count] = query.isCountRequired ? DataUtil.callAdaptorFunction(this, 'onCount', query.isCountRequired, query) : '';
	        req[options.search] = request.searches.length ? DataUtil.callAdaptorFunction(this, 'onSearch', request.searches, query) : '';
	        req[options.skip] = 'onSkip' in singles ?
	            DataUtil.callAdaptorFunction(this, 'onSkip', DataUtil.getValue(singles.onSkip.nos, query), query) : '';
	        req[options.take] = 'onTake' in singles ?
	            DataUtil.callAdaptorFunction(this, 'onTake', DataUtil.getValue(singles.onTake.nos, query), query) : '';
	        req[options.where] = request.filters.length || request.searches.length ?
	            DataUtil.callAdaptorFunction(this, 'onWhere', request.filters, query) : '';
	        req[options.sortBy] = request.sorts.length ? DataUtil.callAdaptorFunction(this, 'onSortBy', request.sorts, query) : '';
	        req[options.group] = request.groups.length ? DataUtil.callAdaptorFunction(this, 'onGroup', request.groups, query) : '';
	        req[options.aggregates] = request.aggregates.length ?
	            DataUtil.callAdaptorFunction(this, 'onAggregates', request.aggregates, query) : '';
	        req[param] = [];
	    };
	    /**
	     * Convert the object from processQuery to string which can be added query string.
	     *
	     * @param {Object} req
	     * @param request
	     * @param {Query} query
	     * @param {DataManager} dm
	     */
	    UrlAdaptor.prototype.convertToQueryString = function (request, query, dm) {
	        return '';
	        // this needs to be overridden
	    };
	    /**
	     * Return the data from the data manager processing.
	     *
	     * @param {DataResult} data
	     * @param {DataOptions} ds?
	     * @param {Query} query?
	     * @param {Request} xhr?
	     * @param {Object} request?
	     * @param {CrudOptions} changes?
	     * @param ds
	     * @param query
	     * @param xhr
	     * @param request
	     * @param changes
	     */
	    UrlAdaptor.prototype.processResponse = function (data, ds, query, xhr, request, changes) {
	        if (xhr && xhr.headers.get('Content-Type') &&
	            xhr.headers.get('Content-Type').indexOf('application/json') !== -1) {
	            var handleTimeZone = DataUtil.timeZoneHandling;
	            if (ds && !ds.timeZoneHandling) {
	                DataUtil.timeZoneHandling = false;
	            }
	            data = DataUtil.parse.parseJson(data);
	            DataUtil.timeZoneHandling = handleTimeZone;
	        }
	        var requests = request;
	        var pvt = requests.pvtData || {};
	        var groupDs = data ? data.groupDs : [];
	        if (xhr && xhr.headers.get('Content-Type') &&
	            xhr.headers.get('Content-Type').indexOf('xml') !== -1) {
	            return (query.isCountRequired ? { result: [], count: 0 } : []);
	        }
	        var d = JSON.parse(requests.data);
	        if (d && d.action === 'batch' && data && data.addedRecords) {
	            changes.addedRecords = data.addedRecords;
	            return changes;
	        }
	        if (data && data.d) {
	            data = data.d;
	        }
	        var args = {};
	        if (data && 'count' in data) {
	            args.count = data.count;
	        }
	        args.result = data && data.result ? data.result : data;
	        var isExpand = false;
	        if (Array.isArray(data.result) && data.result.length) {
	            var key = 'key';
	            var val = 'value';
	            var level = 'level';
	            if (!isNullOrUndefined(data.result[0][key])) {
	                args.result = this.formRemoteGroupedData(args.result, 1, pvt.groups.length - 1);
	            }
	            if (query && query.lazyLoad.length && pvt.groups.length) {
	                for (var i = 0; i < query.lazyLoad.length; i++) {
	                    if (query.lazyLoad[i][key] === 'onDemandGroupInfo') {
	                        var value = query.lazyLoad[i][val][level];
	                        if (pvt.groups.length === value) {
	                            isExpand = true;
	                        }
	                    }
	                }
	            }
	        }
	        if (!isExpand) {
	            this.getAggregateResult(pvt, data, args, groupDs, query);
	        }
	        return DataUtil.isNull(args.count) ? args.result : { result: args.result, count: args.count, aggregates: args.aggregates };
	    };
	    UrlAdaptor.prototype.formRemoteGroupedData = function (data, level, childLevel) {
	        for (var i = 0; i < data.length; i++) {
	            if (data[i].items.length && Object.keys(data[i].items[0]).indexOf('key') > -1) {
	                this.formRemoteGroupedData(data[i].items, level + 1, childLevel - 1);
	            }
	        }
	        var uid = 'GroupGuid';
	        var childLvl = 'childLevels';
	        var lvl = 'level';
	        var records = 'records';
	        data[uid] = consts[uid];
	        data[lvl] = level;
	        data[childLvl] = childLevel;
	        data[records] = data[0].items.length ? this.getGroupedRecords(data, !isNullOrUndefined(data[0].items[records])) : [];
	        return data;
	    };
	    UrlAdaptor.prototype.getGroupedRecords = function (data, hasRecords) {
	        var childGroupedRecords = [];
	        var records = 'records';
	        for (var i = 0; i < data.length; i++) {
	            if (!hasRecords) {
	                for (var j = 0; j < data[i].items.length; j++) {
	                    childGroupedRecords.push(data[i].items[j]);
	                }
	            }
	            else {
	                childGroupedRecords = childGroupedRecords.concat(data[i].items[records]);
	            }
	        }
	        return childGroupedRecords;
	    };
	    /**
	     * Add the group query to the adaptor`s option.
	     *
	     * @param  {Object[]} e
	     * @returns void
	     */
	    UrlAdaptor.prototype.onGroup = function (e) {
	        this.pvt.groups = e;
	        return e;
	    };
	    /**
	     * Add the aggregate query to the adaptor`s option.
	     *
	     * @param  {Aggregates[]} e
	     * @returns void
	     */
	    UrlAdaptor.prototype.onAggregates = function (e) {
	        this.pvt.aggregates = e;
	    };
	    /**
	     * Prepare the request body based on the newly added, removed and updated records.
	     * The result is used by the batch request.
	     *
	     * @param {DataManager} dm
	     * @param {CrudOptions} changes
	     * @param {Object} e
	     * @param query
	     * @param original
	     */
	    UrlAdaptor.prototype.batchRequest = function (dm, changes, e, query, original) {
	        var url;
	        var key;
	        return {
	            type: 'POST',
	            url: dm.dataSource.batchUrl || dm.dataSource.crudUrl || dm.dataSource.removeUrl || dm.dataSource.url,
	            contentType: 'application/json; charset=utf-8',
	            dataType: 'json',
	            data: JSON.stringify(extend({}, {
	                changed: changes.changedRecords,
	                added: changes.addedRecords,
	                deleted: changes.deletedRecords,
	                action: 'batch',
	                table: e[url],
	                key: e[key]
	            }, DataUtil.getAddParams(this, dm, query)))
	        };
	    };
	    /**
	     * Method will trigger before send the request to server side.
	     * Used to set the custom header or modify the request options.
	     *
	     * @param  {DataManager} dm
	     * @param  {Request} request
	     * @returns void
	     */
	    UrlAdaptor.prototype.beforeSend = function (dm, request) {
	        // need to extend this method
	    };
	    /**
	     * Prepare and returns request body which is used to insert a new record in the table.
	     *
	     * @param {DataManager} dm
	     * @param {Object} data
	     * @param {string} tableName
	     * @param query
	     */
	    UrlAdaptor.prototype.insert = function (dm, data, tableName, query) {
	        return {
	            url: dm.dataSource.insertUrl || dm.dataSource.crudUrl || dm.dataSource.url,
	            data: JSON.stringify(extend({}, {
	                value: data,
	                table: tableName,
	                action: 'insert'
	            }, DataUtil.getAddParams(this, dm, query)))
	        };
	    };
	    /**
	     * Prepare and return request body which is used to remove record from the table.
	     *
	     * @param {DataManager} dm
	     * @param {string} keyField
	     * @param {number|string} value
	     * @param {string} tableName
	     * @param query
	     */
	    UrlAdaptor.prototype.remove = function (dm, keyField, value, tableName, query) {
	        return {
	            type: 'POST',
	            url: dm.dataSource.removeUrl || dm.dataSource.crudUrl || dm.dataSource.url,
	            data: JSON.stringify(extend({}, {
	                key: value,
	                keyColumn: keyField,
	                table: tableName,
	                action: 'remove'
	            }, DataUtil.getAddParams(this, dm, query)))
	        };
	    };
	    /**
	     * Prepare and return request body which is used to update record.
	     *
	     * @param {DataManager} dm
	     * @param {string} keyField
	     * @param {Object} value
	     * @param {string} tableName
	     * @param query
	     */
	    UrlAdaptor.prototype.update = function (dm, keyField, value, tableName, query) {
	        return {
	            type: 'POST',
	            url: dm.dataSource.updateUrl || dm.dataSource.crudUrl || dm.dataSource.url,
	            data: JSON.stringify(extend({}, {
	                value: value,
	                action: 'update',
	                keyColumn: keyField,
	                key: DataUtil.getObject(keyField, value),
	                table: tableName
	            }, DataUtil.getAddParams(this, dm, query)))
	        };
	    };
	    /**
	     * To generate the predicate based on the filtered query.
	     *
	     * @param  {Object[]|string[]|number[]} data
	     * @param  {Query} query
	     * @hidden
	     */
	    UrlAdaptor.prototype.getFiltersFrom = function (data, query) {
	        var key = query.fKey;
	        var value;
	        var prop = key;
	        var pKey = query.key;
	        var predicats = [];
	        if (typeof data[0] !== 'object') {
	            prop = null;
	        }
	        for (var i = 0; i < data.length; i++) {
	            if (typeof data[0] === 'object') {
	                value = DataUtil.getObject(pKey || prop, data[i]);
	            }
	            else {
	                value = data[i];
	            }
	            predicats.push(new Predicate(key, 'equal', value));
	        }
	        return Predicate.or(predicats);
	    };
	    UrlAdaptor.prototype.getAggregateResult = function (pvt, data, args, groupDs, query) {
	        var pData = data;
	        if (data && data.result) {
	            pData = data.result;
	        }
	        if (pvt && pvt.aggregates && pvt.aggregates.length) {
	            var agg = pvt.aggregates;
	            var fn = void 0;
	            var aggregateData = pData;
	            var res = {};
	            if (data.aggregate) {
	                aggregateData = data.aggregate;
	            }
	            for (var i = 0; i < agg.length; i++) {
	                fn = DataUtil.aggregates[agg[i].type];
	                if (fn) {
	                    res[agg[i].field + ' - ' + agg[i].type] = fn(aggregateData, agg[i].field);
	                }
	            }
	            args.aggregates = res;
	        }
	        var key = 'key';
	        var isServerGrouping = Array.isArray(data.result) && data.result.length && !isNullOrUndefined(data.result[0][key]);
	        if (pvt && pvt.groups && pvt.groups.length && !isServerGrouping) {
	            var groups = pvt.groups;
	            for (var i = 0; i < groups.length; i++) {
	                var level = null;
	                if (!isNullOrUndefined(groupDs)) {
	                    groupDs = DataUtil.group(groupDs, groups[i]);
	                }
	                var groupQuery = Query.filterQueries(query.queries, 'onGroup')[i].e;
	                pData = DataUtil.group(pData, groups[i], pvt.aggregates, level, groupDs, groupQuery.comparer);
	            }
	            args.result = pData;
	        }
	        return args;
	    };
	    UrlAdaptor.prototype.getQueryRequest = function (query) {
	        var req = { sorts: [], groups: [], filters: [], searches: [], aggregates: [] };
	        req.sorts = Query.filterQueries(query.queries, 'onSortBy');
	        req.groups = Query.filterQueries(query.queries, 'onGroup');
	        req.filters = Query.filterQueries(query.queries, 'onWhere');
	        req.searches = Query.filterQueries(query.queries, 'onSearch');
	        req.aggregates = Query.filterQueries(query.queries, 'onAggregates');
	        return req;
	    };
	    UrlAdaptor.prototype.addParams = function (options) {
	        var req = options.reqParams;
	        if (options.params.length) {
	            req.params = {};
	        }
	        for (var _i = 0, _a = options.params; _i < _a.length; _i++) {
	            var tmp = _a[_i];
	            if (req[tmp.key]) {
	                throw new Error('Query() - addParams: Custom Param is conflicting other request arguments');
	            }
	            req[tmp.key] = tmp.value;
	            if (tmp.fn) {
	                req[tmp.key] = tmp.fn.call(options.query, tmp.key, options.query, options.dm);
	            }
	            req.params[tmp.key] = req[tmp.key];
	        }
	    };
	    return UrlAdaptor;
	}(Adaptor));
	/**
	 * OData Adaptor that is extended from URL Adaptor, is used for consuming data through OData Service.
	 *
	 * @hidden
	 */
	var ODataAdaptor = /** @class */ (function (_super) {
	    __extends$E(ODataAdaptor, _super);
	    function ODataAdaptor(props) {
	        var _this = _super.call(this) || this;
	        // options replaced the default adaptor options
	        _this.options = extend({}, _this.options, {
	            requestType: 'get',
	            accept: 'application/json;odata=light;q=1,application/json;odata=verbose;q=0.5',
	            multipartAccept: 'multipart/mixed',
	            sortBy: '$orderby',
	            select: '$select',
	            skip: '$skip',
	            take: '$top',
	            count: '$inlinecount',
	            where: '$filter',
	            expand: '$expand',
	            batch: '$batch',
	            changeSet: '--changeset_',
	            batchPre: 'batch_',
	            contentId: 'Content-Id: ',
	            batchContent: 'Content-Type: multipart/mixed; boundary=',
	            changeSetContent: 'Content-Type: application/http\nContent-Transfer-Encoding: binary ',
	            batchChangeSetContentType: 'Content-Type: application/json; charset=utf-8 ',
	            updateType: 'PUT'
	        });
	        extend(_this.options, props || {});
	        return _this;
	    }
	    ODataAdaptor.prototype.getModuleName = function () {
	        return 'ODataAdaptor';
	    };
	    /**
	     * Generate request string based on the filter criteria from query.
	     *
	     * @param {Predicate} pred
	     * @param {boolean} requiresCast?
	     * @param predicate
	     * @param query
	     * @param requiresCast
	     */
	    ODataAdaptor.prototype.onPredicate = function (predicate, query, requiresCast) {
	        var returnValue = '';
	        var operator;
	        var guid;
	        var val = predicate.value;
	        var type = typeof val;
	        var field = predicate.field ? ODataAdaptor.getField(predicate.field) : null;
	        if (val instanceof Date) {
	            val = 'datetime\'' + DataUtil.parse.replacer(val) + '\'';
	        }
	        if (type === 'string') {
	            val = val.replace(/'/g, '\'\'');
	            if (predicate.ignoreCase) {
	                val = val.toLowerCase();
	            }
	            if (predicate.operator !== 'like') {
	                val = encodeURIComponent(val);
	            }
	            if (predicate.operator !== 'wildcard' && predicate.operator !== 'like') {
	                val = '\'' + val + '\'';
	            }
	            if (requiresCast) {
	                field = 'cast(' + field + ', \'Edm.String\')';
	            }
	            if (DataUtil.parse.isGuid(val)) {
	                guid = 'guid';
	            }
	            if (predicate.ignoreCase) {
	                if (!guid) {
	                    field = 'tolower(' + field + ')';
	                }
	                val = val.toLowerCase();
	            }
	        }
	        if (predicate.operator === 'isempty' || predicate.operator === 'isnull' || predicate.operator === 'isnotempty' ||
	            predicate.operator === 'isnotnull') {
	            operator = predicate.operator.indexOf('isnot') !== -1 ? DataUtil.odBiOperator['notequal'] : DataUtil.odBiOperator['equal'];
	            val = predicate.operator === 'isnull' || predicate.operator === 'isnotnull' ? null : '\'\'';
	        }
	        else {
	            operator = DataUtil.odBiOperator[predicate.operator];
	        }
	        if (operator) {
	            returnValue += field;
	            returnValue += operator;
	            if (guid) {
	                returnValue += guid;
	            }
	            return returnValue + val;
	        }
	        if (!isNullOrUndefined(this.getModuleName) && this.getModuleName() === 'ODataV4Adaptor') {
	            operator = DataUtil.odv4UniOperator[predicate.operator];
	        }
	        else {
	            operator = DataUtil.odUniOperator[predicate.operator];
	        }
	        if (operator === 'like') {
	            val = val;
	            if (val.indexOf('%') !== -1) {
	                if (val.charAt(0) === '%' && val.lastIndexOf('%') < 2) {
	                    val = val.substring(1, val.length);
	                    operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === 'ODataV4Adaptor' ?
	                        DataUtil.odv4UniOperator['startswith'] : DataUtil.odUniOperator['startswith'];
	                }
	                else if (val.charAt(val.length - 1) === '%' && val.indexOf('%') > val.length - 3) {
	                    val = val.substring(0, val.length - 1);
	                    operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === 'ODataV4Adaptor' ?
	                        DataUtil.odv4UniOperator['endswith'] : DataUtil.odUniOperator['endswith'];
	                }
	                else if (val.lastIndexOf('%') !== val.indexOf('%') && val.lastIndexOf('%') > val.indexOf('%') + 1) {
	                    val = val.substring(val.indexOf('%') + 1, val.lastIndexOf('%'));
	                    operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === 'ODataV4Adaptor' ?
	                        DataUtil.odv4UniOperator['contains'] : DataUtil.odUniOperator['contains'];
	                }
	                else {
	                    operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === 'ODataV4Adaptor' ?
	                        DataUtil.odv4UniOperator['contains'] : DataUtil.odUniOperator['contains'];
	                }
	            }
	            val = encodeURIComponent(val);
	            val = '\'' + val + '\'';
	        }
	        else if (operator === 'wildcard') {
	            val = val;
	            if (val.indexOf('*') !== -1) {
	                var splittedStringValue = val.split('*');
	                var splittedValue = void 0;
	                var count = 0;
	                if (val.indexOf('*') !== 0 && splittedStringValue[0].indexOf('%3f') === -1 &&
	                    splittedStringValue[0].indexOf('?') === -1) {
	                    splittedValue = splittedStringValue[0];
	                    splittedValue = '\'' + splittedValue + '\'';
	                    operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === 'ODataV4Adaptor' ?
	                        DataUtil.odv4UniOperator['startswith'] : DataUtil.odUniOperator['startswith'];
	                    returnValue += operator + '(';
	                    returnValue += field + ',';
	                    if (guid) {
	                        returnValue += guid;
	                    }
	                    returnValue += splittedValue + ')';
	                    count++;
	                }
	                if (val.lastIndexOf('*') !== val.length - 1 && splittedStringValue[splittedStringValue.length - 1].indexOf('%3f') === -1 &&
	                    splittedStringValue[splittedStringValue.length - 1].indexOf('?') === -1) {
	                    splittedValue = splittedStringValue[splittedStringValue.length - 1];
	                    splittedValue = '\'' + splittedValue + '\'';
	                    operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === 'ODataV4Adaptor' ?
	                        DataUtil.odv4UniOperator['endswith'] : DataUtil.odUniOperator['endswith'];
	                    if (count > 0) {
	                        returnValue += ' and ';
	                    }
	                    returnValue += operator + '(';
	                    returnValue += field + ',';
	                    if (guid) {
	                        returnValue += guid;
	                    }
	                    returnValue += splittedValue + ')';
	                    count++;
	                }
	                if (splittedStringValue.length > 2) {
	                    for (var i = 1; i < splittedStringValue.length - 1; i++) {
	                        if (splittedStringValue[i].indexOf('%3f') === -1 && splittedStringValue[i].indexOf('?') === -1) {
	                            splittedValue = splittedStringValue[i];
	                            splittedValue = '\'' + splittedValue + '\'';
	                            operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === 'ODataV4Adaptor' ?
	                                DataUtil.odv4UniOperator['contains'] : DataUtil.odUniOperator['contains'];
	                            if (count > 0) {
	                                returnValue += ' and ';
	                            }
	                            if (operator === 'substringof' || operator === 'not substringof') {
	                                var temp = splittedValue;
	                                splittedValue = field;
	                                field = temp;
	                            }
	                            returnValue += operator + '(';
	                            returnValue += field + ',';
	                            if (guid) {
	                                returnValue += guid;
	                            }
	                            returnValue += splittedValue + ')';
	                            count++;
	                        }
	                    }
	                }
	                if (count === 0) {
	                    operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === 'ODataV4Adaptor' ?
	                        DataUtil.odv4UniOperator['contains'] : DataUtil.odUniOperator['contains'];
	                    if (val.indexOf('?') !== -1 || val.indexOf('%3f') !== -1) {
	                        val = val.indexOf('?') !== -1 ? val.split('?').join('') : val.split('%3f').join('');
	                    }
	                    val = '\'' + val + '\'';
	                }
	                else {
	                    operator = 'wildcard';
	                }
	            }
	            else {
	                operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === 'ODataV4Adaptor' ?
	                    DataUtil.odv4UniOperator['contains'] : DataUtil.odUniOperator['contains'];
	                if (val.indexOf('?') !== -1 || val.indexOf('%3f') !== -1) {
	                    val = val.indexOf('?') !== -1 ? val.split('?').join('') : val.split('%3f').join('');
	                }
	                val = '\'' + val + '\'';
	            }
	        }
	        if (operator === 'substringof' || operator === 'not substringof') {
	            var temp = val;
	            val = field;
	            field = temp;
	        }
	        if (operator !== 'wildcard') {
	            returnValue += operator + '(';
	            returnValue += field + ',';
	            if (guid) {
	                returnValue += guid;
	            }
	            returnValue += val + ')';
	        }
	        return returnValue;
	    };
	    ODataAdaptor.prototype.addParams = function (options) {
	        _super.prototype.addParams.call(this, options);
	        delete options.reqParams.params;
	    };
	    /**
	     * Generate request string based on the multiple filter criteria from query.
	     *
	     * @param {Predicate} pred
	     * @param {boolean} requiresCast?
	     * @param predicate
	     * @param query
	     * @param requiresCast
	     */
	    ODataAdaptor.prototype.onComplexPredicate = function (predicate, query, requiresCast) {
	        var res = [];
	        for (var i = 0; i < predicate.predicates.length; i++) {
	            res.push('(' + this.onEachWhere(predicate.predicates[i], query, requiresCast) + ')');
	        }
	        return res.join(' ' + predicate.condition + ' ');
	    };
	    /**
	     * Generate query string based on the multiple filter criteria from query.
	     *
	     * @param {Predicate} filter
	     * @param {boolean} requiresCast?
	     * @param query
	     * @param requiresCast
	     */
	    ODataAdaptor.prototype.onEachWhere = function (filter, query, requiresCast) {
	        return filter.isComplex ? this.onComplexPredicate(filter, query, requiresCast) : this.onPredicate(filter, query, requiresCast);
	    };
	    /**
	     * Generate query string based on the multiple filter criteria from query.
	     *
	     * @param  {string[]} filters
	     */
	    ODataAdaptor.prototype.onWhere = function (filters) {
	        if (this.pvt.search) {
	            filters.push(this.onEachWhere(this.pvt.search, null, true));
	        }
	        return filters.join(' and ');
	    };
	    /**
	     * Generate query string based on the multiple search criteria from query.
	     *
	     * @param e
	     * @param {string} operator
	     * @param {string} key
	     * @param {boolean} } ignoreCase
	     * @param e.fields
	     * @param e.operator
	     * @param e.key
	     * @param e.ignoreCase
	     */
	    ODataAdaptor.prototype.onEachSearch = function (e) {
	        if (e.fields && e.fields.length === 0) {
	            DataUtil.throwError('Query() - Search : oData search requires list of field names to search');
	        }
	        var filter = this.pvt.search || [];
	        for (var i = 0; i < e.fields.length; i++) {
	            filter.push(new Predicate(e.fields[i], e.operator, e.key, e.ignoreCase));
	        }
	        this.pvt.search = filter;
	    };
	    /**
	     * Generate query string based on the search criteria from query.
	     *
	     * @param  {Object} e
	     */
	    ODataAdaptor.prototype.onSearch = function (e) {
	        this.pvt.search = Predicate.or(this.pvt.search);
	        return '';
	    };
	    /**
	     * Generate query string based on multiple sort criteria from query.
	     *
	     * @param  {QueryOptions} e
	     */
	    ODataAdaptor.prototype.onEachSort = function (e) {
	        var res = [];
	        if (e.name instanceof Array) {
	            for (var i = 0; i < e.name.length; i++) {
	                res.push(ODataAdaptor.getField(e.name[i]) + (e.direction === 'descending' ? ' desc' : ''));
	            }
	        }
	        else {
	            res.push(ODataAdaptor.getField(e.name) + (e.direction === 'descending' ? ' desc' : ''));
	        }
	        return res.join(',');
	    };
	    /**
	     * Returns sort query string.
	     *
	     * @param  {string[]} e
	     */
	    ODataAdaptor.prototype.onSortBy = function (e) {
	        return e.reverse().join(',');
	    };
	    /**
	     * Adds the group query to the adaptor option.
	     *
	     * @param  {Object[]} e
	     * @returns string
	     */
	    ODataAdaptor.prototype.onGroup = function (e) {
	        this.pvt.groups = e;
	        return [];
	    };
	    /**
	     * Returns the select query string.
	     *
	     * @param  {string[]} e
	     */
	    ODataAdaptor.prototype.onSelect = function (e) {
	        for (var i = 0; i < e.length; i++) {
	            e[i] = ODataAdaptor.getField(e[i]);
	        }
	        return e.join(',');
	    };
	    /**
	     * Add the aggregate query to the adaptor option.
	     *
	     * @param  {Object[]} e
	     * @returns string
	     */
	    ODataAdaptor.prototype.onAggregates = function (e) {
	        this.pvt.aggregates = e;
	        return '';
	    };
	    /**
	     * Returns the query string which requests total count from the data source.
	     *
	     * @param  {boolean} e
	     * @returns string
	     */
	    ODataAdaptor.prototype.onCount = function (e) {
	        return e === true ? 'allpages' : '';
	    };
	    /**
	     * Method will trigger before send the request to server side.
	     * Used to set the custom header or modify the request options.
	     *
	     * @param {DataManager} dm
	     * @param {Request} request
	     * @param {Fetch} settings?
	     * @param settings
	     */
	    ODataAdaptor.prototype.beforeSend = function (dm, request, settings) {
	        if (DataUtil.endsWith(settings.url, this.options.batch) && settings.type.toLowerCase() === 'post') {
	            request.headers.set('Accept', this.options.multipartAccept);
	            request.headers.set('DataServiceVersion', '2.0');
	            //request.overrideMimeType('text/plain; charset=x-user-defined');
	        }
	        else {
	            request.headers.set('Accept', this.options.accept);
	        }
	        request.headers.set('DataServiceVersion', '2.0');
	        request.headers.set('MaxDataServiceVersion', '2.0');
	    };
	    /**
	     * Returns the data from the query processing.
	     *
	     * @param {DataResult} data
	     * @param {DataOptions} ds?
	     * @param {Query} query?
	     * @param {Request} xhr?
	     * @param {Fetch} request?
	     * @param {CrudOptions} changes?
	     * @param ds
	     * @param query
	     * @param xhr
	     * @param request
	     * @param changes
	     * @returns aggregateResult
	     */
	    ODataAdaptor.prototype.processResponse = function (data, ds, query, xhr, request, changes) {
	        var metaCheck = 'odata.metadata';
	        if ((request && request.type === 'GET') && !this.rootUrl && data[metaCheck]) {
	            var dataUrls = data[metaCheck].split('/$metadata#');
	            this.rootUrl = dataUrls[0];
	            this.resourceTableName = dataUrls[1];
	        }
	        var pvtData = 'pvtData';
	        if (!isNullOrUndefined(data.d)) {
	            var dataCopy = ((query && query.isCountRequired) ? data.d.results : data.d);
	            var metaData = '__metadata';
	            if (!isNullOrUndefined(dataCopy)) {
	                for (var i = 0; i < dataCopy.length; i++) {
	                    if (!isNullOrUndefined(dataCopy[i][metaData])) {
	                        delete dataCopy[i][metaData];
	                    }
	                }
	            }
	        }
	        var pvt = request && request[pvtData];
	        var emptyAndBatch = this.processBatchResponse(data, query, xhr, request, changes);
	        if (emptyAndBatch) {
	            return emptyAndBatch;
	        }
	        var versionCheck = xhr && request.fetchRequest.headers.get('DataServiceVersion');
	        var count = null;
	        var version = (versionCheck && parseInt(versionCheck, 10)) || 2;
	        if (query && query.isCountRequired) {
	            var oDataCount = '__count';
	            if (data[oDataCount] || data['odata.count']) {
	                count = data[oDataCount] || data['odata.count'];
	            }
	            if (data.d) {
	                data = data.d;
	            }
	            if (data[oDataCount] || data['odata.count']) {
	                count = data[oDataCount] || data['odata.count'];
	            }
	        }
	        if (version === 3 && data.value) {
	            data = data.value;
	        }
	        if (data.d) {
	            data = data.d;
	        }
	        if (version < 3 && data.results) {
	            data = data.results;
	        }
	        var args = {};
	        args.count = count;
	        args.result = data;
	        this.getAggregateResult(pvt, data, args, null, query);
	        return DataUtil.isNull(count) ? args.result : { result: args.result, count: args.count, aggregates: args.aggregates };
	    };
	    /**
	     * Converts the request object to query string.
	     *
	     * @param {Object} req
	     * @param request
	     * @param {Query} query
	     * @param {DataManager} dm
	     * @returns tableName
	     */
	    ODataAdaptor.prototype.convertToQueryString = function (request, query, dm) {
	        var res = [];
	        var table = 'table';
	        var tableName = request[table] || '';
	        var format = '$format';
	        delete request[table];
	        if (dm.dataSource.requiresFormat) {
	            request[format] = 'json';
	        }
	        var keys = Object.keys(request);
	        for (var _i = 0, keys_4 = keys; _i < keys_4.length; _i++) {
	            var prop = keys_4[_i];
	            res.push(prop + '=' + request[prop]);
	        }
	        res = res.join('&');
	        if (dm.dataSource.url && dm.dataSource.url.indexOf('?') !== -1 && !tableName) {
	            return res;
	        }
	        return res.length ? tableName + '?' + res : tableName || '';
	    };
	    ODataAdaptor.prototype.localTimeReplacer = function (key, convertObj) {
	        for (var _i = 0, _a = !isNullOrUndefined(convertObj) ? Object.keys(convertObj) : []; _i < _a.length; _i++) {
	            var prop = _a[_i];
	            if ((convertObj[prop] instanceof Date)) {
	                convertObj[prop] = DataUtil.dateParse.toLocalTime(convertObj[prop]);
	            }
	        }
	        return convertObj;
	    };
	    /**
	     * Prepare and returns request body which is used to insert a new record in the table.
	     *
	     * @param {DataManager} dm
	     * @param {Object} data
	     * @param {string} tableName?
	     * @param tableName
	     */
	    ODataAdaptor.prototype.insert = function (dm, data, tableName) {
	        return {
	            url: (dm.dataSource.insertUrl || dm.dataSource.url).replace(/\/*$/, tableName ? '/' + tableName : ''),
	            data: JSON.stringify(data, this.options.localTime ? this.localTimeReplacer : null)
	        };
	    };
	    /**
	     * Prepare and return request body which is used to remove record from the table.
	     *
	     * @param {DataManager} dm
	     * @param {string} keyField
	     * @param {number} value
	     * @param {string} tableName?
	     * @param tableName
	     */
	    ODataAdaptor.prototype.remove = function (dm, keyField, value, tableName) {
	        var url;
	        if (typeof value === 'string' && !DataUtil.parse.isGuid(value)) {
	            url = "('" + value + "')";
	        }
	        else {
	            url = "(" + value + ")";
	        }
	        return {
	            type: 'DELETE',
	            url: (dm.dataSource.removeUrl || dm.dataSource.url).replace(/\/*$/, tableName ? '/' + tableName : '') + url
	        };
	    };
	    /**
	     * Updates existing record and saves the changes to the table.
	     *
	     * @param {DataManager} dm
	     * @param {string} keyField
	     * @param {Object} value
	     * @param {string} tableName?
	     * @param tableName
	     * @param query
	     * @param original
	     * @returns this
	     */
	    ODataAdaptor.prototype.update = function (dm, keyField, value, tableName, query, original) {
	        if (this.options.updateType === 'PATCH' && !isNullOrUndefined(original)) {
	            value = this.compareAndRemove(value, original, keyField);
	        }
	        var url;
	        if (typeof value[keyField] === 'string' && !DataUtil.parse.isGuid(value[keyField])) {
	            url = "('" + value[keyField] + "')";
	        }
	        else {
	            url = "(" + value[keyField] + ")";
	        }
	        return {
	            type: this.options.updateType,
	            url: (dm.dataSource.updateUrl || dm.dataSource.url).replace(/\/*$/, tableName ? '/' + tableName : '') + url,
	            data: JSON.stringify(value, this.options.localTime ? this.localTimeReplacer : null),
	            accept: this.options.accept
	        };
	    };
	    /**
	     * Prepare the request body based on the newly added, removed and updated records.
	     * The result is used by the batch request.
	     *
	     * @param {DataManager} dm
	     * @param {CrudOptions} changes
	     * @param {RemoteArgs} e
	     * @param query
	     * @param original
	     * @returns {Object}
	     */
	    ODataAdaptor.prototype.batchRequest = function (dm, changes, e, query, original) {
	        var initialGuid = e.guid = DataUtil.getGuid(this.options.batchPre);
	        var url = this.rootUrl ? this.rootUrl + '/' + this.options.batch :
	            dm.dataSource.url.replace(/\/*$/, '/' + this.options.batch);
	        e.url = this.resourceTableName ? this.resourceTableName : e.url;
	        var args = {
	            url: e.url,
	            key: e.key,
	            cid: 1,
	            cSet: DataUtil.getGuid(this.options.changeSet)
	        };
	        var req = '--' + initialGuid + '\n';
	        req += 'Content-Type: multipart/mixed; boundary=' + args.cSet.replace('--', '') + '\n';
	        this.pvt.changeSet = 0;
	        req += this.generateInsertRequest(changes.addedRecords, args, dm);
	        req += this.generateUpdateRequest(changes.changedRecords, args, dm, original ? original.changedRecords : []);
	        req += this.generateDeleteRequest(changes.deletedRecords, args, dm);
	        req += args.cSet + '--\n';
	        req += '--' + initialGuid + '--';
	        return {
	            type: 'POST',
	            url: url,
	            dataType: 'json',
	            contentType: 'multipart/mixed; charset=UTF-8;boundary=' + initialGuid,
	            data: req
	        };
	    };
	    /**
	     * Generate the string content from the removed records.
	     * The result will be send during batch update.
	     *
	     * @param {Object[]} arr
	     * @param {RemoteArgs} e
	     * @param dm
	     * @returns this
	     */
	    ODataAdaptor.prototype.generateDeleteRequest = function (arr, e, dm) {
	        if (!arr) {
	            return '';
	        }
	        var req = '';
	        var stat = {
	            'method': 'DELETE ',
	            'url': function (data, i, key) {
	                var url = DataUtil.getObject(key, data[i]);
	                if (typeof url === 'number' || DataUtil.parse.isGuid(url)) {
	                    return '(' + url + ')';
	                }
	                else if (url instanceof Date) {
	                    var dateTime = data[i][key];
	                    return '(' + dateTime.toJSON() + ')';
	                }
	                else {
	                    return "('" + url + "')";
	                }
	            },
	            'data': function (data, i) { return ''; }
	        };
	        req = this.generateBodyContent(arr, e, stat, dm);
	        return req + '\n';
	    };
	    /**
	     * Generate the string content from the inserted records.
	     * The result will be send during batch update.
	     *
	     * @param {Object[]} arr
	     * @param {RemoteArgs} e
	     * @param dm
	     */
	    ODataAdaptor.prototype.generateInsertRequest = function (arr, e, dm) {
	        if (!arr) {
	            return '';
	        }
	        var req = '';
	        var stat = {
	            'method': 'POST ',
	            'url': function (data, i, key) { return ''; },
	            'data': function (data, i) { return JSON.stringify(data[i]) + '\n\n'; }
	        };
	        req = this.generateBodyContent(arr, e, stat, dm);
	        return req;
	    };
	    /**
	     * Generate the string content from the updated records.
	     * The result will be send during batch update.
	     *
	     * @param {Object[]} arr
	     * @param {RemoteArgs} e
	     * @param dm
	     * @param org
	     */
	    ODataAdaptor.prototype.generateUpdateRequest = function (arr, e, dm, org) {
	        var _this = this;
	        if (!arr) {
	            return '';
	        }
	        var req = '';
	        arr.forEach(function (change) { return change = _this.compareAndRemove(change, org.filter(function (o) { return DataUtil.getObject(e.key, o) === DataUtil.getObject(e.key, change); })[0], e.key); });
	        var stat = {
	            'method': this.options.updateType + ' ',
	            'url': function (data, i, key) {
	                if (typeof data[i][key] === 'number' || DataUtil.parse.isGuid(data[i][key])) {
	                    return '(' + data[i][key] + ')';
	                }
	                else if (data[i][key] instanceof Date) {
	                    var date = data[i][key];
	                    return '(' + date.toJSON() + ')';
	                }
	                else {
	                    return "('" + data[i][key] + "')";
	                }
	            },
	            'data': function (data, i) { return JSON.stringify(data[i]) + '\n\n'; }
	        };
	        req = this.generateBodyContent(arr, e, stat, dm);
	        return req;
	    };
	    ODataAdaptor.getField = function (prop) {
	        return prop.replace(/\./g, '/');
	    };
	    ODataAdaptor.prototype.generateBodyContent = function (arr, e, stat, dm) {
	        var req = '';
	        for (var i = 0; i < arr.length; i++) {
	            req += '\n' + e.cSet + '\n';
	            req += this.options.changeSetContent + '\n\n';
	            req += stat.method;
	            if (stat.method === 'POST ') {
	                req += (dm.dataSource.insertUrl || dm.dataSource.crudUrl || e.url) + stat.url(arr, i, e.key) + ' HTTP/1.1\n';
	            }
	            else if (stat.method === 'PUT ' || stat.method === 'PATCH ') {
	                req += (dm.dataSource.updateUrl || dm.dataSource.crudUrl || e.url) + stat.url(arr, i, e.key) + ' HTTP/1.1\n';
	            }
	            else if (stat.method === 'DELETE ') {
	                req += (dm.dataSource.removeUrl || dm.dataSource.crudUrl || e.url) + stat.url(arr, i, e.key) + ' HTTP/1.1\n';
	            }
	            req += 'Accept: ' + this.options.accept + '\n';
	            req += 'Content-Id: ' + this.pvt.changeSet++ + '\n';
	            req += this.options.batchChangeSetContentType + '\n';
	            if (!isNullOrUndefined(arr[i]['@odata.etag'])) {
	                req += 'If-Match: ' + arr[i]['@odata.etag'] + '\n\n';
	                delete arr[i]['@odata.etag'];
	            }
	            else {
	                req += '\n';
	            }
	            req += stat.data(arr, i);
	        }
	        return req;
	    };
	    ODataAdaptor.prototype.processBatchResponse = function (data, query, xhr, request, changes) {
	        if (xhr && xhr.headers.get('Content-Type') && xhr.headers.get('Content-Type').indexOf('xml') !== -1) {
	            return (query.isCountRequired ? { result: [], count: 0 } : []);
	        }
	        if (request && this.options.batch && DataUtil.endsWith(request.url, this.options.batch) && request.type.toLowerCase() === 'post') {
	            var guid = xhr.headers.get('Content-Type');
	            var cIdx = void 0;
	            var jsonObj = void 0;
	            var d = data + '';
	            guid = guid.substring(guid.indexOf('=batchresponse') + 1);
	            d = d.split(guid);
	            if (d.length < 2) {
	                return {};
	            }
	            d = d[1];
	            var exVal = /(?:\bContent-Type.+boundary=)(changesetresponse.+)/i.exec(d);
	            if (exVal) {
	                d.replace(exVal[0], '');
	            }
	            var changeGuid = exVal ? exVal[1] : '';
	            d = d.split(changeGuid);
	            for (var i = d.length; i > -1; i--) {
	                if (!/\bContent-ID:/i.test(d[i]) || !/\bHTTP.+201/.test(d[i])) {
	                    continue;
	                }
	                cIdx = parseInt(/\bContent-ID: (\d+)/i.exec(d[i])[1], 10);
	                if (changes.addedRecords[cIdx]) {
	                    jsonObj = DataUtil.parse.parseJson(/^\{.+\}/m.exec(d[i])[0]);
	                    extend({}, changes.addedRecords[cIdx], this.processResponse(jsonObj));
	                }
	            }
	            return changes;
	        }
	        return null;
	    };
	    ODataAdaptor.prototype.compareAndRemove = function (data, original, key) {
	        var _this = this;
	        if (isNullOrUndefined(original)) {
	            return data;
	        }
	        Object.keys(data).forEach(function (prop) {
	            if (prop !== key && prop !== '@odata.etag') {
	                if (DataUtil.isPlainObject(data[prop])) {
	                    _this.compareAndRemove(data[prop], original[prop]);
	                    var final = Object.keys(data[prop]).filter(function (data) { return data !== '@odata.etag'; });
	                    if (final.length === 0) {
	                        delete data[prop];
	                    }
	                }
	                else if (data[prop] === original[prop]) {
	                    delete data[prop];
	                }
	                else if (data[prop] && original[prop] && data[prop].valueOf() === original[prop].valueOf()) {
	                    delete data[prop];
	                }
	            }
	        });
	        return data;
	    };
	    return ODataAdaptor;
	}(UrlAdaptor));
	/**
	 * The OData v4 is an improved version of OData protocols.
	 * The DataManager uses the ODataV4Adaptor to consume OData v4 services.
	 *
	 * @hidden
	 */
	/** @class */ ((function (_super) {
	    __extends$E(ODataV4Adaptor, _super);
	    function ODataV4Adaptor(props) {
	        var _this = _super.call(this, props) || this;
	        // options replaced the default adaptor options
	        _this.options = extend({}, _this.options, {
	            requestType: 'get',
	            accept: 'application/json, text/javascript, */*; q=0.01',
	            multipartAccept: 'multipart/mixed',
	            sortBy: '$orderby',
	            select: '$select',
	            skip: '$skip',
	            take: '$top',
	            count: '$count',
	            search: '$search',
	            where: '$filter',
	            expand: '$expand',
	            batch: '$batch',
	            changeSet: '--changeset_',
	            batchPre: 'batch_',
	            contentId: 'Content-Id: ',
	            batchContent: 'Content-Type: multipart/mixed; boundary=',
	            changeSetContent: 'Content-Type: application/http\nContent-Transfer-Encoding: binary ',
	            batchChangeSetContentType: 'Content-Type: application/json; charset=utf-8 ',
	            updateType: 'PATCH',
	            localTime: false,
	            apply: '$apply'
	        });
	        extend(_this.options, props || {});
	        return _this;
	    }
	    /**
	     * @hidden
	     */
	    ODataV4Adaptor.prototype.getModuleName = function () {
	        return 'ODataV4Adaptor';
	    };
	    /**
	     * Returns the query string which requests total count from the data source.
	     *
	     * @param  {boolean} e
	     * @returns string
	     */
	    ODataV4Adaptor.prototype.onCount = function (e) {
	        return e === true ? 'true' : '';
	    };
	    /**
	     * Generate request string based on the filter criteria from query.
	     *
	     * @param {Predicate} pred
	     * @param {boolean} requiresCast?
	     * @param predicate
	     * @param query
	     * @param requiresCast
	     */
	    ODataV4Adaptor.prototype.onPredicate = function (predicate, query, requiresCast) {
	        var returnValue = '';
	        var val = predicate.value;
	        var isDate = val instanceof Date;
	        if (query instanceof Query) {
	            var queries = this.getQueryRequest(query);
	            for (var i = 0; i < queries.filters.length; i++) {
	                if (queries.filters[i].e.key === predicate.value) {
	                    requiresCast = true;
	                }
	            }
	        }
	        returnValue = _super.prototype.onPredicate.call(this, predicate, query, requiresCast);
	        if (isDate) {
	            returnValue = returnValue.replace(/datetime'(.*)'$/, '$1');
	        }
	        if (DataUtil.parse.isGuid(val)) {
	            returnValue = returnValue.replace('guid', '').replace(/'/g, '');
	        }
	        return returnValue;
	    };
	    /**
	     * Generate query string based on the multiple search criteria from query.
	     *
	     * @param e
	     * @param {string} operator
	     * @param {string} key
	     * @param {boolean} } ignoreCase
	     * @param e.fields
	     * @param e.operator
	     * @param e.key
	     * @param e.ignoreCase
	     */
	    ODataV4Adaptor.prototype.onEachSearch = function (e) {
	        var search = this.pvt.searches || [];
	        search.push(e.key);
	        this.pvt.searches = search;
	    };
	    /**
	     *  Generate query string based on the search criteria from query.
	     *
	     * @param  {Object} e
	     */
	    ODataV4Adaptor.prototype.onSearch = function (e) {
	        return this.pvt.searches.join(' OR ');
	    };
	    /**
	     * Returns the expand query string.
	     *
	     * @param {string} e
	     * @param e.selects
	     * @param e.expands
	     */
	    ODataV4Adaptor.prototype.onExpand = function (e) {
	        var _this = this;
	        var selected = {};
	        var expanded = {};
	        var expands = e.expands.slice();
	        var exArr = [];
	        var selects = e.selects.filter(function (item) { return item.indexOf('.') > -1; });
	        selects.forEach(function (select) {
	            var splits = select.split('.');
	            if (!(splits[0] in selected)) {
	                selected[splits[0]] = [];
	            }
	            if (splits.length === 2) {
	                if (selected[splits[0]].length && Object.keys(selected).indexOf(splits[0]) !== -1) {
	                    if (selected[splits[0]][0].indexOf('$expand') !== -1 && selected[splits[0]][0].indexOf(';$select=') === -1) {
	                        selected[splits[0]][0] = selected[splits[0]][0] + ';' + '$select=' + splits[1];
	                    }
	                    else {
	                        selected[splits[0]][0] = selected[splits[0]][0] + ',' + splits[1];
	                    }
	                }
	                else {
	                    selected[splits[0]].push('$select=' + splits[1]);
	                }
	            }
	            else {
	                var sel = '$select=' + splits[splits.length - 1];
	                var exp = '';
	                var close_1 = '';
	                for (var i = 1; i < splits.length - 1; i++) {
	                    exp = exp + '$expand=' + splits[i] + '(';
	                    close_1 = close_1 + ')';
	                }
	                var combineVal = exp + sel + close_1;
	                if (selected[splits[0]].length && Object.keys(selected).indexOf(splits[0]) !== -1 &&
	                    _this.expandQueryIndex(selected[splits[0]], true)) {
	                    var idx = _this.expandQueryIndex(selected[splits[0]]);
	                    selected[splits[0]][idx] = selected[splits[0]][idx] + combineVal.replace('$expand=', ',');
	                }
	                else {
	                    selected[splits[0]].push(combineVal);
	                }
	            }
	        });
	        //Auto expand from select query
	        Object.keys(selected).forEach(function (expand) {
	            if ((expands.indexOf(expand) === -1)) {
	                expands.push(expand);
	            }
	        });
	        expands.forEach(function (expand) {
	            expanded[expand] = expand in selected ? expand + "(" + selected[expand].join(';') + ")" : expand;
	        });
	        Object.keys(expanded).forEach(function (ex) { return exArr.push(expanded[ex]); });
	        return exArr.join(',');
	    };
	    ODataV4Adaptor.prototype.expandQueryIndex = function (query, isExpand) {
	        for (var i = 0; i < query.length; i++) {
	            if (query[i].indexOf('$expand') !== -1) {
	                return isExpand ? true : i;
	            }
	        }
	        return isExpand ? false : 0;
	    };
	    /**
	     * Returns the groupby query string.
	     *
	     * @param {string} e
	     * @param distinctFields
	     */
	    ODataV4Adaptor.prototype.onDistinct = function (distinctFields) {
	        var fields = distinctFields.map(function (field) { return ODataAdaptor.getField(field); }).join(',');
	        return "groupby((" + fields + "))";
	    };
	    /**
	     * Returns the select query string.
	     *
	     * @param  {string[]} e
	     */
	    ODataV4Adaptor.prototype.onSelect = function (e) {
	        return _super.prototype.onSelect.call(this, e.filter(function (item) { return item.indexOf('.') === -1; }));
	    };
	    /**
	     * Method will trigger before send the request to server side.
	     * Used to set the custom header or modify the request options.
	     *
	     * @param  {DataManager} dm
	     * @param  {Request} request
	     * @param  {Fetch} settings
	     * @returns void
	     */
	    ODataV4Adaptor.prototype.beforeSend = function (dm, request, settings) {
	        if (settings.type === 'POST' || settings.type === 'PUT' || settings.type === 'PATCH') {
	            request.headers.set('Prefer', 'return=representation');
	        }
	        request.headers.set('Accept', this.options.accept);
	    };
	    /**
	     * Returns the data from the query processing.
	     *
	     * @param {DataResult} data
	     * @param {DataOptions} ds?
	     * @param {Query} query?
	     * @param {Request} xhr?
	     * @param {Fetch} request?
	     * @param {CrudOptions} changes?
	     * @param ds
	     * @param query
	     * @param xhr
	     * @param request
	     * @param changes
	     * @returns aggregateResult
	     */
	    ODataV4Adaptor.prototype.processResponse = function (data, ds, query, xhr, request, changes) {
	        var metaName = '@odata.context';
	        var metaV4Name = '@context';
	        if ((request && request.type === 'GET') && !this.rootUrl && (data[metaName] || data[metaV4Name])) {
	            var dataUrl = data[metaName] ? data[metaName].split('/$metadata#') : data[metaV4Name].split('/$metadata#');
	            this.rootUrl = dataUrl[0];
	            this.resourceTableName = dataUrl[1];
	        }
	        var pvtData = 'pvtData';
	        var pvt = request && request[pvtData];
	        var emptyAndBatch = _super.prototype.processBatchResponse.call(this, data, query, xhr, request, changes);
	        if (emptyAndBatch) {
	            return emptyAndBatch;
	        }
	        var count = null;
	        var dataCount = '@odata.count';
	        var dataV4Count = '@count';
	        if (query && query.isCountRequired) {
	            if (dataCount in data) {
	                count = data[dataCount];
	            }
	            else if (dataV4Count in data) {
	                count = data[dataV4Count];
	            }
	        }
	        data = !isNullOrUndefined(data.value) ? data.value : data;
	        var args = {};
	        args.count = count;
	        args.result = data;
	        this.getAggregateResult(pvt, data, args, null, query);
	        return DataUtil.isNull(count) ? args.result : { result: args.result, count: count, aggregates: args.aggregates };
	    };
	    return ODataV4Adaptor;
	})(ODataAdaptor));
	/**
	 * The Web API is a programmatic interface to define the request and response messages system that is mostly exposed in JSON or XML.
	 * The DataManager uses the WebApiAdaptor to consume Web API.
	 * Since this adaptor is targeted to interact with Web API created using OData endpoint, it is extended from ODataAdaptor
	 *
	 * @hidden
	 */
	/** @class */ ((function (_super) {
	    __extends$E(WebApiAdaptor, _super);
	    function WebApiAdaptor() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    WebApiAdaptor.prototype.getModuleName = function () {
	        return 'WebApiAdaptor';
	    };
	    /**
	     * Prepare and returns request body which is used to insert a new record in the table.
	     *
	     * @param {DataManager} dm
	     * @param {Object} data
	     * @param {string} tableName?
	     * @param tableName
	     */
	    WebApiAdaptor.prototype.insert = function (dm, data, tableName) {
	        return {
	            type: 'POST',
	            url: dm.dataSource.url,
	            data: JSON.stringify(data)
	        };
	    };
	    /**
	     * Prepare and return request body which is used to remove record from the table.
	     *
	     * @param {DataManager} dm
	     * @param {string} keyField
	     * @param {number} value
	     * @param {string} tableName?
	     * @param tableName
	     */
	    WebApiAdaptor.prototype.remove = function (dm, keyField, value, tableName) {
	        return {
	            type: 'DELETE',
	            url: dm.dataSource.url + '/' + value,
	            data: JSON.stringify(value)
	        };
	    };
	    /**
	     * Prepare and return request body which is used to update record.
	     *
	     * @param {DataManager} dm
	     * @param {string} keyField
	     * @param {Object} value
	     * @param {string} tableName?
	     * @param tableName
	     */
	    WebApiAdaptor.prototype.update = function (dm, keyField, value, tableName) {
	        return {
	            type: 'PUT',
	            url: dm.dataSource.url,
	            data: JSON.stringify(value)
	        };
	    };
	    WebApiAdaptor.prototype.batchRequest = function (dm, changes, e) {
	        var _this = this;
	        var initialGuid = e.guid = DataUtil.getGuid(this.options.batchPre);
	        var url = dm.dataSource.url.replace(/\/*$/, '/' + this.options.batch);
	        e.url = this.resourceTableName ? this.resourceTableName : e.url;
	        var req = [];
	        var _loop_1 = function (i, x) {
	            changes.addedRecords.forEach(function (j, d) {
	                var stat = {
	                    'method': 'POST ',
	                    'url': function (data, i, key) { return ''; },
	                    'data': function (data, i) { return JSON.stringify(data[i]) + '\n\n'; }
	                };
	                req.push('--' + initialGuid);
	                req.push('Content-Type: application/http; msgtype=request', '');
	                req.push('POST ' + '/api/' + (dm.dataSource.insertUrl || dm.dataSource.crudUrl || e.url)
	                    + stat.url(changes.addedRecords, i, e.key) + ' HTTP/1.1');
	                req.push('Content-Type: ' + 'application/json; charset=utf-8');
	                req.push('Host: ' + location.host);
	                req.push('', j ? JSON.stringify(j) : '');
	            });
	        };
	        //insertion
	        for (var i = 0, x = changes.addedRecords.length; i < x; i++) {
	            _loop_1(i);
	        }
	        var _loop_2 = function (i, x) {
	            changes.changedRecords.forEach(function (j, d) {
	                var stat = {
	                    'method': _this.options.updateType + ' ',
	                    'url': function (data, i, key) { return ''; },
	                    'data': function (data, i) { return JSON.stringify(data[i]) + '\n\n'; }
	                };
	                req.push('--' + initialGuid);
	                req.push('Content-Type: application/http; msgtype=request', '');
	                req.push('PUT ' + '/api/' + (dm.dataSource.updateUrl || dm.dataSource.crudUrl || e.url)
	                    + stat.url(changes.changedRecords, i, e.key) + ' HTTP/1.1');
	                req.push('Content-Type: ' + 'application/json; charset=utf-8');
	                req.push('Host: ' + location.host);
	                req.push('', j ? JSON.stringify(j) : '');
	            });
	        };
	        //updation
	        for (var i = 0, x = changes.changedRecords.length; i < x; i++) {
	            _loop_2(i);
	        }
	        var _loop_3 = function (i, x) {
	            changes.deletedRecords.forEach(function (j, d) {
	                var state = {
	                    'mtd': 'DELETE ',
	                    'url': function (data, i, key) {
	                        var url = DataUtil.getObject(key, data[i]);
	                        if (typeof url === 'number' || DataUtil.parse.isGuid(url)) {
	                            return '/' + url;
	                        }
	                        else if (url instanceof Date) {
	                            var datTime = data[i][key];
	                            return '/' + datTime.toJSON();
	                        }
	                        else {
	                            return "/'" + url + "'";
	                        }
	                    },
	                    'data': function (data, i) { return ''; }
	                };
	                req.push('--' + initialGuid);
	                req.push('Content-Type: application/http; msgtype=request', '');
	                req.push('DELETE ' + '/api/' + (dm.dataSource.removeUrl || dm.dataSource.crudUrl || e.url)
	                    + state.url(changes.deletedRecords, i, e.key) + ' HTTP/1.1');
	                req.push('Content-Type: ' + 'application/json; charset=utf-8');
	                req.push('Host: ' + location.host);
	                req.push('', j ? JSON.stringify(j) : '');
	            });
	        };
	        //deletion
	        for (var i = 0, x = changes.deletedRecords.length; i < x; i++) {
	            _loop_3(i);
	        }
	        req.push('--' + initialGuid + '--', '');
	        return {
	            type: 'POST',
	            url: url,
	            contentType: 'multipart/mixed; boundary=' + initialGuid,
	            data: req.join('\r\n')
	        };
	    };
	    /**
	     * Method will trigger before send the request to server side.
	     * Used to set the custom header or modify the request options.
	     *
	     * @param  {DataManager} dm
	     * @param  {Request} request
	     * @param  {Fetch} settings
	     * @returns void
	     */
	    WebApiAdaptor.prototype.beforeSend = function (dm, request, settings) {
	        request.headers.set('Accept', 'application/json, text/javascript, */*; q=0.01');
	    };
	    /**
	     * Returns the data from the query processing.
	     *
	     * @param {DataResult} data
	     * @param {DataOptions} ds?
	     * @param {Query} query?
	     * @param {Request} xhr?
	     * @param {Fetch} request?
	     * @param {CrudOptions} changes?
	     * @param ds
	     * @param query
	     * @param xhr
	     * @param request
	     * @param changes
	     * @returns aggregateResult
	     */
	    WebApiAdaptor.prototype.processResponse = function (data, ds, query, xhr, request, changes) {
	        var pvtData = 'pvtData';
	        var pvt = request && request[pvtData];
	        var count = null;
	        var args = {};
	        if (request && request.type.toLowerCase() !== 'post') {
	            var versionCheck = xhr && request.fetchRequest.headers.get('DataServiceVersion');
	            var version = (versionCheck && parseInt(versionCheck, 10)) || 2;
	            if (query && query.isCountRequired) {
	                if (!DataUtil.isNull(data.Count)) {
	                    count = data.Count;
	                }
	            }
	            if (version < 3 && data.Items) {
	                data = data.Items;
	            }
	            args.count = count;
	            args.result = data;
	            this.getAggregateResult(pvt, data, args, null, query);
	        }
	        args.result = args.result || data;
	        return DataUtil.isNull(count) ? args.result : { result: args.result, count: args.count, aggregates: args.aggregates };
	    };
	    return WebApiAdaptor;
	})(ODataAdaptor));
	/**
	 * WebMethodAdaptor can be used by DataManager to interact with web method.
	 *
	 * @hidden
	 */
	/** @class */ ((function (_super) {
	    __extends$E(WebMethodAdaptor, _super);
	    function WebMethodAdaptor() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * Prepare the request body based on the query.
	     * The query information can be accessed at the WebMethod using variable named `value`.
	     *
	     * @param {DataManager} dm
	     * @param {Query} query
	     * @param {Object[]} hierarchyFilters?
	     * @param hierarchyFilters
	     * @returns application
	     */
	    WebMethodAdaptor.prototype.processQuery = function (dm, query, hierarchyFilters) {
	        var obj = new UrlAdaptor().processQuery(dm, query, hierarchyFilters);
	        var getData = 'data';
	        var data = DataUtil.parse.parseJson(obj[getData]);
	        var result = {};
	        var value = 'value';
	        if (data.param) {
	            for (var i = 0; i < data.param.length; i++) {
	                var param = data.param[i];
	                var key = Object.keys(param)[0];
	                result[key] = param[key];
	            }
	        }
	        result[value] = data;
	        var pvtData = 'pvtData';
	        var url = 'url';
	        return {
	            data: JSON.stringify(result),
	            url: obj[url],
	            pvtData: obj[pvtData],
	            type: 'POST',
	            contentType: 'application/json; charset=utf-8'
	        };
	    };
	    return WebMethodAdaptor;
	})(UrlAdaptor));
	/**
	 * RemoteSaveAdaptor, extended from JsonAdaptor and it is used for binding local data and performs all DataManager queries in client-side.
	 * It interacts with server-side only for CRUD operations.
	 *
	 * @hidden
	 */
	var RemoteSaveAdaptor = /** @class */ (function (_super) {
	    __extends$E(RemoteSaveAdaptor, _super);
	    /**
	     * @hidden
	     */
	    function RemoteSaveAdaptor() {
	        var _this = _super.call(this) || this;
	        setValue('beforeSend', UrlAdaptor.prototype.beforeSend, _this);
	        return _this;
	    }
	    RemoteSaveAdaptor.prototype.insert = function (dm, data, tableName, query, position) {
	        this.pvt.position = position;
	        this.updateType = 'add';
	        return {
	            url: dm.dataSource.insertUrl || dm.dataSource.crudUrl || dm.dataSource.url,
	            data: JSON.stringify(extend({}, {
	                value: data,
	                table: tableName,
	                action: 'insert'
	            }, DataUtil.getAddParams(this, dm, query)))
	        };
	    };
	    RemoteSaveAdaptor.prototype.remove = function (dm, keyField, val, tableName, query) {
	        _super.prototype.remove.call(this, dm, keyField, val);
	        return {
	            type: 'POST',
	            url: dm.dataSource.removeUrl || dm.dataSource.crudUrl || dm.dataSource.url,
	            data: JSON.stringify(extend({}, {
	                key: val,
	                keyColumn: keyField,
	                table: tableName,
	                action: 'remove'
	            }, DataUtil.getAddParams(this, dm, query)))
	        };
	    };
	    RemoteSaveAdaptor.prototype.update = function (dm, keyField, val, tableName, query) {
	        this.updateType = 'update';
	        this.updateKey = keyField;
	        return {
	            type: 'POST',
	            url: dm.dataSource.updateUrl || dm.dataSource.crudUrl || dm.dataSource.url,
	            data: JSON.stringify(extend({}, {
	                value: val,
	                action: 'update',
	                keyColumn: keyField,
	                key: val[keyField],
	                table: tableName
	            }, DataUtil.getAddParams(this, dm, query)))
	        };
	    };
	    RemoteSaveAdaptor.prototype.processResponse = function (data, ds, query, xhr, request, changes, e) {
	        var i;
	        var newData = request ? JSON.parse(request.data) : data;
	        data = newData.action === 'batch' ? DataUtil.parse.parseJson(data) : data;
	        if (this.updateType === 'add') {
	            _super.prototype.insert.call(this, ds, data, null, null, this.pvt.position);
	        }
	        if (this.updateType === 'update') {
	            _super.prototype.update.call(this, ds, this.updateKey, data);
	        }
	        this.updateType = undefined;
	        if (data.added) {
	            for (i = 0; i < data.added.length; i++) {
	                _super.prototype.insert.call(this, ds, data.added[i]);
	            }
	        }
	        if (data.changed) {
	            for (i = 0; i < data.changed.length; i++) {
	                _super.prototype.update.call(this, ds, e.key, data.changed[i]);
	            }
	        }
	        if (data.deleted) {
	            for (i = 0; i < data.deleted.length; i++) {
	                _super.prototype.remove.call(this, ds, e.key, data.deleted[i]);
	            }
	        }
	        return data;
	    };
	    /**
	     * Prepare the request body based on the newly added, removed and updated records.
	     * Also perform the changes in the locally cached data to sync with the remote data.
	     * The result is used by the batch request.
	     *
	     * @param {DataManager} dm
	     * @param {CrudOptions} changes
	     * @param {RemoteArgs} e
	     * @param query
	     * @param original
	     */
	    RemoteSaveAdaptor.prototype.batchRequest = function (dm, changes, e, query, original) {
	        return {
	            type: 'POST',
	            url: dm.dataSource.batchUrl || dm.dataSource.crudUrl || dm.dataSource.url,
	            contentType: 'application/json; charset=utf-8',
	            dataType: 'json',
	            data: JSON.stringify(extend({}, {
	                changed: changes.changedRecords,
	                added: changes.addedRecords,
	                deleted: changes.deletedRecords,
	                action: 'batch',
	                table: e.url,
	                key: e.key
	            }, DataUtil.getAddParams(this, dm, query)))
	        };
	    };
	    RemoteSaveAdaptor.prototype.addParams = function (options) {
	        var urlParams = new UrlAdaptor();
	        urlParams.addParams(options);
	    };
	    return RemoteSaveAdaptor;
	}(JsonAdaptor));
	/**
	 * Fetch Adaptor that is extended from URL Adaptor, is used for handle data operations with user defined functions.
	 *
	 * @hidden
	 */
	var CustomDataAdaptor = /** @class */ (function (_super) {
	    __extends$E(CustomDataAdaptor, _super);
	    function CustomDataAdaptor(props) {
	        var _this = _super.call(this) || this;
	        // options replaced the default adaptor options
	        _this.options = extend({}, _this.options, {
	            getData: new Function(),
	            addRecord: new Function(),
	            updateRecord: new Function(),
	            deleteRecord: new Function(),
	            batchUpdate: new Function()
	        });
	        extend(_this.options, props || {});
	        return _this;
	    }
	    CustomDataAdaptor.prototype.getModuleName = function () {
	        return 'CustomDataAdaptor';
	    };
	    return CustomDataAdaptor;
	}(UrlAdaptor));
	/**
	 * The GraphqlAdaptor that is extended from URL Adaptor, is used for retrieving data from the Graphql server.
	 * It interacts with the Graphql server with all the DataManager Queries and performs CRUD operations.
	 *
	 * @hidden
	 */
	/** @class */ ((function (_super) {
	    __extends$E(GraphQLAdaptor, _super);
	    function GraphQLAdaptor(options) {
	        var _this = _super.call(this) || this;
	        _this.opt = options;
	        _this.schema = _this.opt.response;
	        _this.query = _this.opt.query;
	        /* eslint-disable @typescript-eslint/no-empty-function */
	        // tslint:disable-next-line:no-empty
	        _this.getVariables = _this.opt.getVariables ? _this.opt.getVariables : function () { };
	        /* eslint-enable @typescript-eslint/no-empty-function */
	        _this.getQuery = function () { return _this.query; };
	        return _this;
	    }
	    GraphQLAdaptor.prototype.getModuleName = function () {
	        return 'GraphQLAdaptor';
	    };
	    /**
	     * Process the JSON data based on the provided queries.
	     *
	     * @param {DataManager} dm
	     * @param {Query} query?
	     * @param datamanager
	     * @param query
	     */
	    GraphQLAdaptor.prototype.processQuery = function (datamanager, query) {
	        var urlQuery = _super.prototype.processQuery.apply(this, arguments);
	        var dm = JSON.parse(urlQuery.data);
	        // constructing GraphQL parameters
	        var keys = ['skip', 'take', 'sorted', 'table', 'select', 'where',
	            'search', 'requiresCounts', 'aggregates', 'params'];
	        var temp = {};
	        var str = 'searchwhereparams';
	        keys.filter(function (e) {
	            temp[e] = str.indexOf(e) > -1 ? JSON.stringify(dm[e]) : dm[e];
	        });
	        var vars = this.getVariables() || {};
	        // tslint:disable-next-line:no-string-literal
	        vars['datamanager'] = temp;
	        var data = JSON.stringify({
	            query: this.getQuery(),
	            variables: vars
	        });
	        urlQuery.data = data;
	        return urlQuery;
	    };
	    /**
	     * Returns the data from the query processing.
	     * It will also cache the data for later usage.
	     *
	     * @param {DataResult} data
	     * @param {DataManager} ds?
	     * @param {Query} query?
	     * @param {Request} xhr?
	     * @param {Object} request?
	     * @param resData
	     * @param ds
	     * @param query
	     * @param xhr
	     * @param request
	     * @returns DataResult
	     */
	    GraphQLAdaptor.prototype.processResponse = function (resData, ds, query, xhr, request) {
	        var res = resData;
	        var count;
	        var aggregates;
	        var result = getValue(this.schema.result, res.data);
	        if (this.schema.count) {
	            count = getValue(this.schema.count, res.data);
	        }
	        if (this.schema.aggregates) {
	            aggregates = getValue(this.schema.aggregates, res.data);
	            aggregates = !isNullOrUndefined(aggregates) ? DataUtil.parse.parseJson(aggregates) : aggregates;
	        }
	        var pvt = request.pvtData || {};
	        var args = { result: result, aggregates: aggregates };
	        var data = args;
	        if (pvt && pvt.groups && pvt.groups.length) {
	            this.getAggregateResult(pvt, data, args, null, query);
	        }
	        return !isNullOrUndefined(count) ? { result: args.result, count: count, aggregates: aggregates } : args.result;
	    };
	    /**
	     * Prepare and returns request body which is used to insert a new record in the table.
	     */
	    GraphQLAdaptor.prototype.insert = function () {
	        var inserted = _super.prototype.insert.apply(this, arguments);
	        return this.generateCrudData(inserted, 'insert');
	    };
	    /**
	     * Prepare and returns request body which is used to update a new record in the table.
	     */
	    GraphQLAdaptor.prototype.update = function () {
	        var inserted = _super.prototype.update.apply(this, arguments);
	        return this.generateCrudData(inserted, 'update');
	    };
	    /**
	     * Prepare and returns request body which is used to remove a new record in the table.
	     */
	    GraphQLAdaptor.prototype.remove = function () {
	        var inserted = _super.prototype.remove.apply(this, arguments);
	        return this.generateCrudData(inserted, 'remove');
	    };
	    /**
	     * Prepare the request body based on the newly added, removed and updated records.
	     * The result is used by the batch request.
	     *
	     * @param {DataManager} dm
	     * @param {CrudOptions} changes
	     * @param {Object} e
	     * @param e.key
	     * @param {Query} query
	     * @param {Object} original
	     */
	    GraphQLAdaptor.prototype.batchRequest = function (dm, changes, e, query, original) {
	        var batch = _super.prototype.batchRequest.apply(this, arguments);
	        // tslint:disable-next-line:typedef
	        var bData = JSON.parse(batch.data);
	        bData.key = e.key;
	        batch.data = JSON.stringify(bData);
	        return this.generateCrudData(batch, 'batch');
	    };
	    GraphQLAdaptor.prototype.generateCrudData = function (crudData, action) {
	        var parsed = JSON.parse(crudData.data);
	        crudData.data = JSON.stringify({
	            query: this.opt.getMutation(action),
	            variables: parsed
	        });
	        return crudData;
	    };
	    return GraphQLAdaptor;
	})(UrlAdaptor));
	/**
	 * Cache Adaptor is used to cache the data of the visited pages. It prevents new requests for the previously visited pages.
	 * You can configure cache page size and duration of caching by using cachingPageSize and timeTillExpiration properties of the DataManager
	 *
	 * @hidden
	 */
	var CacheAdaptor = /** @class */ (function (_super) {
	    __extends$E(CacheAdaptor, _super);
	    /**
	     * Constructor for CacheAdaptor class.
	     *
	     * @param {CacheAdaptor} adaptor?
	     * @param {number} timeStamp?
	     * @param {number} pageSize?
	     * @param adaptor
	     * @param timeStamp
	     * @param pageSize
	     * @hidden
	     */
	    function CacheAdaptor(adaptor, timeStamp, pageSize) {
	        var _this = _super.call(this) || this;
	        _this.isCrudAction = false;
	        _this.isInsertAction = false;
	        if (!isNullOrUndefined(adaptor)) {
	            _this.cacheAdaptor = adaptor;
	        }
	        _this.pageSize = pageSize;
	        _this.guidId = DataUtil.getGuid('cacheAdaptor');
	        var obj = { keys: [], results: [] };
	        window.localStorage.setItem(_this.guidId, JSON.stringify(obj));
	        var guid = _this.guidId;
	        if (!isNullOrUndefined(timeStamp)) {
	            setInterval(function () {
	                var data = DataUtil.parse.parseJson(window.localStorage.getItem(guid));
	                var forDel = [];
	                for (var i = 0; i < data.results.length; i++) {
	                    var currentTime = +new Date();
	                    var requestTime = +new Date(data.results[i].timeStamp);
	                    data.results[i].timeStamp = currentTime - requestTime;
	                    if (currentTime - requestTime > timeStamp) {
	                        forDel.push(i);
	                    }
	                }
	                for (var i = 0; i < forDel.length; i++) {
	                    data.results.splice(forDel[i], 1);
	                    data.keys.splice(forDel[i], 1);
	                }
	                window.localStorage.removeItem(guid);
	                window.localStorage.setItem(guid, JSON.stringify(data));
	            }, timeStamp);
	        }
	        return _this;
	    }
	    /**
	     * It will generate the key based on the URL when we send a request to server.
	     *
	     * @param {string} url
	     * @param {Query} query?
	     * @param query
	     * @hidden
	     */
	    CacheAdaptor.prototype.generateKey = function (url, query) {
	        var queries = this.getQueryRequest(query);
	        var singles = Query.filterQueryLists(query.queries, ['onSelect', 'onPage', 'onSkip', 'onTake', 'onRange']);
	        var key = url;
	        var page = 'onPage';
	        if (page in singles) {
	            key += singles[page].pageIndex;
	        }
	        queries.sorts.forEach(function (obj) {
	            key += obj.e.direction + obj.e.fieldName;
	        });
	        queries.groups.forEach(function (obj) {
	            key += obj.e.fieldName;
	        });
	        queries.searches.forEach(function (obj) {
	            key += obj.e.searchKey;
	        });
	        for (var filter = 0; filter < queries.filters.length; filter++) {
	            var currentFilter = queries.filters[filter];
	            if (currentFilter.e.isComplex) {
	                var newQuery = query.clone();
	                newQuery.queries = [];
	                for (var i = 0; i < currentFilter.e.predicates.length; i++) {
	                    newQuery.queries.push({ fn: 'onWhere', e: currentFilter.e.predicates[i], filter: query.queries.filter });
	                }
	                key += currentFilter.e.condition + this.generateKey(url, newQuery);
	            }
	            else {
	                key += currentFilter.e.field + currentFilter.e.operator + currentFilter.e.value;
	            }
	        }
	        return key;
	    };
	    /**
	     * Process the query to generate request body.
	     * If the data is already cached, it will return the cached data.
	     *
	     * @param {DataManager} dm
	     * @param {Query} query?
	     * @param {Object[]} hierarchyFilters?
	     * @param query
	     * @param hierarchyFilters
	     */
	    CacheAdaptor.prototype.processQuery = function (dm, query, hierarchyFilters) {
	        var key = this.generateKey(dm.dataSource.url, query);
	        var cachedItems = DataUtil.parse.parseJson(window.localStorage.getItem(this.guidId));
	        var data = cachedItems ? cachedItems.results[cachedItems.keys.indexOf(key)] : null;
	        if (data != null && !this.isCrudAction && !this.isInsertAction) {
	            return data;
	        }
	        this.isCrudAction = null;
	        this.isInsertAction = null;
	        /* eslint-disable prefer-spread */
	        return this.cacheAdaptor.processQuery.apply(this.cacheAdaptor, [].slice.call(arguments, 0));
	        /* eslint-enable prefer-spread */
	    };
	    /**
	     * Returns the data from the query processing.
	     * It will also cache the data for later usage.
	     *
	     * @param {DataResult} data
	     * @param {DataManager} ds?
	     * @param {Query} query?
	     * @param {Request} xhr?
	     * @param {Fetch} request?
	     * @param {CrudOptions} changes?
	     * @param ds
	     * @param query
	     * @param xhr
	     * @param request
	     * @param changes
	     */
	    CacheAdaptor.prototype.processResponse = function (data, ds, query, xhr, request, changes) {
	        if (this.isInsertAction || (request && this.cacheAdaptor.options.batch &&
	            DataUtil.endsWith(request.url, this.cacheAdaptor.options.batch) && request.type.toLowerCase() === 'post')) {
	            return this.cacheAdaptor.processResponse(data, ds, query, xhr, request, changes);
	        }
	        /* eslint-disable prefer-spread */
	        data = this.cacheAdaptor.processResponse.apply(this.cacheAdaptor, [].slice.call(arguments, 0));
	        /* eslint-enable prefer-spread */
	        var key = query ? this.generateKey(ds.dataSource.url, query) : ds.dataSource.url;
	        var obj = {};
	        obj = DataUtil.parse.parseJson(window.localStorage.getItem(this.guidId));
	        var index = obj.keys.indexOf(key);
	        if (index !== -1) {
	            obj.results.splice(index, 1);
	            obj.keys.splice(index, 1);
	        }
	        obj.results[obj.keys.push(key) - 1] = { keys: key, result: data.result, timeStamp: new Date(), count: data.count };
	        while (obj.results.length > this.pageSize) {
	            obj.results.splice(0, 1);
	            obj.keys.splice(0, 1);
	        }
	        window.localStorage.setItem(this.guidId, JSON.stringify(obj));
	        return data;
	    };
	    /**
	     * Method will trigger before send the request to server side. Used to set the custom header or modify the request options.
	     *
	     * @param {DataManager} dm
	     * @param {Request} request
	     * @param {Fetch} settings?
	     * @param settings
	     */
	    CacheAdaptor.prototype.beforeSend = function (dm, request, settings) {
	        if (!isNullOrUndefined(this.cacheAdaptor.options.batch) && DataUtil.endsWith(settings.url, this.cacheAdaptor.options.batch)
	            && settings.type.toLowerCase() === 'post') {
	            request.headers.set('Accept', this.cacheAdaptor.options.multipartAccept);
	        }
	        if (!dm.dataSource.crossDomain) {
	            request.headers.set('Accept', this.cacheAdaptor.options.accept);
	        }
	    };
	    /**
	     * Updates existing record and saves the changes to the table.
	     *
	     * @param  {DataManager} dm
	     * @param  {string} keyField
	     * @param  {Object} value
	     * @param  {string} tableName
	     */
	    CacheAdaptor.prototype.update = function (dm, keyField, value, tableName) {
	        this.isCrudAction = true;
	        return this.cacheAdaptor.update(dm, keyField, value, tableName);
	    };
	    /**
	     * Prepare and returns request body which is used to insert a new record in the table.
	     *
	     * @param {DataManager} dm
	     * @param {Object} data
	     * @param {string} tableName?
	     * @param tableName
	     */
	    CacheAdaptor.prototype.insert = function (dm, data, tableName) {
	        this.isInsertAction = true;
	        return this.cacheAdaptor.insert(dm, data, tableName);
	    };
	    /**
	     * Prepare and return request body which is used to remove record from the table.
	     *
	     * @param {DataManager} dm
	     * @param {string} keyField
	     * @param {Object} value
	     * @param {string} tableName?
	     * @param tableName
	     */
	    CacheAdaptor.prototype.remove = function (dm, keyField, value, tableName) {
	        this.isCrudAction = true;
	        return this.cacheAdaptor.remove(dm, keyField, value, tableName);
	    };
	    /**
	     * Prepare the request body based on the newly added, removed and updated records.
	     * The result is used by the batch request.
	     *
	     * @param  {DataManager} dm
	     * @param  {CrudOptions} changes
	     * @param  {RemoteArgs} e
	     */
	    CacheAdaptor.prototype.batchRequest = function (dm, changes, e) {
	        return this.cacheAdaptor.batchRequest(dm, changes, e);
	    };
	    return CacheAdaptor;
	}(UrlAdaptor));

	/* eslint-disable valid-jsdoc */
	/* eslint-disable security/detect-object-injection */
	/**
	 * DataManager is used to manage and manipulate relational data.
	 */
	var DataManager = /** @class */ (function () {
	    /**
	     * Constructor for DataManager class
	     *
	     * @param {DataOptions|JSON[]} dataSource?
	     * @param {Query} query?
	     * @param {AdaptorOptions|string} adaptor?
	     * @param dataSource
	     * @param query
	     * @param adaptor
	     * @hidden
	     */
	    function DataManager(dataSource, query, adaptor) {
	        var _this = this;
	        /** @hidden */
	        this.dateParse = true;
	        /** @hidden */
	        this.timeZoneHandling = true;
	        this.persistQuery = {};
	        this.isInitialLoad = false;
	        this.requests = [];
	        this.isInitialLoad = true;
	        if (!dataSource && !this.dataSource) {
	            dataSource = [];
	        }
	        adaptor = adaptor || dataSource.adaptor;
	        if (dataSource && dataSource.timeZoneHandling === false) {
	            this.timeZoneHandling = dataSource.timeZoneHandling;
	        }
	        var data;
	        if (dataSource instanceof Array) {
	            data = {
	                json: dataSource,
	                offline: true
	            };
	        }
	        else if (typeof dataSource === 'object') {
	            if (!dataSource.json) {
	                dataSource.json = [];
	            }
	            if (!dataSource.enablePersistence) {
	                dataSource.enablePersistence = false;
	            }
	            if (!dataSource.id) {
	                dataSource.id = '';
	            }
	            if (!dataSource.ignoreOnPersist) {
	                dataSource.ignoreOnPersist = [];
	            }
	            data = {
	                url: dataSource.url,
	                insertUrl: dataSource.insertUrl,
	                removeUrl: dataSource.removeUrl,
	                updateUrl: dataSource.updateUrl,
	                crudUrl: dataSource.crudUrl,
	                batchUrl: dataSource.batchUrl,
	                json: dataSource.json,
	                headers: dataSource.headers,
	                accept: dataSource.accept,
	                data: dataSource.data,
	                timeTillExpiration: dataSource.timeTillExpiration,
	                cachingPageSize: dataSource.cachingPageSize,
	                enableCaching: dataSource.enableCaching,
	                requestType: dataSource.requestType,
	                key: dataSource.key,
	                crossDomain: dataSource.crossDomain,
	                jsonp: dataSource.jsonp,
	                dataType: dataSource.dataType,
	                offline: dataSource.offline !== undefined ? dataSource.offline
	                    : dataSource.adaptor instanceof RemoteSaveAdaptor || dataSource.adaptor instanceof CustomDataAdaptor ?
	                        false : dataSource.url ? false : true,
	                requiresFormat: dataSource.requiresFormat,
	                enablePersistence: dataSource.enablePersistence,
	                id: dataSource.id,
	                ignoreOnPersist: dataSource.ignoreOnPersist
	            };
	        }
	        else {
	            DataUtil.throwError('DataManager: Invalid arguments');
	        }
	        if (data.requiresFormat === undefined && !DataUtil.isCors()) {
	            data.requiresFormat = isNullOrUndefined(data.crossDomain) ? true : data.crossDomain;
	        }
	        if (data.dataType === undefined) {
	            data.dataType = 'json';
	        }
	        this.dataSource = data;
	        this.defaultQuery = query;
	        if (this.dataSource.enablePersistence && this.dataSource.id) {
	            window.addEventListener('unload', this.setPersistData.bind(this));
	        }
	        if (data.url && data.offline && !data.json.length) {
	            this.isDataAvailable = false;
	            this.adaptor = adaptor || new ODataAdaptor();
	            this.dataSource.offline = false;
	            this.ready = this.executeQuery(query || new Query());
	            this.ready.then(function (e) {
	                _this.dataSource.offline = true;
	                _this.isDataAvailable = true;
	                data.json = e.result;
	                _this.adaptor = new JsonAdaptor();
	            });
	        }
	        else {
	            this.adaptor = data.offline ? new JsonAdaptor() : new ODataAdaptor();
	        }
	        if (!data.jsonp && this.adaptor instanceof ODataAdaptor) {
	            data.jsonp = 'callback';
	        }
	        this.adaptor = adaptor || this.adaptor;
	        if (data.enableCaching) {
	            this.adaptor = new CacheAdaptor(this.adaptor, data.timeTillExpiration, data.cachingPageSize);
	        }
	        return this;
	    }
	    /**
	     * Get the queries maintained in the persisted state.
	     * @param {string} id - The identifier of the persisted query to retrieve.
	     * @returns {object} The persisted data object.
	     */
	    DataManager.prototype.getPersistedData = function (id) {
	        var persistedData = localStorage.getItem(id || this.dataSource.id);
	        return JSON.parse(persistedData);
	    };
	    /**
	    * Set the queries to be maintained in the persisted state.
	    * @param {Event} e - The event parameter that triggers the setPersistData method.
	    * @param {string} id - The identifier of the persisted query to set.
	    * @param {object} persistData - The data to be persisted.
	    * @returns {void} .
	    */
	    DataManager.prototype.setPersistData = function (e, id, persistData) {
	        localStorage.setItem(id || this.dataSource.id, JSON.stringify(persistData || this.persistQuery));
	    };
	    DataManager.prototype.setPersistQuery = function (query) {
	        var _this = this;
	        var persistedQuery = this.getPersistedData();
	        if (this.isInitialLoad && persistedQuery && Object.keys(persistedQuery).length) {
	            this.persistQuery = persistedQuery;
	            this.persistQuery.queries = this.persistQuery.queries.filter(function (query) {
	                if (_this.dataSource.ignoreOnPersist && _this.dataSource.ignoreOnPersist.length) {
	                    if (query.fn && _this.dataSource.ignoreOnPersist.some(function (keyword) { return query.fn === keyword; })) {
	                        return false; // Exclude the matching query
	                    }
	                }
	                if (query.fn === 'onWhere') {
	                    var e = query.e;
	                    if (e && e.isComplex && e.predicates instanceof Array) {
	                        var allPredicates = e.predicates.map(function (predicateObj) {
	                            if (predicateObj.predicates && predicateObj.predicates instanceof Array) {
	                                // Process nested predicate array
	                                var nestedPredicates = predicateObj.predicates.map(function (nestedPredicate) {
	                                    var field = nestedPredicate.field, operator = nestedPredicate.operator, value = nestedPredicate.value, ignoreCase = nestedPredicate.ignoreCase, ignoreAccent = nestedPredicate.ignoreAccent, matchCase = nestedPredicate.matchCase;
	                                    return new Predicate(field, operator, value, ignoreCase, ignoreAccent, matchCase);
	                                });
	                                return predicateObj.condition === 'and' ? Predicate.and(nestedPredicates) : Predicate.or(nestedPredicates);
	                            }
	                            else {
	                                // Process individual predicate
	                                var field = predicateObj.field, operator = predicateObj.operator, value = predicateObj.value, ignoreCase = predicateObj.ignoreCase, ignoreAccent = predicateObj.ignoreAccent, matchCase = predicateObj.matchCase;
	                                return new Predicate(field, operator, value, ignoreCase, ignoreAccent, matchCase);
	                            }
	                        });
	                        query.e = new Predicate(allPredicates[0], e.condition, allPredicates.slice(1));
	                    }
	                }
	                return true; // Keep all other queries
	            });
	            var newQuery = extend(new Query(), this.persistQuery);
	            this.isInitialLoad = false;
	            return (newQuery);
	        }
	        else {
	            this.persistQuery = query;
	            this.isInitialLoad = false;
	            return query;
	        }
	    };
	    /**
	     * Overrides DataManager's default query with given query.
	     *
	     * @param  {Query} query - Defines the new default query.
	     */
	    DataManager.prototype.setDefaultQuery = function (query) {
	        this.defaultQuery = query;
	        return this;
	    };
	    /**
	     * Executes the given query with local data source.
	     *
	     * @param  {Query} query - Defines the query to retrieve data.
	     */
	    DataManager.prototype.executeLocal = function (query) {
	        if (!this.defaultQuery && !(query instanceof Query)) {
	            DataUtil.throwError('DataManager - executeLocal() : A query is required to execute');
	        }
	        if (!this.dataSource.json) {
	            DataUtil.throwError('DataManager - executeLocal() : Json data is required to execute');
	        }
	        if (this.dataSource.enablePersistence && this.dataSource.id) {
	            query = this.setPersistQuery(query);
	        }
	        query = query || this.defaultQuery;
	        var result = this.adaptor.processQuery(this, query);
	        if (query.subQuery) {
	            var from = query.subQuery.fromTable;
	            var lookup = query.subQuery.lookups;
	            var res = query.isCountRequired ? result.result :
	                result;
	            if (lookup && lookup instanceof Array) {
	                DataUtil.buildHierarchy(query.subQuery.fKey, from, res, lookup, query.subQuery.key);
	            }
	            for (var j = 0; j < res.length; j++) {
	                if (res[j][from] instanceof Array) {
	                    res[j] = extend({}, {}, res[j]);
	                    res[j][from] = this.adaptor.processResponse(query.subQuery.using(new DataManager(res[j][from].slice(0))).executeLocal(), this, query);
	                }
	            }
	        }
	        return this.adaptor.processResponse(result, this, query);
	    };
	    /**
	     * Executes the given query with either local or remote data source.
	     * It will be executed as asynchronously and returns Promise object which will be resolved or rejected after action completed.
	     *
	     * @param  {Query|Function} query - Defines the query to retrieve data.
	     * @param  {Function} done - Defines the callback function and triggers when the Promise is resolved.
	     * @param  {Function} fail - Defines the callback function and triggers when the Promise is rejected.
	     * @param  {Function} always - Defines the callback function and triggers when the Promise is resolved or rejected.
	     */
	    DataManager.prototype.executeQuery = function (query, done, fail, always) {
	        var _this = this;
	        var makeRequest = 'makeRequest';
	        if (this.dataSource.enablePersistence && this.dataSource.id) {
	            query = this.setPersistQuery(query);
	        }
	        if (typeof query === 'function') {
	            always = fail;
	            fail = done;
	            done = query;
	            query = null;
	        }
	        if (!query) {
	            query = this.defaultQuery;
	        }
	        if (!(query instanceof Query)) {
	            DataUtil.throwError('DataManager - executeQuery() : A query is required to execute');
	        }
	        var deffered = new Deferred();
	        var args = { query: query };
	        if (!this.dataSource.offline && (this.dataSource.url !== undefined && this.dataSource.url !== '')
	            || (!isNullOrUndefined(this.adaptor[makeRequest])) || this.isCustomDataAdaptor(this.adaptor)) {
	            var result = this.adaptor.processQuery(this, query);
	            if (!isNullOrUndefined(this.adaptor[makeRequest])) {
	                this.adaptor[makeRequest](result, deffered, args, query);
	            }
	            else if (!isNullOrUndefined(result.url) || this.isCustomDataAdaptor(this.adaptor)) {
	                this.requests = [];
	                this.makeRequest(result, deffered, args, query);
	            }
	            else {
	                args = DataManager.getDeferedArgs(query, result, args);
	                deffered.resolve(args);
	            }
	        }
	        else {
	            DataManager.nextTick(function () {
	                var res = _this.executeLocal(query);
	                args = DataManager.getDeferedArgs(query, res, args);
	                deffered.resolve(args);
	            });
	        }
	        if (done || fail) {
	            deffered.promise.then(done, fail);
	        }
	        if (always) {
	            deffered.promise.then(always, always);
	        }
	        return deffered.promise;
	    };
	    DataManager.getDeferedArgs = function (query, result, args) {
	        if (query.isCountRequired) {
	            args.result = result.result;
	            args.count = result.count;
	            args.aggregates = result.aggregates;
	        }
	        else {
	            args.result = result;
	        }
	        return args;
	    };
	    DataManager.nextTick = function (fn) {
	        /* eslint-disable @typescript-eslint/no-explicit-any */
	        // tslint:disable-next-line:no-any
	        (window.setImmediate || window.setTimeout)(fn, 0);
	        /* eslint-enable @typescript-eslint/no-explicit-any */
	    };
	    DataManager.prototype.extendRequest = function (url, fnSuccess, fnFail) {
	        return extend({}, {
	            type: 'GET',
	            dataType: this.dataSource.dataType,
	            crossDomain: this.dataSource.crossDomain,
	            jsonp: this.dataSource.jsonp,
	            cache: true,
	            processData: false,
	            onSuccess: fnSuccess,
	            onFailure: fnFail
	        }, url);
	    };
	    // tslint:disable-next-line:max-func-body-length
	    DataManager.prototype.makeRequest = function (url, deffered, args, query) {
	        var _this = this;
	        var isSelector = !!query.subQuerySelector;
	        var fnFail = function (e) {
	            args.error = e;
	            deffered.reject(args);
	        };
	        var process = function (data, count, xhr, request, actual, aggregates, virtualSelectRecords) {
	            args.xhr = xhr;
	            args.count = count ? parseInt(count.toString(), 10) : 0;
	            args.result = data;
	            args.request = request;
	            args.aggregates = aggregates;
	            args.actual = actual;
	            args.virtualSelectRecords = virtualSelectRecords;
	            deffered.resolve(args);
	        };
	        var fnQueryChild = function (data, selector) {
	            var subDeffer = new Deferred();
	            var childArgs = { parent: args };
	            query.subQuery.isChild = true;
	            var subUrl = _this.adaptor.processQuery(_this, query.subQuery, data ? _this.adaptor.processResponse(data) : selector);
	            var childReq = _this.makeRequest(subUrl, subDeffer, childArgs, query.subQuery);
	            if (!isSelector) {
	                subDeffer.then(function (subData) {
	                    if (data) {
	                        DataUtil.buildHierarchy(query.subQuery.fKey, query.subQuery.fromTable, data, subData, query.subQuery.key);
	                        process(data, subData.count, subData.xhr);
	                    }
	                }, fnFail);
	            }
	            return childReq;
	        };
	        var fnSuccess = function (data, request) {
	            if (_this.isGraphQLAdaptor(_this.adaptor)) {
	                // tslint:disable-next-line:no-string-literal
	                if (!isNullOrUndefined(data['errors'])) {
	                    // tslint:disable-next-line:no-string-literal
	                    return fnFail(data['errors']);
	                }
	            }
	            if (_this.isCustomDataAdaptor(_this.adaptor)) {
	                request = extend({}, _this.fetchReqOption, request);
	            }
	            if (request.contentType.indexOf('xml') === -1 && _this.dateParse) {
	                data = DataUtil.parse.parseJson(data);
	            }
	            var result = _this.adaptor.processResponse(data, _this, query, request.fetchRequest, request);
	            var count = 0;
	            var aggregates = null;
	            var virtualSelectRecords = 'virtualSelectRecords';
	            var virtualRecords = data[virtualSelectRecords];
	            if (query.isCountRequired) {
	                count = result.count;
	                aggregates = result.aggregates;
	                result = result.result;
	            }
	            if (!query.subQuery) {
	                process(result, count, request.fetchRequest, request.type, data, aggregates, virtualRecords);
	                return;
	            }
	            if (!isSelector) {
	                fnQueryChild(result, request);
	            }
	        };
	        var req = this.extendRequest(url, fnSuccess, fnFail);
	        if (!this.isCustomDataAdaptor(this.adaptor)) {
	            var fetch_1 = new Fetch(req);
	            fetch_1.beforeSend = function () {
	                _this.beforeSend(fetch_1.fetchRequest, fetch_1);
	            };
	            req = fetch_1.send();
	            req.catch(function (e) { return true; }); // to handle failure remote requests.
	            this.requests.push(fetch_1);
	        }
	        else {
	            this.fetchReqOption = req;
	            var request = req;
	            this.adaptor.options.getData({
	                data: request.data,
	                onSuccess: request.onSuccess, onFailure: request.onFailure
	            });
	        }
	        if (isSelector) {
	            var promise = void 0;
	            var res = query.subQuerySelector.call(this, { query: query.subQuery, parent: query });
	            if (res && res.length) {
	                promise = Promise.all([req, fnQueryChild(null, res)]);
	                promise.then(function () {
	                    var args = [];
	                    for (var _i = 0; _i < arguments.length; _i++) {
	                        args[_i] = arguments[_i];
	                    }
	                    var result = args[0];
	                    var pResult = _this.adaptor.processResponse(result[0], _this, query, _this.requests[0].fetchRequest, _this.requests[0]);
	                    var count = 0;
	                    if (query.isCountRequired) {
	                        count = pResult.count;
	                        pResult = pResult.result;
	                    }
	                    var cResult = _this.adaptor.processResponse(result[1], _this, query.subQuery, _this.requests[1].fetchRequest, _this.requests[1]);
	                    count = 0;
	                    if (query.subQuery.isCountRequired) {
	                        count = cResult.count;
	                        cResult = cResult.result;
	                    }
	                    DataUtil.buildHierarchy(query.subQuery.fKey, query.subQuery.fromTable, pResult, cResult, query.subQuery.key);
	                    isSelector = false;
	                    process(pResult, count, _this.requests[0].fetchRequest);
	                });
	            }
	            else {
	                isSelector = false;
	            }
	        }
	        return req;
	    };
	    DataManager.prototype.beforeSend = function (request, settings) {
	        this.adaptor.beforeSend(this, request, settings);
	        var headers = this.dataSource.headers;
	        var props;
	        for (var i = 0; headers && i < headers.length; i++) {
	            props = [];
	            var keys = Object.keys(headers[i]);
	            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
	                var prop = keys_1[_i];
	                props.push(prop);
	                request.headers.set(prop, headers[i][prop]);
	            }
	        }
	    };
	    /**
	     * Save bulk changes to the given table name.
	     * User can add a new record, edit an existing record, and delete a record at the same time.
	     * If the datasource from remote, then updated in a single post.
	     *
	     * @param {Object} changes - Defines the CrudOptions.
	     * @param {string} key - Defines the column field.
	     * @param {string|Query} tableName - Defines the table name.
	     * @param {Query} query - Sets default query for the DataManager.
	     * @param original
	     */
	    DataManager.prototype.saveChanges = function (changes, key, tableName, query, original) {
	        var _this = this;
	        if (tableName instanceof Query) {
	            query = tableName;
	            tableName = null;
	        }
	        var args = {
	            url: tableName,
	            key: key || this.dataSource.key
	        };
	        var req = this.adaptor.batchRequest(this, changes, args, query || new Query(), original);
	        var dofetchRequest = 'dofetchRequest';
	        if (this.dataSource.offline) {
	            return req;
	        }
	        if (!isNullOrUndefined(this.adaptor[dofetchRequest])) {
	            return this.adaptor[dofetchRequest](req);
	        }
	        else if (!this.isCustomDataAdaptor(this.adaptor)) {
	            var deff_1 = new Deferred();
	            var fetch_2 = new Fetch(req);
	            fetch_2.beforeSend = function () {
	                _this.beforeSend(fetch_2.fetchRequest, fetch_2);
	            };
	            fetch_2.onSuccess = function (data, request) {
	                if (_this.isGraphQLAdaptor(_this.adaptor)) {
	                    // tslint:disable-next-line:no-string-literal
	                    if (!isNullOrUndefined(data['errors'])) {
	                        // tslint:disable-next-line:no-string-literal
	                        fetch_2.onFailure(JSON.stringify(data['errors']));
	                    }
	                }
	                deff_1.resolve(_this.adaptor.processResponse(data, _this, null, request.fetchRequest, request, changes, args));
	            };
	            fetch_2.onFailure = function (e) {
	                deff_1.reject([{ error: e }]);
	            };
	            fetch_2.send().catch(function (e) { return true; }); // to handle the failure requests.
	            return deff_1.promise;
	        }
	        else {
	            return this.dofetchRequest(req, this.adaptor.options.batchUpdate);
	        }
	    };
	    /**
	     * Inserts new record in the given table.
	     *
	     * @param {Object} data - Defines the data to insert.
	     * @param {string|Query} tableName - Defines the table name.
	     * @param {Query} query - Sets default query for the DataManager.
	     * @param position
	     */
	    DataManager.prototype.insert = function (data, tableName, query, position) {
	        if (tableName instanceof Query) {
	            query = tableName;
	            tableName = null;
	        }
	        var req = this.adaptor.insert(this, data, tableName, query, position);
	        var dofetchRequest = 'dofetchRequest';
	        if (this.dataSource.offline) {
	            return req;
	        }
	        if (!isNullOrUndefined(this.adaptor[dofetchRequest])) {
	            return this.adaptor[dofetchRequest](req);
	        }
	        else {
	            return this.dofetchRequest(req, this.adaptor.options.addRecord);
	        }
	    };
	    /**
	     * Removes data from the table with the given key.
	     *
	     * @param  {string} keyField - Defines the column field.
	     * @param  {Object} value - Defines the value to find the data in the specified column.
	     * @param  {string|Query} tableName - Defines the table name
	     * @param  {Query} query - Sets default query for the DataManager.
	     */
	    DataManager.prototype.remove = function (keyField, value, tableName, query) {
	        if (typeof value === 'object') {
	            value = DataUtil.getObject(keyField, value);
	        }
	        if (tableName instanceof Query) {
	            query = tableName;
	            tableName = null;
	        }
	        var res = this.adaptor.remove(this, keyField, value, tableName, query);
	        var dofetchRequest = 'dofetchRequest';
	        if (this.dataSource.offline) {
	            return res;
	        }
	        if (!isNullOrUndefined(this.adaptor[dofetchRequest])) {
	            return this.adaptor[dofetchRequest](res);
	        }
	        else {
	            var remove = this.adaptor.options.deleteRecord;
	            return this.dofetchRequest(res, remove);
	        }
	    };
	    /**
	     * Updates existing record in the given table.
	     *
	     * @param {string} keyField - Defines the column field.
	     * @param {Object} value - Defines the value to find the data in the specified column.
	     * @param {string|Query} tableName - Defines the table name
	     * @param {Query} query - Sets default query for the DataManager.
	     * @param original
	     */
	    DataManager.prototype.update = function (keyField, value, tableName, query, original) {
	        if (tableName instanceof Query) {
	            query = tableName;
	            tableName = null;
	        }
	        var res = this.adaptor.update(this, keyField, value, tableName, query, original);
	        var dofetchRequest = 'dofetchRequest';
	        if (this.dataSource.offline) {
	            return res;
	        }
	        if (!isNullOrUndefined(this.adaptor[dofetchRequest])) {
	            return this.adaptor[dofetchRequest](res);
	        }
	        else {
	            var update = this.adaptor.options.updateRecord;
	            return this.dofetchRequest(res, update);
	        }
	    };
	    DataManager.prototype.isCustomDataAdaptor = function (dataSource) {
	        return this.adaptor.getModuleName &&
	            this.adaptor.getModuleName() === 'CustomDataAdaptor';
	    };
	    DataManager.prototype.isGraphQLAdaptor = function (dataSource) {
	        return this.adaptor.getModuleName &&
	            this.adaptor.getModuleName() === 'GraphQLAdaptor';
	    };
	    DataManager.prototype.successFunc = function (record, request) {
	        if (this.isGraphQLAdaptor(this.adaptor)) {
	            var data = JSON.parse(record);
	            // tslint:disable-next-line:no-string-literal
	            if (!isNullOrUndefined(data['errors'])) {
	                // tslint:disable-next-line:no-string-literal
	                this.failureFunc(JSON.stringify(data['errors']));
	            }
	        }
	        if (this.isCustomDataAdaptor(this.adaptor)) {
	            request = extend({}, this.fetchReqOption, request);
	        }
	        try {
	            DataUtil.parse.parseJson(record);
	        }
	        catch (e) {
	            record = [];
	        }
	        record = this.adaptor.processResponse(DataUtil.parse.parseJson(record), this, null, request.fetchRequest, request);
	        this.fetchDeffered.resolve(record);
	    };
	    DataManager.prototype.failureFunc = function (e) {
	        this.fetchDeffered.reject([{ error: e }]);
	    };
	    DataManager.prototype.dofetchRequest = function (res, fetchFunc) {
	        var _this = this;
	        res = extend({}, {
	            type: 'POST',
	            contentType: 'application/json; charset=utf-8',
	            processData: false
	        }, res);
	        this.fetchDeffered = new Deferred();
	        if (!this.isCustomDataAdaptor(this.adaptor)) {
	            var fetch_3 = new Fetch(res);
	            fetch_3.beforeSend = function () {
	                _this.beforeSend(fetch_3.fetchRequest, fetch_3);
	            };
	            fetch_3.onSuccess = this.successFunc.bind(this);
	            fetch_3.onFailure = this.failureFunc.bind(this);
	            fetch_3.send().catch(function (e) { return true; }); // to handle the failure requests.
	        }
	        else {
	            this.fetchReqOption = res;
	            fetchFunc.call(this, {
	                data: res.data, onSuccess: this.successFunc.bind(this),
	                onFailure: this.failureFunc.bind(this)
	            });
	        }
	        return this.fetchDeffered.promise;
	    };
	    DataManager.prototype.clearPersistence = function () {
	        window.removeEventListener('unload', this.setPersistData.bind(this));
	        this.dataSource.enablePersistence = false;
	        this.persistQuery = {};
	        window.localStorage.setItem(this.dataSource.id, '[]');
	    };
	    return DataManager;
	}());
	/**
	 * Deferred is used to handle asynchronous operation.
	 */
	var Deferred = /** @class */ (function () {
	    function Deferred() {
	        var _this = this;
	        /**
	         * Promise is an object that represents a value that may not be available yet, but will be resolved at some point in the future.
	         */
	        this.promise = new Promise(function (resolve, reject) {
	            _this.resolve = resolve;
	            _this.reject = reject;
	        });
	        /**
	         * Defines the callback function triggers when the Deferred object is resolved.
	         */
	        this.then = this.promise.then.bind(this.promise);
	        /**
	         * Defines the callback function triggers when the Deferred object is rejected.
	         */
	        this.catch = this.promise.catch.bind(this.promise);
	    }
	    return Deferred;
	}());

	/* eslint-disable no-inner-declarations */
	var cssClass = {
	    li: 'e-list-item',
	    ul: 'e-list-parent e-ul',
	    group: 'e-list-group-item',
	    icon: 'e-list-icon',
	    text: 'e-list-text',
	    check: 'e-list-check',
	    checked: 'e-checked',
	    selected: 'e-selected',
	    expanded: 'e-expanded',
	    textContent: 'e-text-content',
	    hasChild: 'e-has-child',
	    level: 'e-level',
	    url: 'e-list-url',
	    collapsible: 'e-icon-collapsible',
	    disabled: 'e-disabled',
	    image: 'e-list-img',
	    iconWrapper: 'e-icon-wrapper',
	    anchorWrap: 'e-anchor-wrap',
	    navigable: 'e-navigable'
	};
	/**
	 * Base List Generator
	 */
	// eslint-disable-next-line @typescript-eslint/no-namespace
	var ListBase;
	(function (ListBase) {
	    /**
	     *
	     * Default mapped fields.
	     */
	    ListBase.defaultMappedFields = {
	        id: 'id',
	        text: 'text',
	        url: 'url',
	        value: 'value',
	        isChecked: 'isChecked',
	        enabled: 'enabled',
	        expanded: 'expanded',
	        selected: 'selected',
	        iconCss: 'iconCss',
	        child: 'child',
	        isVisible: 'isVisible',
	        hasChildren: 'hasChildren',
	        tooltip: 'tooltip',
	        htmlAttributes: 'htmlAttributes',
	        urlAttributes: 'urlAttributes',
	        imageAttributes: 'imageAttributes',
	        imageUrl: 'imageUrl',
	        groupBy: null,
	        sortBy: null
	    };
	    var defaultAriaAttributes = {
	        level: 1,
	        listRole: 'presentation',
	        itemRole: 'presentation',
	        groupItemRole: 'group',
	        itemText: 'list-item',
	        wrapperRole: 'presentation'
	    };
	    var defaultListBaseOptions = {
	        showCheckBox: false,
	        showIcon: false,
	        enableHtmlSanitizer: false,
	        expandCollapse: false,
	        fields: ListBase.defaultMappedFields,
	        ariaAttributes: defaultAriaAttributes,
	        listClass: '',
	        itemClass: '',
	        processSubChild: false,
	        sortOrder: 'None',
	        template: null,
	        groupTemplate: null,
	        headerTemplate: null,
	        expandIconClass: 'e-icon-collapsible',
	        moduleName: 'list',
	        expandIconPosition: 'Right',
	        itemNavigable: false
	    };
	    /**
	     * Function helps to created and return the UL Li element based on your data.
	     *
	     * @param  {createElementParams} createElement - Specifies an array of JSON data.
	     *
	     * @param  {{Object}[]} dataSource - Specifies an array of JSON data.
	     *
	     * @param  {ListBaseOptions} options? - Specifies the list options that need to provide.
	     *
	     * @param  {boolean} isSingleLevel? - Specifies the list options that need to provide.
	     *
	     * @param  {any} componentInstance? - Specifies the list options that need to provide.
	     *
	     * @returns  {createElement} createListFromJson - Specifies the list options that need to provide.
	     */
	    function createList(createElement, dataSource, 
	    // eslint-disable-next-line
	    options, isSingleLevel, componentInstance) {
	        var curOpt = extend({}, defaultListBaseOptions, options);
	        var ariaAttributes = extend({}, defaultAriaAttributes, curOpt.ariaAttributes);
	        var type = typeofData(dataSource).typeof;
	        if (type === 'string' || type === 'number') {
	            return createListFromArray(createElement, dataSource, isSingleLevel, options, componentInstance);
	        }
	        else {
	            return createListFromJson(createElement, dataSource, options, ariaAttributes.level, isSingleLevel, componentInstance);
	        }
	    }
	    ListBase.createList = createList;
	    /**
	     * Function helps to created an element list based on string array input .
	     *
	     * @param  {createElementParams} createElement - Specifies an array of JSON data.
	     *
	     * @param  {{Object}[]} dataSource - Specifies an array of JSON data.
	     *
	     * @param  {ListBaseOptions} options? - Specifies the list options that need to provide.
	     *
	     * @param  {boolean} isSingleLevel? - Specifies the list options that need to provide.
	     *
	     * @param  {any} componentInstance? - Specifies the list options that need to provide.
	     *
	     * @returns  {createElement} generateUL - returns the list options that need to provide.
	     */
	    function createListFromArray(createElement, dataSource, 
	    // tslint:disable-next-line
	    // eslint-disable-next-line
	    isSingleLevel, options, componentInstance) {
	        var subChild = createListItemFromArray(createElement, dataSource, isSingleLevel, options, componentInstance);
	        return generateUL(createElement, subChild, null, options);
	    }
	    ListBase.createListFromArray = createListFromArray;
	    /**
	     * Function helps to created an element list based on string array input .
	     *
	     * @param  {createElementParams} createElement - Specifies an array of JSON data.
	     *
	     * @param  {{Object}[]} dataSource - Specifies an array of JSON data.
	     *
	     * @param  {ListBaseOptions} options? - Specifies the list options that need to provide.
	     *
	     * @param  {boolean} isSingleLevel? - Specifies the list options that need to provide.
	     *
	     * @param  {any} componentInstance? - Specifies the list options that need to provide.
	     *
	     * @returns  {HTMLElement[]} subChild - returns the list options that need to provide.
	     */
	    function createListItemFromArray(createElement, dataSource, 
	    // eslint-disable-next-line
	    isSingleLevel, options, componentInstance) {
	        var subChild = [];
	        var curOpt = extend({}, defaultListBaseOptions, options);
	        cssClass = getModuleClass(curOpt.moduleName);
	        var id = generateId(); // generate id for drop-down-list option.
	        for (var i = 0; i < dataSource.length; i++) {
	            if (isNullOrUndefined(dataSource[i])) {
	                continue;
	            }
	            var li = void 0;
	            if (curOpt.itemCreating && typeof curOpt.itemCreating === 'function') {
	                var curData = {
	                    dataSource: dataSource,
	                    curData: dataSource[i],
	                    text: dataSource[i],
	                    options: curOpt
	                };
	                curOpt.itemCreating(curData);
	            }
	            if (isSingleLevel) {
	                li = generateSingleLevelLI(createElement, dataSource[i], undefined, null, null, [], null, id, i, options);
	            }
	            else {
	                li = generateLI(createElement, dataSource[i], undefined, null, null, options, componentInstance);
	            }
	            if (curOpt.itemCreated && typeof curOpt.itemCreated === 'function') {
	                var curData = {
	                    dataSource: dataSource,
	                    curData: dataSource[i],
	                    text: dataSource[i],
	                    item: li,
	                    options: curOpt
	                };
	                curOpt.itemCreated(curData);
	            }
	            subChild.push(li);
	        }
	        return subChild;
	    }
	    ListBase.createListItemFromArray = createListItemFromArray;
	    /**
	     * Function helps to created an element list based on array of JSON input .
	     *
	     * @param  {createElementParams} createElement - Specifies an array of JSON data.
	     *
	     * @param  {{Object}[]} dataSource - Specifies an array of JSON data.
	     *
	     * @param  {ListBaseOptions} options? - Specifies the list options that need to provide.
	     *
	     * @param  {boolean} isSingleLevel? - Specifies the list options that need to provide.
	     *
	     * @param  {number} level? - Specifies the list options that need to provide.
	     *
	     * @param  {any} componentInstance? - Specifies the list options that need to provide.
	     *
	     * @returns  {HTMLElement[]} child - returns the list options that need to provide.
	     */
	    function createListItemFromJson(createElement, dataSource, 
	    // eslint-disable-next-line
	    options, level, isSingleLevel, componentInstance) {
	        var curOpt = extend({}, defaultListBaseOptions, options);
	        cssClass = getModuleClass(curOpt.moduleName);
	        var fields = (componentInstance &&
	            (componentInstance.getModuleName() === 'listview' || componentInstance.getModuleName() === 'multiselect'))
	            ? curOpt.fields : extend({}, ListBase.defaultMappedFields, curOpt.fields);
	        var ariaAttributes = extend({}, defaultAriaAttributes, curOpt.ariaAttributes);
	        var id;
	        var checkboxElement = [];
	        if (level) {
	            ariaAttributes.level = level;
	        }
	        var child = [];
	        var li;
	        var anchorElement;
	        if (dataSource && dataSource.length && !isNullOrUndefined(typeofData(dataSource).item) &&
	            // eslint-disable-next-line no-prototype-builtins
	            !typeofData(dataSource).item.hasOwnProperty(fields.id)) {
	            id = generateId(); // generate id for drop-down-list option.
	        }
	        for (var i = 0; i < dataSource.length; i++) {
	            var fieldData = getFieldValues(dataSource[i], fields);
	            if (isNullOrUndefined(dataSource[i])) {
	                continue;
	            }
	            if (curOpt.itemCreating && typeof curOpt.itemCreating === 'function') {
	                var curData = {
	                    dataSource: dataSource,
	                    curData: dataSource[i],
	                    text: fieldData[fields.text],
	                    options: curOpt,
	                    fields: fields
	                };
	                curOpt.itemCreating(curData);
	            }
	            var curItem = dataSource[i];
	            if (curOpt.itemCreating && typeof curOpt.itemCreating === 'function') {
	                fieldData = getFieldValues(dataSource[i], fields);
	            }
	            // eslint-disable-next-line no-prototype-builtins
	            if (fieldData.hasOwnProperty(fields.id) && !isNullOrUndefined(fieldData[fields.id])) {
	                id = fieldData[fields.id];
	            }
	            var innerEle = [];
	            if (curOpt.showCheckBox) {
	                if (curOpt.itemNavigable && (fieldData[fields.url] || fieldData[fields.urlAttributes])) {
	                    checkboxElement.push(createElement('input', { className: cssClass.check, attrs: { type: 'checkbox' } }));
	                }
	                else {
	                    innerEle.push(createElement('input', { className: cssClass.check, attrs: { type: 'checkbox' } }));
	                }
	            }
	            if (isSingleLevel === true) {
	                // eslint-disable-next-line no-prototype-builtins
	                if (curOpt.showIcon && fieldData.hasOwnProperty(fields.iconCss) && !isNullOrUndefined(fieldData[fields.iconCss])) {
	                    innerEle.push(createElement('span', { className: cssClass.icon + ' ' + fieldData[fields.iconCss] }));
	                }
	                li = generateSingleLevelLI(createElement, curItem, fieldData, fields, curOpt.itemClass, innerEle, 
	                // eslint-disable-next-line no-prototype-builtins
	                (curItem.hasOwnProperty('isHeader') &&
	                    curItem.isHeader) ? true : false, id, i, options);
	                anchorElement = li.querySelector('.' + cssClass.anchorWrap);
	                if (curOpt.itemNavigable && checkboxElement.length) {
	                    prepend(checkboxElement, li.firstElementChild);
	                }
	            }
	            else {
	                li = generateLI(createElement, curItem, fieldData, fields, curOpt.itemClass, options, componentInstance);
	                li.classList.add(cssClass.level + '-' + ariaAttributes.level);
	                li.setAttribute('aria-level', ariaAttributes.level.toString());
	                if (ariaAttributes.groupItemRole == 'presentation' || ariaAttributes.itemRole == 'presentation') {
	                    li.removeAttribute('aria-level');
	                }
	                anchorElement = li.querySelector('.' + cssClass.anchorWrap);
	                // eslint-disable-next-line no-prototype-builtins
	                if (fieldData.hasOwnProperty(fields.tooltip)) {
	                    li.setAttribute('title', fieldData[fields.tooltip]);
	                }
	                // eslint-disable-next-line no-prototype-builtins
	                if (fieldData.hasOwnProperty(fields.htmlAttributes) && fieldData[fields.htmlAttributes]) {
	                    setAttribute(li, fieldData[fields.htmlAttributes]);
	                }
	                // eslint-disable-next-line no-prototype-builtins
	                if (fieldData.hasOwnProperty(fields.enabled) && fieldData[fields.enabled] === false) {
	                    li.classList.add(cssClass.disabled);
	                }
	                // eslint-disable-next-line no-prototype-builtins
	                if (fieldData.hasOwnProperty(fields.isVisible) && fieldData[fields.isVisible] === false) {
	                    li.style.display = 'none';
	                }
	                // eslint-disable-next-line no-prototype-builtins
	                if (fieldData.hasOwnProperty(fields.imageUrl) && !isNullOrUndefined(fieldData[fields.imageUrl])
	                    && !curOpt.template) {
	                    var attr = { src: fieldData[fields.imageUrl] };
	                    merge(attr, fieldData[fields.imageAttributes]);
	                    var imageElemnt = createElement('img', { className: cssClass.image, attrs: attr });
	                    if (anchorElement) {
	                        anchorElement.insertAdjacentElement('afterbegin', imageElemnt);
	                    }
	                    else {
	                        prepend([imageElemnt], li.firstElementChild);
	                    }
	                }
	                // eslint-disable-next-line no-prototype-builtins
	                if (curOpt.showIcon && fieldData.hasOwnProperty(fields.iconCss) &&
	                    !isNullOrUndefined(fieldData[fields.iconCss]) && !curOpt.template) {
	                    var iconElement = createElement('div', { className: cssClass.icon + ' ' + fieldData[fields.iconCss] });
	                    if (anchorElement) {
	                        anchorElement.insertAdjacentElement('afterbegin', iconElement);
	                    }
	                    else {
	                        prepend([iconElement], li.firstElementChild);
	                    }
	                }
	                if (innerEle.length) {
	                    prepend(innerEle, li.firstElementChild);
	                }
	                if (curOpt.itemNavigable && checkboxElement.length) {
	                    prepend(checkboxElement, li.firstElementChild);
	                }
	                processSubChild(createElement, fieldData, fields, dataSource, curOpt, li, ariaAttributes.level);
	            }
	            if (anchorElement) {
	                addClass([li], [cssClass.navigable]);
	            }
	            if (curOpt.itemCreated && typeof curOpt.itemCreated === 'function') {
	                var curData = {
	                    dataSource: dataSource,
	                    curData: dataSource[i],
	                    text: fieldData[fields.text],
	                    item: li,
	                    options: curOpt,
	                    fields: fields
	                };
	                curOpt.itemCreated(curData);
	            }
	            checkboxElement = [];
	            child.push(li);
	        }
	        return child;
	    }
	    ListBase.createListItemFromJson = createListItemFromJson;
	    /**
	     * Function helps to created an element list based on array of JSON input .
	     *
	     * @param  {createElementParams} createElement - Specifies an array of JSON data.
	     *
	     * @param  {{Object}[]} dataSource - Specifies an array of JSON data.
	     *
	     * @param  {ListBaseOptions} options? - Specifies the list options that need to provide.
	     *
	     * @param  {number} level? - Specifies the list options that need to provide.
	     *
	     * @param  {boolean} isSingleLevel? - Specifies the list options that need to provide.
	     *
	     * @param  {any} componentInstance? - Specifies the list options that need to provide.
	     *
	     * @returns  {createElement} generateUL - Specifies the list options that need to provide.
	     */
	    function createListFromJson(createElement, dataSource, 
	    // eslint-disable-next-line
	    options, level, isSingleLevel, componentInstance) {
	        var curOpt = extend({}, defaultListBaseOptions, options);
	        var li = createListItemFromJson(createElement, dataSource, options, level, isSingleLevel, componentInstance);
	        return generateUL(createElement, li, curOpt.listClass, options);
	    }
	    ListBase.createListFromJson = createListFromJson;
	    /**
	     * Return the next or previous visible element.
	     *
	     * @param  {Element[]|NodeList} elementArray - An element array to find next or previous element.
	     * @param  {Element} li - An element to find next or previous after this element.
	     * @param  {boolean} isPrevious? - Specify when the need get previous element from array.
	     */
	    function getSiblingLI(elementArray, element, isPrevious) {
	        cssClass = getModuleClass(defaultListBaseOptions.moduleName);
	        if (!elementArray || !elementArray.length) {
	            return void 0;
	        }
	        var siblingLI;
	        var liIndex;
	        var liCollections = Array.prototype.slice.call(elementArray);
	        if (element) {
	            liIndex = indexOf(element, liCollections);
	        }
	        else {
	            liIndex = (isPrevious === true ? liCollections.length : -1);
	        }
	        siblingLI = liCollections[liIndex + (isPrevious === true ? -1 : 1)];
	        while (siblingLI && (!isVisible(siblingLI) || siblingLI.classList.contains(cssClass.disabled))) {
	            liIndex = liIndex + (isPrevious === true ? -1 : 1);
	            siblingLI = liCollections[liIndex];
	        }
	        return siblingLI;
	    }
	    ListBase.getSiblingLI = getSiblingLI;
	    /**
	     * Return the index of the li element
	     *
	     * @param  {Element} item - An element to find next or previous after this element.
	     * @param  {Element[]} elementArray - An element array to find index of given li.
	     */
	    function indexOf(item, elementArray) {
	        if (!elementArray || !item) {
	            return void 0;
	        }
	        else {
	            var liCollections = elementArray;
	            liCollections = Array.prototype.slice.call(elementArray);
	            return liCollections.indexOf(item);
	        }
	    }
	    ListBase.indexOf = indexOf;
	    /**
	     * Returns the grouped data from given dataSource.
	     *
	     * @param  {{Object}[]} dataSource - The JSON data which is necessary to process.
	     * @param  {FieldsMapping} fields - Fields that are mapped from the data source.
	     * @param  {SortOrder} sortOrder- Specifies final result sort order.
	     */
	    function groupDataSource(dataSource, fields, sortOrder) {
	        if (sortOrder === void 0) { sortOrder = 'None'; }
	        var curFields = extend({}, ListBase.defaultMappedFields, fields);
	        var cusQuery = new Query().group(curFields.groupBy);
	        // need to remove once sorting issues fixed in DataManager
	        cusQuery = addSorting(sortOrder, 'key', cusQuery);
	        var ds = getDataSource(dataSource, cusQuery);
	        dataSource = [];
	        for (var j = 0; j < ds.length; j++) {
	            var itemObj = ds[j].items;
	            var grpItem = {};
	            var hdr = 'isHeader';
	            grpItem[curFields.text] = ds[j].key;
	            grpItem["" + hdr] = true;
	            var newtext = curFields.text;
	            if (newtext === 'id') {
	                newtext = 'text';
	                grpItem["" + newtext] = ds[j].key;
	            }
	            grpItem._id = 'group-list-item-' + (ds[j].key ?
	                ds[j].key.toString().trim() : 'undefined');
	            grpItem.items = itemObj;
	            dataSource.push(grpItem);
	            for (var k = 0; k < itemObj.length; k++) {
	                dataSource.push(itemObj[k]);
	            }
	        }
	        return dataSource;
	    }
	    ListBase.groupDataSource = groupDataSource;
	    /**
	     * Returns a sorted query object.
	     *
	     * @param  {SortOrder} sortOrder - Specifies that sort order.
	     * @param  {string} sortBy - Specifies sortBy fields.
	     * @param  {Query} query - Pass if any existing query.
	     */
	    function addSorting(sortOrder, sortBy, query) {
	        if (query === void 0) { query = new Query(); }
	        if (sortOrder === 'Ascending') {
	            query.sortBy(sortBy, 'ascending', true);
	        }
	        else if (sortOrder === 'Descending') {
	            query.sortBy(sortBy, 'descending', true);
	        }
	        else {
	            for (var i = 0; i < query.queries.length; i++) {
	                if (query.queries[i].fn === 'onSortBy') {
	                    query.queries.splice(i, 1);
	                }
	            }
	        }
	        return query;
	    }
	    ListBase.addSorting = addSorting;
	    /**
	     * Return an array of JSON Data that processed based on queries.
	     *
	     * @param  {{Object}[]} dataSource - Specifies local JSON data source.
	     *
	     * @param  {Query} query - Specifies query that need to process.
	     */
	    function getDataSource(dataSource, query) {
	        // eslint-disable-next-line
	        return new DataManager(dataSource)
	            .executeLocal(query);
	    }
	    ListBase.getDataSource = getDataSource;
	    /**
	     * Created JSON data based the UL and LI element
	     *
	     * @param  {HTMLElement|Element} element - UL element that need to convert as a JSON
	     * @param  {ListBaseOptions} options? - Specifies listbase option for fields.
	     */
	    function createJsonFromElement(element, options) {
	        var curOpt = extend({}, defaultListBaseOptions, options);
	        var fields = extend({}, ListBase.defaultMappedFields, curOpt.fields);
	        var curEle = element.cloneNode(true);
	        // eslint-disable-next-line
	        var jsonAr = [];
	        curEle.classList.add('json-parent');
	        var childs = curEle.querySelectorAll('.json-parent>li');
	        curEle.classList.remove('json-parent');
	        for (var i = 0; i < childs.length; i++) {
	            var li = childs[i];
	            var anchor = li.querySelector('a');
	            var ul = li.querySelector('ul');
	            // eslint-disable-next-line
	            var json = {};
	            var childNodes = anchor ? anchor.childNodes : li.childNodes;
	            var keys = Object.keys(childNodes);
	            for (var i_1 = 0; i_1 < childNodes.length; i_1++) {
	                if (!(childNodes[Number(keys[i_1])]).hasChildNodes()) {
	                    json[fields.text] = childNodes[Number(keys[i_1])].textContent;
	                }
	            }
	            var attributes_1 = getAllAttributes(li);
	            if (attributes_1.id) {
	                json[fields.id] = attributes_1.id;
	                delete attributes_1.id;
	            }
	            else {
	                json[fields.id] = generateId();
	            }
	            if (Object.keys(attributes_1).length) {
	                json[fields.htmlAttributes] = attributes_1;
	            }
	            if (anchor) {
	                attributes_1 = getAllAttributes(anchor);
	                if (Object.keys(attributes_1).length) {
	                    json[fields.urlAttributes] = attributes_1;
	                }
	            }
	            if (ul) {
	                json[fields.child] = createJsonFromElement(ul, options);
	            }
	            jsonAr.push(json);
	        }
	        return jsonAr;
	    }
	    ListBase.createJsonFromElement = createJsonFromElement;
	    function typeofData(data) {
	        var match = { typeof: null, item: null };
	        for (var i = 0; i < data.length; i++) {
	            if (!isNullOrUndefined(data[i])) {
	                return match = { typeof: typeof data[i], item: data[i] };
	            }
	        }
	        return match;
	    }
	    function setAttribute(element, elementAttributes) {
	        var attr = {};
	        merge(attr, elementAttributes);
	        if (attr.class) {
	            addClass([element], attr.class.split(' '));
	            delete attr.class;
	        }
	        attributes(element, attr);
	    }
	    function getAllAttributes(element) {
	        var attributes = {};
	        var attr = element.attributes;
	        for (var index = 0; index < attr.length; index++) {
	            attributes[attr[index].nodeName] = attr[index].nodeValue;
	        }
	        return attributes;
	    }
	    /**
	     * Created UL element from content template.
	     *
	     * @param  {string} template - that need to convert and generate li element.
	     * @param  {{Object}[]} dataSource - Specifies local JSON data source.
	     * @param  {ListBaseOptions} options? - Specifies listbase option for fields.
	     */
	    function renderContentTemplate(createElement, template, dataSource, 
	    // eslint-disable-next-line
	    fields, options, componentInstance) {
	        cssClass = getModuleClass(defaultListBaseOptions.moduleName);
	        var ulElement = createElement('ul', { className: cssClass.ul, attrs: { role: 'presentation' } });
	        var curOpt = extend({}, defaultListBaseOptions, options);
	        var curFields = extend({}, ListBase.defaultMappedFields, fields);
	        // eslint-disable-next-line
	        var compiledString = compileTemplate(template);
	        var liCollection = [];
	        var value;
	        var id = generateId(); // generate id for drop-down-list option.
	        for (var i = 0; i < dataSource.length; i++) {
	            var fieldData = getFieldValues(dataSource[i], curFields);
	            var curItem = dataSource[i];
	            var isHeader = curItem.isHeader;
	            if (typeof dataSource[i] === 'string' || typeof dataSource[i] === 'number') {
	                value = curItem;
	            }
	            else {
	                value = fieldData[curFields.value];
	            }
	            if (curOpt.itemCreating && typeof curOpt.itemCreating === 'function') {
	                var curData = {
	                    dataSource: dataSource,
	                    curData: curItem,
	                    text: value,
	                    options: curOpt,
	                    fields: curFields
	                };
	                curOpt.itemCreating(curData);
	            }
	            if (curOpt.itemCreating && typeof curOpt.itemCreating === 'function') {
	                fieldData = getFieldValues(dataSource[i], curFields);
	                if (typeof dataSource[i] === 'string' || typeof dataSource[i] === 'number') {
	                    value = curItem;
	                }
	                else {
	                    value = fieldData[curFields.value];
	                }
	            }
	            var li = createElement('li', {
	                id: id + '-' + i,
	                className: isHeader ? cssClass.group : cssClass.li, attrs: { role: 'presentation' }
	            });
	            if (isHeader) {
	                if (typeof dataSource[i] === 'string' || typeof dataSource[i] === 'number') {
	                    li.innerText = curItem;
	                }
	                else {
	                    li.innerText = fieldData[curFields.text];
	                }
	            }
	            else {
	                var currentID = isHeader ? curOpt.groupTemplateID : curOpt.templateID;
	                if (isHeader) {
	                    if (componentInstance && componentInstance.getModuleName() != 'listview') {
	                        // eslint-disable-next-line
	                        var compiledElement = compiledString(curItem, componentInstance, 'headerTemplate', currentID, !!curOpt.isStringTemplate, null, li);
	                        if (compiledElement) {
	                            append(compiledElement, li);
	                        }
	                    }
	                    else {
	                        append(compiledString(curItem, componentInstance, 'headerTemplate', currentID, !!curOpt.isStringTemplate), li);
	                    }
	                }
	                else {
	                    if (componentInstance && componentInstance.getModuleName() !== 'listview') {
	                        // eslint-disable-next-line
	                        var compiledElement = compiledString(curItem, componentInstance, 'template', currentID, !!curOpt.isStringTemplate, null, li);
	                        if (compiledElement) {
	                            append(compiledElement, li);
	                        }
	                    }
	                    else {
	                        append(compiledString(curItem, componentInstance, 'template', currentID, !!curOpt.isStringTemplate), li);
	                    }
	                }
	                li.setAttribute('data-value', isNullOrUndefined(value) ? 'null' : value);
	                li.setAttribute('role', 'option');
	            }
	            if (curOpt.itemCreated && typeof curOpt.itemCreated === 'function') {
	                var curData = {
	                    dataSource: dataSource,
	                    curData: curItem,
	                    text: value,
	                    item: li,
	                    options: curOpt,
	                    fields: curFields
	                };
	                curOpt.itemCreated(curData);
	            }
	            liCollection.push(li);
	        }
	        append(liCollection, ulElement);
	        return ulElement;
	    }
	    ListBase.renderContentTemplate = renderContentTemplate;
	    /**
	     * Created header items from group template.
	     *
	     * @param  {string} template - that need to convert and generate li element.
	     *
	     * @param  {{Object}[]} dataSource - Specifies local JSON data source.
	     *
	     * @param  {FieldsMapping} fields - Specifies fields for mapping the dataSource.
	     *
	     * @param  {Element[]} headerItems? - Specifies listbase header items.
	     */
	    // tslint:disable-next-line
	    function renderGroupTemplate(groupTemplate, groupDataSource, fields, 
	    // eslint-disable-next-line
	    headerItems, options, componentInstance) {
	        // eslint-disable-next-line @typescript-eslint/ban-types
	        var compiledString = compileTemplate(groupTemplate);
	        var curFields = extend({}, ListBase.defaultMappedFields, fields);
	        var curOpt = extend({}, defaultListBaseOptions, options);
	        var category = curFields.groupBy;
	        for (var _i = 0, headerItems_1 = headerItems; _i < headerItems_1.length; _i++) {
	            var header = headerItems_1[_i];
	            var headerData = {};
	            headerData["" + category] = header.textContent;
	            header.innerHTML = '';
	            if (componentInstance && componentInstance.getModuleName() !== "listview") {
	                // eslint-disable-next-line
	                var compiledElement = compiledString(headerData, componentInstance, 'groupTemplate', curOpt.groupTemplateID, !!curOpt.isStringTemplate, null, header);
	                if (compiledElement) {
	                    append(compiledElement, header);
	                }
	            }
	            else {
	                append(compiledString(headerData, componentInstance, 'groupTemplate', curOpt.groupTemplateID, !!curOpt.isStringTemplate), header);
	            }
	        }
	        return headerItems;
	    }
	    ListBase.renderGroupTemplate = renderGroupTemplate;
	    function generateId() {
	        return Math.floor((1 + Math.random()) * 0x10000)
	            .toString(16)
	            .substring(1);
	    }
	    ListBase.generateId = generateId;
	    function processSubChild(createElement, fieldData, fields, ds, options, element, level) {
	        // Get SubList
	        var subDS = fieldData[fields.child] || [];
	        var hasChildren = fieldData[fields.hasChildren];
	        //Create Sub child
	        if (subDS.length) {
	            hasChildren = true;
	            element.classList.add(cssClass.hasChild);
	            if (options.processSubChild) {
	                var subLi = createListFromJson(createElement, subDS, options, ++level);
	                element.appendChild(subLi);
	            }
	        }
	        // Create expand and collapse node
	        if (!!options.expandCollapse && hasChildren && !options.template) {
	            element.firstElementChild.classList.add(cssClass.iconWrapper);
	            // eslint-disable-next-line @typescript-eslint/ban-types
	            var expandElement = options.expandIconPosition === 'Left' ? prepend : append;
	            expandElement([createElement('div', { className: 'e-icons ' + options.expandIconClass })], element.querySelector('.' + cssClass.textContent));
	        }
	    }
	    function generateSingleLevelLI(createElement, item, fieldData, fields, className, innerElements, grpLI, id, index, options) {
	        var curOpt = extend({}, defaultListBaseOptions, options);
	        var ariaAttributes = extend({}, defaultAriaAttributes, curOpt.ariaAttributes);
	        var text = item;
	        var value = item;
	        var dataSource;
	        if (typeof item !== 'string' && typeof item !== 'number' && typeof item !== 'boolean') {
	            dataSource = item;
	            text = (typeof fieldData[fields.text] === 'boolean' || typeof fieldData[fields.text] === 'number') ?
	                fieldData[fields.text] : (fieldData[fields.text] || '');
	            value = fieldData[fields.value];
	        }
	        var elementID;
	        if (!isNullOrUndefined(dataSource) && !isNullOrUndefined(fieldData[fields.id])
	            && fieldData[fields.id] !== '') {
	            elementID = id;
	        }
	        else {
	            elementID = id + '-' + index;
	        }
	        var li = createElement('li', {
	            className: (grpLI === true ? cssClass.group : cssClass.li) + ' ' + (isNullOrUndefined(className) ? '' : className),
	            id: elementID, attrs: (ariaAttributes.groupItemRole !== '' && ariaAttributes.itemRole !== '' ?
	                { role: (grpLI === true ? ariaAttributes.groupItemRole : ariaAttributes.itemRole) } : {})
	        });
	        // eslint-disable-next-line no-prototype-builtins
	        if (dataSource && fieldData.hasOwnProperty(fields.enabled) && fieldData[fields.enabled].toString() === 'false') {
	            li.classList.add(cssClass.disabled);
	        }
	        if (grpLI) {
	            li.innerText = text;
	        }
	        else {
	            li.setAttribute('data-value', isNullOrUndefined(value) ? 'null' : value);
	            li.setAttribute('role', 'option');
	            // eslint-disable-next-line no-prototype-builtins
	            if (dataSource && fieldData.hasOwnProperty(fields.htmlAttributes) && fieldData[fields.htmlAttributes]) {
	                setAttribute(li, fieldData[fields.htmlAttributes]);
	            }
	            if (innerElements.length && !curOpt.itemNavigable) {
	                append(innerElements, li);
	            }
	            if (dataSource && (fieldData[fields.url] || (fieldData[fields.urlAttributes] &&
	                fieldData[fields.urlAttributes].href))) {
	                li.appendChild(anchorTag(createElement, dataSource, fields, text, innerElements, curOpt.itemNavigable));
	            }
	            else {
	                if (innerElements.length && curOpt.itemNavigable) {
	                    append(innerElements, li);
	                }
	                li.appendChild(document.createTextNode(text));
	            }
	        }
	        return li;
	    }
	    function getModuleClass(moduleName) {
	        // eslint-disable-next-line
	        return {
	            li: "e-" + moduleName + "-item",
	            ul: "e-" + moduleName + "-parent e-ul",
	            group: "e-" + moduleName + "-group-item",
	            icon: "e-" + moduleName + "-icon",
	            text: "e-" + moduleName + "-text",
	            check: "e-" + moduleName + "-check",
	            checked: 'e-checked',
	            selected: 'e-selected',
	            expanded: 'e-expanded',
	            textContent: 'e-text-content',
	            hasChild: 'e-has-child',
	            level: 'e-level',
	            url: "e-" + moduleName + "-url",
	            collapsible: 'e-icon-collapsible',
	            disabled: 'e-disabled',
	            image: "e-" + moduleName + "-img",
	            iconWrapper: 'e-icon-wrapper',
	            anchorWrap: 'e-anchor-wrap',
	            navigable: 'e-navigable'
	        };
	    }
	    function anchorTag(createElement, dataSource, fields, text, innerElements, isFullNavigation) {
	        var fieldData = getFieldValues(dataSource, fields);
	        var attr = { href: fieldData[fields.url] };
	        // eslint-disable-next-line no-prototype-builtins
	        if (fieldData.hasOwnProperty(fields.urlAttributes) && fieldData[fields.urlAttributes]) {
	            merge(attr, fieldData[fields.urlAttributes]);
	            attr.href = fieldData[fields.url] ? fieldData[fields.url] :
	                fieldData[fields.urlAttributes].href;
	        }
	        var anchorTag;
	        if (!isFullNavigation) {
	            anchorTag = createElement('a', { className: cssClass.text + ' ' + cssClass.url, innerHTML: text });
	        }
	        else {
	            anchorTag = createElement('a', { className: cssClass.text + ' ' + cssClass.url });
	            var anchorWrapper = createElement('div', { className: cssClass.anchorWrap });
	            if (innerElements && innerElements.length) {
	                append(innerElements, anchorWrapper);
	            }
	            anchorWrapper.appendChild(document.createTextNode(text));
	            append([anchorWrapper], anchorTag);
	        }
	        setAttribute(anchorTag, attr);
	        return anchorTag;
	    }
	    // tslint:disable-next-line
	    /* tslint:disable:align */
	    function generateLI(createElement, item, fieldData, 
	    // eslint-disable-next-line
	    fields, className, options, componentInstance) {
	        var curOpt = extend({}, defaultListBaseOptions, options);
	        var ariaAttributes = extend({}, defaultAriaAttributes, curOpt.ariaAttributes);
	        var text = item;
	        var uID;
	        var grpLI;
	        var dataSource;
	        if (typeof item !== 'string' && typeof item !== 'number') {
	            dataSource = item;
	            text = fieldData[fields.text] || '';
	            // tslint:disable-next-line
	            uID = (isNullOrUndefined(fieldData['_id'])) ? fieldData[fields.id] : fieldData['_id'];
	            // eslint-disable-next-line no-prototype-builtins
	            grpLI = (item.hasOwnProperty('isHeader') && item.isHeader)
	                ? true : false;
	        }
	        if (options && options.enableHtmlSanitizer) {
	            // eslint-disable-next-line no-self-assign
	            text = text;
	        }
	        var li = createElement('li', {
	            className: (grpLI === true ? cssClass.group : cssClass.li) + ' ' + (isNullOrUndefined(className) ? '' : className),
	            attrs: (ariaAttributes.groupItemRole !== '' && ariaAttributes.itemRole !== '' ?
	                { role: (grpLI === true ? ariaAttributes.groupItemRole : ariaAttributes.itemRole) } : {})
	        });
	        if (!isNullOrUndefined(uID) === true) {
	            li.setAttribute('data-uid', uID);
	        }
	        else {
	            li.setAttribute('data-uid', generateId());
	        }
	        if (grpLI && options && options.groupTemplate) {
	            // eslint-disable-next-line @typescript-eslint/ban-types
	            var compiledString = compileTemplate(options.groupTemplate);
	            if (componentInstance && componentInstance.getModuleName() !== "listview") {
	                // eslint-disable-next-line
	                var compiledElement = compiledString(item, componentInstance, 'groupTemplate', curOpt.groupTemplateID, !!curOpt.isStringTemplate, null, li);
	                if (compiledElement) {
	                    append(compiledElement, li);
	                }
	            }
	            else {
	                append(compiledString(item, componentInstance, 'groupTemplate', curOpt.groupTemplateID, !!curOpt.isStringTemplate), li);
	            }
	        }
	        else if (!grpLI && options && options.template) {
	            // eslint-disable-next-line @typescript-eslint/ban-types
	            var compiledString = compileTemplate(options.template);
	            if (componentInstance && componentInstance.getModuleName() !== 'listview') {
	                // eslint-disable-next-line
	                var compiledElement = compiledString(item, componentInstance, 'template', curOpt.templateID, !!curOpt.isStringTemplate, null, li);
	                if (compiledElement) {
	                    append(compiledElement, li);
	                }
	            }
	            else {
	                append(compiledString(item, componentInstance, 'template', curOpt.templateID, !!curOpt.isStringTemplate), li);
	            }
	        }
	        else {
	            var innerDiv = createElement('div', {
	                className: cssClass.textContent,
	                attrs: (ariaAttributes.wrapperRole !== '' ? { role: ariaAttributes.wrapperRole } : {})
	            });
	            if (dataSource && (fieldData[fields.url] || (fieldData[fields.urlAttributes] &&
	                fieldData[fields.urlAttributes].href))) {
	                innerDiv.appendChild(anchorTag(createElement, dataSource, fields, text, null, curOpt.itemNavigable));
	            }
	            else {
	                var element = createElement('span', {
	                    className: cssClass.text,
	                    attrs: (ariaAttributes.itemText !== '' ? { role: ariaAttributes.itemText } : {})
	                });
	                if (options && options.enableHtmlSanitizer) {
	                    element.innerText = SanitizeHtmlHelper.sanitize(text);
	                }
	                else {
	                    element.innerHTML = text;
	                }
	                innerDiv.appendChild(element);
	            }
	            li.appendChild(innerDiv);
	        }
	        return li;
	    }
	    /**
	     * Returns UL element based on the given LI element.
	     *
	     * @param  {HTMLElement[]} liElement - Specifies array of LI element.
	     *
	     * @param  {string} className? - Specifies class name that need to be added in UL element.
	     *
	     * @param  {ListBaseOptions} options? - Specifies ListBase options.
	     */
	    function generateUL(createElement, liElement, className, options) {
	        var curOpt = extend({}, defaultListBaseOptions, options);
	        var ariaAttributes = extend({}, defaultAriaAttributes, curOpt.ariaAttributes);
	        cssClass = getModuleClass(curOpt.moduleName);
	        var ulElement = createElement('ul', {
	            className: cssClass.ul + ' ' + (isNullOrUndefined(className) ? '' : className),
	            attrs: (ariaAttributes.listRole !== '' ? { role: ariaAttributes.listRole } : {})
	        });
	        append(liElement, ulElement);
	        return ulElement;
	    }
	    ListBase.generateUL = generateUL;
	    /**
	     * Returns LI element with additional DIV tag based on the given LI element.
	     *
	     * @param  {liElement} liElement - Specifies LI element.
	     *
	     * @param  {string} className? - Specifies class name that need to be added in created DIV element.
	     *
	     * @param  {ListBaseOptions} options? - Specifies ListBase options.
	     */
	    function generateIcon(createElement, liElement, className, options) {
	        var curOpt = extend({}, defaultListBaseOptions, options);
	        cssClass = getModuleClass(curOpt.moduleName);
	        // eslint-disable-next-line @typescript-eslint/ban-types
	        var expandElement = curOpt.expandIconPosition === 'Left' ? prepend : append;
	        expandElement([createElement('div', {
	                className: 'e-icons ' + curOpt.expandIconClass + ' ' +
	                    (isNullOrUndefined(className) ? '' : className)
	            })], liElement.querySelector('.' + cssClass.textContent));
	        return liElement;
	    }
	    ListBase.generateIcon = generateIcon;
	})(ListBase || (ListBase = {}));
	/**
	 * Used to get dataSource item from complex data using fields.
	 *
	 * @param {Object} dataSource - Specifies an  JSON or String data.
	 *
	 * @param {FieldsMapping} fields - Fields that are mapped from the dataSource.
	 */
	function getFieldValues(dataItem, fields) {
	    var fieldData = {};
	    if (isNullOrUndefined(dataItem) || typeof (dataItem) === 'string' || typeof (dataItem) === 'number'
	        || !isNullOrUndefined(dataItem.isHeader)) {
	        return dataItem;
	    }
	    else {
	        for (var _i = 0, _a = Object.keys(fields); _i < _a.length; _i++) {
	            var field = _a[_i];
	            var dataField = fields["" + field];
	            var value = !isNullOrUndefined(dataField) &&
	                typeof (dataField) === 'string' ? getValue(dataField, dataItem) : undefined;
	            if (!isNullOrUndefined(value)) {
	                fieldData["" + dataField] = value;
	            }
	        }
	    }
	    return fieldData;
	}
	function compileTemplate(template) {
	    if (template) {
	        try {
	            if (typeof template !== 'function' && document.querySelector(template)) {
	                return compile(document.querySelector(template).innerHTML.trim());
	            }
	            else {
	                return compile(template);
	            }
	        }
	        catch (e) {
	            return compile(template);
	        }
	    }
	    return undefined;
	}

	var __extends$D = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var DATERANGEWRAPPER = 'e-date-range-wrapper';
	var INPUTCONTAINER = 'e-input-group';
	var DATERANGEICON = 'e-input-group-icon e-range-icon e-icons';
	var POPUP = 'e-popup';
	var LEFTCALENDER = 'e-left-calendar';
	var RIGHTCALENDER = 'e-right-calendar';
	var LEFTCONTAINER = 'e-left-container';
	var RIGHTCONTAINER = 'e-right-container';
	var ROOT = 'e-daterangepicker';
	var LIBRARY = 'e-lib';
	var CONTROL = 'e-control';
	var ERROR = 'e-error';
	var ACTIVE = 'e-active';
	var STARTENDCONTAINER = 'e-start-end';
	var STARTDATE = 'e-start-date';
	var ENDDATE = 'e-end-date';
	var STARTBUTTON = 'e-start-btn';
	var INPUTFOCUS = 'e-input-focus';
	var ENDBUTTON = 'e-end-btn';
	var RANGEHOVER = 'e-range-hover';
	var OTHERMONTH = 'e-other-month';
	var STARTLABEL = 'e-start-label';
	var ENDLABEL = 'e-end-label';
	var DISABLED = 'e-disabled';
	var SELECTED = 'e-selected';
	var CALENDAR = 'e-calendar';
	var NEXTICON = 'e-next';
	var PREVICON = 'e-prev';
	var HEADER = 'e-header';
	var TITLE = 'e-title';
	var ICONCONTAINER = 'e-icon-container';
	var RANGECONTAINER = 'e-date-range-container';
	var RANGEHEADER = 'e-range-header';
	var PRESETS = 'e-presets';
	var FOOTER = 'e-footer';
	var RANGEBORDER = 'e-range-border';
	var TODAY = 'e-today';
	var FOCUSDATE = 'e-focused-date';
	var CONTENT = 'e-content';
	var DAYSPAN = 'e-day-span';
	var WEEKNUMBER = 'e-week-number';
	var DATEDISABLED = 'e-date-disabled';
	var ICONDISABLED = 'e-icon-disabled';
	var CALENDARCONTAINER = 'e-calendar-container';
	var SEPARATOR = 'e-separator';
	var APPLY = 'e-apply';
	var CANCEL = 'e-cancel';
	var DEVICE = 'e-device';
	var OVERLAY = 'e-overlay';
	var CHANGEICON = 'e-change-icon e-icons';
	var LISTCLASS = 'e-list-item';
	var RTL = 'e-rtl';
	var HOVER = 'e-hover';
	var OVERFLOW = 'e-range-overflow';
	var OFFSETVALUE = 4;
	var PRIMARY = 'e-primary';
	var FLAT = 'e-flat';
	var CSS = 'e-css';
	var ZOOMIN = 'e-zoomin';
	var NONEDITABLE = 'e-non-edit';
	var DAYHEADERLONG = 'e-daterange-day-header-lg';
	var HIDDENELEMENT = 'e-daterange-hidden';
	var wrapperAttr = ['title', 'class', 'style'];
	var Presets = /** @class */ (function (_super) {
	    __extends$D(Presets, _super);
	    function Presets() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$8([
	        Property()
	    ], Presets.prototype, "label", void 0);
	    __decorate$8([
	        Property()
	    ], Presets.prototype, "start", void 0);
	    __decorate$8([
	        Property()
	    ], Presets.prototype, "end", void 0);
	    return Presets;
	}(ChildProperty));
	/**
	 * Represents the DateRangePicker component that allows user to select the date range from the calendar
	 * or entering the range through the input element.
	 * ```html
	 * <input id="daterangepicker"/>
	 * ```
	 * ```typescript
	 * <script>
	 *   var dateRangePickerObj = new DateRangePicker({ startDate: new Date("05/07/2017"), endDate: new Date("10/07/2017") });
	 *   dateRangePickerObj.appendTo("#daterangepicker");
	 * </script>
	 * ```
	 */
	var DateRangePicker = /** @class */ (function (_super) {
	    __extends$D(DateRangePicker, _super);
	    /**
	     * Constructor for creating the widget
	     *
	     * @param {DateRangePickerModel} options - Specifies the DateRangePicker model.
	     * @param {string | HTMLInputElement} element - Specifies the element to render as component.
	     * @private
	     */
	    function DateRangePicker(options, element) {
	        var _this = _super.call(this, options, element) || this;
	        _this.isCustomRange = false;
	        _this.isCustomWindow = false;
	        _this.presetsItem = [];
	        _this.liCollections = [];
	        _this.previousEleValue = '';
	        _this.isKeyPopup = false;
	        _this.dateDisabled = false;
	        _this.isRangeIconClicked = false;
	        _this.isMaxDaysClicked = false;
	        _this.disabledDays = [];
	        _this.preventBlur = false;
	        _this.preventFocus = false;
	        _this.invalidValueString = null;
	        _this.isAngular = false;
	        _this.preventChange = false;
	        _this.isKeyPressed = false;
	        _this.dateRangeOptions = options;
	        return _this;
	    }
	    /**
	     * To Initialize the control rendering.
	     *
	     * @returns {void}
	     * @private
	     */
	    DateRangePicker.prototype.render = function () {
	        this.initialize();
	        this.setProperties({ startDate: this.startValue }, true);
	        this.setProperties({ endDate: this.endValue }, true);
	        this.setModelValue();
	        this.setDataAttribute(false);
	        if (this.element.hasAttribute('data-val')) {
	            this.element.setAttribute('data-val', 'false');
	        }
	        if (this.floatLabelType === 'Auto') {
	            Input.calculateWidth(this.inputElement, this.inputWrapper.container);
	        }
	        if (!isNullOrUndefined(this.inputWrapper.buttons[0]) && !isNullOrUndefined(this.inputWrapper.container.getElementsByClassName('e-float-text-overflow')[0]) && this.floatLabelType !== 'Never') {
	            this.inputWrapper.container.getElementsByClassName('e-float-text-overflow')[0].classList.add('e-icon');
	        }
	        if (!isNullOrUndefined(closest(this.element, 'fieldset')) && closest(this.element, 'fieldset').disabled) {
	            this.enabled = false;
	        }
	        this.renderComplete();
	    };
	    /**
	     * Initialize the event handler
	     *
	     * @returns {void}
	     * @private
	     */
	    DateRangePicker.prototype.preRender = function () {
	        this.keyInputConfigs = {
	            altDownArrow: 'alt+downarrow',
	            escape: 'escape',
	            enter: 'enter',
	            tab: 'tab',
	            altRightArrow: 'alt+rightarrow',
	            altLeftArrow: 'alt+leftarrow',
	            moveUp: 'uparrow',
	            moveDown: 'downarrow',
	            spacebar: 'space'
	        };
	        this.defaultConstant = {
	            placeholder: this.placeholder,
	            startLabel: 'Start Date',
	            endLabel: 'End Date',
	            customRange: 'Custom Range',
	            applyText: 'Apply',
	            cancelText: 'Cancel',
	            selectedDays: 'Selected Days',
	            days: 'days'
	        };
	        /**
	         * Mobile View
	         */
	        this.isMobile = (Browser.isDevice) ? true : window.matchMedia('(max-width:550px)').matches;
	        this.inputElement = this.element;
	        this.angularTag = null;
	        if (this.element.tagName === 'EJS-DATERANGEPICKER') {
	            this.angularTag = this.element.tagName;
	            this.inputElement = this.createElement('input');
	            this.element.appendChild(this.inputElement);
	        }
	        this.cloneElement = this.element.cloneNode(true);
	        removeClass([this.cloneElement], [ROOT, CONTROL, LIBRARY]);
	        this.updateHtmlAttributeToElement();
	        if (this.element.getAttribute('id')) {
	            if (this.angularTag !== null) {
	                this.inputElement.id = this.element.getAttribute('id') + '_input';
	            }
	        }
	        else {
	            this.element.id = getUniqueID('ej2-datetimepicker');
	            if (this.angularTag !== null) {
	                attributes(this.inputElement, { 'id': this.element.id + '_input' });
	            }
	        }
	        this.checkInvalidRange(this.value);
	        if (!this.invalidValueString && (typeof (this.value) === 'string')) {
	            var rangeArray = this.value.split(' ' + this.separator + ' ');
	            this.value = [new Date(rangeArray[0]), new Date(rangeArray[1])];
	        }
	        this.initProperty();
	        this.tabIndex = this.element.hasAttribute('tabindex') ? this.element.getAttribute('tabindex') : '0';
	        this.element.removeAttribute('tabindex');
	        _super.prototype.preRender.call(this);
	        this.navNextFunction = this.navNextMonth.bind(this);
	        this.navPrevFunction = this.navPrevMonth.bind(this);
	        this.deviceNavNextFunction = this.deviceNavNext.bind(this);
	        this.deviceNavPrevFunction = this.deviceNavPrevious.bind(this);
	        this.initStartDate = this.checkDateValue(this.startValue);
	        this.initEndDate = this.checkDateValue(this.endValue);
	        this.formElement = closest(this.element, 'form');
	    };
	    DateRangePicker.prototype.updateValue = function () {
	        if (this.value && this.value.length > 0) {
	            if (this.value[0] instanceof Date && !isNaN(+this.value[0])) {
	                this.setProperties({ startDate: this.value[0] }, true);
	                this.startValue = this.value[0];
	            }
	            else if (typeof this.value[0] === 'string') {
	                if (+this.value[0] === 0 || isNaN(+(new Date(this.checkValue(this.value[0]))))) {
	                    this.startValue = null;
	                    this.setValue();
	                }
	                else {
	                    this.setProperties({ startDate: new Date(this.checkValue(this.value[0])) }, true);
	                    this.startValue = new Date(this.checkValue(this.value[0]));
	                }
	            }
	            else {
	                this.startValue = null;
	                this.setValue();
	            }
	            if (this.value[1] instanceof Date && !isNaN(+this.value[1])) {
	                this.setProperties({ endDate: this.value[1] }, true);
	                this.endValue = this.value[1];
	            }
	            else if (typeof this.value[1] === 'string') {
	                if (+this.value[0] === 0 || isNaN(+(new Date(this.checkValue(this.value[0]))))) {
	                    this.setProperties({ endDate: null }, true);
	                    this.endValue = null;
	                    this.setValue();
	                }
	                else {
	                    this.setProperties({ endDate: new Date(this.checkValue(this.value[1])) }, true);
	                    this.endValue = new Date(this.checkValue(this.value[1]));
	                    this.setValue();
	                }
	            }
	            else {
	                this.setProperties({ endDate: null }, true);
	                this.endValue = null;
	                this.setValue();
	            }
	        }
	        else if (this.value && this.value.start) {
	            if (this.value.start instanceof Date && !isNaN(+this.value.start)) {
	                this.setProperties({ startDate: this.value.start }, true);
	                this.startValue = this.value.start;
	            }
	            else if (typeof this.value.start === 'string') {
	                this.setProperties({ startDate: new Date(this.checkValue(this.value.start)) }, true);
	                this.startValue = new Date(this.checkValue(this.value.start));
	            }
	            else {
	                this.startValue = null;
	                this.setValue();
	            }
	            if (this.value.end instanceof Date && !isNaN(+this.value.end)) {
	                this.setProperties({ endDate: this.value.end }, true);
	                this.endValue = this.value.end;
	            }
	            else if (typeof this.value.end === 'string') {
	                this.setProperties({ endDate: new Date(this.checkValue(this.value.end)) }, true);
	                this.endValue = new Date(this.checkValue(this.value.end));
	                this.setValue();
	            }
	            else {
	                this.setProperties({ endDate: null }, true);
	                this.endValue = null;
	                this.setValue();
	            }
	        }
	        else if (isNullOrUndefined(this.value)) {
	            this.endValue = this.checkDateValue(new Date(this.checkValue(this.endDate)));
	            this.startValue = this.checkDateValue(new Date(this.checkValue(this.startDate)));
	            this.setValue();
	        }
	    };
	    DateRangePicker.prototype.initProperty = function () {
	        this.globalize = new Internationalization(this.locale);
	        this.checkFormat();
	        this.checkView();
	        if (isNullOrUndefined(this.firstDayOfWeek) || this.firstDayOfWeek > 6 || this.firstDayOfWeek < 0) {
	            this.setProperties({ firstDayOfWeek: this.globalize.getFirstDayOfWeek() }, true);
	        }
	        this.updateValue();
	    };
	    DateRangePicker.prototype.checkFormat = function () {
	        if (this.format) {
	            if (typeof this.format === 'string') {
	                this.formatString = this.format;
	            }
	            else if (this.format.skeleton !== '' && !isNullOrUndefined(this.format.skeleton)) {
	                var skeletonString = this.format.skeleton;
	                this.formatString = this.globalize.getDatePattern({ skeleton: skeletonString, type: 'date' });
	            }
	            else {
	                this.formatString = null;
	            }
	        }
	        else {
	            this.formatString = null;
	        }
	    };
	    DateRangePicker.prototype.initialize = function () {
	        if (this.angularTag !== null) {
	            this.validationAttribute(this.element, this.inputElement);
	        }
	        this.checkHtmlAttributes(false);
	        merge(this.defaultKeyConfigs, { shiftTab: 'shift+tab', tab: 'tab' });
	        var start = this.checkDateValue(new Date(this.checkValue(this.startValue)));
	        this.setProperties({ startDate: start }, true); // persist the value propeerty.
	        this.setProperties({ endValue: this.checkDateValue(new Date(this.checkValue(this.endValue))) }, true);
	        this.setValue();
	        this.setProperties({ min: this.checkDateValue(new Date(this.checkValue(this.min))) }, true);
	        this.setProperties({ max: this.checkDateValue(new Date(this.checkValue(this.max))) }, true);
	        this.l10n = new L10n('daterangepicker', this.defaultConstant, this.locale);
	        this.l10n.setLocale(this.locale);
	        this.setProperties({ placeholder: this.placeholder || this.l10n.getConstant('placeholder') }, true);
	        this.processPresets();
	        this.createInput();
	        this.updateHtmlAttributeToWrapper();
	        this.setRangeAllowEdit();
	        this.bindEvents();
	    };
	    DateRangePicker.prototype.setDataAttribute = function (isDynamic) {
	        var attributes = {};
	        if (!isDynamic) {
	            for (var i = 0; i < this.element.attributes.length; i++) {
	                attributes[this.element.attributes[i].name] =
	                    this.element.getAttribute(this.element.attributes[i].name);
	            }
	        }
	        else {
	            attributes = this.htmlAttributes;
	        }
	        for (var _i = 0, _a = Object.keys(attributes); _i < _a.length; _i++) {
	            var pro = _a[_i];
	            if (pro.indexOf('data') === 0) {
	                this.firstHiddenChild.setAttribute(pro, attributes["" + pro]);
	                this.secondHiddenChild.setAttribute(pro, attributes["" + pro]);
	            }
	        }
	    };
	    DateRangePicker.prototype.setRangeAllowEdit = function () {
	        if (this.allowEdit) {
	            if (!this.readonly) {
	                this.inputElement.removeAttribute('readonly');
	            }
	        }
	        else {
	            attributes(this.inputElement, { 'readonly': '' });
	        }
	        this.updateClearIconState();
	    };
	    DateRangePicker.prototype.updateClearIconState = function () {
	        if (!this.allowEdit && this.inputWrapper && !this.readonly) {
	            if (this.inputElement.value === '') {
	                removeClass([this.inputWrapper.container], [NONEDITABLE]);
	            }
	            else {
	                addClass([this.inputWrapper.container], [NONEDITABLE]);
	            }
	        }
	        else if (this.inputWrapper) {
	            removeClass([this.inputWrapper.container], [NONEDITABLE]);
	        }
	    };
	    DateRangePicker.prototype.validationAttribute = function (element, input) {
	        var name = element.getAttribute('name') ? element.getAttribute('name') : element.getAttribute('id');
	        input.setAttribute('name', name);
	        element.removeAttribute('name');
	        var attributes = ['required', 'aria-required', 'form'];
	        for (var i = 0; i < attributes.length; i++) {
	            if (isNullOrUndefined(element.getAttribute(attributes[i]))) {
	                continue;
	            }
	            var attr = element.getAttribute(attributes[i]);
	            input.setAttribute(attributes[i], attr);
	            element.removeAttribute(attributes[i]);
	        }
	    };
	    DateRangePicker.prototype.updateHtmlAttributeToWrapper = function () {
	        if (!isNullOrUndefined(this.htmlAttributes)) {
	            for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
	                var key = _a[_i];
	                if (wrapperAttr.indexOf(key) > -1) {
	                    if (key === 'class') {
	                        var updatedClassValue = (this.htmlAttributes["" + key].replace(/\s+/g, ' ')).trim();
	                        if (updatedClassValue !== '') {
	                            addClass([this.inputWrapper.container], updatedClassValue.split(' '));
	                        }
	                    }
	                    else if (key === 'style') {
	                        var dateRangeStyle = this.inputWrapper.container.getAttribute(key);
	                        dateRangeStyle = !isNullOrUndefined(dateRangeStyle) ? (dateRangeStyle + this.htmlAttributes["" + key]) :
	                            this.htmlAttributes["" + key];
	                        this.inputWrapper.container.setAttribute(key, dateRangeStyle);
	                    }
	                    else {
	                        this.inputWrapper.container.setAttribute(key, this.htmlAttributes["" + key]);
	                    }
	                }
	            }
	        }
	    };
	    DateRangePicker.prototype.updateHtmlAttributeToElement = function () {
	        if (!isNullOrUndefined(this.htmlAttributes)) {
	            for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
	                var key = _a[_i];
	                if (wrapperAttr.indexOf(key) < 0) {
	                    this.inputElement.setAttribute(key, this.htmlAttributes["" + key]);
	                }
	            }
	        }
	    };
	    DateRangePicker.prototype.updateCssClass = function (cssNewClass, cssOldClass) {
	        if (!isNullOrUndefined(cssOldClass)) {
	            cssOldClass = (cssOldClass.replace(/\s+/g, ' ')).trim();
	        }
	        if (!isNullOrUndefined(cssNewClass)) {
	            cssNewClass = (cssNewClass.replace(/\s+/g, ' ')).trim();
	        }
	        Input.setCssClass(cssNewClass, [this.inputWrapper.container], cssOldClass);
	        if (this.popupWrapper) {
	            Input.setCssClass(cssNewClass, [this.popupWrapper], cssOldClass);
	        }
	    };
	    DateRangePicker.prototype.processPresets = function () {
	        this.presetsItem = [];
	        var i = 0;
	        if (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label)) {
	            for (var _i = 0, _a = this.presets; _i < _a.length; _i++) {
	                var range = _a[_i];
	                var id = range.label.replace(/\s+/g, '') + '_' + (++i);
	                if (typeof range.end === 'string') {
	                    this.presetsItem.push({
	                        id: id, text: range.label, end: new Date(this.checkValue(range.end)), start: new Date(this.checkValue(range.start))
	                    });
	                }
	                else {
	                    this.presetsItem.push({ id: id, text: range.label, start: range.start, end: range.end });
	                }
	            }
	            var startDate = isNullOrUndefined(this.startValue) ? null : new Date(+this.startValue);
	            var endDate = isNullOrUndefined(this.endValue) ? null : new Date(+this.endValue);
	            this.presetsItem.push({ id: 'custom_range', text: this.l10n.getConstant('customRange'), start: startDate, end: endDate });
	            if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) {
	                this.isCustomRange = true;
	                this.activeIndex = this.presetsItem.length - 1;
	            }
	        }
	    };
	    DateRangePicker.prototype.bindEvents = function () {
	        EventHandler.add(this.inputWrapper.buttons[0], 'mousedown', this.rangeIconHandler, this);
	        EventHandler.add(this.inputElement, 'focus', this.inputFocusHandler, this);
	        EventHandler.add(this.inputElement, 'blur', this.inputBlurHandler, this);
	        EventHandler.add(this.inputElement, 'change', this.inputChangeHandler, this);
	        EventHandler.add(this.inputElement, 'keyup', this.keyupHandler, this);
	        if (this.showClearButton && this.inputWrapper.clearButton) {
	            EventHandler.add(this.inputWrapper.clearButton, 'mousedown', this.resetHandler, this);
	        }
	        if (!this.isMobile) {
	            this.keyInputConfigs = extend(this.keyInputConfigs, this.keyConfigs);
	            this.inputKeyboardModule = new KeyboardEvents(this.inputElement, {
	                eventName: 'keydown',
	                keyAction: this.inputHandler.bind(this),
	                keyConfigs: this.keyInputConfigs
	            });
	        }
	        if (this.formElement) {
	            EventHandler.add(this.formElement, 'reset', this.formResetHandler, this);
	        }
	        if (this.enabled) {
	            this.inputElement.setAttribute('tabindex', this.tabIndex);
	        }
	        else {
	            this.inputElement.tabIndex = -1;
	        }
	    };
	    DateRangePicker.prototype.unBindEvents = function () {
	        EventHandler.remove(this.inputWrapper.buttons[0], 'mousedown', this.rangeIconHandler);
	        EventHandler.remove(this.inputElement, 'blur', this.inputBlurHandler);
	        EventHandler.remove(this.inputElement, 'focus', this.inputFocusHandler);
	        EventHandler.remove(this.inputElement, 'change', this.inputChangeHandler);
	        EventHandler.remove(this.inputElement, 'keyup', this.keyupHandler);
	        if (this.showClearButton && this.inputWrapper.clearButton) {
	            EventHandler.remove(this.inputWrapper.clearButton, 'mousedown touchstart', this.resetHandler);
	        }
	        if (!this.isMobile) {
	            if (!isNullOrUndefined(this.inputKeyboardModule)) {
	                this.inputKeyboardModule.destroy();
	            }
	        }
	        if (this.formElement) {
	            EventHandler.remove(this.formElement, 'reset', this.formResetHandler);
	        }
	        this.inputElement.tabIndex = -1;
	    };
	    DateRangePicker.prototype.updateHiddenInput = function () {
	        if (this.firstHiddenChild && this.secondHiddenChild) {
	            var format = { format: this.formatString, type: 'datetime', skeleton: 'yMd' };
	            if (typeof this.startDate === 'string') {
	                this.startDate = this.globalize.parseDate(this.startDate, format);
	            }
	            if (typeof this.endDate === 'string') {
	                this.endDate = this.globalize.parseDate(this.endDate, format);
	            }
	            this.firstHiddenChild.value = (this.startDate && this.globalize.formatDate(this.startDate, format))
	                || (this.inputElement.value);
	            this.secondHiddenChild.value = (this.endDate && this.globalize.formatDate(this.endDate, format)) ||
	                (this.inputElement.value);
	            this.dispatchEvent(this.firstHiddenChild, 'focusout');
	            this.dispatchEvent(this.firstHiddenChild, 'change');
	        }
	    };
	    DateRangePicker.prototype.inputChangeHandler = function (e) {
	        if (!this.enabled) {
	            return;
	        }
	        e.stopPropagation();
	        this.updateHiddenInput();
	    };
	    DateRangePicker.prototype.bindClearEvent = function () {
	        if (this.showClearButton && this.inputWrapper.clearButton) {
	            EventHandler.add(this.inputWrapper.clearButton, 'mousedown', this.resetHandler, this);
	        }
	    };
	    DateRangePicker.prototype.resetHandler = function (e) {
	        if (!this.enabled) {
	            return;
	        }
	        this.valueType = this.value;
	        e.preventDefault();
	        this.clear();
	        var clearedArgs = {
	            event: e
	        };
	        this.setProperties({ endDate: this.checkDateValue(this.endValue) }, true);
	        this.setProperties({ startDate: this.checkDateValue(this.startValue) }, true);
	        this.trigger('cleared', clearedArgs);
	        this.changeTrigger(e);
	        this.clearRange();
	        this.hide(e);
	        if (closest(this.element, 'form')) {
	            var element = this.firstHiddenChild;
	            var keyupEvent = document.createEvent('KeyboardEvent');
	            keyupEvent.initEvent('keyup', false, true);
	            element.dispatchEvent(keyupEvent);
	        }
	    };
	    DateRangePicker.prototype.restoreValue = function () {
	        this.previousEleValue = this.inputElement.value;
	        this.previousStartValue = this.startValue;
	        this.previousEndValue = this.endValue;
	        this.valueType = null;
	        this.initStartDate = this.checkDateValue(this.startValue);
	        this.initEndDate = this.checkDateValue(this.endValue);
	        this.setValue();
	        this.setModelValue();
	    };
	    DateRangePicker.prototype.formResetHandler = function (e) {
	        if (!this.enabled) {
	            return;
	        }
	        if (this.formElement && (e.target === this.formElement) && !this.inputElement.disabled) {
	            var val = this.inputElement.getAttribute('value');
	            if (!isNullOrUndefined(this.startCopy)) {
	                if (!isNullOrUndefined(this.value) && !isNullOrUndefined(this.value.start)) {
	                    this.setProperties({ value: { start: this.startCopy, end: this.endCopy } }, true);
	                    this.startValue = this.value.start;
	                    this.endValue = this.value.end;
	                }
	                else {
	                    this.setProperties({ value: [this.startCopy, this.endCopy] }, true);
	                    this.startValue = this.value[0];
	                    this.endValue = this.value[1];
	                }
	                this.setProperties({ startDate: this.startValue, endDate: this.endValue }, true);
	            }
	            else {
	                this.setProperties({ value: null, startDate: null, endDate: null }, true);
	                this.startValue = this.endValue = null;
	            }
	            if (this.element.tagName === 'EJS-DATERANGEPICKER') {
	                this.setProperties({ value: null, startDate: null, endDate: null }, true);
	                val = '';
	                this.startValue = this.endValue = null;
	                this.inputElement.setAttribute('value', '');
	            }
	            this.restoreValue();
	            if (this.inputElement) {
	                Input.setValue(val, this.inputElement, this.floatLabelType, this.showClearButton);
	                this.errorClass();
	            }
	        }
	    };
	    DateRangePicker.prototype.clear = function () {
	        if (this.startValue !== null) {
	            this.startValue = null;
	        }
	        if (this.endValue !== null) {
	            this.endValue = null;
	        }
	        if (this.value && this.value.start) {
	            this.setProperties({ value: { start: null, end: null } }, true);
	        }
	        if (this.value !== null && this.value.length > 0) {
	            this.setProperties({ value: null }, true);
	        }
	        Input.setValue('', this.inputElement, this.floatLabelType, this.showClearButton);
	        if (!(isNullOrUndefined(this.applyButton))) {
	            this.applyButton.disabled = this.applyButton.element.disabled = true;
	        }
	        this.removeSelection();
	    };
	    DateRangePicker.prototype.rangeIconHandler = function (e) {
	        if (!this.enabled) {
	            return;
	        }
	        if (this.isMobile) {
	            this.inputElement.setAttribute('readonly', '');
	        }
	        e.preventDefault();
	        this.targetElement = null;
	        if (this.isPopupOpen() && document.body.contains(this.popupObj.element)) {
	            this.applyFunction(e);
	        }
	        else {
	            this.isRangeIconClicked = true;
	            this.inputWrapper.container.children[0].focus();
	            this.show(null, e);
	            if (!this.isMobile) {
	                if (!isNullOrUndefined(this.leftCalendar)) {
	                    this.isRangeIconClicked = false;
	                    this.calendarFocus();
	                    this.isRangeIconClicked = true;
	                }
	            }
	            addClass([this.inputWrapper.container], [INPUTFOCUS]);
	        }
	    };
	    DateRangePicker.prototype.checkHtmlAttributes = function (isDynamic) {
	        this.globalize = new Internationalization(this.locale);
	        var attributes = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) :
	            ['startDate', 'endDate', 'minDays', 'maxDays', 'min', 'max', 'disabled', 'readonly', 'style', 'name', 'placeholder',
	                'type', 'value'];
	        var format = { format: this.formatString, type: 'date', skeleton: 'yMd' };
	        for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
	            var prop = attributes_1[_i];
	            if (!isNullOrUndefined(this.inputElement.getAttribute(prop))) {
	                switch (prop) {
	                    case 'disabled':
	                        if ((isNullOrUndefined(this.dateRangeOptions) || (this.dateRangeOptions['enabled'] === undefined)) || isDynamic) {
	                            var disabled = this.inputElement.getAttribute(prop) === 'disabled' ||
	                                this.inputElement.getAttribute(prop) === '' || this.inputElement.getAttribute(prop) === 'true' ? true : false;
	                            this.setProperties({ enabled: !disabled }, !isDynamic);
	                        }
	                        break;
	                    case 'readonly':
	                        if ((isNullOrUndefined(this.dateRangeOptions) || (this.dateRangeOptions['readonly'] === undefined)) || isDynamic) {
	                            var readonly = this.inputElement.getAttribute(prop) === 'readonly' ||
	                                this.inputElement.getAttribute(prop) === 'true' || this.inputElement.getAttribute(prop) === '' ? true : false;
	                            this.setProperties({ readonly: readonly }, !isDynamic);
	                        }
	                        break;
	                    case 'placeholder':
	                        if ((isNullOrUndefined(this.dateRangeOptions) || (this.dateRangeOptions['placeholder'] === undefined)) || isDynamic) {
	                            this.setProperties({ placeholder: this.inputElement.getAttribute(prop) }, !isDynamic);
	                        }
	                        break;
	                    case 'value':
	                        if ((isNullOrUndefined(this.dateRangeOptions) || (this.dateRangeOptions['value'] === undefined)) || isDynamic) {
	                            var value = this.inputElement.getAttribute(prop);
	                            this.setProperties(setValue(prop, value, {}), !isDynamic);
	                        }
	                        break;
	                    case 'style':
	                        this.inputElement.setAttribute('style', '' + this.inputElement.getAttribute(prop));
	                        break;
	                    case 'min':
	                        if ((isNullOrUndefined(this.min) || +this.min === +new Date(1900, 0, 1)) || isDynamic) {
	                            var dateValue = this.globalize.parseDate(this.inputElement.getAttribute(prop), format);
	                            this.setProperties(setValue(prop, dateValue, {}), !isDynamic);
	                        }
	                        break;
	                    case 'name':
	                        this.inputElement.setAttribute('name', '' + this.inputElement.getAttribute(prop));
	                        break;
	                    case 'max':
	                        if ((isNullOrUndefined(this.max) || +this.max === +new Date(2099, 11, 31)) || isDynamic) {
	                            var dateValue = this.globalize.parseDate(this.inputElement.getAttribute(prop), format);
	                            this.setProperties(setValue(prop, dateValue, {}), !isDynamic);
	                        }
	                        break;
	                    case 'startDate':
	                        if (isNullOrUndefined(this.startDate)) {
	                            var dateValue = this.globalize.parseDate(this.inputElement.getAttribute(prop), format);
	                            this.startValue = dateValue;
	                            this.setValue();
	                        }
	                        break;
	                    case 'endDate':
	                        if (isNullOrUndefined(this.endDate)) {
	                            var dateValue = this.globalize.parseDate(this.inputElement.getAttribute(prop), format);
	                            this.endValue = dateValue;
	                            this.setValue();
	                        }
	                        break;
	                    case 'minDays':
	                        if (isNullOrUndefined(this.minDays)) {
	                            this.setProperties(setValue(prop, parseInt(this.inputElement.getAttribute(prop), 10), {}), true);
	                        }
	                        break;
	                    case 'maxDays':
	                        if (isNullOrUndefined(this.maxDays)) {
	                            this.setProperties(setValue(prop, parseInt(this.inputElement.getAttribute(prop), 10), {}), true);
	                        }
	                        break;
	                    case 'type':
	                        if (this.inputElement.getAttribute(prop) !== 'text') {
	                            this.inputElement.setAttribute('type', 'text');
	                        }
	                        break;
	                }
	            }
	        }
	    };
	    DateRangePicker.prototype.createPopup = function () {
	        for (var i = 0; i < this.presetsItem.length; i++) {
	            if ((i !== (this.presetsItem.length - 1)) && this.presetsItem[i].id === 'custom_range') {
	                this.presetsItem.splice(i, 1);
	            }
	        }
	        this.activeIndex = this.presetsItem.length - 1;
	        this.isCustomRange = true;
	        for (var i = 0; i <= this.presetsItem.length - 2; i++) {
	            var startDate = this.presetsItem[i].start;
	            var endDate = this.presetsItem[i].end;
	            if (this.startValue && this.endValue) {
	                if ((+new Date(startDate.setHours(0, 0, 0, 0)) === +new Date(this.startValue.setHours(0, 0, 0, 0))) &&
	                    (+new Date(endDate.setHours(0, 0, 0, 0)) === +new Date(this.endValue.setHours(0, 0, 0, 0)))) {
	                    this.activeIndex = i;
	                    this.isCustomRange = false;
	                }
	            }
	        }
	        this.popupWrapper = createElement('div', { id: this.element.id + '_popup', className: ROOT + ' ' + POPUP });
	        this.adjustLongHeaderWidth();
	        var isPreset = (!this.isCustomRange || this.isMobile);
	        if (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label) && isPreset) {
	            this.isCustomWindow = false;
	            this.createPresets();
	            this.listRippleEffect();
	            this.renderPopup();
	        }
	        else {
	            this.isCustomWindow = true;
	            this.renderControl();
	        }
	    };
	    DateRangePicker.prototype.renderControl = function () {
	        this.createControl();
	        this.bindCalendarEvents();
	        this.updateRange((this.isMobile ? [this.calendarElement] : [this.leftCalendar, this.rightCalendar]));
	        if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue) &&
	            !isNullOrUndefined(this.renderDayCellArgs) && this.renderDayCellArgs.isDisabled) {
	            this.disabledDateRender();
	        }
	        this.updateHeader();
	    };
	    DateRangePicker.prototype.clearCalendarEvents = function () {
	        if (this.leftCalPrevIcon && this.leftCalNextIcon && this.rightCalPrevIcon && this.rightCalNextIcon) {
	            EventHandler.clearEvents(this.leftCalPrevIcon);
	            EventHandler.clearEvents(this.leftCalNextIcon);
	            EventHandler.clearEvents(this.rightCalPrevIcon);
	            EventHandler.clearEvents(this.rightCalNextIcon);
	        }
	    };
	    DateRangePicker.prototype.updateNavIcons = function () {
	        _super.prototype.iconHandler.call(this);
	    };
	    DateRangePicker.prototype.calendarIconEvent = function () {
	        this.clearCalendarEvents();
	        if (this.leftCalPrevIcon && !this.leftCalPrevIcon.classList.contains(DISABLED)) {
	            EventHandler.add(this.leftCalPrevIcon, 'mousedown', this.navPrevFunction);
	        }
	        if (this.leftCalNextIcon && !this.leftCalNextIcon.classList.contains(DISABLED)) {
	            EventHandler.add(this.leftCalNextIcon, 'mousedown', this.navNextFunction);
	        }
	        if (this.rightCalPrevIcon && !this.rightCalPrevIcon.classList.contains(DISABLED)) {
	            EventHandler.add(this.rightCalPrevIcon, 'mousedown', this.navPrevFunction);
	        }
	        if (this.rightCalNextIcon && !this.rightCalNextIcon.classList.contains(DISABLED)) {
	            EventHandler.add(this.rightCalNextIcon, 'mousedown', this.navNextFunction);
	        }
	    };
	    DateRangePicker.prototype.bindCalendarEvents = function () {
	        if (!this.isMobile) {
	            this.updateNavIcons();
	            this.calendarIconEvent();
	            this.calendarIconRipple();
	            this.headerTitleElement = this.popupObj.element.querySelector('.' + RIGHTCALENDER + ' .' + HEADER + ' .' + TITLE);
	            this.headerTitleElement = this.popupObj.element.querySelector('.' + LEFTCALENDER + ' .' + HEADER + ' .' + TITLE);
	            this.defaultKeyConfigs = extend(this.defaultKeyConfigs, this.keyConfigs);
	            this.leftKeyboardModule = new KeyboardEvents(this.leftCalendar, {
	                eventName: 'keydown',
	                keyAction: this.keyInputHandler.bind(this),
	                keyConfigs: this.defaultKeyConfigs
	            });
	            this.rightKeyboardModule = new KeyboardEvents(this.rightCalendar, {
	                eventName: 'keydown',
	                keyAction: this.keyInputHandler.bind(this),
	                keyConfigs: this.defaultKeyConfigs
	            });
	        }
	        else {
	            this.deviceCalendarEvent();
	            EventHandler.add(this.startButton.element, 'click', this.deviceHeaderClick, this);
	            EventHandler.add(this.endButton.element, 'click', this.deviceHeaderClick, this);
	        }
	        if (this.start === this.depth) {
	            this.bindCalendarCellEvents();
	        }
	        this.removeFocusedDate();
	    };
	    DateRangePicker.prototype.calendarIconRipple = function () {
	        rippleEffect(this.leftCalPrevIcon, { selector: '.e-prev', duration: 400, isCenterRipple: true });
	        rippleEffect(this.leftCalNextIcon, { selector: '.e-next', duration: 400, isCenterRipple: true });
	        rippleEffect(this.rightCalPrevIcon, { selector: '.e-prev', duration: 400, isCenterRipple: true });
	        rippleEffect(this.rightCalNextIcon, { selector: '.e-next', duration: 400, isCenterRipple: true });
	    };
	    DateRangePicker.prototype.deviceCalendarEvent = function () {
	        EventHandler.clearEvents(this.nextIcon);
	        EventHandler.clearEvents(this.previousIcon);
	        rippleEffect(this.nextIcon, { selector: '.e-prev', duration: 400, isCenterRipple: true });
	        rippleEffect(this.previousIcon, { selector: '.e-next', duration: 400, isCenterRipple: true });
	        if (this.nextIcon && !this.nextIcon.classList.contains(DISABLED)) {
	            EventHandler.add(this.nextIcon, 'mousedown', this.deviceNavNextFunction);
	        }
	        if (this.previousIcon && !this.previousIcon.classList.contains(DISABLED)) {
	            EventHandler.add(this.previousIcon, 'mousedown', this.deviceNavPrevFunction);
	        }
	    };
	    DateRangePicker.prototype.deviceNavNext = function (e) {
	        var calendar = closest(e.target, '.' + CALENDAR);
	        this.updateDeviceCalendar(calendar);
	        this.navigateNext(e);
	        this.deviceNavigation();
	    };
	    DateRangePicker.prototype.deviceNavPrevious = function (e) {
	        var calendar = closest(e.target, '.' + CALENDAR);
	        this.updateDeviceCalendar(calendar);
	        this.navigatePrevious(e);
	        this.deviceNavigation();
	    };
	    DateRangePicker.prototype.updateDeviceCalendar = function (calendar) {
	        if (calendar) {
	            this.previousIcon = calendar.querySelector('.' + PREVICON);
	            this.nextIcon = calendar.querySelector('.' + NEXTICON);
	            this.calendarElement = calendar;
	            this.deviceCalendar = calendar;
	            this.contentElement = calendar.querySelector('.' + CONTENT);
	            this.tableBodyElement = select('.' + CONTENT + ' tbody', calendar);
	            this.table = calendar.querySelector('.' + CONTENT).getElementsByTagName('table')[0];
	            this.headerTitleElement = calendar.querySelector('.' + HEADER + ' .' + TITLE);
	            this.headerElement = calendar.querySelector('.' + HEADER);
	        }
	    };
	    DateRangePicker.prototype.deviceHeaderClick = function (event) {
	        var element = event.currentTarget;
	        if (element.classList.contains(STARTBUTTON) && !isNullOrUndefined(this.startValue)) {
	            this.endButton.element.classList.remove(ACTIVE);
	            this.startButton.element.classList.add(ACTIVE);
	            var calendar = this.popupObj.element.querySelector('.' + CALENDAR);
	            this.updateDeviceCalendar(calendar);
	            if (isNullOrUndefined(this.calendarElement.querySelector('.' + STARTDATE + ':not(.e-other-month)'))) {
	                this.currentDate = new Date(+this.startValue);
	                remove(this.tableBodyElement);
	                this.createContentBody();
	                this.deviceNavigation();
	            }
	            this.removeClassDisabled();
	        }
	        else if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) {
	            this.startButton.element.classList.remove(ACTIVE);
	            this.endButton.element.classList.add(ACTIVE);
	            var calendar = this.popupObj.element.querySelector('.' + CALENDAR);
	            this.updateDeviceCalendar(calendar);
	            if (isNullOrUndefined(this.calendarElement.querySelector('.' + ENDDATE + ':not(.e-other-month)'))) {
	                this.currentDate = new Date(+this.endValue);
	                remove(this.tableBodyElement);
	                this.createContentBody();
	                this.deviceNavigation();
	            }
	            this.updateMinMaxDays(this.popupObj.element.querySelector('.' + CALENDAR));
	            this.selectableDates();
	        }
	    };
	    DateRangePicker.prototype.inputFocusHandler = function () {
	        if (!this.enabled) {
	            return;
	        }
	        this.preventBlur = false;
	        var focusArguments = {
	            model: this
	        };
	        if (!this.preventFocus) {
	            this.trigger('focus', focusArguments);
	        }
	        this.updateClearIconState();
	        if (this.openOnFocus && !this.preventFocus) {
	            this.preventFocus = true;
	            this.show();
	        }
	        else {
	            this.preventFocus = true;
	        }
	    };
	    DateRangePicker.prototype.inputBlurHandler = function (e) {
	        if (!this.enabled) {
	            return;
	        }
	        if (!this.preventBlur) {
	            var value = this.inputElement.value;
	            if (!isNullOrUndefined(this.presetsItem)) {
	                if (this.presetsItem.length > 0 && this.previousEleValue !== this.inputElement.value) {
	                    this.activeIndex = this.presetsItem.length - 1;
	                    this.isCustomRange = true;
	                }
	            }
	            if (!isNullOrUndefined(value) && value.trim() !== '') {
	                var range = value.split(' ' + this.separator + ' ');
	                if (range.length > 1) {
	                    this.invalidValueString = null;
	                    var dateOptions = { format: this.formatString, type: 'date', skeleton: 'yMd' };
	                    var start = new Date(range[0]);
	                    var end = new Date(range[1]);
	                    var startDate = this.getStartEndDate(start, false, range, dateOptions);
	                    var endDate = this.getStartEndDate(end, true, range, dateOptions);
	                    if (!isNullOrUndefined(startDate) && !isNaN(+startDate) && !isNullOrUndefined(endDate) && !isNaN(+endDate)) {
	                        var prevStartVal = this.startValue;
	                        this.startValue = startDate;
	                        var prevEndVal = this.endValue;
	                        this.endValue = endDate;
	                        this.setValue();
	                        this.refreshControl();
	                        if (value !== this.previousEleValue) {
	                            this.changeTrigger(e);
	                        }
	                        if (!this.preventBlur && document.activeElement !== this.inputElement) {
	                            this.preventFocus = false;
	                            var blurArguments = {
	                                model: this
	                            };
	                            this.trigger('blur', blurArguments);
	                        }
	                        this.updateHiddenInput();
	                        // For Mobile mode, when a value is present and choose another range and click on console
	                        // when popup is open, two startvalues and end values are updated in the popup.
	                        if (this.isMobile && this.isPopupOpen()) {
	                            this.startValue = prevStartVal;
	                            this.endValue = prevEndVal;
	                        }
	                        return;
	                    }
	                    else {
	                        if (!this.strictMode) {
	                            this.startValue = null;
	                            this.endValue = null;
	                            this.setValue();
	                        }
	                    }
	                }
	                else {
	                    if (!this.strictMode) {
	                        this.startValue = null;
	                        this.endValue = null;
	                        this.setValue();
	                    }
	                }
	            }
	            if (!this.strictMode) {
	                if (isNullOrUndefined(this.popupObj)) {
	                    this.currentDate = null;
	                }
	                this.previousStartValue = this.previousEndValue = null;
	                this.startValue = null;
	                this.endValue = null;
	                this.setValue();
	            }
	            else {
	                if (!isNullOrUndefined(value) && value.trim() === '') {
	                    this.startValue = null;
	                    this.endValue = null;
	                }
	                Input.setValue('', this.inputElement, this.floatLabelType, this.showClearButton);
	                this.updateInput();
	            }
	            this.errorClass();
	            this.changeTrigger(e);
	            if (!this.preventBlur && document.activeElement !== this.inputElement) {
	                this.preventFocus = false;
	                var blurArguments = {
	                    model: this
	                };
	                this.trigger('blur', blurArguments);
	            }
	        }
	        this.updateHiddenInput();
	    };
	    // eslint-disable-next-line @typescript-eslint/tslint/config
	    DateRangePicker.prototype.getStartEndDate = function (date, isEnd, range, dateOptions) {
	        if (this.depth === 'Month') {
	            return this.globalize.parseDate(range[isEnd ? 1 : 0].trim(), dateOptions);
	        }
	        else if (this.depth === 'Year') {
	            return new Date(date.getFullYear(), date.getMonth() + (isEnd ? 1 : 0), isEnd ? 0 : 1);
	        }
	        else {
	            return new Date(date.getFullYear(), isEnd ? 11 : 0, isEnd ? 31 : 1);
	        }
	    };
	    DateRangePicker.prototype.clearRange = function () {
	        this.previousStartValue = this.previousEndValue = null;
	        this.currentDate = null;
	    };
	    DateRangePicker.prototype.errorClass = function () {
	        var inputStr = this.inputElement.value.trim();
	        if (((isNullOrUndefined(this.endValue) && isNullOrUndefined(this.startValue) && inputStr !== '') ||
	            ((!isNullOrUndefined(this.startValue) && +this.startValue < +this.min)
	                || ((!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) && +this.startValue > +this.endValue)
	                || (!isNullOrUndefined(this.endValue) && +this.endValue > +this.max))
	            || ((this.startValue && this.isDateDisabled(this.startValue))
	                || (this.endValue && this.isDateDisabled(this.endValue)))) && inputStr !== '') {
	            addClass([this.inputWrapper.container], ERROR);
	            attributes(this.inputElement, { 'aria-invalid': 'true' });
	        }
	        else {
	            if (this.inputWrapper) {
	                removeClass([this.inputWrapper.container], ERROR);
	                attributes(this.inputElement, { 'aria-invalid': 'false' });
	            }
	        }
	    };
	    DateRangePicker.prototype.keyCalendarUpdate = function (isLeftCalendar, ele, isRemoveFocus) {
	        if (isRemoveFocus === void 0) { isRemoveFocus = true; }
	        if (isRemoveFocus) {
	            this.removeFocusedDate();
	        }
	        if (isLeftCalendar) {
	            this.leftCalCurrentDate = new Date(+this.currentDate);
	            ele = this.leftCalendar;
	        }
	        else {
	            this.rightCalCurrentDate = new Date(+this.currentDate);
	            ele = this.rightCalendar;
	        }
	        this.updateCalendarElement(ele);
	        this.table.focus();
	        return ele;
	    };
	    DateRangePicker.prototype.navInCalendar = function (e, isLeftCalendar, leftLimit, rightLimit, ele) {
	        var view = this.getViewNumber(this.currentView());
	        var date;
	        var min = this.min;
	        var max;
	        if (!isNullOrUndefined(this.maxDays) && this.isMaxDaysClicked && !isNullOrUndefined(this.startValue)) {
	            max = new Date(new Date(+this.startValue).setDate(this.startValue.getDate() + (this.maxDays - 1)));
	        }
	        else {
	            max = this.max;
	        }
	        switch (e.action) {
	            case 'moveRight':
	                date = new Date(+this.currentDate);
	                this.addDay(date, 1, e, max, min);
	                if (isLeftCalendar && +date === +rightLimit) {
	                    ele = this.keyCalendarUpdate(false, ele);
	                }
	                this.keyboardNavigate(1, view, e, max, min);
	                this.keyNavigation(ele, e);
	                break;
	            case 'moveLeft':
	                date = new Date(+this.currentDate);
	                this.addDay(date, -1, e, max, min);
	                if (!isLeftCalendar) {
	                    if (+date === +leftLimit) {
	                        ele = this.keyCalendarUpdate(true, ele);
	                    }
	                }
	                this.keyboardNavigate(-1, view, e, max, min);
	                this.keyNavigation(ele, e);
	                break;
	            case 'moveUp':
	                if (view === 0) {
	                    date = new Date(+this.currentDate);
	                    this.addDay(date, -7, e, max, min);
	                    if (+date <= +leftLimit && !isLeftCalendar) {
	                        ele = this.keyCalendarUpdate(true, ele);
	                    }
	                    this.keyboardNavigate(-7, view, e, max, min);
	                }
	                else {
	                    this.keyboardNavigate(-4, view, e, this.max, this.min); // move the current year to the previous four days.
	                }
	                this.keyNavigation(ele, e);
	                break;
	            case 'moveDown':
	                if (view === 0) {
	                    date = new Date(+this.currentDate);
	                    this.addDay(date, 7, e, max, min);
	                    if (isLeftCalendar && +date >= +rightLimit) {
	                        ele = this.keyCalendarUpdate(false, ele);
	                    }
	                    this.keyboardNavigate(7, view, e, max, min);
	                }
	                else {
	                    this.keyboardNavigate(4, view, e, this.max, this.min);
	                }
	                this.keyNavigation(ele, e);
	                break;
	            case 'home':
	                this.currentDate = this.firstDay(this.currentDate);
	                remove(this.tableBodyElement);
	                if (view === 0) {
	                    this.renderMonths(e);
	                }
	                else if (view === 1) {
	                    this.renderYears(e);
	                }
	                else {
	                    this.renderDecades(e);
	                }
	                this.keyNavigation(ele, e);
	                break;
	            case 'end':
	                this.currentDate = this.lastDay(this.currentDate, view);
	                remove(this.tableBodyElement);
	                if (view === 0) {
	                    this.renderMonths(e);
	                }
	                else if (view === 1) {
	                    this.renderYears(e);
	                }
	                else {
	                    this.renderDecades(e);
	                }
	                this.keyNavigation(ele, e);
	                break;
	            case 'tab':
	                if (this.tabKeyValidation(ele, LEFTCALENDER)) {
	                    ele = this.keyCalendarUpdate(false, ele, false);
	                    this.currentDate = this.firstCellToFocus(this.rightCalendar);
	                    view = this.getViewNumber(this.currentView());
	                    this.keyboardNavigate(0, view, e, max, min);
	                    this.keyNavigation(ele, e);
	                }
	                break;
	            case 'shiftTab':
	                if (this.tabKeyValidation(ele, RIGHTCALENDER)) {
	                    ele = this.keyCalendarUpdate(true, ele, false);
	                    this.currentDate = this.firstCellToFocus(this.leftCalendar);
	                    this.keyboardNavigate(0, view, e, max, min);
	                    this.keyNavigation(ele, e);
	                }
	                break;
	        }
	    };
	    DateRangePicker.prototype.firstCellToFocus = function (calendar) {
	        var focusAbleEle = this.getViewNumber(this.currentView()) === 2 ? calendar.children[1].firstElementChild.querySelector('td.e-cell:not(.e-week-number):not(.e-disabled):not(.e-other-year)') : calendar.children[1].firstElementChild.querySelector('td.e-cell:not(.e-week-number):not(.e-disabled):not(.e-other-month)');
	        var focusEleID = focusAbleEle && focusAbleEle.id ? focusAbleEle.id.split('_')[0] : null;
	        var currentFirstDay = new Date(this.currentDate.getFullYear(), this.currentDate.getMonth(), 1);
	        var focusDate = focusEleID ? new Date(+focusEleID) : currentFirstDay;
	        return focusDate;
	    };
	    DateRangePicker.prototype.keyInputHandler = function (e, value) {
	        var date;
	        var view = this.getViewNumber(this.currentView());
	        var rightDateLimit = new Date(this.rightCalCurrentDate.getFullYear(), this.rightCalCurrentDate.getMonth(), 1);
	        var leftDateLimit = new Date(this.leftCalCurrentDate.getFullYear(), this.leftCalCurrentDate.getMonth() + 1, 0);
	        var ele = closest(e.target, '.' + RIGHTCALENDER);
	        ele = isNullOrUndefined(ele) ? this.leftCalendar : ele;
	        var isLeftCalendar = ele.classList.contains(LEFTCALENDER);
	        this.updateCalendarElement(ele);
	        var selectedDate = this.tableBodyElement.querySelector('tr td.e-selected');
	        var focusedDate = ele.querySelector('tr td.' + FOCUSDATE);
	        var startDate = ele.querySelector('tr td.' + STARTDATE);
	        var endDate = ele.querySelector('tr td.' + ENDDATE);
	        var depthValue = this.getViewNumber(this.depth);
	        var levelRestrict = (view === depthValue && this.getViewNumber(this.start) >= depthValue);
	        var leftCalendar = closest(e.target, '.' + LEFTCALENDER);
	        var rightCalendar = closest(e.target, '.' + RIGHTCALENDER);
	        var presetElement = closest(e.target, '.' + PRESETS);
	        if (!isNullOrUndefined(focusedDate)) {
	            // eslint-disable-next-line no-self-assign
	            this.currentDate = this.currentDate;
	        }
	        else if (!isNullOrUndefined(endDate) && !this.dateDisabled) {
	            this.currentDate = new Date(+this.endValue);
	        }
	        else if (!isNullOrUndefined(startDate) && !this.dateDisabled) {
	            this.currentDate = new Date(+this.startValue);
	        }
	        else if (!this.dateDisabled) {
	            this.currentDate.setDate(1);
	        }
	        this.effect = '';
	        switch (e.action) {
	            case 'altUpArrow':
	                if (this.isPopupOpen()) {
	                    this.hide(e);
	                    this.preventFocus = true;
	                    this.inputElement.focus();
	                    addClass([this.inputWrapper.container], [INPUTFOCUS]);
	                }
	                break;
	            case 'select':
	                if (levelRestrict) {
	                    var element = !isNullOrUndefined(focusedDate) ? focusedDate : startDate;
	                    if (!isNullOrUndefined(element) && !element.classList.contains(DISABLED)) {
	                        this.selectRange(null, (element));
	                    }
	                }
	                else {
	                    if (!isNullOrUndefined(selectedDate) && !levelRestrict || !isNullOrUndefined(focusedDate)) {
	                        if (!isNullOrUndefined(this.value)) {
	                            if (this.calendarElement.classList.contains(LEFTCALENDER)) {
	                                value = this.startDate;
	                            }
	                            else {
	                                value = this.endDate;
	                            }
	                        }
	                        this.controlDown = e;
	                        this.contentClick(null, --view, (focusedDate || selectedDate), value);
	                    }
	                }
	                e.preventDefault();
	                break;
	            case 'controlHome':
	                {
	                    var yearDate = new Date(this.currentDate.getFullYear(), 0, 1);
	                    if (!isLeftCalendar && +yearDate < +leftDateLimit) {
	                        ele = this.keyCalendarUpdate(true, ele);
	                    }
	                    _super.prototype.navigateTo.call(this, 'Month', new Date(this.currentDate.getFullYear(), 0, 1));
	                    this.keyNavigation(ele, e);
	                }
	                break;
	            case 'altRightArrow':
	                if (!isNullOrUndefined(leftCalendar)) {
	                    this.rightCalendar.children[1].firstElementChild.focus();
	                }
	                else if (!isNullOrUndefined(rightCalendar)) {
	                    if (!isNullOrUndefined(this.presetElement)) {
	                        this.presetElement.focus();
	                        this.removeFocusedDate();
	                    }
	                    else {
	                        this.cancelButton.element.focus();
	                    }
	                }
	                else {
	                    if (!isNullOrUndefined(presetElement)) {
	                        this.cancelButton.element.focus();
	                    }
	                }
	                e.preventDefault();
	                break;
	            case 'altLeftArrow':
	                if (!isNullOrUndefined(leftCalendar)) {
	                    if (this.applyButton.element.disabled !== true) {
	                        this.applyButton.element.focus();
	                    }
	                    else {
	                        this.cancelButton.element.focus();
	                    }
	                }
	                else {
	                    if (!isNullOrUndefined(rightCalendar)) {
	                        this.leftCalendar.children[1].firstElementChild.focus();
	                    }
	                }
	                e.preventDefault();
	                break;
	            case 'controlUp':
	                if (this.calendarElement.classList.contains(LEFTCALENDER)) {
	                    this.calendarNavigation(e, this.calendarElement);
	                }
	                else {
	                    this.calendarNavigation(e, this.calendarElement);
	                }
	                e.preventDefault();
	                break;
	            case 'controlDown':
	                if ((!isNullOrUndefined(selectedDate) || !isNullOrUndefined(focusedDate)) && !levelRestrict) {
	                    if (!isNullOrUndefined(this.value)) {
	                        if (this.calendarElement.classList.contains(LEFTCALENDER)) {
	                            value = this.startDate;
	                        }
	                        else {
	                            value = this.endDate;
	                        }
	                    }
	                    this.controlDown = e;
	                    this.contentClick(null, --view, (selectedDate || focusedDate), value);
	                }
	                e.preventDefault();
	                break;
	            case 'controlEnd':
	                {
	                    var yearDate = new Date(this.currentDate.getFullYear(), 11, 31);
	                    if (isLeftCalendar && +yearDate > +rightDateLimit) {
	                        ele = this.keyCalendarUpdate(false, ele);
	                    }
	                    _super.prototype.navigateTo.call(this, 'Month', new Date(this.currentDate.getFullYear(), 11, 31));
	                    this.keyNavigation(ele, e);
	                }
	                break;
	            case 'pageUp':
	                date = new Date(+this.currentDate);
	                this.addMonths(date, -1);
	                if (!isLeftCalendar && +date <= +leftDateLimit) {
	                    ele = this.keyCalendarUpdate(true, ele);
	                }
	                this.addMonths(this.currentDate, -1);
	                _super.prototype.navigateTo.call(this, 'Month', this.currentDate);
	                this.keyNavigation(ele, e);
	                break;
	            case 'pageDown':
	                date = new Date(+this.currentDate);
	                this.addMonths(date, 1);
	                if (isLeftCalendar && +date >= +rightDateLimit) {
	                    ele = this.keyCalendarUpdate(false, ele);
	                }
	                this.addMonths(this.currentDate, 1);
	                _super.prototype.navigateTo.call(this, 'Month', this.currentDate);
	                this.keyNavigation(ele, e);
	                break;
	            case 'shiftPageUp':
	                date = new Date(+this.currentDate);
	                this.addYears(date, -1);
	                if (!isLeftCalendar && +date <= +leftDateLimit) {
	                    ele = this.keyCalendarUpdate(true, ele);
	                }
	                this.addYears(this.currentDate, -1);
	                _super.prototype.navigateTo.call(this, 'Month', this.currentDate);
	                this.keyNavigation(ele, e);
	                break;
	            case 'shiftPageDown':
	                date = new Date(+this.currentDate);
	                this.addYears(date, 1);
	                if (isLeftCalendar && +date >= +rightDateLimit) {
	                    ele = this.keyCalendarUpdate(false, ele);
	                }
	                this.addYears(this.currentDate, 1);
	                _super.prototype.navigateTo.call(this, 'Month', this.currentDate);
	                this.keyNavigation(ele, e);
	                break;
	            case 'shiftTab':
	                if (!isNullOrUndefined(this.presetElement)) {
	                    this.presetElement.setAttribute('tabindex', '0');
	                    this.presetElement.focus();
	                    this.removeFocusedDate();
	                }
	                if (isLeftCalendar) {
	                    e.preventDefault();
	                }
	                if (this.tabKeyValidation(ele, RIGHTCALENDER)) {
	                    this.currentDate = new Date(+this.leftCalCurrentDate);
	                    this.navInCalendar(e, isLeftCalendar, leftDateLimit, rightDateLimit, ele);
	                }
	                break;
	            case 'spacebar':
	                if (this.applyButton && !this.applyButton.disabled) {
	                    this.applyFunction(e);
	                }
	                break;
	            case 'tab':
	                if (this.tabKeyValidation(ele, LEFTCALENDER)) {
	                    this.currentDate = new Date(+this.rightCalCurrentDate);
	                    this.navInCalendar(e, isLeftCalendar, leftDateLimit, rightDateLimit, ele);
	                }
	                break;
	            default:
	                this.navInCalendar(e, isLeftCalendar, leftDateLimit, rightDateLimit, ele);
	                this.checkMinMaxDays();
	        }
	        this.presetHeight();
	    };
	    DateRangePicker.prototype.tabKeyValidation = function (ele, calendarPos) {
	        var isLeftCalendar = ele.classList.contains(calendarPos);
	        var rightHeader = this.rightCalendar.querySelector('.e-header');
	        var leftHeader = this.leftCalendar.querySelector('.e-header');
	        var isRightMonth = rightHeader ? rightHeader.classList.contains('e-month') : false;
	        var isLeftMonth = leftHeader ? leftHeader.classList.contains('e-month') : false;
	        var isRightYear = rightHeader ? rightHeader.classList.contains('e-year') : false;
	        var isLeftYear = leftHeader ? leftHeader.classList.contains('e-year') : false;
	        var isRightDecade = rightHeader ? rightHeader.classList.contains('e-decade') : false;
	        var isLeftDecade = leftHeader ? leftHeader.classList.contains('e-decade') : false;
	        return isLeftCalendar && (isLeftMonth || isLeftYear || isLeftDecade) &&
	            (isRightMonth || isRightYear || isRightDecade) && !this.isMobile;
	    };
	    DateRangePicker.prototype.keyNavigation = function (calendar, e) {
	        this.bindCalendarCellEvents(calendar);
	        if (calendar.classList.contains(LEFTCALENDER)) {
	            this.leftCalCurrentDate = new Date(+this.currentDate);
	        }
	        else {
	            this.rightCalCurrentDate = new Date(+this.currentDate);
	        }
	        this.updateNavIcons();
	        this.calendarIconEvent();
	        this.updateRange([calendar]);
	        this.dateDisabled = this.isDateDisabled(this.currentDate);
	        e.preventDefault();
	    };
	    DateRangePicker.prototype.inputHandler = function (e) {
	        switch (e.action) {
	            case 'altDownArrow':
	                if (!this.isPopupOpen()) {
	                    if (this.inputElement.value === '') {
	                        this.clear();
	                        this.changeTrigger(e);
	                        this.clearRange();
	                    }
	                    this.show(null, e);
	                    this.isRangeIconClicked = false;
	                    if (!this.isMobile) {
	                        if (!isNullOrUndefined(this.leftCalendar)) {
	                            this.calendarFocus();
	                        }
	                    }
	                    this.isKeyPopup = true;
	                }
	                break;
	            case 'escape':
	                if (this.isPopupOpen()) {
	                    this.hide(e);
	                }
	                break;
	            case 'enter':
	                if (document.activeElement === this.inputElement) {
	                    this.inputBlurHandler(e);
	                    this.hide(e);
	                }
	                break;
	            case 'tab':
	                if (document.activeElement === this.inputElement && this.isPopupOpen()) {
	                    this.hide(e);
	                    e.preventDefault();
	                }
	                break;
	        }
	    };
	    DateRangePicker.prototype.bindCalendarCellEvents = function (calendar) {
	        var tdCells;
	        if (calendar) {
	            tdCells = calendar.querySelectorAll('.' + CALENDAR + ' td');
	        }
	        else {
	            tdCells = this.popupObj.element.querySelectorAll('.' + CALENDAR + ' td');
	        }
	        for (var _i = 0, tdCells_1 = tdCells; _i < tdCells_1.length; _i++) {
	            var cell = tdCells_1[_i];
	            EventHandler.clearEvents(cell);
	            var disabledCell = cell.classList.contains(DISABLED) || cell.classList.contains(DATEDISABLED);
	            if (!disabledCell && !cell.classList.contains(WEEKNUMBER)) {
	                if (!this.isMobile) {
	                    EventHandler.add(cell, 'mouseover', this.hoverSelection, this);
	                }
	                EventHandler.add(cell, 'mousedown', this.selectRange, this);
	            }
	        }
	    };
	    DateRangePicker.prototype.removeFocusedDate = function () {
	        var isDate = !isNullOrUndefined(this.startValue) || !isNullOrUndefined(this.endValue);
	        var focusedDate = this.popupObj.element.querySelectorAll('.' + CALENDAR + ' .' + FOCUSDATE);
	        for (var _i = 0, focusedDate_1 = focusedDate; _i < focusedDate_1.length; _i++) {
	            var ele = focusedDate_1[_i];
	            var today = new Date();
	            var eleDate = this.getIdValue(null, ele);
	            if ((this.depth === 'Month' && this.currentView() === 'Month' &&
	                (!ele.classList.contains(TODAY) || (ele.classList.contains(TODAY) && isDate)))
	                || (this.depth === 'Year' && this.currentView() === 'Year' &&
	                    ((!this.isSameMonth(today, eleDate) && !this.isSameYear(today, eleDate)) || isDate))
	                || (this.depth === 'Decade' && this.currentView() === 'Decade' &&
	                    (!this.isSameYear(today, eleDate) || isDate))) {
	                ele.classList.remove(FOCUSDATE);
	                if (!ele.classList.contains(STARTDATE) && !ele.classList.contains(ENDDATE)) {
	                    ele.removeAttribute('aria-label');
	                }
	            }
	        }
	    };
	    DateRangePicker.prototype.hoverSelection = function (event, element) {
	        var currentElement = element || event.currentTarget;
	        var currentDate = this.getIdValue(null, currentElement);
	        if (!isNullOrUndefined(this.startValue) && +this.startValue >= +this.min && +this.startValue <= +this.max) {
	            if ((!this.isDateDisabled(this.endValue) && !this.isDateDisabled(this.startValue)
	                && isNullOrUndefined(this.endValue) && isNullOrUndefined(this.startValue))
	                || (!isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue))) {
	                var tdCells = this.popupObj.element.querySelectorAll('.' + CALENDAR + ' td');
	                for (var _i = 0, tdCells_2 = tdCells; _i < tdCells_2.length; _i++) {
	                    var ele = tdCells_2[_i];
	                    var isDisabledCell = (!ele.classList.contains(DISABLED) || ele.classList.contains(DATEDISABLED));
	                    if (!ele.classList.contains(WEEKNUMBER) && isDisabledCell) {
	                        var eleDate = this.getIdValue(null, ele);
	                        var startDateValue = new Date(+this.startValue);
	                        var eleDateValue = new Date(+eleDate);
	                        if (eleDateValue.setHours(0, 0, 0, 0) >= startDateValue.setHours(0, 0, 0, 0) && +eleDate <= +currentDate) {
	                            addClass([ele], RANGEHOVER);
	                        }
	                        else {
	                            removeClass([ele], [RANGEHOVER]);
	                        }
	                    }
	                }
	            }
	        }
	    };
	    DateRangePicker.prototype.isSameStartEnd = function (startVal, endVal) {
	        var isSame = false;
	        if (this.depth === 'Month') {
	            if ((startVal).setHours(0, 0, 0, 0) === (endVal).setHours(0, 0, 0, 0)) {
	                isSame = true;
	            }
	        }
	        else if (this.depth === 'Year') {
	            if ((startVal.getFullYear() === endVal.getFullYear()) &&
	                (startVal.getMonth() === endVal.getMonth())) {
	                isSame = true;
	            }
	        }
	        else if (this.depth === 'Decade') {
	            if (startVal.getFullYear() === endVal.getFullYear()) {
	                isSame = true;
	            }
	        }
	        return isSame;
	    };
	    DateRangePicker.prototype.updateRange = function (elementCollection) {
	        if (!isNullOrUndefined(this.startValue)) {
	            for (var _i = 0, elementCollection_1 = elementCollection; _i < elementCollection_1.length; _i++) {
	                var calendar = elementCollection_1[_i];
	                var tdCells = calendar.querySelectorAll('.' + CALENDAR + ' td');
	                for (var _a = 0, tdCells_3 = tdCells; _a < tdCells_3.length; _a++) {
	                    var ele = tdCells_3[_a];
	                    if (!ele.classList.contains(WEEKNUMBER) && !ele.classList.contains(DISABLED)) {
	                        var eleDate = this.getIdValue(null, ele);
	                        var eleDateValue = this.getIdValue(null, ele);
	                        if (!isNullOrUndefined(this.endValue)) {
	                            if (this.currentView() === this.depth &&
	                                +eleDateValue.setHours(0, 0, 0, 0) >= +new Date(+this.startValue).setHours(0, 0, 0, 0)
	                                && +eleDateValue.setHours(0, 0, 0, 0) <= +new Date(+this.endValue).setHours(0, 0, 0, 0) &&
	                                !this.isSameStartEnd(new Date(+this.startValue), new Date(+this.endValue)) &&
	                                +new Date(+this.startValue).setHours(0, 0, 0, 0) >= +this.min
	                                && +new Date(+this.endValue).setHours(0, 0, 0, 0) <= +this.max
	                                && !(this.isDateDisabled(this.startValue) || this.isDateDisabled(this.endValue))) {
	                                addClass([ele], RANGEHOVER);
	                            }
	                        }
	                        else {
	                            removeClass([ele], [RANGEHOVER]);
	                        }
	                        if (ele.classList.contains(SELECTED) && ele.classList.contains(ENDDATE) &&
	                            (+eleDateValue !== +this.endValue)) {
	                            removeClass([ele], [SELECTED]);
	                            removeClass([ele], [ENDDATE]);
	                        }
	                        if (ele.classList.contains(RANGEHOVER) && (+eleDateValue > +this.endValue)) {
	                            removeClass([ele], [RANGEHOVER]);
	                        }
	                        if (!ele.classList.contains(OTHERMONTH)) {
	                            var startDateValue = new Date(+this.startValue);
	                            var eleDateValue_1 = new Date(+eleDate);
	                            if (this.currentView() === this.depth &&
	                                +eleDateValue_1.setHours(0, 0, 0, 0) === +startDateValue.setHours(0, 0, 0, 0)
	                                && +eleDateValue_1.setHours(0, 0, 0, 0) >= +startDateValue.setHours(0, 0, 0, 0) &&
	                                +this.startValue >= +this.min
	                                && !this.inputWrapper.container.classList.contains('e-error')
	                                && !(this.isDateDisabled(this.startValue) || this.isDateDisabled(this.endValue))) {
	                                addClass([ele], [STARTDATE, SELECTED]);
	                                this.addSelectedAttributes(ele, this.startValue, true);
	                            }
	                            var endDateValue = new Date(+this.endValue);
	                            if (this.currentView() === 'Year') {
	                                eleDateValue_1 = new Date(eleDateValue_1.getFullYear(), eleDateValue_1.getMonth() + 1, 0);
	                            }
	                            else if (this.currentView() === 'Decade') {
	                                eleDateValue_1 = new Date(eleDateValue_1.getFullYear(), 11, 31);
	                            }
	                            if (this.currentView() === this.depth &&
	                                !isNullOrUndefined(this.endValue) &&
	                                +eleDateValue_1.setHours(0, 0, 0, 0) === +endDateValue.setHours(0, 0, 0, 0)
	                                && +eleDateValue_1.setHours(0, 0, 0, 0) <= +endDateValue.setHours(0, 0, 0, 0) &&
	                                +this.startValue >= +this.min
	                                && !this.inputWrapper.container.classList.contains('e-error')
	                                && !(this.isDateDisabled(this.startValue) || this.isDateDisabled(this.endValue))) {
	                                addClass([ele], [ENDDATE, SELECTED]);
	                                this.addSelectedAttributes(ele, this.startValue, false);
	                            }
	                            if (+eleDate === +this.startValue && !isNullOrUndefined(this.endValue) && +eleDate === +this.endValue) {
	                                this.addSelectedAttributes(ele, this.endValue, false, true);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    };
	    DateRangePicker.prototype.checkMinMaxDays = function () {
	        if ((!isNullOrUndefined(this.minDays) && this.minDays > 0) || (!isNullOrUndefined(this.maxDays) && this.maxDays > 0)) {
	            if (!this.isMobile) {
	                this.updateMinMaxDays(this.popupObj.element.querySelector('.' + LEFTCALENDER));
	                this.updateMinMaxDays(this.popupObj.element.querySelector('.' + RIGHTCALENDER));
	            }
	            else {
	                this.updateMinMaxDays(this.popupObj.element.querySelector('.' + CALENDAR));
	            }
	        }
	    };
	    DateRangePicker.prototype.rangeArgs = function (e) {
	        var inputValue;
	        var range;
	        var startDate = !isNullOrUndefined(this.startValue) ?
	            this.globalize.formatDate(this.startValue, {
	                format: this.formatString, type: 'date', skeleton: 'yMd'
	            }) : null;
	        var endDate = !isNullOrUndefined(this.endValue) ?
	            this.globalize.formatDate(this.endValue, {
	                format: this.formatString, type: 'date', skeleton: 'yMd'
	            }) : null;
	        if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {
	            inputValue = startDate + ' ' + this.separator + ' ' + endDate;
	            range = (Math.round(Math.abs((this.removeTimeValueFromDate(this.startValue).getTime() -
	                this.removeTimeValueFromDate(this.endValue).getTime()) / (1000 * 60 * 60 * 24))) + 1);
	        }
	        else {
	            inputValue = '';
	            range = 0;
	        }
	        var args = {
	            value: this.value,
	            startDate: this.startValue,
	            endDate: this.endValue,
	            daySpan: range,
	            event: e || null,
	            element: this.element,
	            isInteracted: !isNullOrUndefined(e),
	            text: inputValue
	        };
	        return args;
	    };
	    DateRangePicker.prototype.otherMonthSelect = function (ele, isStartDate, sameDate) {
	        var value = +this.getIdValue(null, ele);
	        var dateIdString = '*[id^="/id"]:not(.e-other-month)'.replace('/id', '' + value);
	        var tdCell = this.popupObj && this.popupObj.element.querySelector(dateIdString);
	        if (!isNullOrUndefined(tdCell)) {
	            if (isStartDate) {
	                addClass([tdCell], [STARTDATE, SELECTED]);
	                this.addSelectedAttributes(tdCell, this.startValue, true);
	            }
	            else {
	                addClass([tdCell], [ENDDATE, SELECTED]);
	                this.addSelectedAttributes(tdCell, this.endValue, true);
	            }
	            if (sameDate) {
	                this.addSelectedAttributes(ele, this.endValue, false, true);
	            }
	        }
	    };
	    DateRangePicker.prototype.selectRange = function (event, element) {
	        var leftCalendar;
	        var rightCalendar;
	        if (event) {
	            event.preventDefault();
	        }
	        var date = isNullOrUndefined(event) ? this.getIdValue(null, element)
	            : this.getIdValue(event, null);
	        var y = date.getFullYear();
	        var m = date.getMonth();
	        var firstDay = new Date(y, m, 1);
	        var lastDay = new Date(y, m + 1, 0);
	        var firstMonth = new Date(y, 0, 1);
	        var lastMonth = new Date(y, 11, 31);
	        if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {
	            if (!this.isMobile || this.isMobile && !this.endButton.element.classList.contains(ACTIVE)) {
	                this.removeSelection();
	            }
	        }
	        else if (this.isMobile && this.startButton.element.classList.contains(ACTIVE)) {
	            this.removeSelection();
	        }
	        var ele = element || event.currentTarget;
	        if (isNullOrUndefined(this.startValue)) {
	            if (!isNullOrUndefined(this.previousStartValue)) {
	                date.setHours(this.previousStartValue.getHours());
	                date.setMinutes(this.previousStartValue.getMinutes());
	                date.setSeconds(this.previousStartValue.getSeconds());
	            }
	            this.startValue = (this.depth === 'Month') ? new Date(this.checkValue(date)) :
	                (this.depth === 'Year') ? firstDay : firstMonth;
	            this.endValue = null;
	            this.setValue();
	            addClass([ele], STARTDATE);
	            this.addSelectedAttributes(ele, this.startValue, true);
	            if (ele.classList.contains(OTHERMONTH)) {
	                this.otherMonthSelect(ele, true);
	            }
	            this.checkMinMaxDays();
	            this.applyButton.disabled = true;
	            this.applyButton.element.disabled = true;
	            if (this.isMobile) {
	                this.endButton.element.classList.add(ACTIVE);
	                this.startButton.element.classList.remove(ACTIVE);
	                this.endButton.element.removeAttribute('disabled');
	                this.selectableDates();
	            }
	            this.trigger('select', this.rangeArgs(event));
	        }
	        else {
	            if (+date === +this.startValue || +date > +this.startValue) {
	                if (+date === +this.startValue && !isNullOrUndefined(this.minDays) && this.minDays > 1) {
	                    return;
	                }
	                this.endValue = null;
	                this.setValue();
	                if (this.isMobile || element) {
	                    this.hoverSelection(event, element);
	                }
	                if (!isNullOrUndefined(this.previousEndValue)) {
	                    date.setHours(this.previousEndValue.getHours());
	                    date.setMinutes(this.previousEndValue.getMinutes());
	                    date.setSeconds(this.previousEndValue.getSeconds());
	                }
	                this.endValue = (this.depth === 'Month') ? new Date(this.checkValue(date)) :
	                    (this.depth === 'Year') ? lastDay : lastMonth;
	                this.setValue();
	                var endEle = this.popupObj.element.querySelectorAll('.' + ENDDATE);
	                if (this.isMobile) {
	                    this.startButton.element.classList.remove(ACTIVE);
	                    this.endButton.element.classList.add(ACTIVE);
	                    for (var _i = 0, endEle_1 = endEle; _i < endEle_1.length; _i++) {
	                        var ele_1 = endEle_1[_i];
	                        ele_1.removeAttribute('aria-label');
	                        if (!ele_1.classList.contains(STARTDATE)) {
	                            ele_1.setAttribute('aria-selected', 'false');
	                            removeClass([ele_1], [ENDDATE, SELECTED]);
	                        }
	                        else {
	                            this.addSelectedAttributes(ele_1, this.startValue, true);
	                            removeClass([ele_1], [ENDDATE]);
	                        }
	                    }
	                }
	                addClass([ele], ENDDATE);
	                if (+this.endValue === +this.startValue) {
	                    this.addSelectedAttributes(ele, this.endValue, false, true);
	                }
	                else {
	                    this.addSelectedAttributes(ele, this.endValue, false);
	                }
	                if (ele.classList.contains(OTHERMONTH)) {
	                    if (+this.endValue === +this.startValue) {
	                        this.otherMonthSelect(ele, false, true);
	                    }
	                    else {
	                        this.otherMonthSelect(ele, false);
	                    }
	                }
	                endEle = this.popupObj.element.querySelectorAll('.' + ENDDATE);
	                for (var _a = 0, endEle_2 = endEle; _a < endEle_2.length; _a++) {
	                    var ele_2 = endEle_2[_a];
	                    if (ele_2.classList.contains(STARTDATE)) {
	                        removeClass([ele_2], [RANGEHOVER]);
	                    }
	                }
	                this.applyButton.disabled = false;
	                this.applyButton.element.disabled = false;
	                if (!this.isMobile) {
	                    this.removeClassDisabled();
	                }
	                if (!isNullOrUndefined(this.renderDayCellArgs) && this.renderDayCellArgs.isDisabled) {
	                    this.disabledDateRender();
	                }
	                this.trigger('select', this.rangeArgs(event));
	            }
	            else if (+date < +this.startValue) {
	                this.removeClassDisabled();
	                this.startValue = (this.depth === 'Month') ? new Date(this.checkValue(date)) :
	                    (this.depth === 'Year') ? firstDay : firstMonth;
	                this.setValue();
	                this.removeSelectedAttributes();
	                removeClass(this.popupObj.element.querySelectorAll('.' + STARTDATE), [STARTDATE, SELECTED]);
	                addClass([ele], STARTDATE);
	                this.addSelectedAttributes(ele, this.startValue, true);
	                if (ele.classList.contains(OTHERMONTH)) {
	                    this.otherMonthSelect(ele, true);
	                }
	                this.checkMinMaxDays();
	            }
	        }
	        if (event) {
	            leftCalendar = closest(event.target, '.' + LEFTCALENDER);
	        }
	        if (!isNullOrUndefined(leftCalendar)) {
	            this.leftCalendar.children[1].firstElementChild.focus();
	        }
	        else {
	            if (event) {
	                rightCalendar = event && closest(event.target, '.' + RIGHTCALENDER);
	            }
	            if (!isNullOrUndefined(rightCalendar)) {
	                this.rightCalendar.children[1].firstElementChild.focus();
	            }
	        }
	        addClass([ele], SELECTED);
	        this.calendarIconEvent();
	        this.updateHeader();
	        this.removeFocusedDate();
	    };
	    DateRangePicker.prototype.selectableDates = function () {
	        if (!isNullOrUndefined(this.startValue)) {
	            var tdCells = this.calendarElement.querySelectorAll('.' + CALENDAR + ' td');
	            var isStartDate = false;
	            if (this.currentView() === this.depth) {
	                for (var _i = 0, tdCells_4 = tdCells; _i < tdCells_4.length; _i++) {
	                    var ele = tdCells_4[_i];
	                    if (!ele.classList.contains(STARTDATE) && !ele.classList.contains(WEEKNUMBER)) {
	                        if (!ele.classList.contains(DISABLED)) {
	                            var eleDate = this.getIdValue(null, ele);
	                            if (+eleDate < +this.startValue) {
	                                addClass([ele], [DATEDISABLED, DISABLED, OVERLAY]);
	                                EventHandler.clearEvents(ele);
	                                continue;
	                            }
	                            else {
	                                break;
	                            }
	                        }
	                    }
	                    if (ele.classList.contains(STARTDATE) && !ele.classList.contains(OTHERMONTH)) {
	                        isStartDate = true;
	                        break;
	                    }
	                }
	                if (isStartDate) {
	                    if (!this.previousIcon.classList.contains(DISABLED)) {
	                        addClass([this.previousIcon], [ICONDISABLED, DISABLED, OVERLAY]);
	                    }
	                }
	            }
	            else {
	                for (var _a = 0, tdCells_5 = tdCells; _a < tdCells_5.length; _a++) {
	                    var ele = tdCells_5[_a];
	                    var startMonth = this.startValue.getMonth();
	                    var startYear = this.startValue.getFullYear();
	                    var element = this.getIdValue(null, ele);
	                    if (!this.startButton.element.classList.contains(ACTIVE) && ((this.currentView() === 'Year' &&
	                        (element.getMonth() < startMonth) && (element.getFullYear() <= startYear))
	                        || (this.currentView() === 'Decade' && (element.getMonth() <= startMonth) &&
	                            (element.getFullYear() < startYear)))) {
	                        addClass([ele], [DISABLED]);
	                    }
	                    else {
	                        break;
	                    }
	                }
	                if (tdCells[0].classList.contains(DISABLED)) {
	                    this.previousIconHandler(true);
	                }
	                else if (tdCells[tdCells.length - 1].classList.contains(DISABLED)) {
	                    this.nextIconHandler(true);
	                }
	            }
	        }
	    };
	    DateRangePicker.prototype.updateMinMaxDays = function (calendar) {
	        if ((!isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) ||
	            (this.isMobile && this.endButton.element.classList.contains(ACTIVE))) {
	            if ((!isNullOrUndefined(this.minDays) && this.minDays > 0) || (!isNullOrUndefined(this.maxDays) && this.maxDays > 0)) {
	                var startValueSelected = this.removeTimeValueFromDate(this.startValue);
	                var minDate = new Date(new Date(+startValueSelected).setDate(startValueSelected.getDate() + (this.minDays - 1)));
	                var maxDate = new Date(new Date(+startValueSelected).setDate(startValueSelected.getDate() + (this.maxDays - 1)));
	                minDate = (!isNullOrUndefined(this.minDays) && this.minDays > 0) ? minDate : null;
	                maxDate = (!isNullOrUndefined(this.maxDays) && this.maxDays > 0) ? maxDate : null;
	                if (this.currentView() === 'Year') {
	                    minDate = isNullOrUndefined(minDate) ? null : new Date(minDate.getFullYear(), minDate.getMonth(), 0);
	                    maxDate = isNullOrUndefined(maxDate) ? null : new Date(maxDate.getFullYear(), maxDate.getMonth(), 1);
	                }
	                else if (this.currentView() === 'Decade') {
	                    minDate = isNullOrUndefined(minDate) ? null : new Date(minDate.getFullYear() - 1, 11, 1);
	                    maxDate = isNullOrUndefined(maxDate) ? null : new Date(maxDate.getFullYear(), 0, 1);
	                }
	                var tdCells = calendar.querySelectorAll('.' + CALENDAR + ' td');
	                var maxEle = void 0;
	                for (var _i = 0, tdCells_6 = tdCells; _i < tdCells_6.length; _i++) {
	                    var ele = tdCells_6[_i];
	                    if (!ele.classList.contains(STARTDATE) && !ele.classList.contains(WEEKNUMBER)) {
	                        var eleDate = this.getIdValue(null, ele);
	                        eleDate = this.removeTimeValueFromDate(eleDate);
	                        if (!isNullOrUndefined(minDate) && +eleDate === +minDate && ele.classList.contains(DISABLED)) {
	                            minDate.setDate(minDate.getDate() + 1);
	                        }
	                        if (!ele.classList.contains(DISABLED)) {
	                            if (+eleDate <= +startValueSelected) {
	                                continue;
	                            }
	                            if (!isNullOrUndefined(minDate) && +eleDate < +minDate) {
	                                addClass([ele], [DATEDISABLED, DISABLED, OVERLAY]);
	                                EventHandler.clearEvents(ele);
	                            }
	                            if (!isNullOrUndefined(maxDate) && +eleDate > +maxDate) {
	                                addClass([ele], [DATEDISABLED, DISABLED, OVERLAY]);
	                                this.isMaxDaysClicked = true;
	                                EventHandler.clearEvents(ele);
	                                if (isNullOrUndefined(maxEle) && !ele.classList.contains(OTHERMONTH)) {
	                                    maxEle = ele;
	                                }
	                            }
	                        }
	                    }
	                }
	                if (!isNullOrUndefined(maxEle)) {
	                    if (this.isMobile) {
	                        if (!this.nextIcon.classList.contains(DISABLED)) {
	                            addClass([this.nextIcon], [ICONDISABLED, DISABLED, OVERLAY]);
	                        }
	                    }
	                    else {
	                        var calendar_1 = closest(maxEle, '.' + RIGHTCALENDER);
	                        calendar_1 = isNullOrUndefined(calendar_1) ? this.leftCalendar : calendar_1;
	                        var isLeftCalendar = calendar_1.classList.contains(LEFTCALENDER);
	                        if (!isLeftCalendar) {
	                            if (!this.rightCalNextIcon.classList.contains(DISABLED)) {
	                                addClass([this.rightCalNextIcon], [ICONDISABLED, DISABLED, OVERLAY]);
	                            }
	                        }
	                        else {
	                            if (!this.rightCalNextIcon.classList.contains(DISABLED)) {
	                                addClass([this.rightCalNextIcon], [ICONDISABLED, DISABLED, OVERLAY]);
	                            }
	                            if (!this.leftCalNextIcon.classList.contains(DISABLED)) {
	                                addClass([this.leftCalNextIcon], [ICONDISABLED, DISABLED, OVERLAY]);
	                            }
	                            if (!this.rightCalPrevIcon.classList.contains(DISABLED)) {
	                                addClass([this.rightCalPrevIcon], [ICONDISABLED, DISABLED, OVERLAY]);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        else {
	            this.isMaxDaysClicked = false;
	        }
	    };
	    DateRangePicker.prototype.removeTimeValueFromDate = function (value) {
	        var dateValue = new Date(value.getFullYear(), value.getMonth(), value.getDate());
	        return dateValue;
	    };
	    DateRangePicker.prototype.removeClassDisabled = function () {
	        var tdCells = this.popupObj.element.querySelectorAll('.' + CALENDAR + ' td' + '.' + DATEDISABLED);
	        for (var _i = 0, tdCells_7 = tdCells; _i < tdCells_7.length; _i++) {
	            var ele = tdCells_7[_i];
	            if (ele.classList.contains(DATEDISABLED)) {
	                removeClass([ele], [DATEDISABLED, DISABLED, OVERLAY]);
	                EventHandler.add(ele, 'click', this.selectRange, this);
	                if (!this.isMobile) {
	                    EventHandler.add(ele, 'mouseover', this.hoverSelection, this);
	                }
	            }
	        }
	        if (this.isMobile) {
	            if (this.nextIcon.classList.contains(ICONDISABLED)) {
	                removeClass([this.nextIcon], [ICONDISABLED, DISABLED, OVERLAY]);
	            }
	            if (this.previousIcon.classList.contains(ICONDISABLED)) {
	                removeClass([this.previousIcon], [ICONDISABLED, DISABLED, OVERLAY]);
	            }
	        }
	        else {
	            if (this.rightCalNextIcon.classList.contains(ICONDISABLED)) {
	                removeClass([this.rightCalNextIcon], [ICONDISABLED, DISABLED, OVERLAY]);
	            }
	            if (this.rightCalPrevIcon.classList.contains(ICONDISABLED)) {
	                removeClass([this.rightCalPrevIcon], [ICONDISABLED, DISABLED, OVERLAY]);
	            }
	            if (this.leftCalNextIcon.classList.contains(ICONDISABLED)) {
	                removeClass([this.leftCalNextIcon], [ICONDISABLED, DISABLED, OVERLAY]);
	            }
	        }
	    };
	    DateRangePicker.prototype.updateHeader = function () {
	        var format = { type: 'date', skeleton: 'yMMMd' };
	        if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {
	            var range = (Math.round(Math.abs((this.removeTimeValueFromDate(this.startValue).getTime() -
	                this.removeTimeValueFromDate(this.endValue).getTime()) / (1000 * 60 * 60 * 24))) + 1);
	            if (!isNullOrUndefined(this.disabledDayCnt)) {
	                range = range - this.disabledDayCnt;
	                this.disabledDayCnt = null;
	            }
	            this.popupObj.element.querySelector('.' + DAYSPAN).textContent = range.toString() + ' ' + this.l10n.getConstant('days');
	        }
	        else {
	            this.popupObj.element.querySelector('.' + DAYSPAN).textContent = this.l10n.getConstant('selectedDays');
	        }
	        if (!this.isMobile) {
	            if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {
	                this.popupObj.element.querySelector('.' + ENDLABEL).textContent = this.globalize.formatDate(this.endValue, format);
	            }
	            else {
	                this.popupObj.element.querySelector('.' + ENDLABEL).textContent = this.l10n.getConstant('endLabel');
	            }
	            if (!isNullOrUndefined(this.startValue)) {
	                this.popupObj.element.querySelector('.' + STARTLABEL).textContent = this.globalize.formatDate(this.startValue, format);
	            }
	            else {
	                this.popupObj.element.querySelector('.' + STARTLABEL).textContent = this.l10n.getConstant('startLabel');
	            }
	        }
	        else {
	            if (!isNullOrUndefined(this.startValue)) {
	                this.startButton.element.textContent = this.globalize.formatDate(this.startValue, format);
	            }
	            else {
	                this.startButton.element.textContent = this.l10n.getConstant('startLabel');
	            }
	            if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {
	                this.endButton.element.textContent = this.globalize.formatDate(this.endValue, format);
	            }
	            else {
	                this.endButton.element.textContent = this.l10n.getConstant('endLabel');
	            }
	        }
	        if ((this.isDateDisabled(this.startValue) || this.isDateDisabled(this.endValue)) ||
	            ((!isNullOrUndefined(this.startValue) && +this.startValue < +this.min)
	                || (!isNullOrUndefined(this.endValue) && +this.endValue > +this.max)
	                || ((!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue))
	                    && +this.startValue > +this.endValue))) {
	            if (!this.isMobile) {
	                this.popupObj.element.querySelector('.' + DAYSPAN).textContent = this.l10n.getConstant('selectedDays');
	                this.popupObj.element.querySelector('.' + STARTLABEL).textContent = this.l10n.getConstant('startLabel');
	                this.popupObj.element.querySelector('.' + ENDLABEL).textContent = this.l10n.getConstant('endLabel');
	            }
	            else {
	                this.startButton.element.textContent = this.l10n.getConstant('startLabel');
	                this.endButton.element.textContent = this.l10n.getConstant('endLabel');
	                this.popupObj.element.querySelector('.' + DAYSPAN).textContent = this.l10n.getConstant('selectedDays');
	            }
	        }
	        if (this.popupObj.element.querySelector('#custom_range')) {
	            this.popupObj.element.querySelector('#custom_range').textContent =
	                this.l10n.getConstant('customRange') !== '' ? this.l10n.getConstant('customRange') : 'Custom Range';
	        }
	    };
	    DateRangePicker.prototype.removeSelection = function () {
	        this.startValue = null;
	        this.endValue = null;
	        this.setValue();
	        this.removeSelectedAttributes();
	        if (this.popupObj) {
	            if (this.popupObj.element.querySelectorAll('.' + SELECTED).length > 0) {
	                removeClass(this.popupObj.element.querySelectorAll('.' + SELECTED), [STARTDATE, ENDDATE, SELECTED]);
	            }
	            if (this.popupObj.element.querySelectorAll('.' + FOCUSDATE).length > 0) {
	                removeClass(this.popupObj.element.querySelectorAll('.' + FOCUSDATE), FOCUSDATE);
	            }
	            if (this.popupObj.element.querySelectorAll('.' + RANGEHOVER).length > 0) {
	                removeClass(this.popupObj.element.querySelectorAll('.' + RANGEHOVER), [RANGEHOVER]);
	            }
	        }
	    };
	    DateRangePicker.prototype.addSelectedAttributes = function (ele, date, isStartDate, sameDate) {
	        if (ele) {
	            var title = this.globalize.formatDate(date, { type: 'date', skeleton: 'full' });
	            if (!isNullOrUndefined(sameDate) && sameDate) {
	                ele.setAttribute('aria-label', 'The current start and end date is ' + '' + title);
	            }
	            else {
	                ele.setAttribute('aria-label', 'The current ' + (isStartDate ? 'start' : 'end') + ' date is ' + '' + title);
	            }
	            ele.setAttribute('aria-selected', 'true');
	        }
	    };
	    DateRangePicker.prototype.removeSelectedAttributes = function () {
	        if (this.popupObj) {
	            var start = this.popupObj.element.querySelectorAll('.' + STARTDATE);
	            for (var _i = 0, start_1 = start; _i < start_1.length; _i++) {
	                var ele = start_1[_i];
	                ele.setAttribute('aria-selected', 'false');
	                ele.removeAttribute('aria-label');
	            }
	            var end = this.popupObj.element.querySelectorAll('.' + ENDDATE);
	            for (var _a = 0, end_1 = end; _a < end_1.length; _a++) {
	                var ele = end_1[_a];
	                ele.setAttribute('aria-selected', 'false');
	                ele.removeAttribute('aria-label');
	            }
	        }
	    };
	    DateRangePicker.prototype.updateCalendarElement = function (calendar) {
	        if (calendar.classList.contains(LEFTCALENDER)) {
	            this.calendarElement = this.leftCalendar;
	            this.currentDate = this.leftCalCurrentDate;
	            this.previousIcon = this.leftCalPrevIcon;
	            this.nextIcon = this.leftCalNextIcon;
	        }
	        else {
	            this.calendarElement = this.rightCalendar;
	            this.currentDate = this.rightCalCurrentDate;
	            this.previousIcon = this.rightCalPrevIcon;
	            this.nextIcon = this.rightCalNextIcon;
	        }
	        this.contentElement = calendar.querySelector('.' + CONTENT);
	        this.tableBodyElement = select('.' + CONTENT + ' tbody', calendar);
	        this.table = calendar.querySelector('.' + CONTENT).getElementsByTagName('table')[0];
	        this.headerTitleElement = calendar.querySelector('.' + HEADER + ' .' + TITLE);
	        this.headerElement = calendar.querySelector('.' + HEADER);
	    };
	    DateRangePicker.prototype.navPrevMonth = function (e) {
	        e.preventDefault();
	        var ele = closest(e.target, '.' + LEFTCALENDER);
	        ele = isNullOrUndefined(ele) ? closest(e.target, '.' + RIGHTCALENDER) : ele;
	        this.updateCalendarElement(ele);
	        this.navigatePrevious(e);
	        if (!isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) {
	            this.updateMinMaxDays(ele);
	        }
	        this.updateControl(ele);
	    };
	    // eslint-disable-next-line @typescript-eslint/no-unused-vars
	    DateRangePicker.prototype.deviceNavigation = function (ele) {
	        this.deviceCalendarEvent();
	        this.updateRange([this.popupObj.element.querySelector('.' + CALENDAR)]);
	        if (this.endButton.element.classList.contains(ACTIVE)) {
	            this.updateMinMaxDays(this.popupObj.element.querySelector('.' + CALENDAR));
	        }
	        if (this.endButton.element.classList.contains(ACTIVE)) {
	            this.selectableDates();
	        }
	        if (this.currentView() === this.depth) {
	            this.bindCalendarCellEvents();
	        }
	        this.removeFocusedDate();
	    };
	    DateRangePicker.prototype.updateControl = function (calendar, customDate) {
	        if (customDate === void 0) { customDate = null; }
	        if (calendar.classList.contains(RIGHTCALENDER)) {
	            this.rightCalCurrentDate = new Date(+(customDate ? customDate : this.currentDate));
	        }
	        else {
	            this.leftCalCurrentDate = new Date(+this.currentDate);
	        }
	        this.calendarIconEvent();
	        if ((((this.depth === 'Month')
	            && this.leftCalendar.querySelector('.e-content').classList.contains('e-month')
	            && this.rightCalendar.querySelector('.e-content').classList.contains('e-month'))
	            || ((this.depth === 'Year')
	                && this.leftCalendar.querySelector('.e-content').classList.contains('e-year')
	                && this.rightCalendar.querySelector('.e-content').classList.contains('e-year'))
	            || ((this.depth === 'Decade')
	                && this.leftCalendar.querySelector('.e-content').classList.contains('e-decade')
	                && this.rightCalendar.querySelector('.e-content').classList.contains('e-decade')))
	            || this.isMobile) {
	            this.bindCalendarCellEvents();
	        }
	        this.removeFocusedDate();
	        this.updateRange([calendar]);
	    };
	    DateRangePicker.prototype.navNextMonth = function (event) {
	        event.preventDefault();
	        var ele = closest(event.target, '.' + LEFTCALENDER);
	        ele = isNullOrUndefined(ele) ? closest(event.target, '.' + RIGHTCALENDER) : ele;
	        this.updateCalendarElement(ele);
	        this.navigateNext(event);
	        if (!isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) {
	            this.updateMinMaxDays(ele);
	        }
	        this.updateControl(ele);
	    };
	    DateRangePicker.prototype.isPopupOpen = function () {
	        if (!isNullOrUndefined(this.popupObj) && this.popupObj.element.classList.contains(POPUP)) {
	            return true;
	        }
	        return false;
	    };
	    DateRangePicker.prototype.createRangeHeader = function () {
	        var labelContainer = this.createElement('div', { className: STARTENDCONTAINER });
	        if (!this.isMobile) {
	            var startLabel = this.createElement('a', { className: STARTLABEL });
	            var endLabel = this.createElement('a', { className: ENDLABEL });
	            var changeIcon = this.createElement('span', { className: CHANGEICON });
	            attributes(startLabel, { 'aria-atomic': 'true', 'aria-live': 'assertive', 'aria-label': 'Start Date', 'role': 'button' });
	            attributes(endLabel, { 'aria-atomic': 'true', 'aria-live': 'assertive', 'aria-label': 'End Date', 'role': 'button' });
	            labelContainer.appendChild(startLabel);
	            labelContainer.appendChild(changeIcon);
	            labelContainer.appendChild(endLabel);
	            startLabel.textContent = this.l10n.getConstant('startLabel');
	            endLabel.textContent = this.l10n.getConstant('endLabel');
	        }
	        else {
	            var endBtn = this.createElement('button', { className: ENDBUTTON });
	            var startBtn = this.createElement('button', { className: STARTBUTTON });
	            this.startButton = new Button({ content: this.l10n.getConstant('startLabel') }, startBtn);
	            this.endButton = new Button({ content: this.l10n.getConstant('endLabel') }, endBtn);
	            labelContainer.appendChild(startBtn);
	            labelContainer.appendChild(endBtn);
	        }
	        return labelContainer;
	    };
	    DateRangePicker.prototype.disableInput = function () {
	        if (this.strictMode) {
	            if (!isNullOrUndefined(this.previousStartValue) && !isNullOrUndefined(this.previousEndValue)) {
	                this.startValue = this.previousStartValue;
	                this.endValue = this.previousEndValue;
	                this.setValue();
	                this.updateInput();
	            }
	        }
	        else {
	            this.updateInput();
	            this.clearRange();
	            this.setProperties({ startDate: null }, true);
	            this.setProperties({ endDate: null }, true);
	            this.startValue = null;
	            this.endValue = null;
	            this.setValue();
	            this.errorClass();
	        }
	        this.setProperties({ enabled: false }, true);
	        Input.setEnabled(this.enabled, this.inputElement);
	        this.bindEvents();
	    };
	    DateRangePicker.prototype.validateMinMax = function () {
	        this.min = isNullOrUndefined(this.min) || !(+this.min) ? this.min = new Date(1900, 0, 1) : this.min;
	        this.max = isNullOrUndefined(this.max) || !(+this.max) ? this.max = new Date(2099, 11, 31) : this.max;
	        if (!(this.min <= this.max)) {
	            this.disableInput();
	            return;
	        }
	        if (!isNullOrUndefined(this.minDays) && !isNullOrUndefined(this.maxDays)) {
	            if (this.maxDays > 0 && this.minDays > 0 && (this.minDays > this.maxDays)) {
	                this.maxDays = null;
	            }
	        }
	        if (!isNullOrUndefined(this.minDays) && this.minDays < 0) {
	            this.minDays = null;
	        }
	        if (!isNullOrUndefined(this.maxDays) && this.maxDays < 0) {
	            this.maxDays = null;
	        }
	    };
	    DateRangePicker.prototype.validateRangeStrict = function () {
	        if (!isNullOrUndefined(this.startValue)) {
	            if (+this.startValue <= +this.min) {
	                this.startValue = this.min;
	                this.setValue();
	            }
	            else if (+this.startValue >= +this.min && +this.startValue >= +this.max) {
	                this.startValue = this.max;
	            }
	        }
	        if (!isNullOrUndefined(this.endValue)) {
	            if (+this.endValue > +this.max) {
	                this.endValue = this.max;
	                this.setValue();
	            }
	            else if (+this.endValue < +this.min) {
	                this.endValue = this.min;
	                this.setValue();
	            }
	        }
	        this.validateMinMaxDays();
	    };
	    DateRangePicker.prototype.validateRange = function () {
	        this.validateMinMaxDays();
	    };
	    DateRangePicker.prototype.validateMinMaxDays = function () {
	        if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) {
	            var range = (Math.round(Math.abs((this.removeTimeValueFromDate(this.startValue).getTime() -
	                this.removeTimeValueFromDate(this.endValue).getTime()) / (1000 * 60 * 60 * 24))) + 1);
	            if ((!isNullOrUndefined(this.minDays) && this.minDays > 0) && !(range >= this.minDays)) {
	                if (this.strictMode) {
	                    var date = new Date(+this.startValue);
	                    date.setDate(date.getDate() + (this.minDays - 1));
	                    if (+date > +this.max) {
	                        this.endValue = this.max;
	                        this.setValue();
	                    }
	                    else {
	                        this.endValue = date;
	                        this.setValue();
	                    }
	                }
	                else {
	                    this.startValue = null;
	                    this.endValue = null;
	                    this.setValue();
	                }
	            }
	            if ((!isNullOrUndefined(this.maxDays) && this.maxDays > 0) && !(range <= this.maxDays)) {
	                if (this.strictMode) {
	                    this.endValue = new Date(+this.startValue);
	                    this.endValue.setDate(this.endValue.getDate() + (this.maxDays - 1));
	                    this.setValue();
	                }
	                else {
	                    this.startValue = null;
	                    this.endValue = null;
	                    this.setValue();
	                }
	            }
	        }
	    };
	    DateRangePicker.prototype.renderCalendar = function () {
	        this.calendarElement = this.createElement('div');
	        this.calendarElement.classList.add(CALENDAR);
	        if (this.enableRtl) {
	            this.calendarElement.classList.add(RTL);
	        }
	        attributes(this.calendarElement, { 'data-role': 'calendar' });
	        _super.prototype.createHeader.call(this);
	        _super.prototype.createContent.call(this);
	    };
	    DateRangePicker.prototype.isSameMonth = function (start, end) {
	        if (start.getMonth() === end.getMonth() && start.getFullYear() === end.getFullYear()) {
	            return true;
	        }
	        return false;
	    };
	    DateRangePicker.prototype.isSameYear = function (start, end) {
	        if (start.getFullYear() === end.getFullYear()) {
	            return true;
	        }
	        return false;
	    };
	    DateRangePicker.prototype.isSameDecade = function (start, end) {
	        var startYear = start.getFullYear();
	        var endYear = end.getFullYear();
	        if ((startYear - (startYear % 10)) === (endYear - (endYear % 10))) {
	            return true;
	        }
	        return false;
	    };
	    DateRangePicker.prototype.startMonthCurrentDate = function () {
	        if (this.isSameMonth(this.min, this.max) || +this.currentDate > +this.max || this.isSameMonth(this.currentDate, this.max)) {
	            this.currentDate = new Date(+this.max);
	            this.currentDate.setDate(1);
	            this.currentDate.setMonth(this.currentDate.getMonth() - 1);
	        }
	        else if (this.currentDate < this.min) {
	            this.currentDate = new Date(this.checkValue(this.min));
	        }
	    };
	    DateRangePicker.prototype.selectNextMonth = function () {
	        if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue) && !this.isSameMonth(this.endValue, this.currentDate)
	            && !this.isDateDisabled(this.endValue) && !this.isDateDisabled(this.startValue)) {
	            this.currentDate = new Date(+this.endValue);
	        }
	        else {
	            this.currentDate.setDate(1);
	            this.currentDate.setMonth(this.currentDate.getMonth() + 1);
	            return;
	        }
	        if ((!isNullOrUndefined(this.startValue) && +this.startValue < +this.min)
	            || (!isNullOrUndefined(this.endValue) && +this.endValue > +this.max)
	            || ((!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) && +this.startValue > +this.endValue)) {
	            this.currentDate = new Date(new Date().setHours(0, 0, 0, 0));
	            this.currentDate.setDate(1);
	            var month = this.currentDate.getMonth() + 1;
	            this.currentDate.setMonth(month);
	        }
	    };
	    DateRangePicker.prototype.selectNextYear = function () {
	        if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue) && !this.isSameYear(this.endValue, this.currentDate)
	            && !this.isDateDisabled(this.endValue) && !this.isDateDisabled(this.startValue)) {
	            this.currentDate = new Date(+this.endValue);
	        }
	        else {
	            this.currentDate.setMonth(0);
	            var yr = this.currentDate.getFullYear() + 1;
	            this.currentDate.setFullYear(yr);
	            return;
	        }
	        if ((!isNullOrUndefined(this.endValue) && +this.endValue > +this.max)
	            || ((!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) && +this.startValue > +this.endValue)
	            || (!isNullOrUndefined(this.startValue) && +this.startValue < +this.min)) {
	            this.currentDate = new Date(new Date().setHours(0, 0, 0, 0));
	            this.currentDate.setMonth(0);
	            this.currentDate.setFullYear(this.currentDate.getFullYear() + 1);
	        }
	    };
	    DateRangePicker.prototype.selectNextDecade = function () {
	        if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue) && !this.isSameDecade(this.endValue, this.currentDate)
	            && !this.isDateDisabled(this.endValue) && !this.isDateDisabled(this.startValue)) {
	            this.currentDate = new Date(+this.endValue);
	        }
	        else {
	            var decyr = this.currentDate.getFullYear() + 10;
	            this.currentDate.setFullYear(decyr);
	            return;
	        }
	        if (((!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) && +this.startValue > +this.endValue)
	            || (!isNullOrUndefined(this.endValue) && +this.endValue > +this.max)
	            || (!isNullOrUndefined(this.startValue) && +this.startValue < +this.min)) {
	            this.currentDate = new Date(new Date().setHours(0, 0, 0, 0));
	            this.currentDate.setFullYear(this.currentDate.getFullYear() + 10);
	        }
	    };
	    DateRangePicker.prototype.selectStartMonth = function () {
	        if (!isNullOrUndefined(this.startValue)) {
	            if (!isNullOrUndefined(this.max) && this.isSameMonth(this.startValue, this.max)) {
	                this.currentDate = new Date(+this.max);
	                this.currentDate.setDate(1);
	                this.currentDate.setMonth(this.currentDate.getMonth() - 1);
	            }
	            else if (!(this.startValue >= this.min && this.startValue <= this.max)
	                || this.isDateDisabled(this.startValue)) {
	                this.currentDate = new Date(new Date().setHours(0, 0, 0, 0));
	            }
	            else {
	                this.currentDate = new Date(+this.startValue);
	            }
	        }
	        else {
	            this.currentDate = new Date(new Date().setHours(0, 0, 0, 0));
	            this.startMonthCurrentDate();
	        }
	        if ((!isNullOrUndefined(this.endValue) && +this.endValue > +this.max)
	            || (!isNullOrUndefined(this.startValue) && +this.startValue < +this.min)
	            || ((!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) && +this.startValue > +this.endValue)) {
	            this.currentDate = new Date(new Date().setHours(0, 0, 0, 0));
	        }
	        this.startMonthCurrentDate();
	    };
	    DateRangePicker.prototype.createCalendar = function () {
	        var calendarContainer = this.createElement('div', { className: CALENDARCONTAINER });
	        if (!this.isMobile) {
	            this.selectStartMonth();
	            this.renderCalendar();
	            this.leftCalCurrentDate = new Date(+this.currentDate);
	            this.calendarElement.classList.add(LEFTCALENDER);
	            this.leftCalPrevIcon = this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + PREVICON);
	            this.leftCalNextIcon = this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + NEXTICON);
	            this.leftTitle = this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + TITLE);
	            remove(this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + ICONCONTAINER));
	            this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + HEADER).appendChild(this.leftCalNextIcon);
	            this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + HEADER).appendChild(this.leftCalPrevIcon);
	            prepend([this.leftCalPrevIcon], this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + HEADER));
	            this.leftCalendar = this.calendarElement;
	            var leftContainer = this.createElement('div', { className: LEFTCONTAINER });
	            var rightContainer = this.createElement('div', { className: RIGHTCONTAINER });
	            leftContainer.appendChild(this.leftCalendar);
	            calendarContainer.appendChild(leftContainer);
	            if (!this.isMobile) {
	                EventHandler.add(this.leftTitle, 'click', this.leftNavTitle, this);
	            }
	            if (this.start === 'Month') {
	                this.selectNextMonth();
	            }
	            if (this.start === 'Year') {
	                this.selectNextYear();
	            }
	            if (this.start === 'Decade') {
	                this.selectNextDecade();
	            }
	            this.renderCalendar();
	            this.rightCalCurrentDate = new Date(+this.currentDate);
	            addClass([this.calendarElement], RIGHTCALENDER);
	            this.rightCalendar = this.calendarElement;
	            removeClass([this.leftCalendar && this.leftCalendar.querySelector('.e-content tbody')], 'e-zoomin');
	            removeClass([this.rightCalendar && this.rightCalendar.querySelector('.e-content tbody')], 'e-zoomin');
	            this.rightCalPrevIcon = this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + PREVICON);
	            this.rightCalNextIcon = this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + NEXTICON);
	            this.rightTitle = this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + TITLE);
	            remove(this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + ICONCONTAINER));
	            this.calendarElement.querySelector('table').setAttribute('tabindex', '0');
	            this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + HEADER).appendChild(this.rightCalNextIcon);
	            this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + HEADER).appendChild(this.rightCalPrevIcon);
	            prepend([this.rightCalPrevIcon], this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + HEADER));
	            rightContainer.appendChild(this.rightCalendar);
	            calendarContainer.appendChild(rightContainer);
	            if (!this.isMobile) {
	                EventHandler.add(this.rightTitle, 'click', this.rightNavTitle, this);
	            }
	        }
	        else {
	            if (!isNullOrUndefined(this.startValue)) {
	                this.currentDate = new Date(+this.startValue);
	            }
	            _super.prototype.validateDate.call(this);
	            _super.prototype.minMaxUpdate.call(this);
	            _super.prototype.render.call(this);
	            var prevIcon = this.calendarElement.querySelector('.' + CALENDAR + ' .' + PREVICON);
	            var nextIcon = this.calendarElement.querySelector('.' + CALENDAR + ' .' + NEXTICON);
	            remove(this.calendarElement.querySelector('.' + CALENDAR + ' .' + ICONCONTAINER));
	            this.calendarElement.querySelector('.' + CALENDAR + ' .' + HEADER).appendChild(nextIcon);
	            this.calendarElement.querySelector('.' + CALENDAR + ' .' + HEADER).appendChild(prevIcon);
	            prepend([prevIcon], this.calendarElement.querySelector('.' + CALENDAR + ' .' + HEADER));
	            this.deviceCalendar = this.calendarElement;
	            calendarContainer.appendChild(this.calendarElement);
	            this.headerTitleElement = this.calendarElement.querySelector('.' + CALENDAR + ' .' + HEADER + ' .' + TITLE);
	        }
	        return calendarContainer;
	    };
	    DateRangePicker.prototype.leftNavTitle = function (e) {
	        if (this.isPopupOpen()) {
	            this.calendarElement = this.leftCalendar;
	            this.calendarNavigation(e, this.calendarElement);
	        }
	    };
	    DateRangePicker.prototype.calendarNavigation = function (e, element) {
	        this.table = element.querySelector('table');
	        this.headerTitleElement = element.querySelector('.e-title');
	        this.tableBodyElement = element.querySelector('tbody');
	        this.tableHeadElement = element.querySelector('thead');
	        this.contentElement = element.querySelector('.e-content');
	        this.updateCalendarElement(element);
	        _super.prototype.navigateTitle.call(this, e);
	        this.updateNavIcons();
	    };
	    DateRangePicker.prototype.rightNavTitle = function (e) {
	        if (this.isPopupOpen()) {
	            this.calendarElement = this.rightCalendar;
	            this.calendarNavigation(e, this.calendarElement);
	        }
	    };
	    DateRangePicker.prototype.clickEventEmitter = function (e) {
	        if (!this.isMobile) {
	            if (closest(e.target, '.e-calendar.e-left-calendar')) {
	                this.calendarElement = this.leftCalendar;
	                this.updateCalendarElement(this.leftCalendar);
	            }
	            else {
	                this.calendarElement = this.rightCalendar;
	                this.updateCalendarElement(this.rightCalendar);
	            }
	        }
	    };
	    /* eslint-disable valid-jsdoc, jsdoc/require-returns-description */
	    /**
	     * Gets the current view of the Calendar.
	     *
	     * @returns {string}
	     * @private
	     * @hidden
	     */
	    DateRangePicker.prototype.currentView = function () {
	        return _super.prototype.currentView.call(this);
	    };
	    /* eslint-enable valid-jsdoc, jsdoc/require-returns-description */
	    DateRangePicker.prototype.getCalendarView = function (view) {
	        if (view === 'Year') {
	            return 'Year';
	        }
	        else if (view === 'Decade') {
	            return 'Decade';
	        }
	        else {
	            return 'Month';
	        }
	    };
	    DateRangePicker.prototype.navigatedEvent = function (e) {
	        this.trigger('navigated', this.navigatedArgs);
	        if (!isNullOrUndefined(this.popupObj)) {
	            var element = void 0;
	            var view = this.getCalendarView(this.currentView());
	            if (this.isMobile) {
	                if (view === this.depth) {
	                    this.bindCalendarCellEvents();
	                    this.deviceNavigation();
	                    this.removeFocusedDate();
	                    this.checkMinMaxDays();
	                }
	                else {
	                    this.selectableDates();
	                }
	            }
	            else {
	                if (!this.isMobile && view === this.depth) {
	                    element = this.calendarElement.classList.contains('e-left-calendar') ? this.leftCalendar : this.rightCalendar;
	                    if (element === this.leftCalendar && ((e && !e.currentTarget.children[0].classList.contains('e-icons'))
	                        || (!isNullOrUndefined(this.controlDown)))) {
	                        this.leftCalCurrentDate = new Date(+this.currentDate);
	                        this.effect = '';
	                        this.currentDate = this.leftCalCurrentDate;
	                        this.updateCalendarElement(this.leftCalendar);
	                        this.updateControl(this.leftCalendar);
	                        this.updateCalendarElement(this.rightCalendar);
	                        _super.prototype.navigateTo.call(this, view, this.rightCalCurrentDate);
	                        var customDate = this.rightCalCurrentDate ? this.rightCalCurrentDate : this.currentDate;
	                        this.updateControl(this.rightCalendar, customDate);
	                        this.updateNavIcons();
	                        this.calendarIconEvent();
	                        this.calendarIconRipple();
	                        this.controlDown = null;
	                    }
	                    else if (e && !e.currentTarget.children[0].classList.contains('e-icons')
	                        || (!isNullOrUndefined(this.controlDown))) {
	                        this.rightCalCurrentDate = new Date(+this.currentDate);
	                        this.effect = '';
	                        this.currentDate = this.rightCalCurrentDate;
	                        this.updateCalendarElement(this.rightCalendar);
	                        this.updateControl(this.rightCalendar);
	                        this.updateCalendarElement(this.leftCalendar);
	                        if (this.startValue && isNullOrUndefined(this.endValue)) {
	                            if (view === 'Month' && this.startValue.getMonth() < this.rightCalCurrentDate.getMonth() &&
	                                this.startValue.getFullYear() <= this.rightCalCurrentDate.getFullYear()) {
	                                _super.prototype.navigateTo.call(this, view, new Date(+this.startValue));
	                            }
	                            else if (view === 'Year' && this.startValue.getFullYear() < this.rightCalCurrentDate.getFullYear()) {
	                                _super.prototype.navigateTo.call(this, view, new Date(+this.startValue));
	                            }
	                            else {
	                                _super.prototype.navigateTo.call(this, view, this.leftCalCurrentDate);
	                            }
	                        }
	                        else {
	                            _super.prototype.navigateTo.call(this, view, this.leftCalCurrentDate);
	                        }
	                        this.updateControl(this.leftCalendar);
	                        this.updateNavIcons();
	                        this.calendarIconEvent();
	                        this.calendarIconRipple();
	                        this.controlDown = null;
	                    }
	                    this.checkMinMaxDays();
	                }
	                else {
	                    this.updateNavIcons();
	                    this.calendarIconEvent();
	                }
	            }
	        }
	    };
	    DateRangePicker.prototype.createControl = function () {
	        var controlContainer = this.createElement('div', { className: RANGECONTAINER });
	        var headerContainer = this.createElement('div', { className: RANGEHEADER });
	        if (this.isMobile && this.fullScreenMode) {
	            var modelHeaderIconWrapper = this.createElement("div", { className: "e-model-header-wrapper" });
	            var modelCloseIcon = this.createElement("span", { className: "e-popup-close" });
	            EventHandler.add(modelCloseIcon, 'mousedown touchstart', this.modelRangeCloseHandler, this);
	            var modelApplyButton = this.createElement("span", { className: "e-apply" });
	            EventHandler.add(modelApplyButton, 'mousedown touchstart', this.applyFunction, this);
	            modelHeaderIconWrapper.appendChild(modelCloseIcon);
	            modelHeaderIconWrapper.appendChild(modelApplyButton);
	            headerContainer.appendChild(modelHeaderIconWrapper);
	        }
	        var labelContainer = this.createRangeHeader();
	        headerContainer.appendChild(labelContainer);
	        var daySpan = this.createElement('div', { className: DAYSPAN });
	        attributes(daySpan, { 'aria-label': 'Selected Days' });
	        daySpan.textContent = this.l10n.getConstant('selectedDays');
	        headerContainer.appendChild(daySpan);
	        var separator = this.createElement('div', { className: SEPARATOR });
	        var calendarContainer = this.createCalendar();
	        controlContainer.appendChild(headerContainer);
	        controlContainer.appendChild(separator);
	        controlContainer.appendChild(calendarContainer);
	        var footerSection = this.createElement('div', { className: FOOTER });
	        var cancelBtn = this.createElement('button', { className: CANCEL + ' ' + FLAT + ' ' + CSS });
	        var applyBtn = this.createElement('button');
	        addClass([applyBtn], [APPLY, FLAT, PRIMARY, CSS]);
	        footerSection.appendChild(applyBtn);
	        footerSection.appendChild(cancelBtn);
	        var enable = !isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue);
	        this.cancelButton = new Button({ content: this.l10n.getConstant('cancelText') }, cancelBtn);
	        this.applyButton = new Button({ content: this.l10n.getConstant('applyText'), disabled: !enable }, applyBtn);
	        EventHandler.add(applyBtn, 'click', this.applyFunction, this);
	        EventHandler.add(cancelBtn, 'click', this.cancelFunction, this);
	        this.popupWrapper.appendChild(controlContainer);
	        if (!this.isMobile) {
	            if (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label)) {
	                this.createPresets();
	                this.listRippleEffect();
	                addClass([controlContainer], RANGEBORDER);
	                addClass([this.popupWrapper], 'e-preset-wrapper');
	                var presets = this.popupWrapper.querySelector('.' + PRESETS);
	                presets.style.height = this.popupWrapper.querySelector('.' + RANGECONTAINER).getBoundingClientRect().height + 'px';
	            }
	        }
	        this.popupWrapper.appendChild(footerSection);
	        if (this.isMobile) {
	            this.deviceHeaderUpdate();
	        }
	        this.renderPopup();
	    };
	    DateRangePicker.prototype.modelRangeCloseHandler = function (e) {
	        this.hide();
	    };
	    DateRangePicker.prototype.cancelFunction = function (eve) {
	        if (document.activeElement !== this.inputElement) {
	            this.preventFocus = true;
	            this.inputElement.focus();
	            addClass([this.inputWrapper.container], [INPUTFOCUS]);
	        }
	        eve.preventDefault();
	        if (this.isKeyPopup) {
	            this.inputElement.focus();
	            this.isKeyPopup = false;
	        }
	        this.startValue = null;
	        this.endValue = null;
	        this.removeSelection();
	        this.hide(eve);
	    };
	    DateRangePicker.prototype.deviceHeaderUpdate = function () {
	        if (isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) {
	            this.endButton.element.setAttribute('disabled', '');
	            this.startButton.element.classList.add(ACTIVE);
	        }
	        else if (!isNullOrUndefined(this.startValue)) {
	            this.startButton.element.classList.add(ACTIVE);
	        }
	    };
	    DateRangePicker.prototype.keyupHandler = function (e) {
	        this.isKeyPressed = (this.inputElement.value !== this.previousEleValue) ? true : false;
	    };
	    DateRangePicker.prototype.applyFunction = function (eve) {
	        var isValueChanged = false;
	        if (eve.type !== 'touchstart') {
	            eve.preventDefault();
	        }
	        if (this.closeEventArgs && this.closeEventArgs.cancel) {
	            this.startValue = this.popupWrapper.querySelector('.e-start-date') &&
	                this.getIdValue(null, this.popupWrapper.querySelector('.e-start-date'));
	            this.endValue = this.popupWrapper.querySelector('.e-end-date') &&
	                this.getIdValue(null, this.popupWrapper.querySelector('.e-end-date'));
	            this.setValue();
	        }
	        if (document.activeElement !== this.inputElement) {
	            this.preventFocus = true;
	            this.inputElement.focus();
	            addClass([this.inputWrapper.container], [INPUTFOCUS]);
	        }
	        if (eve.type !== 'touchstart' &&
	            this.closeEventArgs && !this.closeEventArgs.cancel) {
	            eve.preventDefault();
	        }
	        if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) {
	            this.previousStartValue = new Date(+this.startValue);
	            this.previousEndValue = new Date(+this.endValue);
	            this.previousEleValue = this.inputElement.value;
	            if (!this.isKeyPressed) {
	                Input.setValue(this.rangeArgs(eve).text, this.inputElement, this.floatLabelType, this.showClearButton);
	            }
	            this.isKeyPressed = false;
	            if (+this.initStartDate !== +this.startValue || +this.initEndDate !== +this.endValue) {
	                isValueChanged = true;
	            }
	            this.changeTrigger(eve);
	            this.hide(eve ? eve : null);
	            this.errorClass();
	            isValueChanged = true;
	        }
	        else {
	            this.hide(eve ? eve : null);
	        }
	        if (!(closest(eve.target, '.' + INPUTCONTAINER))
	            && (!isValueChanged)) {
	            this.focusOut();
	        }
	        if (!this.isMobile) {
	            this.isKeyPopup = false;
	            if (this.isRangeIconClicked) {
	                this.inputWrapper.container.children[1].focus();
	                this.keyInputConfigs = extend(this.keyInputConfigs, this.keyConfigs);
	                this.popupKeyboardModule = new KeyboardEvents(this.inputWrapper.container.children[1], {
	                    eventName: 'keydown',
	                    keyConfigs: this.keyInputConfigs,
	                    keyAction: this.popupKeyActionHandle.bind(this)
	                });
	            }
	        }
	    };
	    DateRangePicker.prototype.onMouseClick = function (event, item) {
	        if (event.type === 'touchstart') {
	            return;
	        }
	        var target = item || event.target;
	        var li = closest(target, '.' + LISTCLASS);
	        var isClick = li && li.classList.contains(ACTIVE);
	        if (li && li.classList.contains(LISTCLASS)) {
	            this.setListSelection(li, event);
	        }
	        this.preventFocus = true;
	        this.inputElement.focus();
	        if (!this.isMobile) {
	            this.preventFocus = true;
	            if (li && li.classList.contains(LISTCLASS) && li.getAttribute('id') === 'custom_range') {
	                this.leftCalendar.children[1].firstElementChild.focus();
	            }
	            else {
	                if (!isClick && event.type === 'keydown') {
	                    this.inputElement.focus();
	                }
	            }
	        }
	    };
	    DateRangePicker.prototype.onMouseOver = function (event) {
	        var li = closest(event.target, '.' + LISTCLASS);
	        if (li && li.classList.contains(LISTCLASS) && !li.classList.contains(HOVER)) {
	            addClass([li], HOVER);
	        }
	    };
	    DateRangePicker.prototype.onMouseLeave = function (event) {
	        var item = closest(event.target, '.' + HOVER);
	        if (!isNullOrUndefined(item)) {
	            removeClass([item], HOVER);
	        }
	    };
	    DateRangePicker.prototype.setListSelection = function (li, event) {
	        if (li && (!li.classList.contains(ACTIVE) || (this.isMobile && li.classList.contains(ACTIVE)))) {
	            if (this.isMobile && li.classList.contains(ACTIVE)) {
	                this.activeIndex = Array.prototype.slice.call(this.liCollections).indexOf(li);
	                var values_1 = this.presetsItem[this.activeIndex];
	                if (values_1.id === 'custom_range') {
	                    this.renderCustomPopup();
	                    return;
	                }
	                return;
	            }
	            this.removeListSelection();
	            this.activeIndex = Array.prototype.slice.call(this.liCollections).indexOf(li);
	            addClass([li], ACTIVE);
	            li.setAttribute('aria-selected', 'true');
	            var values = this.presetsItem[this.activeIndex];
	            if (values.id === 'custom_range') {
	                this.renderCustomPopup();
	            }
	            else {
	                this.applyPresetRange(values, event);
	            }
	        }
	    };
	    DateRangePicker.prototype.removeListSelection = function () {
	        var item = this.presetElement.querySelector('.' + ACTIVE);
	        if (!isNullOrUndefined(item)) {
	            removeClass([item], ACTIVE);
	            item.removeAttribute('aria-selected');
	        }
	    };
	    DateRangePicker.prototype.setValue = function () {
	        this.modelValue = [this.startValue, this.endValue];
	    };
	    DateRangePicker.prototype.applyPresetRange = function (values, e) {
	        this.hide(null);
	        this.presetsItem[this.presetsItem.length - 1].start = null;
	        this.presetsItem[this.presetsItem.length - 1].end = null;
	        this.startValue = values.start;
	        this.endValue = values.end;
	        this.setValue();
	        this.refreshControl();
	        this.trigger('select', this.rangeArgs(e));
	        this.changeTrigger(e);
	        this.previousEleValue = this.inputElement.value;
	        this.isCustomRange = false;
	        this.leftCalendar = this.rightCalendar = null;
	        if (this.isKeyPopup) {
	            this.isRangeIconClicked = false;
	            this.inputElement.focus();
	        }
	    };
	    // eslint-disable-next-line @typescript-eslint/no-unused-vars
	    DateRangePicker.prototype.showPopup = function (element, event) {
	        this.presetHeight();
	        if (this.zIndex === 1000) {
	            this.popupObj.show(null, this.element);
	        }
	        else {
	            this.popupObj.show(null, null);
	        }
	        if (this.isMobile) {
	            this.popupObj.refreshPosition();
	        }
	    };
	    DateRangePicker.prototype.renderCustomPopup = function () {
	        this.isCustomWindow = true;
	        this.popupObj.hide();
	        this.popupWrapper = this.createElement('div', { id: this.element.id + '_popup', className: ROOT + ' ' + POPUP });
	        this.renderControl();
	        this.openEventArgs.appendTo.appendChild(this.popupWrapper);
	        this.showPopup();
	        this.isCustomRange = true;
	        if (!this.isMobile) {
	            this.calendarFocus();
	        }
	    };
	    DateRangePicker.prototype.listRippleEffect = function () {
	        for (var _i = 0, _a = this.liCollections; _i < _a.length; _i++) {
	            var li = _a[_i];
	            rippleEffect(li);
	        }
	    };
	    DateRangePicker.prototype.createPresets = function () {
	        if (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label)) {
	            this.presetElement = this.createElement('div', { className: PRESETS, attrs: { 'tabindex': '0' } });
	            var listTag = ListBase.createList(this.createElement, this.presetsItem, null, true);
	            attributes(listTag, { 'role': 'listbox', 'aria-hidden': 'false', 'id': this.element.id + '_options', 'tabindex': '0' });
	            this.presetElement.appendChild(listTag);
	            this.popupWrapper.appendChild(this.presetElement);
	            var customElement = this.presetElement.querySelector('#custom_range');
	            if (!isNullOrUndefined(customElement)) {
	                customElement.textContent = this.l10n.getConstant('customRange') !== '' ? this.l10n.getConstant('customRange')
	                    : 'Custom Range';
	            }
	            this.liCollections = this.presetElement.querySelectorAll('.' + LISTCLASS);
	            this.wireListEvents();
	            if (this.isMobile) {
	                if (this.fullScreenMode) {
	                    var modelWrapper = createElement('div', { className: 'e-range-mob-popup-wrap' });
	                    var modelHeader = this.createElement('div', { className: 'e-model-header' });
	                    var modelTitleSpan = this.createElement("span", { className: "e-model-title" });
	                    modelTitleSpan.textContent = "Select Preset";
	                    var modelCloseIcon = this.createElement("span", { className: "e-popup-close" });
	                    EventHandler.add(modelCloseIcon, 'mousedown touchstart', this.modelRangeCloseHandler, this);
	                    var presetContent = this.presetElement;
	                    modelHeader.appendChild(modelCloseIcon);
	                    modelHeader.appendChild(modelTitleSpan);
	                    modelWrapper.appendChild(modelHeader);
	                    modelWrapper.appendChild(presetContent);
	                    this.popupWrapper.insertBefore(modelWrapper, this.popupWrapper.firstElementChild);
	                    this.presetElement.style.width = '100%';
	                }
	                else {
	                    this.presetElement.style.width = this.inputWrapper.container.getBoundingClientRect().width + 'px';
	                }
	            }
	            if (!isNullOrUndefined(this.activeIndex) && this.activeIndex > -1) {
	                addClass([this.liCollections[this.activeIndex]], ACTIVE);
	            }
	        }
	    };
	    DateRangePicker.prototype.wireListEvents = function () {
	        EventHandler.add(this.presetElement, 'click', this.onMouseClick, this);
	        if (!this.isMobile) {
	            EventHandler.add(this.presetElement, 'mouseover', this.onMouseOver, this);
	            EventHandler.add(this.presetElement, 'mouseout', this.onMouseLeave, this);
	        }
	    };
	    DateRangePicker.prototype.unWireListEvents = function () {
	        if (!isNullOrUndefined(this.presetElement)) {
	            EventHandler.remove(this.presetElement, 'click touchstart', this.onMouseClick);
	            if (!this.isMobile) {
	                EventHandler.remove(this.presetElement, 'mouseover', this.onMouseOver);
	                EventHandler.remove(this.presetElement, 'mouseout', this.onMouseLeave);
	            }
	        }
	    };
	    DateRangePicker.prototype.renderPopup = function () {
	        var _this = this;
	        this.popupWrapper.classList.add('e-control');
	        var popupWidth = this.popupWrapper.getBoundingClientRect().width;
	        if (!isNullOrUndefined(this.cssClass) && this.cssClass.trim() !== '') {
	            this.popupWrapper.className += ' ' + this.cssClass;
	        }
	        if (this.isMobile && this.isCustomWindow) {
	            this.modal = this.createElement('div');
	            document.body.appendChild(this.modal);
	        }
	        this.popupObj = new Popup(this.popupWrapper, {
	            relateTo: this.isMobile && this.isCustomWindow ? document.body :
	                (!isNullOrUndefined(this.targetElement) ? this.targetElement : this.inputWrapper.container),
	            position: (this.isMobile ?
	                (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label) && !this.isCustomWindow ?
	                    { X: 'left', Y: 'bottom' } : { X: 'center', Y: 'center' }) :
	                this.enableRtl ? { X: 'left', Y: 'bottom' } : { X: 'right', Y: 'bottom' }),
	            offsetX: this.isMobile || this.enableRtl ? 0 : -popupWidth,
	            offsetY: OFFSETVALUE,
	            collision: this.isMobile ?
	                (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label) && !this.isCustomWindow ?
	                    { X: 'fit' } : { X: 'fit', Y: 'fit' }) : { X: 'fit', Y: 'flip' },
	            targetType: this.isMobile && this.isCustomWindow ? 'container' : 'relative',
	            enableRtl: this.enableRtl,
	            zIndex: this.zIndex,
	            open: function () {
	                if (_this.isMobile && _this.fullScreenMode) {
	                    _this.iconRangeRight = _this.calendarElement && window.getComputedStyle(_this.calendarElement.querySelector('.e-header.e-month .e-prev')).cssFloat;
	                    if (_this.iconRangeRight) {
	                        _this.touchRangeModule = new Touch(_this.calendarElement.querySelector(".e-content.e-month"), {
	                            swipe: _this.dateRangeSwipeHandler.bind(_this)
	                        });
	                        EventHandler.add(_this.calendarElement.querySelector(".e-content.e-month"), "touchstart", _this.touchStartRangeHandler, _this);
	                    }
	                }
	                attributes(_this.inputElement, { 'aria-expanded': 'true', 'aria-owns': _this.inputElement.id + '_options' });
	                if (_this.value) {
	                    attributes(_this.inputElement, { 'aria-activedescendant': _this.inputElement.id });
	                }
	                else {
	                    _this.inputElement.removeAttribute('aria-activedescendant');
	                }
	                addClass([_this.inputWrapper.buttons[0]], ACTIVE);
	                if (!_this.isMobile) {
	                    if (_this.cancelButton) {
	                        _this.btnKeyboardModule = new KeyboardEvents(_this.cancelButton.element, {
	                            eventName: 'keydown',
	                            keyAction: _this.popupKeyActionHandle.bind(_this),
	                            keyConfigs: { tab: 'tab', altRightArrow: 'alt+rightarrow', altLeftArrow: 'alt+leftarrow' }
	                        });
	                        _this.btnKeyboardModule = new KeyboardEvents(_this.applyButton.element, {
	                            eventName: 'keydown',
	                            keyAction: _this.popupKeyActionHandle.bind(_this),
	                            keyConfigs: { altRightArrow: 'alt+rightarrow', altLeftArrow: 'alt+leftarrow' }
	                        });
	                    }
	                    if (!isNullOrUndefined(_this.leftCalendar)) {
	                        if (!_this.isRangeIconClicked) {
	                            _this.calendarFocus();
	                        }
	                    }
	                    if (!isNullOrUndefined(_this.presetElement)) {
	                        _this.keyInputConfigs = extend(_this.keyInputConfigs, _this.keyConfigs);
	                        _this.presetKeyboardModule = new KeyboardEvents(_this.presetElement, {
	                            eventName: 'keydown',
	                            keyAction: _this.presetKeyActionHandler.bind(_this),
	                            keyConfigs: _this.keyInputConfigs
	                        });
	                        _this.presetKeyboardModule = new KeyboardEvents(_this.presetElement, {
	                            eventName: 'keydown',
	                            keyAction: _this.popupKeyActionHandle.bind(_this),
	                            keyConfigs: { altRightArrow: 'alt+rightarrow', altLeftArrow: 'alt+leftarrow' }
	                        });
	                        if (isNullOrUndefined(_this.leftCalendar)) {
	                            _this.preventBlur = true;
	                            _this.presetElement.focus();
	                        }
	                        else {
	                            _this.presetElement.setAttribute('tabindex', '-1');
	                        }
	                    }
	                    _this.popupKeyBoardHandler();
	                }
	                if (_this.isMobile && !Browser.isDevice) {
	                    EventHandler.add(document, 'keydown', _this.popupCloseHandler, _this);
	                }
	            },
	            close: function () {
	                attributes(_this.inputElement, { 'aria-expanded': 'false' });
	                _this.inputElement.removeAttribute('aria-owns');
	                _this.inputElement.removeAttribute('aria-activedescendant');
	                removeClass([_this.inputWrapper.buttons[0]], ACTIVE);
	                if (_this.isRangeIconClicked) {
	                    _this.inputWrapper.container.children[1].focus();
	                }
	                if (!isUndefined(_this.presets[0].start && _this.presets[0].end && _this.presets[0].label)) {
	                    _this.unWireListEvents();
	                }
	                if (!isNullOrUndefined(_this.popupObj)) {
	                    if (!isNullOrUndefined(_this.popupObj.element.parentElement)) {
	                        detach(_this.popupObj.element);
	                    }
	                    _this.popupObj.destroy();
	                    _this.popupObj = null;
	                }
	                if (_this.isMobile && !Browser.isDevice) {
	                    EventHandler.remove(document, 'keydown', _this.popupCloseHandler);
	                }
	            }, targetExitViewport: function () {
	                var popupEle = _this.popupObj && _this.popupObj.element;
	                if (!Browser.isDevice && popupEle && popupEle.getBoundingClientRect().height < popupEle.parentElement.getBoundingClientRect().height) {
	                    _this.hide();
	                }
	            }
	        });
	        if (this.isMobile) {
	            this.popupObj.element.classList.add(DEVICE);
	            if (!this.isMobile) {
	                this.popupObj.element.classList.add('e-bigger');
	            }
	        }
	        if (this.isMobile && this.isCustomWindow) {
	            addClass([this.modal], [DEVICE, ROOT, 'e-range-modal']);
	            document.body.className += ' ' + OVERFLOW;
	            this.modal.style.display = 'block';
	        }
	        EventHandler.add(document, 'mousedown touchstart', this.documentHandler, this);
	    };
	    DateRangePicker.prototype.dateRangeSwipeHandler = function (e) {
	        var direction = 0;
	        if (this.iconRangeRight == 'left') {
	            switch (e.swipeDirection) {
	                case "Left":
	                    direction = 1;
	                    break;
	                case "Right":
	                    direction = -1;
	                    break;
	            }
	        }
	        else {
	            switch (e.swipeDirection) {
	                case "Up":
	                    direction = 1;
	                    break;
	                case "Down":
	                    direction = -1;
	                    break;
	            }
	        }
	        if (this.touchRangeStart) {
	            if (direction === 1) {
	                this.navigateNext(e);
	            }
	            else if (direction === -1) {
	                this.navigatePrevious(e);
	            }
	            this.touchRangeStart = false;
	        }
	    };
	    DateRangePicker.prototype.touchStartRangeHandler = function (e) {
	        this.touchRangeStart = true;
	    };
	    DateRangePicker.prototype.popupCloseHandler = function (e) {
	        switch (e.keyCode) {
	            case 27:
	                this.hide(e);
	                break;
	        }
	    };
	    DateRangePicker.prototype.calendarFocus = function () {
	        var startDate = this.popupObj && this.popupObj.element.querySelector('.' + STARTDATE);
	        if (startDate) {
	            var ele = closest(startDate, '.' + RIGHTCALENDER);
	            ele = isNullOrUndefined(ele) ? this.leftCalendar : ele;
	            if (this.isRangeIconClicked) {
	                this.inputWrapper.container.focus();
	            }
	            else {
	                this.preventBlur = true;
	                ele.children[1].firstElementChild.focus();
	            }
	            addClass([startDate], FOCUSDATE);
	        }
	        else {
	            if (this.isRangeIconClicked) {
	                this.inputWrapper.container.focus();
	            }
	            else {
	                this.preventBlur = true;
	                this.leftCalendar.children[1].firstElementChild.focus();
	            }
	        }
	    };
	    DateRangePicker.prototype.presetHeight = function () {
	        var presets = this.popupObj && this.popupObj.element.querySelector('.' + PRESETS);
	        var rangeContainer = this.popupObj && this.popupObj.element.querySelector('.' + RANGECONTAINER);
	        if (!isNullOrUndefined(presets) && !isNullOrUndefined(rangeContainer)) {
	            presets.style.height = rangeContainer.getBoundingClientRect().height + 'px';
	        }
	    };
	    DateRangePicker.prototype.presetKeyActionHandler = function (e) {
	        switch (e.action) {
	            case 'moveDown':
	                this.listMoveDown(e);
	                this.setScrollPosition();
	                e.preventDefault();
	                break;
	            case 'moveUp':
	                this.listMoveUp(e);
	                this.setScrollPosition();
	                e.preventDefault();
	                break;
	            case 'enter':
	                {
	                    var hvrItem = this.getHoverLI();
	                    var actItem = this.getActiveLI();
	                    if (!isNullOrUndefined(this.leftCalendar) && !isNullOrUndefined(actItem)) {
	                        if (isNullOrUndefined(hvrItem) || (!isNullOrUndefined(actItem) && actItem === hvrItem)) {
	                            this.activeIndex = Array.prototype.slice.call(this.liCollections).indexOf(actItem);
	                            var values = this.presetsItem[this.activeIndex];
	                            if (values.id === 'custom_range') {
	                                this.calendarFocus();
	                                actItem.classList.remove(HOVER);
	                                e.preventDefault();
	                                return;
	                            }
	                        }
	                    }
	                    if (!isNullOrUndefined(hvrItem) || !isNullOrUndefined(actItem)) {
	                        this.onMouseClick(e, hvrItem || actItem);
	                    }
	                    e.preventDefault();
	                }
	                break;
	            case 'tab':
	                if (this.leftCalendar) {
	                    var item = this.getHoverLI();
	                    if (!isNullOrUndefined(item)) {
	                        item.classList.remove(HOVER);
	                    }
	                }
	                else {
	                    this.hide(e);
	                    e.preventDefault();
	                }
	                break;
	        }
	    };
	    // eslint-disable-next-line @typescript-eslint/no-unused-vars
	    DateRangePicker.prototype.listMoveDown = function (e) {
	        var hvrItem = this.getHoverLI();
	        var actItem = this.getActiveLI();
	        if (!isNullOrUndefined(hvrItem)) {
	            var li = hvrItem.nextElementSibling;
	            if (!isNullOrUndefined(li) && li.classList.contains(LISTCLASS)) {
	                removeClass([hvrItem], HOVER);
	                addClass([li], HOVER);
	            }
	        }
	        else if (!isNullOrUndefined(actItem)) {
	            var li = actItem.nextElementSibling;
	            if (!isNullOrUndefined(li) && li.classList.contains(LISTCLASS)) {
	                addClass([li], HOVER);
	            }
	        }
	        else {
	            addClass([this.liCollections[0]], HOVER);
	        }
	    };
	    // eslint-disable-next-line @typescript-eslint/no-unused-vars
	    DateRangePicker.prototype.listMoveUp = function (e) {
	        var hvrItem = this.getHoverLI();
	        var actItem = this.getActiveLI();
	        if (!isNullOrUndefined(hvrItem)) {
	            var li = hvrItem.previousElementSibling;
	            if (!isNullOrUndefined(li) && li.classList.contains(LISTCLASS)) {
	                removeClass([hvrItem], HOVER);
	                addClass([li], HOVER);
	            }
	        }
	        else if (!isNullOrUndefined(actItem)) {
	            var li = actItem.previousElementSibling;
	            if (!isNullOrUndefined(li) && li.classList.contains(LISTCLASS)) {
	                addClass([li], HOVER);
	            }
	        }
	    };
	    DateRangePicker.prototype.getHoverLI = function () {
	        var item = this.presetElement.querySelector('.' + HOVER);
	        return item;
	    };
	    DateRangePicker.prototype.getActiveLI = function () {
	        var item = this.presetElement.querySelector('.' + ACTIVE);
	        return item;
	    };
	    DateRangePicker.prototype.popupKeyBoardHandler = function () {
	        this.popupKeyboardModule = new KeyboardEvents(this.popupWrapper, {
	            eventName: 'keydown',
	            keyAction: this.popupKeyActionHandle.bind(this),
	            keyConfigs: { escape: 'escape' }
	        });
	        this.keyInputConfigs = extend(this.keyInputConfigs, this.keyConfigs);
	        this.popupKeyboardModule = new KeyboardEvents(this.inputWrapper.container.children[1], {
	            eventName: 'keydown',
	            keyAction: this.popupKeyActionHandle.bind(this),
	            keyConfigs: this.keyInputConfigs
	        });
	    };
	    DateRangePicker.prototype.setScrollPosition = function () {
	        var listHeight = this.presetElement.getBoundingClientRect().height;
	        var hover = this.presetElement.querySelector('.' + HOVER);
	        var active = this.presetElement.querySelector('.' + ACTIVE);
	        var element = !isNullOrUndefined(hover) ? hover : active;
	        if (!isNullOrUndefined(element)) {
	            var nextEle = element.nextElementSibling;
	            var height = nextEle ? nextEle.offsetTop : element.offsetTop;
	            var liHeight = element.getBoundingClientRect().height;
	            if ((height + element.offsetTop) > listHeight) {
	                this.presetElement.scrollTop = nextEle ? (height - (listHeight / 2 + liHeight / 2)) : height;
	            }
	            else {
	                this.presetElement.scrollTop = 0;
	            }
	        }
	    };
	    DateRangePicker.prototype.popupKeyActionHandle = function (e) {
	        var presetElement = closest(e.target, '.' + PRESETS);
	        switch (e.action) {
	            case 'escape':
	                if (this.isPopupOpen()) {
	                    if (this.isKeyPopup) {
	                        this.inputElement.focus();
	                        this.isKeyPopup = false;
	                    }
	                    this.hide(e);
	                }
	                else {
	                    this.inputWrapper.container.children[1].blur();
	                }
	                break;
	            case 'enter':
	                if (!this.isPopupOpen()) {
	                    this.show(null, e);
	                }
	                else {
	                    this.inputWrapper.container.children[1].focus();
	                }
	                break;
	            case 'tab':
	                this.hide(e);
	                break;
	            case 'altRightArrow':
	                if (!isNullOrUndefined(presetElement)) {
	                    this.cancelButton.element.focus();
	                }
	                else {
	                    if (document.activeElement === this.cancelButton.element && this.applyButton.element.disabled !== true) {
	                        this.applyButton.element.focus();
	                    }
	                    else {
	                        this.leftCalendar.children[1].firstElementChild.focus();
	                    }
	                }
	                e.preventDefault();
	                break;
	            case 'altLeftArrow':
	                if (!isNullOrUndefined(presetElement)) {
	                    this.rightCalendar.children[1].firstElementChild.focus();
	                }
	                else {
	                    if (document.activeElement === this.applyButton.element && this.applyButton.element.disabled !== true) {
	                        this.cancelButton.element.focus();
	                    }
	                    else {
	                        if (!isNullOrUndefined(this.presetElement) && (document.activeElement === this.cancelButton.element)) {
	                            this.presetElement.focus();
	                        }
	                        else {
	                            this.rightCalendar.children[1].firstElementChild.focus();
	                        }
	                    }
	                }
	                e.preventDefault();
	                break;
	        }
	    };
	    DateRangePicker.prototype.documentHandler = function (e) {
	        if (isNullOrUndefined(this.popupObj)) {
	            return;
	        }
	        var target = e.target;
	        if (!this.inputWrapper.container.contains(target) ||
	            (!isNullOrUndefined(this.popupObj) && !closest(target, '[id="' + this.popupWrapper.id + '"]') && e.type !== 'mousedown')) {
	            if (e.type !== 'touchstart' && ((e.type === 'mousedown') ||
	                this.closeEventArgs && !this.closeEventArgs.cancel)) {
	                e.preventDefault();
	            }
	        }
	        if ((isNullOrUndefined(this.targetElement) ||
	            (!isNullOrUndefined(this.targetElement) && !(target === this.targetElement))) &&
	            !(closest(target, '[id="' + this.popupWrapper.id + '"]'))
	            && !(closest(target, '.' + INPUTCONTAINER) === this.inputWrapper.container)
	            && !(closest(target, '.e-daterangepicker.e-popup') && (!target.classList.contains('e-day')))) {
	            this.preventBlur = false;
	            if (this.isPopupOpen() && document.body.contains(this.popupObj.element)) {
	                this.applyFunction(e);
	                if (!this.isMobile) {
	                    this.isRangeIconClicked = false;
	                }
	            }
	        }
	    };
	    DateRangePicker.prototype.createInput = function () {
	        if (this.fullScreenMode && this.isMobile) {
	            this.cssClass += ' ' + "e-popup-expand";
	        }
	        var updatedCssClassValue = this.cssClass;
	        if (!isNullOrUndefined(this.cssClass) && this.cssClass !== '') {
	            updatedCssClassValue = (this.cssClass.replace(/\s+/g, ' ')).trim();
	        }
	        this.inputWrapper = Input.createInput({
	            floatLabelType: this.floatLabelType,
	            element: this.inputElement,
	            properties: {
	                readonly: this.readonly,
	                placeholder: this.placeholder,
	                cssClass: updatedCssClassValue,
	                enabled: this.enabled,
	                enableRtl: this.enableRtl,
	                showClearButton: this.showClearButton
	            },
	            buttons: [DATERANGEICON]
	        }, this.createElement);
	        attributes(this.inputElement, {
	            'tabindex': '0', 'aria-expanded': 'false', 'role': 'combobox',
	            'autocomplete': 'off', 'aria-disabled': !this.enabled ? 'true' : 'false',
	            'autocorrect': 'off', 'autocapitalize': 'off', 'spellcheck': 'false'
	        });
	        Input.addAttributes({ 'aria-label': 'select' }, this.inputWrapper.buttons[0]);
	        if (!isNullOrUndefined(this.placeholder) && this.placeholder.trim() !== '') {
	            Input.addAttributes({ 'aria-placeholder': this.placeholder }, this.inputElement);
	        }
	        this.setEleWidth(this.width);
	        addClass([this.inputWrapper.container], DATERANGEWRAPPER);
	        if (isNullOrUndefined(this.inputElement.getAttribute('name'))) {
	            attributes(this.inputElement, { 'name': this.element.id });
	        }
	        if (this.inputElement.type === 'hidden') {
	            this.inputWrapper.container.style.display = 'none';
	        }
	        this.refreshControl();
	        this.previousEleValue = this.inputElement.value;
	        this.inputElement.setAttribute('value', this.inputElement.value);
	        this.startCopy = this.startDate;
	        this.endCopy = this.endDate;
	    };
	    DateRangePicker.prototype.setEleWidth = function (width) {
	        if (typeof width === 'string') {
	            this.inputWrapper.container.style.width = (this.width);
	        }
	        else if (typeof width === 'number') {
	            this.inputWrapper.container.style.width = formatUnit(this.width);
	        }
	        else {
	            this.inputWrapper.container.style.width = '100%';
	        }
	    };
	    DateRangePicker.prototype.adjustLongHeaderWidth = function () {
	        if (this.dayHeaderFormat === 'Wide') {
	            addClass([this.popupWrapper], DAYHEADERLONG);
	        }
	    };
	    DateRangePicker.prototype.refreshControl = function () {
	        this.validateMinMax();
	        if (this.strictMode) {
	            this.validateRangeStrict();
	        }
	        var isDisabled = this.disabledDates();
	        if (this.strictMode && (isDisabled)) {
	            this.startValue = this.previousStartValue;
	            this.setProperties({ startDate: this.startValue }, true);
	            this.endValue = this.previousEndValue;
	            this.setProperties({ endDate: this.endValue }, true);
	            this.setValue();
	        }
	        this.updateInput();
	        if (!this.strictMode) {
	            this.validateRange();
	        }
	        if (!this.strictMode && (isDisabled)) {
	            this.clearRange();
	        }
	        if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue) &&
	            !isDisabled && !isNullOrUndefined(this.renderDayCellArgs) && this.renderDayCellArgs.isDisabled) {
	            this.disabledDateRender();
	        }
	        this.errorClass();
	        this.previousStartValue = isNullOrUndefined(this.startValue) || isNaN(+this.startValue) ? null : new Date(+this.startValue);
	        this.previousEndValue = isNullOrUndefined(this.endValue) || isNaN(+this.endValue) ? null : new Date(+this.endValue);
	    };
	    DateRangePicker.prototype.updateInput = function () {
	        if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {
	            var formatOption = { format: this.formatString, type: 'date', skeleton: 'yMd' };
	            var startDate = this.globalize.formatDate(this.startValue, formatOption);
	            var endDate = this.globalize.formatDate(this.endValue, formatOption);
	            Input.setValue(startDate + ' ' + this.separator + ' ' + endDate, this.inputElement, this.floatLabelType, this.showClearButton);
	            this.previousStartValue = new Date(+this.startValue);
	            this.previousEndValue = new Date(+this.endValue);
	        }
	        if (!this.strictMode && isNullOrUndefined(this.value) && this.invalidValueString) {
	            Input.setValue(this.invalidValueString, this.inputElement, this.floatLabelType, this.showClearButton);
	        }
	    };
	    DateRangePicker.prototype.checkInvalidRange = function (value) {
	        if (!isNullOrUndefined(value)) {
	            var invalid = false;
	            var startinvalue = void 0;
	            var endinvalue = void 0;
	            var startString = null;
	            var endString = null;
	            var valueString = null;
	            var startObject = false;
	            var endObject = false;
	            var invalidobject = false;
	            if (typeof (value) === 'string') {
	                var range = value.split(' ' + this.separator + ' ');
	                if (range.length === 2) {
	                    startString = range[0];
	                    endString = range[1];
	                }
	                else {
	                    invalid = true;
	                    valueString = value;
	                }
	            }
	            else {
	                if (value.length > 0) {
	                    startinvalue = value[0];
	                    endinvalue = value[1];
	                }
	                else {
	                    startinvalue = value.start;
	                    endinvalue = value.end;
	                }
	                if (!(startinvalue instanceof Date) && typeof (startinvalue) !== 'object') {
	                    startString = this.getstringvalue(startinvalue);
	                }
	                else if (startinvalue instanceof Date) {
	                    startObject = true;
	                }
	                else if (!isNullOrUndefined(startinvalue)) {
	                    invalidobject = true;
	                }
	                if (!(endinvalue instanceof Date) && typeof (endinvalue) !== 'object') {
	                    endString = this.getstringvalue(endinvalue);
	                }
	                else if (endinvalue instanceof Date) {
	                    endObject = true;
	                }
	                else if (!isNullOrUndefined(endinvalue)) {
	                    invalidobject = true;
	                }
	            }
	            if ((isNullOrUndefined(startString) && !startObject && !isNullOrUndefined(endString)) ||
	                (!isNullOrUndefined(startString) && !endObject && isNullOrUndefined(endString))) {
	                invalid = true;
	            }
	            if (invalidobject) {
	                startString = endString = valueString = null;
	                invalid = true;
	            }
	            if (startString) {
	                invalid = invalid || this.checkInvalidValue(startString);
	            }
	            if (endString) {
	                invalid = invalid || this.checkInvalidValue(endString);
	            }
	            if (invalid) {
	                if (startObject && !invalidobject) {
	                    startString = startinvalue.toLocaleDateString();
	                }
	                if (endObject && !invalidobject) {
	                    endString = endinvalue.toLocaleDateString();
	                }
	                if (!isNullOrUndefined(startString) && !isNullOrUndefined(endString)) {
	                    valueString = startString + ' ' + this.separator + ' ' + endString;
	                }
	                else if (!isNullOrUndefined(startString)) {
	                    valueString = startString;
	                }
	                else if (!isNullOrUndefined(endString)) {
	                    valueString = endString;
	                }
	                this.invalidValueString = valueString;
	                this.setProperties({ value: null }, true);
	                this.setProperties({ startValue: null }, true);
	                this.setProperties({ endValue: null }, true);
	                this.startDate = null;
	                this.endDate = null;
	            }
	        }
	    };
	    DateRangePicker.prototype.getstringvalue = function (value) {
	        var stringValue = null;
	        if (!isNullOrUndefined(value) && (typeof value === 'number')) {
	            stringValue = (value).toString();
	        }
	        else if (!isNullOrUndefined(value) && (typeof value === 'string')) {
	            stringValue = '' + value;
	        }
	        return stringValue;
	    };
	    DateRangePicker.prototype.checkInvalidValue = function (value) {
	        var valueString = value;
	        var invalid = false;
	        var formatOpt = null;
	        formatOpt = { format: this.formatString, type: 'date', skeleton: 'yMd' };
	        if (typeof valueString !== 'string') {
	            invalid = true;
	        }
	        else {
	            var globalize = new Internationalization(this.locale);
	            if (!this.checkDateValue(globalize.parseDate(valueString, formatOpt))) {
	                var extISOStr = null;
	                var basISOString = null;
	                // eslint-disable-next-line
	                extISOStr = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
	                // eslint-disable-next-line
	                basISOString = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
	                if ((!extISOStr.test(valueString) && !basISOString.test(valueString))
	                    || (/^[a-zA-Z0-9- ]*$/).test(valueString) || isNaN(+new Date(this.checkValue(valueString)))) {
	                    invalid = true;
	                }
	            }
	        }
	        return invalid;
	    };
	    DateRangePicker.prototype.isDateDisabled = function (date) {
	        if (isNullOrUndefined(date)) {
	            return false;
	        }
	        var value = new Date(+date);
	        if (+value < +this.min || +value > +this.max) {
	            return true;
	        }
	        this.virtualRenderCellArgs = {
	            date: value,
	            isDisabled: false
	        };
	        var args = this.virtualRenderCellArgs;
	        this.virtualRenderCellEvent(args);
	        if (args.isDisabled) {
	            return true;
	        }
	        return false;
	    };
	    DateRangePicker.prototype.disabledDateRender = function () {
	        this.disabledDays = [];
	        this.disabledDayCnt = null;
	        var localDate = new Date(+this.startValue);
	        var count = 0;
	        while (+localDate <= +this.endValue && +this.endValue <= +this.max) {
	            this.virtualRenderCellArgs = {
	                date: localDate,
	                isDisabled: false
	            };
	            var args = this.virtualRenderCellArgs;
	            this.virtualRenderCellEvent(args);
	            if (args.isDisabled) {
	                this.disabledDays.push(new Date(+args.date));
	                if (+localDate > +this.startValue && +localDate < +this.endValue) {
	                    count++;
	                }
	            }
	            this.addDay(localDate, 1, null, this.max, this.min);
	        }
	        this.disabledDayCnt = count;
	    };
	    DateRangePicker.prototype.virtualRenderCellEvent = function (args) {
	        extend(this.virtualRenderCellArgs, { name: 'renderDayCell' });
	        this.trigger('renderDayCell', args);
	    };
	    DateRangePicker.prototype.disabledDates = function () {
	        var isStartDisabled = false;
	        var isEndDisabled = false;
	        if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {
	            isStartDisabled = this.isDateDisabled(this.startValue);
	            isEndDisabled = this.isDateDisabled(this.endValue);
	            if (!this.isPopupOpen()) {
	                this.currentDate = null;
	            }
	            this.setValue();
	        }
	        return (isStartDisabled || isEndDisabled);
	    };
	    DateRangePicker.prototype.setModelValue = function () {
	        if (!this.value && this.startDate === null && this.endDate === null) {
	            this.setProperties({ value: null }, true);
	        }
	        else if (this.value === null || this.value.start === null) {
	            if (this.value === null) {
	                this.setProperties({ value: [this.startDate, this.endDate] }, true);
	            }
	            else if (this.value.start === null) {
	                this.setProperties({ value: { start: this.startDate, end: this.endDate } }, true);
	            }
	        }
	        else {
	            if ((this.value && this.value.length > 0) ||
	                this.valueType && this.valueType.length > 0) {
	                if (+this.startDate !== +this.value[0] || +this.endDate !== +this.value[1]) {
	                    this.setProperties({ value: [this.startDate, this.endDate] }, true);
	                }
	                if (this.value && this.value[0] == null && this.value[1] == null) {
	                    this.setProperties({ value: null }, true);
	                }
	            }
	            else {
	                if ((this.value && this.value.start)) {
	                    this.setProperties({ value: { start: this.startDate, end: this.endDate } }, true);
	                }
	            }
	        }
	        this.createHiddenInput();
	    };
	    /**
	     * To dispatch the event manually
	     *
	     * @param {HTMLElement} element - Specifies the element to dispatch the event.
	     * @param {string} type - Specifies the name of the event.
	     * @returns {void}
	     */
	    DateRangePicker.prototype.dispatchEvent = function (element, type) {
	        var evt = document.createEvent('HTMLEvents');
	        evt.initEvent(type, false, true);
	        element.dispatchEvent(evt);
	        this.firstHiddenChild.dispatchEvent(evt);
	    };
	    DateRangePicker.prototype.changeTrigger = function (e) {
	        if (+this.initStartDate !== +this.startValue || +this.initEndDate !== +this.endValue) {
	            this.setProperties({ endDate: this.checkDateValue(this.endValue) }, true);
	            this.setProperties({ startDate: this.checkDateValue(this.startValue) }, true);
	            this.setModelValue();
	            if (this.isAngular && this.preventChange) {
	                this.preventChange = false;
	            }
	            else {
	                this.trigger('change', this.rangeArgs(e));
	            }
	        }
	        this.previousEleValue = this.inputElement.value;
	        this.initStartDate = this.checkDateValue(this.startValue);
	        this.initEndDate = this.checkDateValue(this.endValue);
	    };
	    /**
	     * This method is used to navigate to the month/year/decade view of the Calendar.
	     *
	     * @param  {string} view - Specifies the view of the Calendar.
	     * @param  {Date} date - Specifies the focused date in a view.
	     * @returns {void}
	     * @hidden
	     */
	    DateRangePicker.prototype.navigateTo = function (view, date) {
	        if (this.isPopupOpen()) {
	            if (view.toLowerCase() === 'month') {
	                view = 'Month';
	            }
	            else if (view.toLowerCase() === 'year') {
	                view = 'Year';
	            }
	            else if (view.toLowerCase() === 'decade') {
	                view = 'Decade';
	            }
	            else {
	                return;
	            }
	            if (this.getViewNumber(view) < this.getViewNumber(this.depth)) {
	                view = this.depth;
	            }
	            if (this.isMobile) {
	                _super.prototype.navigateTo.call(this, view, date);
	            }
	            else {
	                if (date < this.min) {
	                    date = new Date(+this.min);
	                }
	                else if (date >= this.max) {
	                    date = new Date(+this.max);
	                }
	                if (view === 'Month' && this.isSameMonth(date, this.max)) {
	                    date = new Date(this.max.getFullYear(), this.max.getMonth() - 1, this.min.getDate());
	                }
	                else if (view === 'Year' && this.isSameYear(date, this.max)) {
	                    date = new Date((this.max.getFullYear() - 1), this.max.getMonth(), this.max.getDate());
	                }
	                else if (view === 'Decade' && this.isSameDecade(date, this.max)) {
	                    date = new Date((this.max.getFullYear() - 10), this.max.getMonth(), this.max.getDate());
	                }
	                this.leftCalCurrentDate = date;
	                this.navigate(this.leftCalendar, this.leftCalCurrentDate, view);
	                if (view === 'Month') {
	                    date = new Date(this.currentDate.setMonth(this.currentDate.getMonth() + 1));
	                }
	                else if (view === 'Year') {
	                    date = new Date(this.currentDate.setFullYear(this.currentDate.getFullYear() + 1));
	                }
	                else {
	                    date = new Date(this.currentDate.setFullYear(this.currentDate.getFullYear() + 10));
	                }
	                this.rightCalCurrentDate = date;
	                this.navigate(this.rightCalendar, this.rightCalCurrentDate, view);
	                this.leftKeyboardModule = this.rightKeyboardModule = null;
	                this.updateNavIcons();
	            }
	            if (this.currentView() === this.depth) {
	                this.bindCalendarCellEvents();
	            }
	            this.removeFocusedDate();
	            this.updateRange((this.isMobile ? [this.calendarElement] : [this.leftCalendar, this.rightCalendar]));
	        }
	    };
	    DateRangePicker.prototype.navigate = function (calendar, date, view) {
	        this.calendarElement = calendar;
	        this.table = calendar.querySelector('table');
	        this.tableBodyElement = calendar.querySelector('tbody');
	        this.headerTitleElement = calendar.querySelector('.e-title');
	        this.tableHeadElement = calendar.querySelector('thead');
	        this.contentElement = calendar.querySelector('.e-content');
	        this.previousIcon = calendar.querySelector('.e-prev');
	        this.nextIcon = calendar.querySelector('.e-next');
	        this.effect = ZOOMIN;
	        _super.prototype.navigateTo.call(this, view, date);
	    };
	    /**
	     * Sets the focus to widget for interaction.
	     *
	     * @returns {void}
	     */
	    DateRangePicker.prototype.focusIn = function () {
	        if (document.activeElement !== this.inputElement && this.enabled) {
	            addClass([this.inputWrapper.container], [INPUTFOCUS]);
	            this.inputElement.focus();
	        }
	    };
	    /**
	     * Remove the focus from widget, if the widget is in focus state.
	     *
	     * @returns {void}
	     */
	    DateRangePicker.prototype.focusOut = function () {
	        var isBlur = this.preventBlur;
	        if (document.activeElement === this.inputElement) {
	            removeClass([this.inputWrapper.container], [INPUTFOCUS]);
	            this.preventBlur = false;
	            this.inputElement.blur();
	            this.preventBlur = isBlur;
	        }
	    };
	    /**
	     * To destroy the widget.
	     *
	     * @returns {void}
	     */
	    DateRangePicker.prototype.destroy = function () {
	        this.unBindEvents();
	        this.hide(null);
	        var ariaAttrs = {
	            'tabindex': '0', 'aria-expanded': 'false', 'role': 'combobox',
	            'autocomplete': 'off', 'aria-disabled': !this.enabled ? 'true' : 'false',
	            'autocorrect': 'off', 'autocapitalize': 'off', 'aria-invalid': 'false', 'spellcheck': 'false'
	        };
	        if (this.inputElement) {
	            removeClass([this.inputElement], [ROOT]);
	            EventHandler.remove(this.inputElement, 'blur', this.inputBlurHandler);
	            Input.removeAttributes(ariaAttrs, this.inputElement);
	            if (!isNullOrUndefined(this.cloneElement.getAttribute('tabindex'))) {
	                this.inputElement.setAttribute('tabindex', this.tabIndex);
	            }
	            else {
	                this.inputElement.removeAttribute('tabindex');
	            }
	            this.ensureInputAttribute();
	            this.inputElement.classList.remove('e-input');
	            if (!isNullOrUndefined(this.inputWrapper)) {
	                EventHandler.remove(this.inputWrapper.buttons[0], 'mousedown', this.rangeIconHandler);
	                if (this.angularTag === null) {
	                    this.inputWrapper.container.parentElement.appendChild(this.inputElement);
	                }
	                detach(this.inputWrapper.container);
	            }
	        }
	        if (!isNullOrUndefined(this.inputKeyboardModule) && !this.isMobile) {
	            this.inputKeyboardModule.destroy();
	        }
	        if (this.popupObj) {
	            if (!this.isMobile) {
	                this.clearCalendarEvents();
	            }
	        }
	        _super.prototype.destroy.call(this);
	        this.inputWrapper = this.popupWrapper = this.popupObj = this.cloneElement = this.presetElement = null;
	        if (this.formElement) {
	            EventHandler.remove(this.formElement, 'reset', this.formResetHandler);
	        }
	        if ((!isNullOrUndefined(this.firstHiddenChild))
	            && (!isNullOrUndefined(this.secondHiddenChild))) {
	            detach(this.firstHiddenChild);
	            detach(this.secondHiddenChild);
	            this.firstHiddenChild = this.secondHiddenChild = null;
	            this.inputElement.setAttribute('name', this.element.getAttribute('data-name'));
	            this.inputElement.removeAttribute('data-name');
	        }
	        this.closeEventArgs = null;
	        this.leftCalendar = null;
	        this.rightTitle = null;
	        this.leftTitle = null;
	        this.openEventArgs = null;
	        this.leftCalNextIcon = null;
	        this.rightCalendar = null;
	        this.closeEventArgs = null;
	        this.rightCalPrevIcon = null;
	        this.leftCalPrevIcon = null;
	        this.popupKeyboardModule = null;
	        this.cancelButton = null;
	        this.applyButton = null;
	        this.calendarElement = null;
	        this.leftKeyboardModule = null;
	        this.rightCalNextIcon = null;
	        this.leftCalNextIcon = null;
	        this.btnKeyboardModule = null;
	        this.rightKeyboardModule = null;
	        this.leftKeyboardModule = null;
	        this.presetKeyboardModule = null;
	        this.liCollections = null;
	        this.popupObj = null;
	        this.popupWrapper = null;
	    };
	    DateRangePicker.prototype.ensureInputAttribute = function () {
	        var attr = [];
	        for (var i = 0; i < this.inputElement.attributes.length; i++) {
	            attr[i] = this.inputElement.attributes[i].name;
	        }
	        for (var i = 0; i < attr.length; i++) {
	            if (isNullOrUndefined(this.cloneElement.getAttribute(attr[i]))) {
	                if (attr[i].toLowerCase() === 'value') {
	                    this.inputElement.value = '';
	                }
	                this.inputElement.removeAttribute(attr[i]);
	            }
	            else {
	                if (attr[i].toLowerCase() === 'value') {
	                    this.inputElement.value = this.cloneElement.getAttribute(attr[i]);
	                }
	                this.inputElement.setAttribute(attr[i], this.cloneElement.getAttribute(attr[i]));
	            }
	        }
	    };
	    /**
	     * To get component name
	     *
	     * @returns {string} Returns the component name.
	     * @private
	     */
	    DateRangePicker.prototype.getModuleName = function () {
	        return 'daterangepicker';
	    };
	    /* eslint-disable valid-jsdoc, jsdoc/require-returns-description */
	    /**
	     * Return the properties that are maintained upon browser refresh.
	     *
	     * @returns {string}
	     */
	    DateRangePicker.prototype.getPersistData = function () {
	        var keyEntity = ['startDate', 'endDate', 'value'];
	        return this.addOnPersist(keyEntity);
	    };
	    /**
	     * Return the selected range and day span in the DateRangePicker.
	     *
	     * @returns {Object}
	     */
	    DateRangePicker.prototype.getSelectedRange = function () {
	        var range;
	        if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) {
	            range = (Math.round(Math.abs((this.removeTimeValueFromDate(this.startValue).getTime() -
	                this.removeTimeValueFromDate(this.endValue).getTime()) / (1000 * 60 * 60 * 24))) + 1);
	            if (!isNullOrUndefined(this.renderDayCellArgs) && this.renderDayCellArgs.isDisabled) {
	                this.disabledDateRender();
	            }
	            if (!isNullOrUndefined(this.disabledDayCnt)) {
	                range = range - this.disabledDayCnt;
	                this.disabledDayCnt = null;
	            }
	        }
	        else {
	            range = 0;
	        }
	        return { startDate: this.startValue, endDate: this.endValue, daySpan: range };
	    };
	    /* eslint-enable valid-jsdoc, jsdoc/require-returns-description */
	    /* eslint-disable valid-jsdoc, jsdoc/require-param */
	    /**
	     * To open the Popup container in the DateRangePicker component.
	     *
	     * @param {HTMLElement} element - Specifies element.
	     * @returns {void}
	     */
	    DateRangePicker.prototype.show = function (element, event) {
	        var _this = this;
	        if (this.isMobile && this.popupObj) {
	            this.popupObj.refreshPosition();
	        }
	        if ((this.enabled && this.readonly) || !this.enabled || this.popupObj) {
	            return;
	        }
	        else {
	            if (!this.isPopupOpen()) {
	                if (element) {
	                    this.targetElement = element;
	                }
	                this.createPopup();
	                if (this.isMobile || Browser.isDevice) {
	                    this.mobileRangePopupWrap = this.createElement('div', { className: 'e-daterangepick-mob-popup-wrap' });
	                    document.body.appendChild(this.mobileRangePopupWrap);
	                }
	                this.openEventArgs = {
	                    popup: this.popupObj || null,
	                    cancel: false,
	                    date: this.inputElement.value,
	                    model: this,
	                    event: event ? event : null,
	                    appendTo: this.isMobile || Browser.isDevice ? this.mobileRangePopupWrap : document.body
	                };
	                var eventArgs = this.openEventArgs;
	                this.trigger('open', eventArgs, function (eventArgs) {
	                    _this.openEventArgs = eventArgs;
	                    if (!_this.openEventArgs.cancel) {
	                        _this.openEventArgs.appendTo.appendChild(_this.popupWrapper);
	                        _this.showPopup(element, event);
	                        var isPreset = (!_this.isCustomRange || (_this.isMobile && _this.isCustomRange));
	                        if (!isUndefined(_this.presets[0].start && _this.presets[0].end && _this.presets[0].label) && isPreset) {
	                            _this.setScrollPosition();
	                        }
	                        _this.checkMinMaxDays();
	                        if ((_this.isMobile) && (!isNullOrUndefined(_this.startDate)) && (isNullOrUndefined(_this.endDate))) {
	                            _this.endButton.element.classList.add(ACTIVE);
	                            _this.startButton.element.classList.remove(ACTIVE);
	                            _this.endButton.element.removeAttribute('disabled');
	                            _this.selectableDates();
	                        }
	                        _super.prototype.setOverlayIndex.call(_this, _this.mobileRangePopupWrap, _this.popupObj.element, _this.modal, 
	                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	                        _this.isMobile || Browser.isDevice);
	                    }
	                });
	            }
	        }
	    };
	    /**
	     * To close the Popup container in the DateRangePicker component.
	     *
	     * @returns {void}
	     */
	    DateRangePicker.prototype.hide = function (event) {
	        var _this = this;
	        if (this.popupObj) {
	            if (isNullOrUndefined(this.previousEndValue) && isNullOrUndefined(this.previousStartValue)) {
	                this.clearRange();
	            }
	            else {
	                if (!isNullOrUndefined(this.previousStartValue)) {
	                    this.startValue = new Date(this.checkValue(this.previousStartValue));
	                    this.setValue();
	                    this.currentDate = new Date(this.checkValue(this.startValue));
	                }
	                else {
	                    this.startValue = null;
	                    this.setValue();
	                }
	                if (!isNullOrUndefined(this.previousEndValue)) {
	                    this.endValue = new Date(this.checkValue(this.previousEndValue));
	                    this.setValue();
	                }
	                else {
	                    this.endValue = null;
	                    this.setValue();
	                }
	            }
	            if (this.isPopupOpen()) {
	                this.closeEventArgs = {
	                    cancel: false,
	                    popup: this.popupObj,
	                    date: this.inputElement.value,
	                    model: this,
	                    event: event ? event : null
	                };
	                var eventArgs = this.closeEventArgs;
	                this.trigger('close', eventArgs, function (eventArgs) {
	                    _this.closeEventArgs = eventArgs;
	                    if (!_this.closeEventArgs.cancel) {
	                        if (_this.isMobile) {
	                            if (!isNullOrUndefined(_this.startButton) && !isNullOrUndefined(_this.endButton)) {
	                                EventHandler.remove(_this.startButton.element, 'click touchstart', _this.deviceHeaderClick);
	                                EventHandler.remove(_this.endButton.element, 'click touchstart', _this.deviceHeaderClick);
	                            }
	                        }
	                        if (_this.popupObj) {
	                            _this.popupObj.hide();
	                            if (_this.preventBlur) {
	                                _this.inputElement.focus();
	                                addClass([_this.inputWrapper.container], [INPUTFOCUS]);
	                            }
	                        }
	                        if (!_this.isMobile) {
	                            if (!isNullOrUndefined(_this.leftKeyboardModule) && !isNullOrUndefined(_this.rightKeyboardModule)) {
	                                _this.leftKeyboardModule.destroy();
	                                _this.rightKeyboardModule.destroy();
	                            }
	                            if (!isNullOrUndefined(_this.presetElement)) {
	                                _this.presetKeyboardModule.destroy();
	                            }
	                            if (!isNullOrUndefined(_this.cancelButton)) {
	                                _this.btnKeyboardModule.destroy();
	                            }
	                        }
	                        _this.targetElement = null;
	                        removeClass([document.body], OVERFLOW);
	                        EventHandler.remove(document, 'mousedown touchstart', _this.documentHandler);
	                        if (_this.isMobile && _this.modal) {
	                            _this.modal.style.display = 'none';
	                            _this.modal.outerHTML = '';
	                            _this.modal = null;
	                        }
	                        if (_this.isMobile || Browser.isDevice) {
	                            if (!isNullOrUndefined(_this.mobileRangePopupWrap)) {
	                                _this.mobileRangePopupWrap.remove();
	                                _this.mobileRangePopupWrap = null;
	                            }
	                        }
	                        _this.isKeyPopup = _this.dateDisabled = false;
	                    }
	                    else {
	                        removeClass([_this.inputWrapper.buttons[0]], ACTIVE);
	                    }
	                    _this.updateClearIconState();
	                    _this.updateHiddenInput();
	                    if (_this.isMobile && _this.allowEdit && !_this.readonly) {
	                        _this.inputElement.removeAttribute('readonly');
	                    }
	                });
	            }
	        }
	        else {
	            this.updateClearIconState();
	            this.updateHiddenInput();
	            if (this.isMobile && this.allowEdit && !this.readonly) {
	                this.inputElement.removeAttribute('readonly');
	            }
	        }
	    };
	    /* eslint-enable valid-jsdoc, jsdoc/require-param */
	    DateRangePicker.prototype.setLocale = function () {
	        this.globalize = new Internationalization(this.locale);
	        this.l10n.setLocale(this.locale);
	        this.setProperties({ placeholder: this.l10n.getConstant('placeholder') }, true);
	        Input.setPlaceholder(this.placeholder, this.inputElement);
	        this.updateInput();
	        this.updateHiddenInput();
	        this.changeTrigger();
	    };
	    DateRangePicker.prototype.refreshChange = function () {
	        this.checkView();
	        this.refreshControl();
	        this.changeTrigger();
	    };
	    DateRangePicker.prototype.setDate = function () {
	        Input.setValue('', this.inputElement, this.floatLabelType, this.showClearButton);
	        this.refreshChange();
	    };
	    DateRangePicker.prototype.enableInput = function () {
	        if (+this.min <= +this.max) {
	            this.setProperties({ enabled: true }, true);
	            Input.setEnabled(this.enabled, this.inputElement);
	            if (this.element.hasAttribute('disabled')) {
	                this.bindEvents();
	            }
	        }
	    };
	    DateRangePicker.prototype.clearModelvalue = function (newProp, oldProp) {
	        this.setProperties({ startDate: null }, true);
	        this.setProperties({ endDate: null }, true);
	        if (oldProp.value && oldProp.value.length > 0) {
	            this.setProperties({ value: null }, true);
	        }
	        else if (oldProp.value && oldProp.value.start) {
	            this.setProperties({ value: { start: null, end: null } }, true);
	        }
	        else if (oldProp.value && !oldProp.value.start) {
	            this.setProperties({ value: { start: null, end: null } }, true);
	        }
	        this.updateValue();
	        this.setDate();
	    };
	    DateRangePicker.prototype.createHiddenInput = function () {
	        if (isNullOrUndefined(this.firstHiddenChild) && isNullOrUndefined(this.secondHiddenChild)) {
	            this.firstHiddenChild = this.createElement('input');
	            this.secondHiddenChild = this.createElement('input');
	        }
	        if (!isNullOrUndefined(this.inputElement.getAttribute('name'))) {
	            this.inputElement.setAttribute('data-name', this.inputElement.getAttribute('name'));
	            this.inputElement.removeAttribute('name');
	        }
	        attributes(this.firstHiddenChild, {
	            'type': 'text', 'name': this.inputElement.getAttribute('data-name'), 'class': HIDDENELEMENT
	        });
	        attributes(this.secondHiddenChild, {
	            'type': 'text', 'name': this.inputElement.getAttribute('data-name'), 'class': HIDDENELEMENT
	        });
	        var format = { type: 'datetime', skeleton: 'yMd' };
	        this.firstHiddenChild.value = this.startDate && this.globalize.formatDate(this.startDate, format);
	        this.secondHiddenChild.value = this.endDate && this.globalize.formatDate(this.endDate, format);
	        this.inputElement.parentElement.appendChild(this.firstHiddenChild);
	        this.inputElement.parentElement.appendChild(this.secondHiddenChild);
	    };
	    DateRangePicker.prototype.setMinMaxDays = function () {
	        if (this.isPopupOpen()) {
	            this.removeClassDisabled();
	            this.checkMinMaxDays();
	            if (this.isMobile) {
	                this.selectableDates();
	            }
	            if (!this.strictMode && (isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue))) {
	                this.removeSelection();
	            }
	            else {
	                this.updateRange((this.isMobile ? [this.calendarElement] : [this.leftCalendar, this.rightCalendar]));
	            }
	            this.updateHeader();
	        }
	    };
	    // eslint-disable-next-line @typescript-eslint/tslint/config
	    DateRangePicker.prototype.getStartEndValue = function (date, isEnd) {
	        if (this.depth === 'Month') {
	            return this.checkDateValue(new Date(this.checkValue(date)));
	        }
	        else if (this.depth === 'Year') {
	            return new Date(date.getFullYear(), date.getMonth() + (isEnd ? 1 : 0), isEnd ? 0 : 1);
	        }
	        else {
	            return new Date(date.getFullYear(), isEnd ? 11 : 0, isEnd ? 31 : 1);
	        }
	    };
	    /**
	     * Called internally if any of the property value changed.
	     *
	     * @param {DateRangePickerModel} newProp - Returns the dynamic property value of the component.
	     * @param {DateRangePickerModel} oldProp - Returns the previous property value of the component.
	     * @returns {void}
	     * @private
	     */
	    DateRangePicker.prototype.onPropertyChanged = function (newProp, oldProp) {
	        var format = { format: this.formatString, type: 'date', skeleton: 'yMd' };
	        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
	            var prop = _a[_i];
	            var openPopup = ['maxDays', 'minDays', 'value'];
	            if (openPopup.indexOf(prop) < 0) {
	                this.hide(null);
	            }
	            switch (prop) {
	                case 'width':
	                    this.setEleWidth(this.width);
	                    Input.calculateWidth(this.inputElement, this.inputWrapper.container);
	                    if (!isNullOrUndefined(this.inputWrapper.buttons[0]) && !isNullOrUndefined(this.inputWrapper.container.getElementsByClassName('e-float-text-overflow')[0]) && this.floatLabelType !== 'Never') {
	                        this.inputWrapper.container.getElementsByClassName('e-float-text-overflow')[0].classList.add('e-icon');
	                    }
	                    break;
	                case 'separator':
	                    this.previousEleValue = this.inputElement.value;
	                    this.setProperties({ separator: newProp.separator }, true);
	                    this.updateInput();
	                    this.changeTrigger();
	                    break;
	                case 'placeholder':
	                    Input.setPlaceholder(newProp.placeholder, this.inputElement);
	                    this.setProperties({ placeholder: newProp.placeholder }, true);
	                    break;
	                case 'readonly':
	                    Input.setReadonly(this.readonly, this.inputElement);
	                    this.setRangeAllowEdit();
	                    break;
	                case 'cssClass':
	                    this.updateCssClass(newProp.cssClass, oldProp.cssClass);
	                    break;
	                case 'enabled':
	                    this.setProperties({ enabled: newProp.enabled }, true);
	                    Input.setEnabled(this.enabled, this.inputElement);
	                    if (this.enabled) {
	                        this.inputElement.setAttribute('tabindex', this.tabIndex);
	                    }
	                    else {
	                        this.inputElement.tabIndex = -1;
	                    }
	                    break;
	                case 'allowEdit':
	                    this.setRangeAllowEdit();
	                    break;
	                case 'enableRtl':
	                    this.setProperties({ enableRtl: newProp.enableRtl }, true);
	                    Input.setEnableRtl(this.enableRtl, [this.inputWrapper.container]);
	                    break;
	                case 'zIndex':
	                    this.setProperties({ zIndex: newProp.zIndex }, true);
	                    break;
	                case 'format':
	                    this.setProperties({ format: newProp.format }, true);
	                    this.checkFormat();
	                    this.updateInput();
	                    this.changeTrigger();
	                    break;
	                case 'locale':
	                    this.globalize = new Internationalization(this.locale);
	                    this.l10n.setLocale(this.locale);
	                    this.setProperties({ placeholder: this.l10n.getConstant('placeholder') }, true);
	                    Input.setPlaceholder(this.placeholder, this.inputElement);
	                    this.setLocale();
	                    break;
	                case 'htmlAttributes':
	                    this.updateHtmlAttributeToElement();
	                    this.updateHtmlAttributeToWrapper();
	                    this.setDataAttribute(true);
	                    this.checkHtmlAttributes(true);
	                    break;
	                case 'showClearButton':
	                    Input.setClearButton(this.showClearButton, this.inputElement, this.inputWrapper);
	                    this.bindClearEvent();
	                    break;
	                case 'startDate':
	                    if (typeof newProp.startDate === 'string') {
	                        newProp.startDate = this.globalize.parseDate(newProp.startDate, format);
	                    }
	                    if (+this.initStartDate !== +newProp.startDate) {
	                        this.startValue = this.getStartEndValue(newProp.startDate, false);
	                        this.setDate();
	                        this.setValue();
	                    }
	                    break;
	                case 'endDate':
	                    if (typeof newProp.endDate === 'string') {
	                        newProp.endDate = this.globalize.parseDate(newProp.endDate, format);
	                    }
	                    if (+this.initEndDate !== +newProp.endDate) {
	                        this.endValue = this.getStartEndValue(newProp.endDate, true);
	                        this.setDate();
	                        this.setValue();
	                    }
	                    break;
	                case 'value':
	                    this.invalidValueString = null;
	                    this.checkInvalidRange(newProp.value);
	                    if (typeof (newProp.value) === 'string') {
	                        if (!this.invalidValueString) {
	                            var rangeArray = newProp.value.split(' ' + this.separator + ' ');
	                            this.value = [new Date(rangeArray[0]), new Date(rangeArray[1])];
	                            this.updateValue();
	                            this.setDate();
	                        }
	                        else {
	                            this.clearModelvalue(newProp, oldProp);
	                        }
	                    }
	                    else {
	                        if ((!isNullOrUndefined(newProp.value) && newProp.value.length > 0)
	                            || !isNullOrUndefined(newProp.value) && newProp.value.start) {
	                            this.valueType = newProp.value;
	                            if (newProp.value[0] === null || (newProp.value.start === null)) {
	                                if (newProp.value.length === 1 || (newProp.value.start)) {
	                                    this.clearModelvalue(newProp, oldProp);
	                                }
	                                else if (newProp.value[1] === null ||
	                                    (newProp.value.start === null)) {
	                                    this.clearModelvalue(newProp, oldProp);
	                                }
	                            }
	                            else if ((+this.initStartDate !== +newProp.value[0]
	                                || +this.initEndDate !== +newProp.value[1]) ||
	                                (+this.initStartDate !== +(newProp.value.start
	                                    || +this.initEndDate !== +newProp.value.start))) {
	                                if (newProp.value.length === 1) {
	                                    this.modelValue = newProp.value;
	                                }
	                                else if (newProp.value.start) {
	                                    this.modelValue = newProp.value;
	                                }
	                                this.updateValue();
	                                this.setDate();
	                            }
	                        }
	                        else {
	                            if (isNullOrUndefined(this.value)
	                                || newProp.value.start == null) {
	                                this.valueType = newProp.value;
	                                this.startValue = null;
	                                this.endValue = null;
	                                this.clearModelvalue(newProp, oldProp);
	                            }
	                        }
	                    }
	                    if (this.isPopupOpen()) {
	                        if (isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) {
	                            this.removeSelection();
	                            if (this.isMobile) {
	                                this.deviceHeaderUpdate();
	                            }
	                            return;
	                        }
	                        if (this.isMobile) {
	                            this.navigate(this.deviceCalendar, this.startValue, this.currentView());
	                            this.deviceHeaderUpdate();
	                        }
	                        else {
	                            this.navigate(this.leftCalendar, this.startValue, this.currentView());
	                            this.updateControl(this.leftCalendar);
	                            this.navigate(this.rightCalendar, this.endValue, this.currentView());
	                            this.updateControl(this.rightCalendar);
	                        }
	                        this.updateRange((this.isMobile ? [this.calendarElement] : [this.leftCalendar, this.rightCalendar]));
	                        this.updateHeader();
	                        this.applyButton.disabled = this.applyButton.element.disabled = false;
	                    }
	                    this.preventChange = this.isAngular && this.preventChange ? !this.preventChange : this.preventChange;
	                    break;
	                case 'minDays':
	                    this.setProperties({ minDays: newProp.minDays }, true);
	                    this.refreshChange();
	                    this.setMinMaxDays();
	                    break;
	                case 'maxDays':
	                    this.setProperties({ maxDays: newProp.maxDays }, true);
	                    this.refreshChange();
	                    this.setMinMaxDays();
	                    break;
	                case 'min':
	                    this.setProperties({ min: this.checkDateValue(new Date(this.checkValue(newProp.min))) }, true);
	                    this.previousEleValue = this.inputElement.value;
	                    this.enableInput();
	                    this.refreshChange();
	                    break;
	                case 'max':
	                    this.setProperties({ max: this.checkDateValue(new Date(this.checkValue(newProp.max))) }, true);
	                    this.enableInput();
	                    this.refreshChange();
	                    break;
	                case 'strictMode':
	                    this.invalidValueString = null;
	                    this.setProperties({ strictMode: newProp.strictMode }, true);
	                    this.refreshChange();
	                    break;
	                case 'presets':
	                    this.setProperties({ presets: newProp.presets }, true);
	                    this.processPresets();
	                    break;
	                case 'floatLabelType':
	                    this.floatLabelType = newProp.floatLabelType;
	                    Input.removeFloating(this.inputWrapper);
	                    Input.addFloating(this.inputElement, this.floatLabelType, this.placeholder);
	                    if (!isNullOrUndefined(this.inputWrapper.buttons[0]) && !isNullOrUndefined(this.inputWrapper.container.getElementsByClassName('e-float-text-overflow')[0]) && this.floatLabelType !== 'Never') {
	                        this.inputWrapper.container.getElementsByClassName('e-float-text-overflow')[0].classList.add('e-icon');
	                    }
	                    break;
	                case 'start':
	                    this.setProperties({ start: newProp.start }, true);
	                    this.refreshChange();
	                    break;
	                case 'depth':
	                    this.setProperties({ depth: newProp.depth }, true);
	                    this.refreshChange();
	                    break;
	            }
	        }
	    };
	    __decorate$8([
	        Property(null)
	    ], DateRangePicker.prototype, "value", void 0);
	    __decorate$8([
	        Property(false)
	    ], DateRangePicker.prototype, "enablePersistence", void 0);
	    __decorate$8([
	        Property(new Date(1900, 0, 1))
	    ], DateRangePicker.prototype, "min", void 0);
	    __decorate$8([
	        Property(new Date(2099, 11, 31))
	    ], DateRangePicker.prototype, "max", void 0);
	    __decorate$8([
	        Property(null)
	    ], DateRangePicker.prototype, "locale", void 0);
	    __decorate$8([
	        Property(null)
	    ], DateRangePicker.prototype, "firstDayOfWeek", void 0);
	    __decorate$8([
	        Property(false)
	    ], DateRangePicker.prototype, "weekNumber", void 0);
	    __decorate$8([
	        Property('Gregorian')
	    ], DateRangePicker.prototype, "calendarMode", void 0);
	    __decorate$8([
	        Property(false)
	    ], DateRangePicker.prototype, "openOnFocus", void 0);
	    __decorate$8([
	        Property(false)
	    ], DateRangePicker.prototype, "fullScreenMode", void 0);
	    __decorate$8([
	        Event()
	    ], DateRangePicker.prototype, "created", void 0);
	    __decorate$8([
	        Event()
	    ], DateRangePicker.prototype, "destroyed", void 0);
	    __decorate$8([
	        Event()
	    ], DateRangePicker.prototype, "change", void 0);
	    __decorate$8([
	        Event()
	    ], DateRangePicker.prototype, "cleared", void 0);
	    __decorate$8([
	        Event()
	    ], DateRangePicker.prototype, "navigated", void 0);
	    __decorate$8([
	        Event()
	    ], DateRangePicker.prototype, "renderDayCell", void 0);
	    __decorate$8([
	        Property(null)
	    ], DateRangePicker.prototype, "startDate", void 0);
	    __decorate$8([
	        Property(null)
	    ], DateRangePicker.prototype, "endDate", void 0);
	    __decorate$8([
	        Collection([{}], Presets)
	    ], DateRangePicker.prototype, "presets", void 0);
	    __decorate$8([
	        Property('')
	    ], DateRangePicker.prototype, "width", void 0);
	    __decorate$8([
	        Property(1000)
	    ], DateRangePicker.prototype, "zIndex", void 0);
	    __decorate$8([
	        Property(true)
	    ], DateRangePicker.prototype, "showClearButton", void 0);
	    __decorate$8([
	        Property(true)
	    ], DateRangePicker.prototype, "showTodayButton", void 0);
	    __decorate$8([
	        Property('Month')
	    ], DateRangePicker.prototype, "start", void 0);
	    __decorate$8([
	        Property('Month')
	    ], DateRangePicker.prototype, "depth", void 0);
	    __decorate$8([
	        Property('')
	    ], DateRangePicker.prototype, "cssClass", void 0);
	    __decorate$8([
	        Property('-')
	    ], DateRangePicker.prototype, "separator", void 0);
	    __decorate$8([
	        Property(null)
	    ], DateRangePicker.prototype, "minDays", void 0);
	    __decorate$8([
	        Property(null)
	    ], DateRangePicker.prototype, "maxDays", void 0);
	    __decorate$8([
	        Property(false)
	    ], DateRangePicker.prototype, "strictMode", void 0);
	    __decorate$8([
	        Property(null)
	    ], DateRangePicker.prototype, "keyConfigs", void 0);
	    __decorate$8([
	        Property(null)
	    ], DateRangePicker.prototype, "format", void 0);
	    __decorate$8([
	        Property(true)
	    ], DateRangePicker.prototype, "enabled", void 0);
	    __decorate$8([
	        Property(false)
	    ], DateRangePicker.prototype, "readonly", void 0);
	    __decorate$8([
	        Property(true)
	    ], DateRangePicker.prototype, "allowEdit", void 0);
	    __decorate$8([
	        Property('Never')
	    ], DateRangePicker.prototype, "floatLabelType", void 0);
	    __decorate$8([
	        Property(null)
	    ], DateRangePicker.prototype, "placeholder", void 0);
	    __decorate$8([
	        Property({})
	    ], DateRangePicker.prototype, "htmlAttributes", void 0);
	    __decorate$8([
	        Event()
	    ], DateRangePicker.prototype, "open", void 0);
	    __decorate$8([
	        Event()
	    ], DateRangePicker.prototype, "close", void 0);
	    __decorate$8([
	        Event()
	    ], DateRangePicker.prototype, "select", void 0);
	    __decorate$8([
	        Event()
	    ], DateRangePicker.prototype, "focus", void 0);
	    __decorate$8([
	        Event()
	    ], DateRangePicker.prototype, "blur", void 0);
	    DateRangePicker = __decorate$8([
	        NotifyPropertyChanges
	    ], DateRangePicker);
	    return DateRangePicker;
	}(CalendarBase));

	const subscriber_queue = [];

	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * https://svelte.dev/docs/svelte-store#writable
	 * @template T
	 * @param {T} [value] initial value
	 * @param {import('./public.js').StartStopNotifier<T>} [start]
	 * @returns {import('./public.js').Writable<T>}
	 */
	function writable(value, start = noop) {
		/** @type {import('./public.js').Unsubscriber} */
		let stop;
		/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */
		const subscribers = new Set();
		/** @param {T} new_value
		 * @returns {void}
		 */
		function set(new_value) {
			if (safe_not_equal(value, new_value)) {
				value = new_value;
				if (stop) {
					// store is ready
					const run_queue = !subscriber_queue.length;
					for (const subscriber of subscribers) {
						subscriber[1]();
						subscriber_queue.push(subscriber, value);
					}
					if (run_queue) {
						for (let i = 0; i < subscriber_queue.length; i += 2) {
							subscriber_queue[i][0](subscriber_queue[i + 1]);
						}
						subscriber_queue.length = 0;
					}
				}
			}
		}

		/**
		 * @param {import('./public.js').Updater<T>} fn
		 * @returns {void}
		 */
		function update(fn) {
			set(fn(value));
		}

		/**
		 * @param {import('./public.js').Subscriber<T>} run
		 * @param {import('./private.js').Invalidator<T>} [invalidate]
		 * @returns {import('./public.js').Unsubscriber}
		 */
		function subscribe(run, invalidate = noop) {
			/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */
			const subscriber = [run, invalidate];
			subscribers.add(subscriber);
			if (subscribers.size === 1) {
				stop = start(set, update) || noop;
			}
			run(value);
			return () => {
				subscribers.delete(subscriber);
				if (subscribers.size === 0 && stop) {
					stop();
					stop = null;
				}
			};
		}
		return { set, update, subscribe };
	}

	const dateStore = writable({ startDate: '', endDate: '' });

	/* src\Calendar.svelte generated by Svelte v4.2.1 */
	const file$7 = "src\\Calendar.svelte";

	function create_fragment$7(ctx) {
		let div2;
		let div1;
		let div0;
		let input;
		let br0;
		let br1;

		const block = {
			c: function create() {
				div2 = element$1("div");
				div1 = element$1("div");
				div0 = element$1("div");
				input = element$1("input");
				br0 = element$1("br");
				br1 = element$1("br");
				attr_dev(input, "id", "element");
				attr_dev(input, "type", "text");
				add_location(input, file$7, 63, 8, 2426);
				add_location(br0, file$7, 63, 42, 2460);
				add_location(br1, file$7, 63, 47, 2465);
				attr_dev(div0, "id", "wrapper");
				add_location(div0, file$7, 62, 6, 2398);
				attr_dev(div1, "class", "col-lg-12 control-section");
				add_location(div1, file$7, 61, 4, 2351);
				attr_dev(div2, "class", "calendar-container svelte-1nodpmc");
				add_location(div2, file$7, 60, 2, 2313);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div2, anchor);
				append_dev(div2, div1);
				append_dev(div1, div0);
				append_dev(div0, input);
				append_dev(div0, br0);
				append_dev(div0, br1);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div2);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$7.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function formatSelectedDate(date) {
		const day = date.getDate();
		const month = date.getMonth() + 1;
		const year = date.getFullYear();
		return `${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}/${year}`;
	}

	function instance$7($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Calendar', slots, []);
		let daterangepicker;
		let startDate = localStorage.getItem('startDate') || '';
		let endDate = localStorage.getItem('endDate') || '';

		onMount(() => {
			initializeDateRangePicker(startDate, endDate);
		});

		afterUpdate(() => {
			// After the component updates, check if the local storage values have changed
			const updatedStartDate = localStorage.getItem('startDate') || '';

			const updatedEndDate = localStorage.getItem('endDate') || '';

			if (startDate !== updatedStartDate || endDate !== updatedEndDate) {
				startDate = updatedStartDate;
				endDate = updatedEndDate;
			}
		});

		function initializeDateRangePicker(initialStartDate, initialEndDate) {
			daterangepicker = new DateRangePicker({
					placeholder: 'Select Range',
					start: 'Year',
					depth: 'Year',
					format: 'MMM yyyy',
					value: [
						new Date(initialStartDate || new Date()),
						new Date(initialEndDate || new Date())
					], // Initialize with either stored date or a default date
					// Initialize with either stored date or a default date
					change: () => {
						const selectedDates = daterangepicker.getSelectedRange();

						if (selectedDates && selectedDates.startDate && selectedDates.endDate) {
							const selectedStartDate = formatSelectedDate(selectedDates.startDate);
							const selectedEndDate = formatSelectedDate(selectedDates.endDate);
							localStorage.setItem('startDate', selectedStartDate);
							localStorage.setItem('endDate', selectedEndDate);

							dateStore.set({
								startDate: selectedStartDate,
								endDate: selectedEndDate
							});
						}
					}
				});

			daterangepicker.appendTo('#element');
		}

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Calendar> was created with unknown prop '${key}'`);
		});

		$$self.$capture_state = () => ({
			onMount,
			afterUpdate,
			DateRangePicker,
			dateStore,
			daterangepicker,
			startDate,
			endDate,
			initializeDateRangePicker,
			formatSelectedDate
		});

		$$self.$inject_state = $$props => {
			if ('daterangepicker' in $$props) daterangepicker = $$props.daterangepicker;
			if ('startDate' in $$props) startDate = $$props.startDate;
			if ('endDate' in $$props) endDate = $$props.endDate;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [];
	}

	class Calendar extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Calendar",
				options,
				id: create_fragment$7.name
			});
		}
	}

	/**
	 * The code in this file is copied from https://github.com/lukeed/clsx and modified to suit the needs of tailwind-merge better.
	 *
	 * Specifically:
	 * - Runtime code from https://github.com/lukeed/clsx/blob/v1.2.1/src/index.js
	 * - TypeScript types from https://github.com/lukeed/clsx/blob/v1.2.1/clsx.d.ts
	 *
	 * Original code has MIT license: Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)
	 */
	function twJoin() {
	  var index = 0;
	  var argument;
	  var resolvedValue;
	  var string = '';
	  while (index < arguments.length) {
	    if (argument = arguments[index++]) {
	      if (resolvedValue = toValue(argument)) {
	        string && (string += ' ');
	        string += resolvedValue;
	      }
	    }
	  }
	  return string;
	}
	function toValue(mix) {
	  if (typeof mix === 'string') {
	    return mix;
	  }
	  var resolvedValue;
	  var string = '';
	  for (var k = 0; k < mix.length; k++) {
	    if (mix[k]) {
	      if (resolvedValue = toValue(mix[k])) {
	        string && (string += ' ');
	        string += resolvedValue;
	      }
	    }
	  }
	  return string;
	}

	var CLASS_PART_SEPARATOR = '-';
	function createClassUtils(config) {
	  var classMap = createClassMap(config);
	  var conflictingClassGroups = config.conflictingClassGroups,
	    _config$conflictingCl = config.conflictingClassGroupModifiers,
	    conflictingClassGroupModifiers = _config$conflictingCl === void 0 ? {} : _config$conflictingCl;
	  function getClassGroupId(className) {
	    var classParts = className.split(CLASS_PART_SEPARATOR);
	    // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.
	    if (classParts[0] === '' && classParts.length !== 1) {
	      classParts.shift();
	    }
	    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
	  }
	  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
	    var conflicts = conflictingClassGroups[classGroupId] || [];
	    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
	      return [].concat(conflicts, conflictingClassGroupModifiers[classGroupId]);
	    }
	    return conflicts;
	  }
	  return {
	    getClassGroupId: getClassGroupId,
	    getConflictingClassGroupIds: getConflictingClassGroupIds
	  };
	}
	function getGroupRecursive(classParts, classPartObject) {
	  if (classParts.length === 0) {
	    return classPartObject.classGroupId;
	  }
	  var currentClassPart = classParts[0];
	  var nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
	  var classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : undefined;
	  if (classGroupFromNextClassPart) {
	    return classGroupFromNextClassPart;
	  }
	  if (classPartObject.validators.length === 0) {
	    return undefined;
	  }
	  var classRest = classParts.join(CLASS_PART_SEPARATOR);
	  return classPartObject.validators.find(function (_ref) {
	    var validator = _ref.validator;
	    return validator(classRest);
	  })?.classGroupId;
	}
	var arbitraryPropertyRegex = /^\[(.+)\]$/;
	function getGroupIdForArbitraryProperty(className) {
	  if (arbitraryPropertyRegex.test(className)) {
	    var arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
	    var property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(':'));
	    if (property) {
	      // I use two dots here because one dot is used as prefix for class groups in plugins
	      return 'arbitrary..' + property;
	    }
	  }
	}
	/**
	 * Exported for testing only
	 */
	function createClassMap(config) {
	  var theme = config.theme,
	    prefix = config.prefix;
	  var classMap = {
	    nextPart: new Map(),
	    validators: []
	  };
	  var prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
	  prefixedClassGroupEntries.forEach(function (_ref2) {
	    var classGroupId = _ref2[0],
	      classGroup = _ref2[1];
	    processClassesRecursively(classGroup, classMap, classGroupId, theme);
	  });
	  return classMap;
	}
	function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
	  classGroup.forEach(function (classDefinition) {
	    if (typeof classDefinition === 'string') {
	      var classPartObjectToEdit = classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition);
	      classPartObjectToEdit.classGroupId = classGroupId;
	      return;
	    }
	    if (typeof classDefinition === 'function') {
	      if (isThemeGetter(classDefinition)) {
	        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
	        return;
	      }
	      classPartObject.validators.push({
	        validator: classDefinition,
	        classGroupId: classGroupId
	      });
	      return;
	    }
	    Object.entries(classDefinition).forEach(function (_ref3) {
	      var key = _ref3[0],
	        classGroup = _ref3[1];
	      processClassesRecursively(classGroup, getPart(classPartObject, key), classGroupId, theme);
	    });
	  });
	}
	function getPart(classPartObject, path) {
	  var currentClassPartObject = classPartObject;
	  path.split(CLASS_PART_SEPARATOR).forEach(function (pathPart) {
	    if (!currentClassPartObject.nextPart.has(pathPart)) {
	      currentClassPartObject.nextPart.set(pathPart, {
	        nextPart: new Map(),
	        validators: []
	      });
	    }
	    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
	  });
	  return currentClassPartObject;
	}
	function isThemeGetter(func) {
	  return func.isThemeGetter;
	}
	function getPrefixedClassGroupEntries(classGroupEntries, prefix) {
	  if (!prefix) {
	    return classGroupEntries;
	  }
	  return classGroupEntries.map(function (_ref4) {
	    var classGroupId = _ref4[0],
	      classGroup = _ref4[1];
	    var prefixedClassGroup = classGroup.map(function (classDefinition) {
	      if (typeof classDefinition === 'string') {
	        return prefix + classDefinition;
	      }
	      if (typeof classDefinition === 'object') {
	        return Object.fromEntries(Object.entries(classDefinition).map(function (_ref5) {
	          var key = _ref5[0],
	            value = _ref5[1];
	          return [prefix + key, value];
	        }));
	      }
	      return classDefinition;
	    });
	    return [classGroupId, prefixedClassGroup];
	  });
	}

	// LRU cache inspired from hashlru (https://github.com/dominictarr/hashlru/blob/v1.0.4/index.js) but object replaced with Map to improve performance
	function createLruCache(maxCacheSize) {
	  if (maxCacheSize < 1) {
	    return {
	      get: function get() {
	        return undefined;
	      },
	      set: function set() {}
	    };
	  }
	  var cacheSize = 0;
	  var cache = new Map();
	  var previousCache = new Map();
	  function update(key, value) {
	    cache.set(key, value);
	    cacheSize++;
	    if (cacheSize > maxCacheSize) {
	      cacheSize = 0;
	      previousCache = cache;
	      cache = new Map();
	    }
	  }
	  return {
	    get: function get(key) {
	      var value = cache.get(key);
	      if (value !== undefined) {
	        return value;
	      }
	      if ((value = previousCache.get(key)) !== undefined) {
	        update(key, value);
	        return value;
	      }
	    },
	    set: function set(key, value) {
	      if (cache.has(key)) {
	        cache.set(key, value);
	      } else {
	        update(key, value);
	      }
	    }
	  };
	}

	var IMPORTANT_MODIFIER = '!';
	function createSplitModifiers(config) {
	  var separator = config.separator || ':';
	  var isSeparatorSingleCharacter = separator.length === 1;
	  var firstSeparatorCharacter = separator[0];
	  var separatorLength = separator.length;
	  // splitModifiers inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js
	  return function splitModifiers(className) {
	    var modifiers = [];
	    var bracketDepth = 0;
	    var modifierStart = 0;
	    var postfixModifierPosition;
	    for (var index = 0; index < className.length; index++) {
	      var currentCharacter = className[index];
	      if (bracketDepth === 0) {
	        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index, index + separatorLength) === separator)) {
	          modifiers.push(className.slice(modifierStart, index));
	          modifierStart = index + separatorLength;
	          continue;
	        }
	        if (currentCharacter === '/') {
	          postfixModifierPosition = index;
	          continue;
	        }
	      }
	      if (currentCharacter === '[') {
	        bracketDepth++;
	      } else if (currentCharacter === ']') {
	        bracketDepth--;
	      }
	    }
	    var baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
	    var hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
	    var baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
	    var maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : undefined;
	    return {
	      modifiers: modifiers,
	      hasImportantModifier: hasImportantModifier,
	      baseClassName: baseClassName,
	      maybePostfixModifierPosition: maybePostfixModifierPosition
	    };
	  };
	}
	/**
	 * Sorts modifiers according to following schema:
	 * - Predefined modifiers are sorted alphabetically
	 * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it
	 */
	function sortModifiers(modifiers) {
	  if (modifiers.length <= 1) {
	    return modifiers;
	  }
	  var sortedModifiers = [];
	  var unsortedModifiers = [];
	  modifiers.forEach(function (modifier) {
	    var isArbitraryVariant = modifier[0] === '[';
	    if (isArbitraryVariant) {
	      sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort().concat([modifier]));
	      unsortedModifiers = [];
	    } else {
	      unsortedModifiers.push(modifier);
	    }
	  });
	  sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort());
	  return sortedModifiers;
	}

	function createConfigUtils(config) {
	  return {
	    cache: createLruCache(config.cacheSize),
	    splitModifiers: createSplitModifiers(config),
	    ...createClassUtils(config)
	  };
	}

	var SPLIT_CLASSES_REGEX = /\s+/;
	function mergeClassList(classList, configUtils) {
	  var splitModifiers = configUtils.splitModifiers,
	    getClassGroupId = configUtils.getClassGroupId,
	    getConflictingClassGroupIds = configUtils.getConflictingClassGroupIds;
	  /**
	   * Set of classGroupIds in following format:
	   * `{importantModifier}{variantModifiers}{classGroupId}`
	   * @example 'float'
	   * @example 'hover:focus:bg-color'
	   * @example 'md:!pr'
	   */
	  var classGroupsInConflict = new Set();
	  return classList.trim().split(SPLIT_CLASSES_REGEX).map(function (originalClassName) {
	    var _splitModifiers = splitModifiers(originalClassName),
	      modifiers = _splitModifiers.modifiers,
	      hasImportantModifier = _splitModifiers.hasImportantModifier,
	      baseClassName = _splitModifiers.baseClassName,
	      maybePostfixModifierPosition = _splitModifiers.maybePostfixModifierPosition;
	    var classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
	    var hasPostfixModifier = Boolean(maybePostfixModifierPosition);
	    if (!classGroupId) {
	      if (!maybePostfixModifierPosition) {
	        return {
	          isTailwindClass: false,
	          originalClassName: originalClassName
	        };
	      }
	      classGroupId = getClassGroupId(baseClassName);
	      if (!classGroupId) {
	        return {
	          isTailwindClass: false,
	          originalClassName: originalClassName
	        };
	      }
	      hasPostfixModifier = false;
	    }
	    var variantModifier = sortModifiers(modifiers).join(':');
	    var modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
	    return {
	      isTailwindClass: true,
	      modifierId: modifierId,
	      classGroupId: classGroupId,
	      originalClassName: originalClassName,
	      hasPostfixModifier: hasPostfixModifier
	    };
	  }).reverse()
	  // Last class in conflict wins, so we need to filter conflicting classes in reverse order.
	  .filter(function (parsed) {
	    if (!parsed.isTailwindClass) {
	      return true;
	    }
	    var modifierId = parsed.modifierId,
	      classGroupId = parsed.classGroupId,
	      hasPostfixModifier = parsed.hasPostfixModifier;
	    var classId = modifierId + classGroupId;
	    if (classGroupsInConflict.has(classId)) {
	      return false;
	    }
	    classGroupsInConflict.add(classId);
	    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach(function (group) {
	      return classGroupsInConflict.add(modifierId + group);
	    });
	    return true;
	  }).reverse().map(function (parsed) {
	    return parsed.originalClassName;
	  }).join(' ');
	}

	function createTailwindMerge() {
	  for (var _len = arguments.length, createConfig = new Array(_len), _key = 0; _key < _len; _key++) {
	    createConfig[_key] = arguments[_key];
	  }
	  var configUtils;
	  var cacheGet;
	  var cacheSet;
	  var functionToCall = initTailwindMerge;
	  function initTailwindMerge(classList) {
	    var firstCreateConfig = createConfig[0],
	      restCreateConfig = createConfig.slice(1);
	    var config = restCreateConfig.reduce(function (previousConfig, createConfigCurrent) {
	      return createConfigCurrent(previousConfig);
	    }, firstCreateConfig());
	    configUtils = createConfigUtils(config);
	    cacheGet = configUtils.cache.get;
	    cacheSet = configUtils.cache.set;
	    functionToCall = tailwindMerge;
	    return tailwindMerge(classList);
	  }
	  function tailwindMerge(classList) {
	    var cachedResult = cacheGet(classList);
	    if (cachedResult) {
	      return cachedResult;
	    }
	    var result = mergeClassList(classList, configUtils);
	    cacheSet(classList, result);
	    return result;
	  }
	  return function callTailwindMerge() {
	    return functionToCall(twJoin.apply(null, arguments));
	  };
	}

	function fromTheme(key) {
	  var themeGetter = function themeGetter(theme) {
	    return theme[key] || [];
	  };
	  themeGetter.isThemeGetter = true;
	  return themeGetter;
	}

	var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
	var fractionRegex = /^\d+\/\d+$/;
	var stringLengths = /*#__PURE__*/new Set(['px', 'full', 'screen']);
	var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
	var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
	// Shadow always begins with x and y offset separated by underscore
	var shadowRegex = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
	function isLength(value) {
	  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value) || isArbitraryLength(value);
	}
	function isArbitraryLength(value) {
	  return getIsArbitraryValue(value, 'length', isLengthOnly);
	}
	function isArbitrarySize(value) {
	  return getIsArbitraryValue(value, 'size', isNever);
	}
	function isArbitraryPosition(value) {
	  return getIsArbitraryValue(value, 'position', isNever);
	}
	function isArbitraryUrl(value) {
	  return getIsArbitraryValue(value, 'url', isUrl);
	}
	function isArbitraryNumber(value) {
	  return getIsArbitraryValue(value, 'number', isNumber);
	}
	function isNumber(value) {
	  return !Number.isNaN(Number(value));
	}
	function isPercent(value) {
	  return value.endsWith('%') && isNumber(value.slice(0, -1));
	}
	function isInteger(value) {
	  return isIntegerOnly(value) || getIsArbitraryValue(value, 'number', isIntegerOnly);
	}
	function isArbitraryValue(value) {
	  return arbitraryValueRegex.test(value);
	}
	function isAny() {
	  return true;
	}
	function isTshirtSize(value) {
	  return tshirtUnitRegex.test(value);
	}
	function isArbitraryShadow(value) {
	  return getIsArbitraryValue(value, '', isShadow);
	}
	function getIsArbitraryValue(value, label, testValue) {
	  var result = arbitraryValueRegex.exec(value);
	  if (result) {
	    if (result[1]) {
	      return result[1] === label;
	    }
	    return testValue(result[2]);
	  }
	  return false;
	}
	function isLengthOnly(value) {
	  return lengthUnitRegex.test(value);
	}
	function isNever() {
	  return false;
	}
	function isUrl(value) {
	  return value.startsWith('url(');
	}
	function isIntegerOnly(value) {
	  return Number.isInteger(Number(value));
	}
	function isShadow(value) {
	  return shadowRegex.test(value);
	}

	function getDefaultConfig() {
	  var colors = fromTheme('colors');
	  var spacing = fromTheme('spacing');
	  var blur = fromTheme('blur');
	  var brightness = fromTheme('brightness');
	  var borderColor = fromTheme('borderColor');
	  var borderRadius = fromTheme('borderRadius');
	  var borderSpacing = fromTheme('borderSpacing');
	  var borderWidth = fromTheme('borderWidth');
	  var contrast = fromTheme('contrast');
	  var grayscale = fromTheme('grayscale');
	  var hueRotate = fromTheme('hueRotate');
	  var invert = fromTheme('invert');
	  var gap = fromTheme('gap');
	  var gradientColorStops = fromTheme('gradientColorStops');
	  var gradientColorStopPositions = fromTheme('gradientColorStopPositions');
	  var inset = fromTheme('inset');
	  var margin = fromTheme('margin');
	  var opacity = fromTheme('opacity');
	  var padding = fromTheme('padding');
	  var saturate = fromTheme('saturate');
	  var scale = fromTheme('scale');
	  var sepia = fromTheme('sepia');
	  var skew = fromTheme('skew');
	  var space = fromTheme('space');
	  var translate = fromTheme('translate');
	  var getOverscroll = function getOverscroll() {
	    return ['auto', 'contain', 'none'];
	  };
	  var getOverflow = function getOverflow() {
	    return ['auto', 'hidden', 'clip', 'visible', 'scroll'];
	  };
	  var getSpacingWithAutoAndArbitrary = function getSpacingWithAutoAndArbitrary() {
	    return ['auto', isArbitraryValue, spacing];
	  };
	  var getSpacingWithArbitrary = function getSpacingWithArbitrary() {
	    return [isArbitraryValue, spacing];
	  };
	  var getLengthWithEmpty = function getLengthWithEmpty() {
	    return ['', isLength];
	  };
	  var getNumberWithAutoAndArbitrary = function getNumberWithAutoAndArbitrary() {
	    return ['auto', isNumber, isArbitraryValue];
	  };
	  var getPositions = function getPositions() {
	    return ['bottom', 'center', 'left', 'left-bottom', 'left-top', 'right', 'right-bottom', 'right-top', 'top'];
	  };
	  var getLineStyles = function getLineStyles() {
	    return ['solid', 'dashed', 'dotted', 'double', 'none'];
	  };
	  var getBlendModes = function getBlendModes() {
	    return ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity', 'plus-lighter'];
	  };
	  var getAlign = function getAlign() {
	    return ['start', 'end', 'center', 'between', 'around', 'evenly', 'stretch'];
	  };
	  var getZeroAndEmpty = function getZeroAndEmpty() {
	    return ['', '0', isArbitraryValue];
	  };
	  var getBreaks = function getBreaks() {
	    return ['auto', 'avoid', 'all', 'avoid-page', 'page', 'left', 'right', 'column'];
	  };
	  var getNumber = function getNumber() {
	    return [isNumber, isArbitraryNumber];
	  };
	  var getNumberAndArbitrary = function getNumberAndArbitrary() {
	    return [isNumber, isArbitraryValue];
	  };
	  return {
	    cacheSize: 500,
	    theme: {
	      colors: [isAny],
	      spacing: [isLength],
	      blur: ['none', '', isTshirtSize, isArbitraryValue],
	      brightness: getNumber(),
	      borderColor: [colors],
	      borderRadius: ['none', '', 'full', isTshirtSize, isArbitraryValue],
	      borderSpacing: getSpacingWithArbitrary(),
	      borderWidth: getLengthWithEmpty(),
	      contrast: getNumber(),
	      grayscale: getZeroAndEmpty(),
	      hueRotate: getNumberAndArbitrary(),
	      invert: getZeroAndEmpty(),
	      gap: getSpacingWithArbitrary(),
	      gradientColorStops: [colors],
	      gradientColorStopPositions: [isPercent, isArbitraryLength],
	      inset: getSpacingWithAutoAndArbitrary(),
	      margin: getSpacingWithAutoAndArbitrary(),
	      opacity: getNumber(),
	      padding: getSpacingWithArbitrary(),
	      saturate: getNumber(),
	      scale: getNumber(),
	      sepia: getZeroAndEmpty(),
	      skew: getNumberAndArbitrary(),
	      space: getSpacingWithArbitrary(),
	      translate: getSpacingWithArbitrary()
	    },
	    classGroups: {
	      // Layout
	      /**
	       * Aspect Ratio
	       * @see https://tailwindcss.com/docs/aspect-ratio
	       */
	      aspect: [{
	        aspect: ['auto', 'square', 'video', isArbitraryValue]
	      }],
	      /**
	       * Container
	       * @see https://tailwindcss.com/docs/container
	       */
	      container: ['container'],
	      /**
	       * Columns
	       * @see https://tailwindcss.com/docs/columns
	       */
	      columns: [{
	        columns: [isTshirtSize]
	      }],
	      /**
	       * Break After
	       * @see https://tailwindcss.com/docs/break-after
	       */
	      'break-after': [{
	        'break-after': getBreaks()
	      }],
	      /**
	       * Break Before
	       * @see https://tailwindcss.com/docs/break-before
	       */
	      'break-before': [{
	        'break-before': getBreaks()
	      }],
	      /**
	       * Break Inside
	       * @see https://tailwindcss.com/docs/break-inside
	       */
	      'break-inside': [{
	        'break-inside': ['auto', 'avoid', 'avoid-page', 'avoid-column']
	      }],
	      /**
	       * Box Decoration Break
	       * @see https://tailwindcss.com/docs/box-decoration-break
	       */
	      'box-decoration': [{
	        'box-decoration': ['slice', 'clone']
	      }],
	      /**
	       * Box Sizing
	       * @see https://tailwindcss.com/docs/box-sizing
	       */
	      box: [{
	        box: ['border', 'content']
	      }],
	      /**
	       * Display
	       * @see https://tailwindcss.com/docs/display
	       */
	      display: ['block', 'inline-block', 'inline', 'flex', 'inline-flex', 'table', 'inline-table', 'table-caption', 'table-cell', 'table-column', 'table-column-group', 'table-footer-group', 'table-header-group', 'table-row-group', 'table-row', 'flow-root', 'grid', 'inline-grid', 'contents', 'list-item', 'hidden'],
	      /**
	       * Floats
	       * @see https://tailwindcss.com/docs/float
	       */
	      "float": [{
	        "float": ['right', 'left', 'none']
	      }],
	      /**
	       * Clear
	       * @see https://tailwindcss.com/docs/clear
	       */
	      clear: [{
	        clear: ['left', 'right', 'both', 'none']
	      }],
	      /**
	       * Isolation
	       * @see https://tailwindcss.com/docs/isolation
	       */
	      isolation: ['isolate', 'isolation-auto'],
	      /**
	       * Object Fit
	       * @see https://tailwindcss.com/docs/object-fit
	       */
	      'object-fit': [{
	        object: ['contain', 'cover', 'fill', 'none', 'scale-down']
	      }],
	      /**
	       * Object Position
	       * @see https://tailwindcss.com/docs/object-position
	       */
	      'object-position': [{
	        object: [].concat(getPositions(), [isArbitraryValue])
	      }],
	      /**
	       * Overflow
	       * @see https://tailwindcss.com/docs/overflow
	       */
	      overflow: [{
	        overflow: getOverflow()
	      }],
	      /**
	       * Overflow X
	       * @see https://tailwindcss.com/docs/overflow
	       */
	      'overflow-x': [{
	        'overflow-x': getOverflow()
	      }],
	      /**
	       * Overflow Y
	       * @see https://tailwindcss.com/docs/overflow
	       */
	      'overflow-y': [{
	        'overflow-y': getOverflow()
	      }],
	      /**
	       * Overscroll Behavior
	       * @see https://tailwindcss.com/docs/overscroll-behavior
	       */
	      overscroll: [{
	        overscroll: getOverscroll()
	      }],
	      /**
	       * Overscroll Behavior X
	       * @see https://tailwindcss.com/docs/overscroll-behavior
	       */
	      'overscroll-x': [{
	        'overscroll-x': getOverscroll()
	      }],
	      /**
	       * Overscroll Behavior Y
	       * @see https://tailwindcss.com/docs/overscroll-behavior
	       */
	      'overscroll-y': [{
	        'overscroll-y': getOverscroll()
	      }],
	      /**
	       * Position
	       * @see https://tailwindcss.com/docs/position
	       */
	      position: ['static', 'fixed', 'absolute', 'relative', 'sticky'],
	      /**
	       * Top / Right / Bottom / Left
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      inset: [{
	        inset: [inset]
	      }],
	      /**
	       * Right / Left
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      'inset-x': [{
	        'inset-x': [inset]
	      }],
	      /**
	       * Top / Bottom
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      'inset-y': [{
	        'inset-y': [inset]
	      }],
	      /**
	       * Start
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      start: [{
	        start: [inset]
	      }],
	      /**
	       * End
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      end: [{
	        end: [inset]
	      }],
	      /**
	       * Top
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      top: [{
	        top: [inset]
	      }],
	      /**
	       * Right
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      right: [{
	        right: [inset]
	      }],
	      /**
	       * Bottom
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      bottom: [{
	        bottom: [inset]
	      }],
	      /**
	       * Left
	       * @see https://tailwindcss.com/docs/top-right-bottom-left
	       */
	      left: [{
	        left: [inset]
	      }],
	      /**
	       * Visibility
	       * @see https://tailwindcss.com/docs/visibility
	       */
	      visibility: ['visible', 'invisible', 'collapse'],
	      /**
	       * Z-Index
	       * @see https://tailwindcss.com/docs/z-index
	       */
	      z: [{
	        z: ['auto', isInteger]
	      }],
	      // Flexbox and Grid
	      /**
	       * Flex Basis
	       * @see https://tailwindcss.com/docs/flex-basis
	       */
	      basis: [{
	        basis: getSpacingWithAutoAndArbitrary()
	      }],
	      /**
	       * Flex Direction
	       * @see https://tailwindcss.com/docs/flex-direction
	       */
	      'flex-direction': [{
	        flex: ['row', 'row-reverse', 'col', 'col-reverse']
	      }],
	      /**
	       * Flex Wrap
	       * @see https://tailwindcss.com/docs/flex-wrap
	       */
	      'flex-wrap': [{
	        flex: ['wrap', 'wrap-reverse', 'nowrap']
	      }],
	      /**
	       * Flex
	       * @see https://tailwindcss.com/docs/flex
	       */
	      flex: [{
	        flex: ['1', 'auto', 'initial', 'none', isArbitraryValue]
	      }],
	      /**
	       * Flex Grow
	       * @see https://tailwindcss.com/docs/flex-grow
	       */
	      grow: [{
	        grow: getZeroAndEmpty()
	      }],
	      /**
	       * Flex Shrink
	       * @see https://tailwindcss.com/docs/flex-shrink
	       */
	      shrink: [{
	        shrink: getZeroAndEmpty()
	      }],
	      /**
	       * Order
	       * @see https://tailwindcss.com/docs/order
	       */
	      order: [{
	        order: ['first', 'last', 'none', isInteger]
	      }],
	      /**
	       * Grid Template Columns
	       * @see https://tailwindcss.com/docs/grid-template-columns
	       */
	      'grid-cols': [{
	        'grid-cols': [isAny]
	      }],
	      /**
	       * Grid Column Start / End
	       * @see https://tailwindcss.com/docs/grid-column
	       */
	      'col-start-end': [{
	        col: ['auto', {
	          span: ['full', isInteger]
	        }, isArbitraryValue]
	      }],
	      /**
	       * Grid Column Start
	       * @see https://tailwindcss.com/docs/grid-column
	       */
	      'col-start': [{
	        'col-start': getNumberWithAutoAndArbitrary()
	      }],
	      /**
	       * Grid Column End
	       * @see https://tailwindcss.com/docs/grid-column
	       */
	      'col-end': [{
	        'col-end': getNumberWithAutoAndArbitrary()
	      }],
	      /**
	       * Grid Template Rows
	       * @see https://tailwindcss.com/docs/grid-template-rows
	       */
	      'grid-rows': [{
	        'grid-rows': [isAny]
	      }],
	      /**
	       * Grid Row Start / End
	       * @see https://tailwindcss.com/docs/grid-row
	       */
	      'row-start-end': [{
	        row: ['auto', {
	          span: [isInteger]
	        }, isArbitraryValue]
	      }],
	      /**
	       * Grid Row Start
	       * @see https://tailwindcss.com/docs/grid-row
	       */
	      'row-start': [{
	        'row-start': getNumberWithAutoAndArbitrary()
	      }],
	      /**
	       * Grid Row End
	       * @see https://tailwindcss.com/docs/grid-row
	       */
	      'row-end': [{
	        'row-end': getNumberWithAutoAndArbitrary()
	      }],
	      /**
	       * Grid Auto Flow
	       * @see https://tailwindcss.com/docs/grid-auto-flow
	       */
	      'grid-flow': [{
	        'grid-flow': ['row', 'col', 'dense', 'row-dense', 'col-dense']
	      }],
	      /**
	       * Grid Auto Columns
	       * @see https://tailwindcss.com/docs/grid-auto-columns
	       */
	      'auto-cols': [{
	        'auto-cols': ['auto', 'min', 'max', 'fr', isArbitraryValue]
	      }],
	      /**
	       * Grid Auto Rows
	       * @see https://tailwindcss.com/docs/grid-auto-rows
	       */
	      'auto-rows': [{
	        'auto-rows': ['auto', 'min', 'max', 'fr', isArbitraryValue]
	      }],
	      /**
	       * Gap
	       * @see https://tailwindcss.com/docs/gap
	       */
	      gap: [{
	        gap: [gap]
	      }],
	      /**
	       * Gap X
	       * @see https://tailwindcss.com/docs/gap
	       */
	      'gap-x': [{
	        'gap-x': [gap]
	      }],
	      /**
	       * Gap Y
	       * @see https://tailwindcss.com/docs/gap
	       */
	      'gap-y': [{
	        'gap-y': [gap]
	      }],
	      /**
	       * Justify Content
	       * @see https://tailwindcss.com/docs/justify-content
	       */
	      'justify-content': [{
	        justify: ['normal'].concat(getAlign())
	      }],
	      /**
	       * Justify Items
	       * @see https://tailwindcss.com/docs/justify-items
	       */
	      'justify-items': [{
	        'justify-items': ['start', 'end', 'center', 'stretch']
	      }],
	      /**
	       * Justify Self
	       * @see https://tailwindcss.com/docs/justify-self
	       */
	      'justify-self': [{
	        'justify-self': ['auto', 'start', 'end', 'center', 'stretch']
	      }],
	      /**
	       * Align Content
	       * @see https://tailwindcss.com/docs/align-content
	       */
	      'align-content': [{
	        content: ['normal'].concat(getAlign(), ['baseline'])
	      }],
	      /**
	       * Align Items
	       * @see https://tailwindcss.com/docs/align-items
	       */
	      'align-items': [{
	        items: ['start', 'end', 'center', 'baseline', 'stretch']
	      }],
	      /**
	       * Align Self
	       * @see https://tailwindcss.com/docs/align-self
	       */
	      'align-self': [{
	        self: ['auto', 'start', 'end', 'center', 'stretch', 'baseline']
	      }],
	      /**
	       * Place Content
	       * @see https://tailwindcss.com/docs/place-content
	       */
	      'place-content': [{
	        'place-content': [].concat(getAlign(), ['baseline'])
	      }],
	      /**
	       * Place Items
	       * @see https://tailwindcss.com/docs/place-items
	       */
	      'place-items': [{
	        'place-items': ['start', 'end', 'center', 'baseline', 'stretch']
	      }],
	      /**
	       * Place Self
	       * @see https://tailwindcss.com/docs/place-self
	       */
	      'place-self': [{
	        'place-self': ['auto', 'start', 'end', 'center', 'stretch']
	      }],
	      // Spacing
	      /**
	       * Padding
	       * @see https://tailwindcss.com/docs/padding
	       */
	      p: [{
	        p: [padding]
	      }],
	      /**
	       * Padding X
	       * @see https://tailwindcss.com/docs/padding
	       */
	      px: [{
	        px: [padding]
	      }],
	      /**
	       * Padding Y
	       * @see https://tailwindcss.com/docs/padding
	       */
	      py: [{
	        py: [padding]
	      }],
	      /**
	       * Padding Start
	       * @see https://tailwindcss.com/docs/padding
	       */
	      ps: [{
	        ps: [padding]
	      }],
	      /**
	       * Padding End
	       * @see https://tailwindcss.com/docs/padding
	       */
	      pe: [{
	        pe: [padding]
	      }],
	      /**
	       * Padding Top
	       * @see https://tailwindcss.com/docs/padding
	       */
	      pt: [{
	        pt: [padding]
	      }],
	      /**
	       * Padding Right
	       * @see https://tailwindcss.com/docs/padding
	       */
	      pr: [{
	        pr: [padding]
	      }],
	      /**
	       * Padding Bottom
	       * @see https://tailwindcss.com/docs/padding
	       */
	      pb: [{
	        pb: [padding]
	      }],
	      /**
	       * Padding Left
	       * @see https://tailwindcss.com/docs/padding
	       */
	      pl: [{
	        pl: [padding]
	      }],
	      /**
	       * Margin
	       * @see https://tailwindcss.com/docs/margin
	       */
	      m: [{
	        m: [margin]
	      }],
	      /**
	       * Margin X
	       * @see https://tailwindcss.com/docs/margin
	       */
	      mx: [{
	        mx: [margin]
	      }],
	      /**
	       * Margin Y
	       * @see https://tailwindcss.com/docs/margin
	       */
	      my: [{
	        my: [margin]
	      }],
	      /**
	       * Margin Start
	       * @see https://tailwindcss.com/docs/margin
	       */
	      ms: [{
	        ms: [margin]
	      }],
	      /**
	       * Margin End
	       * @see https://tailwindcss.com/docs/margin
	       */
	      me: [{
	        me: [margin]
	      }],
	      /**
	       * Margin Top
	       * @see https://tailwindcss.com/docs/margin
	       */
	      mt: [{
	        mt: [margin]
	      }],
	      /**
	       * Margin Right
	       * @see https://tailwindcss.com/docs/margin
	       */
	      mr: [{
	        mr: [margin]
	      }],
	      /**
	       * Margin Bottom
	       * @see https://tailwindcss.com/docs/margin
	       */
	      mb: [{
	        mb: [margin]
	      }],
	      /**
	       * Margin Left
	       * @see https://tailwindcss.com/docs/margin
	       */
	      ml: [{
	        ml: [margin]
	      }],
	      /**
	       * Space Between X
	       * @see https://tailwindcss.com/docs/space
	       */
	      'space-x': [{
	        'space-x': [space]
	      }],
	      /**
	       * Space Between X Reverse
	       * @see https://tailwindcss.com/docs/space
	       */
	      'space-x-reverse': ['space-x-reverse'],
	      /**
	       * Space Between Y
	       * @see https://tailwindcss.com/docs/space
	       */
	      'space-y': [{
	        'space-y': [space]
	      }],
	      /**
	       * Space Between Y Reverse
	       * @see https://tailwindcss.com/docs/space
	       */
	      'space-y-reverse': ['space-y-reverse'],
	      // Sizing
	      /**
	       * Width
	       * @see https://tailwindcss.com/docs/width
	       */
	      w: [{
	        w: ['auto', 'min', 'max', 'fit', isArbitraryValue, spacing]
	      }],
	      /**
	       * Min-Width
	       * @see https://tailwindcss.com/docs/min-width
	       */
	      'min-w': [{
	        'min-w': ['min', 'max', 'fit', isArbitraryValue, isLength]
	      }],
	      /**
	       * Max-Width
	       * @see https://tailwindcss.com/docs/max-width
	       */
	      'max-w': [{
	        'max-w': ['0', 'none', 'full', 'min', 'max', 'fit', 'prose', {
	          screen: [isTshirtSize]
	        }, isTshirtSize, isArbitraryValue]
	      }],
	      /**
	       * Height
	       * @see https://tailwindcss.com/docs/height
	       */
	      h: [{
	        h: [isArbitraryValue, spacing, 'auto', 'min', 'max', 'fit']
	      }],
	      /**
	       * Min-Height
	       * @see https://tailwindcss.com/docs/min-height
	       */
	      'min-h': [{
	        'min-h': ['min', 'max', 'fit', isArbitraryValue, isLength]
	      }],
	      /**
	       * Max-Height
	       * @see https://tailwindcss.com/docs/max-height
	       */
	      'max-h': [{
	        'max-h': [isArbitraryValue, spacing, 'min', 'max', 'fit']
	      }],
	      // Typography
	      /**
	       * Font Size
	       * @see https://tailwindcss.com/docs/font-size
	       */
	      'font-size': [{
	        text: ['base', isTshirtSize, isArbitraryLength]
	      }],
	      /**
	       * Font Smoothing
	       * @see https://tailwindcss.com/docs/font-smoothing
	       */
	      'font-smoothing': ['antialiased', 'subpixel-antialiased'],
	      /**
	       * Font Style
	       * @see https://tailwindcss.com/docs/font-style
	       */
	      'font-style': ['italic', 'not-italic'],
	      /**
	       * Font Weight
	       * @see https://tailwindcss.com/docs/font-weight
	       */
	      'font-weight': [{
	        font: ['thin', 'extralight', 'light', 'normal', 'medium', 'semibold', 'bold', 'extrabold', 'black', isArbitraryNumber]
	      }],
	      /**
	       * Font Family
	       * @see https://tailwindcss.com/docs/font-family
	       */
	      'font-family': [{
	        font: [isAny]
	      }],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-normal': ['normal-nums'],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-ordinal': ['ordinal'],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-slashed-zero': ['slashed-zero'],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-figure': ['lining-nums', 'oldstyle-nums'],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-spacing': ['proportional-nums', 'tabular-nums'],
	      /**
	       * Font Variant Numeric
	       * @see https://tailwindcss.com/docs/font-variant-numeric
	       */
	      'fvn-fraction': ['diagonal-fractions', 'stacked-fractons'],
	      /**
	       * Letter Spacing
	       * @see https://tailwindcss.com/docs/letter-spacing
	       */
	      tracking: [{
	        tracking: ['tighter', 'tight', 'normal', 'wide', 'wider', 'widest', isArbitraryValue]
	      }],
	      /**
	       * Line Clamp
	       * @see https://tailwindcss.com/docs/line-clamp
	       */
	      'line-clamp': [{
	        'line-clamp': ['none', isNumber, isArbitraryNumber]
	      }],
	      /**
	       * Line Height
	       * @see https://tailwindcss.com/docs/line-height
	       */
	      leading: [{
	        leading: ['none', 'tight', 'snug', 'normal', 'relaxed', 'loose', isArbitraryValue, isLength]
	      }],
	      /**
	       * List Style Image
	       * @see https://tailwindcss.com/docs/list-style-image
	       */
	      'list-image': [{
	        'list-image': ['none', isArbitraryValue]
	      }],
	      /**
	       * List Style Type
	       * @see https://tailwindcss.com/docs/list-style-type
	       */
	      'list-style-type': [{
	        list: ['none', 'disc', 'decimal', isArbitraryValue]
	      }],
	      /**
	       * List Style Position
	       * @see https://tailwindcss.com/docs/list-style-position
	       */
	      'list-style-position': [{
	        list: ['inside', 'outside']
	      }],
	      /**
	       * Placeholder Color
	       * @deprecated since Tailwind CSS v3.0.0
	       * @see https://tailwindcss.com/docs/placeholder-color
	       */
	      'placeholder-color': [{
	        placeholder: [colors]
	      }],
	      /**
	       * Placeholder Opacity
	       * @see https://tailwindcss.com/docs/placeholder-opacity
	       */
	      'placeholder-opacity': [{
	        'placeholder-opacity': [opacity]
	      }],
	      /**
	       * Text Alignment
	       * @see https://tailwindcss.com/docs/text-align
	       */
	      'text-alignment': [{
	        text: ['left', 'center', 'right', 'justify', 'start', 'end']
	      }],
	      /**
	       * Text Color
	       * @see https://tailwindcss.com/docs/text-color
	       */
	      'text-color': [{
	        text: [colors]
	      }],
	      /**
	       * Text Opacity
	       * @see https://tailwindcss.com/docs/text-opacity
	       */
	      'text-opacity': [{
	        'text-opacity': [opacity]
	      }],
	      /**
	       * Text Decoration
	       * @see https://tailwindcss.com/docs/text-decoration
	       */
	      'text-decoration': ['underline', 'overline', 'line-through', 'no-underline'],
	      /**
	       * Text Decoration Style
	       * @see https://tailwindcss.com/docs/text-decoration-style
	       */
	      'text-decoration-style': [{
	        decoration: [].concat(getLineStyles(), ['wavy'])
	      }],
	      /**
	       * Text Decoration Thickness
	       * @see https://tailwindcss.com/docs/text-decoration-thickness
	       */
	      'text-decoration-thickness': [{
	        decoration: ['auto', 'from-font', isLength]
	      }],
	      /**
	       * Text Underline Offset
	       * @see https://tailwindcss.com/docs/text-underline-offset
	       */
	      'underline-offset': [{
	        'underline-offset': ['auto', isArbitraryValue, isLength]
	      }],
	      /**
	       * Text Decoration Color
	       * @see https://tailwindcss.com/docs/text-decoration-color
	       */
	      'text-decoration-color': [{
	        decoration: [colors]
	      }],
	      /**
	       * Text Transform
	       * @see https://tailwindcss.com/docs/text-transform
	       */
	      'text-transform': ['uppercase', 'lowercase', 'capitalize', 'normal-case'],
	      /**
	       * Text Overflow
	       * @see https://tailwindcss.com/docs/text-overflow
	       */
	      'text-overflow': ['truncate', 'text-ellipsis', 'text-clip'],
	      /**
	       * Text Indent
	       * @see https://tailwindcss.com/docs/text-indent
	       */
	      indent: [{
	        indent: getSpacingWithArbitrary()
	      }],
	      /**
	       * Vertical Alignment
	       * @see https://tailwindcss.com/docs/vertical-align
	       */
	      'vertical-align': [{
	        align: ['baseline', 'top', 'middle', 'bottom', 'text-top', 'text-bottom', 'sub', 'super', isArbitraryValue]
	      }],
	      /**
	       * Whitespace
	       * @see https://tailwindcss.com/docs/whitespace
	       */
	      whitespace: [{
	        whitespace: ['normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'break-spaces']
	      }],
	      /**
	       * Word Break
	       * @see https://tailwindcss.com/docs/word-break
	       */
	      "break": [{
	        "break": ['normal', 'words', 'all', 'keep']
	      }],
	      /**
	       * Hyphens
	       * @see https://tailwindcss.com/docs/hyphens
	       */
	      hyphens: [{
	        hyphens: ['none', 'manual', 'auto']
	      }],
	      /**
	       * Content
	       * @see https://tailwindcss.com/docs/content
	       */
	      content: [{
	        content: ['none', isArbitraryValue]
	      }],
	      // Backgrounds
	      /**
	       * Background Attachment
	       * @see https://tailwindcss.com/docs/background-attachment
	       */
	      'bg-attachment': [{
	        bg: ['fixed', 'local', 'scroll']
	      }],
	      /**
	       * Background Clip
	       * @see https://tailwindcss.com/docs/background-clip
	       */
	      'bg-clip': [{
	        'bg-clip': ['border', 'padding', 'content', 'text']
	      }],
	      /**
	       * Background Opacity
	       * @deprecated since Tailwind CSS v3.0.0
	       * @see https://tailwindcss.com/docs/background-opacity
	       */
	      'bg-opacity': [{
	        'bg-opacity': [opacity]
	      }],
	      /**
	       * Background Origin
	       * @see https://tailwindcss.com/docs/background-origin
	       */
	      'bg-origin': [{
	        'bg-origin': ['border', 'padding', 'content']
	      }],
	      /**
	       * Background Position
	       * @see https://tailwindcss.com/docs/background-position
	       */
	      'bg-position': [{
	        bg: [].concat(getPositions(), [isArbitraryPosition])
	      }],
	      /**
	       * Background Repeat
	       * @see https://tailwindcss.com/docs/background-repeat
	       */
	      'bg-repeat': [{
	        bg: ['no-repeat', {
	          repeat: ['', 'x', 'y', 'round', 'space']
	        }]
	      }],
	      /**
	       * Background Size
	       * @see https://tailwindcss.com/docs/background-size
	       */
	      'bg-size': [{
	        bg: ['auto', 'cover', 'contain', isArbitrarySize]
	      }],
	      /**
	       * Background Image
	       * @see https://tailwindcss.com/docs/background-image
	       */
	      'bg-image': [{
	        bg: ['none', {
	          'gradient-to': ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl']
	        }, isArbitraryUrl]
	      }],
	      /**
	       * Background Color
	       * @see https://tailwindcss.com/docs/background-color
	       */
	      'bg-color': [{
	        bg: [colors]
	      }],
	      /**
	       * Gradient Color Stops From Position
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-from-pos': [{
	        from: [gradientColorStopPositions]
	      }],
	      /**
	       * Gradient Color Stops Via Position
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-via-pos': [{
	        via: [gradientColorStopPositions]
	      }],
	      /**
	       * Gradient Color Stops To Position
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-to-pos': [{
	        to: [gradientColorStopPositions]
	      }],
	      /**
	       * Gradient Color Stops From
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-from': [{
	        from: [gradientColorStops]
	      }],
	      /**
	       * Gradient Color Stops Via
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-via': [{
	        via: [gradientColorStops]
	      }],
	      /**
	       * Gradient Color Stops To
	       * @see https://tailwindcss.com/docs/gradient-color-stops
	       */
	      'gradient-to': [{
	        to: [gradientColorStops]
	      }],
	      // Borders
	      /**
	       * Border Radius
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      rounded: [{
	        rounded: [borderRadius]
	      }],
	      /**
	       * Border Radius Start
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-s': [{
	        'rounded-s': [borderRadius]
	      }],
	      /**
	       * Border Radius End
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-e': [{
	        'rounded-e': [borderRadius]
	      }],
	      /**
	       * Border Radius Top
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-t': [{
	        'rounded-t': [borderRadius]
	      }],
	      /**
	       * Border Radius Right
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-r': [{
	        'rounded-r': [borderRadius]
	      }],
	      /**
	       * Border Radius Bottom
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-b': [{
	        'rounded-b': [borderRadius]
	      }],
	      /**
	       * Border Radius Left
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-l': [{
	        'rounded-l': [borderRadius]
	      }],
	      /**
	       * Border Radius Start Start
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-ss': [{
	        'rounded-ss': [borderRadius]
	      }],
	      /**
	       * Border Radius Start End
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-se': [{
	        'rounded-se': [borderRadius]
	      }],
	      /**
	       * Border Radius End End
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-ee': [{
	        'rounded-ee': [borderRadius]
	      }],
	      /**
	       * Border Radius End Start
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-es': [{
	        'rounded-es': [borderRadius]
	      }],
	      /**
	       * Border Radius Top Left
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-tl': [{
	        'rounded-tl': [borderRadius]
	      }],
	      /**
	       * Border Radius Top Right
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-tr': [{
	        'rounded-tr': [borderRadius]
	      }],
	      /**
	       * Border Radius Bottom Right
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-br': [{
	        'rounded-br': [borderRadius]
	      }],
	      /**
	       * Border Radius Bottom Left
	       * @see https://tailwindcss.com/docs/border-radius
	       */
	      'rounded-bl': [{
	        'rounded-bl': [borderRadius]
	      }],
	      /**
	       * Border Width
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w': [{
	        border: [borderWidth]
	      }],
	      /**
	       * Border Width X
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-x': [{
	        'border-x': [borderWidth]
	      }],
	      /**
	       * Border Width Y
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-y': [{
	        'border-y': [borderWidth]
	      }],
	      /**
	       * Border Width Start
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-s': [{
	        'border-s': [borderWidth]
	      }],
	      /**
	       * Border Width End
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-e': [{
	        'border-e': [borderWidth]
	      }],
	      /**
	       * Border Width Top
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-t': [{
	        'border-t': [borderWidth]
	      }],
	      /**
	       * Border Width Right
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-r': [{
	        'border-r': [borderWidth]
	      }],
	      /**
	       * Border Width Bottom
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-b': [{
	        'border-b': [borderWidth]
	      }],
	      /**
	       * Border Width Left
	       * @see https://tailwindcss.com/docs/border-width
	       */
	      'border-w-l': [{
	        'border-l': [borderWidth]
	      }],
	      /**
	       * Border Opacity
	       * @see https://tailwindcss.com/docs/border-opacity
	       */
	      'border-opacity': [{
	        'border-opacity': [opacity]
	      }],
	      /**
	       * Border Style
	       * @see https://tailwindcss.com/docs/border-style
	       */
	      'border-style': [{
	        border: [].concat(getLineStyles(), ['hidden'])
	      }],
	      /**
	       * Divide Width X
	       * @see https://tailwindcss.com/docs/divide-width
	       */
	      'divide-x': [{
	        'divide-x': [borderWidth]
	      }],
	      /**
	       * Divide Width X Reverse
	       * @see https://tailwindcss.com/docs/divide-width
	       */
	      'divide-x-reverse': ['divide-x-reverse'],
	      /**
	       * Divide Width Y
	       * @see https://tailwindcss.com/docs/divide-width
	       */
	      'divide-y': [{
	        'divide-y': [borderWidth]
	      }],
	      /**
	       * Divide Width Y Reverse
	       * @see https://tailwindcss.com/docs/divide-width
	       */
	      'divide-y-reverse': ['divide-y-reverse'],
	      /**
	       * Divide Opacity
	       * @see https://tailwindcss.com/docs/divide-opacity
	       */
	      'divide-opacity': [{
	        'divide-opacity': [opacity]
	      }],
	      /**
	       * Divide Style
	       * @see https://tailwindcss.com/docs/divide-style
	       */
	      'divide-style': [{
	        divide: getLineStyles()
	      }],
	      /**
	       * Border Color
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color': [{
	        border: [borderColor]
	      }],
	      /**
	       * Border Color X
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-x': [{
	        'border-x': [borderColor]
	      }],
	      /**
	       * Border Color Y
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-y': [{
	        'border-y': [borderColor]
	      }],
	      /**
	       * Border Color Top
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-t': [{
	        'border-t': [borderColor]
	      }],
	      /**
	       * Border Color Right
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-r': [{
	        'border-r': [borderColor]
	      }],
	      /**
	       * Border Color Bottom
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-b': [{
	        'border-b': [borderColor]
	      }],
	      /**
	       * Border Color Left
	       * @see https://tailwindcss.com/docs/border-color
	       */
	      'border-color-l': [{
	        'border-l': [borderColor]
	      }],
	      /**
	       * Divide Color
	       * @see https://tailwindcss.com/docs/divide-color
	       */
	      'divide-color': [{
	        divide: [borderColor]
	      }],
	      /**
	       * Outline Style
	       * @see https://tailwindcss.com/docs/outline-style
	       */
	      'outline-style': [{
	        outline: [''].concat(getLineStyles())
	      }],
	      /**
	       * Outline Offset
	       * @see https://tailwindcss.com/docs/outline-offset
	       */
	      'outline-offset': [{
	        'outline-offset': [isArbitraryValue, isLength]
	      }],
	      /**
	       * Outline Width
	       * @see https://tailwindcss.com/docs/outline-width
	       */
	      'outline-w': [{
	        outline: [isLength]
	      }],
	      /**
	       * Outline Color
	       * @see https://tailwindcss.com/docs/outline-color
	       */
	      'outline-color': [{
	        outline: [colors]
	      }],
	      /**
	       * Ring Width
	       * @see https://tailwindcss.com/docs/ring-width
	       */
	      'ring-w': [{
	        ring: getLengthWithEmpty()
	      }],
	      /**
	       * Ring Width Inset
	       * @see https://tailwindcss.com/docs/ring-width
	       */
	      'ring-w-inset': ['ring-inset'],
	      /**
	       * Ring Color
	       * @see https://tailwindcss.com/docs/ring-color
	       */
	      'ring-color': [{
	        ring: [colors]
	      }],
	      /**
	       * Ring Opacity
	       * @see https://tailwindcss.com/docs/ring-opacity
	       */
	      'ring-opacity': [{
	        'ring-opacity': [opacity]
	      }],
	      /**
	       * Ring Offset Width
	       * @see https://tailwindcss.com/docs/ring-offset-width
	       */
	      'ring-offset-w': [{
	        'ring-offset': [isLength]
	      }],
	      /**
	       * Ring Offset Color
	       * @see https://tailwindcss.com/docs/ring-offset-color
	       */
	      'ring-offset-color': [{
	        'ring-offset': [colors]
	      }],
	      // Effects
	      /**
	       * Box Shadow
	       * @see https://tailwindcss.com/docs/box-shadow
	       */
	      shadow: [{
	        shadow: ['', 'inner', 'none', isTshirtSize, isArbitraryShadow]
	      }],
	      /**
	       * Box Shadow Color
	       * @see https://tailwindcss.com/docs/box-shadow-color
	       */
	      'shadow-color': [{
	        shadow: [isAny]
	      }],
	      /**
	       * Opacity
	       * @see https://tailwindcss.com/docs/opacity
	       */
	      opacity: [{
	        opacity: [opacity]
	      }],
	      /**
	       * Mix Blend Mode
	       * @see https://tailwindcss.com/docs/mix-blend-mode
	       */
	      'mix-blend': [{
	        'mix-blend': getBlendModes()
	      }],
	      /**
	       * Background Blend Mode
	       * @see https://tailwindcss.com/docs/background-blend-mode
	       */
	      'bg-blend': [{
	        'bg-blend': getBlendModes()
	      }],
	      // Filters
	      /**
	       * Filter
	       * @deprecated since Tailwind CSS v3.0.0
	       * @see https://tailwindcss.com/docs/filter
	       */
	      filter: [{
	        filter: ['', 'none']
	      }],
	      /**
	       * Blur
	       * @see https://tailwindcss.com/docs/blur
	       */
	      blur: [{
	        blur: [blur]
	      }],
	      /**
	       * Brightness
	       * @see https://tailwindcss.com/docs/brightness
	       */
	      brightness: [{
	        brightness: [brightness]
	      }],
	      /**
	       * Contrast
	       * @see https://tailwindcss.com/docs/contrast
	       */
	      contrast: [{
	        contrast: [contrast]
	      }],
	      /**
	       * Drop Shadow
	       * @see https://tailwindcss.com/docs/drop-shadow
	       */
	      'drop-shadow': [{
	        'drop-shadow': ['', 'none', isTshirtSize, isArbitraryValue]
	      }],
	      /**
	       * Grayscale
	       * @see https://tailwindcss.com/docs/grayscale
	       */
	      grayscale: [{
	        grayscale: [grayscale]
	      }],
	      /**
	       * Hue Rotate
	       * @see https://tailwindcss.com/docs/hue-rotate
	       */
	      'hue-rotate': [{
	        'hue-rotate': [hueRotate]
	      }],
	      /**
	       * Invert
	       * @see https://tailwindcss.com/docs/invert
	       */
	      invert: [{
	        invert: [invert]
	      }],
	      /**
	       * Saturate
	       * @see https://tailwindcss.com/docs/saturate
	       */
	      saturate: [{
	        saturate: [saturate]
	      }],
	      /**
	       * Sepia
	       * @see https://tailwindcss.com/docs/sepia
	       */
	      sepia: [{
	        sepia: [sepia]
	      }],
	      /**
	       * Backdrop Filter
	       * @deprecated since Tailwind CSS v3.0.0
	       * @see https://tailwindcss.com/docs/backdrop-filter
	       */
	      'backdrop-filter': [{
	        'backdrop-filter': ['', 'none']
	      }],
	      /**
	       * Backdrop Blur
	       * @see https://tailwindcss.com/docs/backdrop-blur
	       */
	      'backdrop-blur': [{
	        'backdrop-blur': [blur]
	      }],
	      /**
	       * Backdrop Brightness
	       * @see https://tailwindcss.com/docs/backdrop-brightness
	       */
	      'backdrop-brightness': [{
	        'backdrop-brightness': [brightness]
	      }],
	      /**
	       * Backdrop Contrast
	       * @see https://tailwindcss.com/docs/backdrop-contrast
	       */
	      'backdrop-contrast': [{
	        'backdrop-contrast': [contrast]
	      }],
	      /**
	       * Backdrop Grayscale
	       * @see https://tailwindcss.com/docs/backdrop-grayscale
	       */
	      'backdrop-grayscale': [{
	        'backdrop-grayscale': [grayscale]
	      }],
	      /**
	       * Backdrop Hue Rotate
	       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
	       */
	      'backdrop-hue-rotate': [{
	        'backdrop-hue-rotate': [hueRotate]
	      }],
	      /**
	       * Backdrop Invert
	       * @see https://tailwindcss.com/docs/backdrop-invert
	       */
	      'backdrop-invert': [{
	        'backdrop-invert': [invert]
	      }],
	      /**
	       * Backdrop Opacity
	       * @see https://tailwindcss.com/docs/backdrop-opacity
	       */
	      'backdrop-opacity': [{
	        'backdrop-opacity': [opacity]
	      }],
	      /**
	       * Backdrop Saturate
	       * @see https://tailwindcss.com/docs/backdrop-saturate
	       */
	      'backdrop-saturate': [{
	        'backdrop-saturate': [saturate]
	      }],
	      /**
	       * Backdrop Sepia
	       * @see https://tailwindcss.com/docs/backdrop-sepia
	       */
	      'backdrop-sepia': [{
	        'backdrop-sepia': [sepia]
	      }],
	      // Tables
	      /**
	       * Border Collapse
	       * @see https://tailwindcss.com/docs/border-collapse
	       */
	      'border-collapse': [{
	        border: ['collapse', 'separate']
	      }],
	      /**
	       * Border Spacing
	       * @see https://tailwindcss.com/docs/border-spacing
	       */
	      'border-spacing': [{
	        'border-spacing': [borderSpacing]
	      }],
	      /**
	       * Border Spacing X
	       * @see https://tailwindcss.com/docs/border-spacing
	       */
	      'border-spacing-x': [{
	        'border-spacing-x': [borderSpacing]
	      }],
	      /**
	       * Border Spacing Y
	       * @see https://tailwindcss.com/docs/border-spacing
	       */
	      'border-spacing-y': [{
	        'border-spacing-y': [borderSpacing]
	      }],
	      /**
	       * Table Layout
	       * @see https://tailwindcss.com/docs/table-layout
	       */
	      'table-layout': [{
	        table: ['auto', 'fixed']
	      }],
	      /**
	       * Caption Side
	       * @see https://tailwindcss.com/docs/caption-side
	       */
	      caption: [{
	        caption: ['top', 'bottom']
	      }],
	      // Transitions and Animation
	      /**
	       * Tranisition Property
	       * @see https://tailwindcss.com/docs/transition-property
	       */
	      transition: [{
	        transition: ['none', 'all', '', 'colors', 'opacity', 'shadow', 'transform', isArbitraryValue]
	      }],
	      /**
	       * Transition Duration
	       * @see https://tailwindcss.com/docs/transition-duration
	       */
	      duration: [{
	        duration: getNumberAndArbitrary()
	      }],
	      /**
	       * Transition Timing Function
	       * @see https://tailwindcss.com/docs/transition-timing-function
	       */
	      ease: [{
	        ease: ['linear', 'in', 'out', 'in-out', isArbitraryValue]
	      }],
	      /**
	       * Transition Delay
	       * @see https://tailwindcss.com/docs/transition-delay
	       */
	      delay: [{
	        delay: getNumberAndArbitrary()
	      }],
	      /**
	       * Animation
	       * @see https://tailwindcss.com/docs/animation
	       */
	      animate: [{
	        animate: ['none', 'spin', 'ping', 'pulse', 'bounce', isArbitraryValue]
	      }],
	      // Transforms
	      /**
	       * Transform
	       * @see https://tailwindcss.com/docs/transform
	       */
	      transform: [{
	        transform: ['', 'gpu', 'none']
	      }],
	      /**
	       * Scale
	       * @see https://tailwindcss.com/docs/scale
	       */
	      scale: [{
	        scale: [scale]
	      }],
	      /**
	       * Scale X
	       * @see https://tailwindcss.com/docs/scale
	       */
	      'scale-x': [{
	        'scale-x': [scale]
	      }],
	      /**
	       * Scale Y
	       * @see https://tailwindcss.com/docs/scale
	       */
	      'scale-y': [{
	        'scale-y': [scale]
	      }],
	      /**
	       * Rotate
	       * @see https://tailwindcss.com/docs/rotate
	       */
	      rotate: [{
	        rotate: [isInteger, isArbitraryValue]
	      }],
	      /**
	       * Translate X
	       * @see https://tailwindcss.com/docs/translate
	       */
	      'translate-x': [{
	        'translate-x': [translate]
	      }],
	      /**
	       * Translate Y
	       * @see https://tailwindcss.com/docs/translate
	       */
	      'translate-y': [{
	        'translate-y': [translate]
	      }],
	      /**
	       * Skew X
	       * @see https://tailwindcss.com/docs/skew
	       */
	      'skew-x': [{
	        'skew-x': [skew]
	      }],
	      /**
	       * Skew Y
	       * @see https://tailwindcss.com/docs/skew
	       */
	      'skew-y': [{
	        'skew-y': [skew]
	      }],
	      /**
	       * Transform Origin
	       * @see https://tailwindcss.com/docs/transform-origin
	       */
	      'transform-origin': [{
	        origin: ['center', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left', isArbitraryValue]
	      }],
	      // Interactivity
	      /**
	       * Accent Color
	       * @see https://tailwindcss.com/docs/accent-color
	       */
	      accent: [{
	        accent: ['auto', colors]
	      }],
	      /**
	       * Appearance
	       * @see https://tailwindcss.com/docs/appearance
	       */
	      appearance: ['appearance-none'],
	      /**
	       * Cursor
	       * @see https://tailwindcss.com/docs/cursor
	       */
	      cursor: [{
	        cursor: ['auto', 'default', 'pointer', 'wait', 'text', 'move', 'help', 'not-allowed', 'none', 'context-menu', 'progress', 'cell', 'crosshair', 'vertical-text', 'alias', 'copy', 'no-drop', 'grab', 'grabbing', 'all-scroll', 'col-resize', 'row-resize', 'n-resize', 'e-resize', 's-resize', 'w-resize', 'ne-resize', 'nw-resize', 'se-resize', 'sw-resize', 'ew-resize', 'ns-resize', 'nesw-resize', 'nwse-resize', 'zoom-in', 'zoom-out', isArbitraryValue]
	      }],
	      /**
	       * Caret Color
	       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
	       */
	      'caret-color': [{
	        caret: [colors]
	      }],
	      /**
	       * Pointer Events
	       * @see https://tailwindcss.com/docs/pointer-events
	       */
	      'pointer-events': [{
	        'pointer-events': ['none', 'auto']
	      }],
	      /**
	       * Resize
	       * @see https://tailwindcss.com/docs/resize
	       */
	      resize: [{
	        resize: ['none', 'y', 'x', '']
	      }],
	      /**
	       * Scroll Behavior
	       * @see https://tailwindcss.com/docs/scroll-behavior
	       */
	      'scroll-behavior': [{
	        scroll: ['auto', 'smooth']
	      }],
	      /**
	       * Scroll Margin
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-m': [{
	        'scroll-m': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin X
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-mx': [{
	        'scroll-mx': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Y
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-my': [{
	        'scroll-my': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Start
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-ms': [{
	        'scroll-ms': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin End
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-me': [{
	        'scroll-me': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Top
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-mt': [{
	        'scroll-mt': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Right
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-mr': [{
	        'scroll-mr': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Bottom
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-mb': [{
	        'scroll-mb': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Margin Left
	       * @see https://tailwindcss.com/docs/scroll-margin
	       */
	      'scroll-ml': [{
	        'scroll-ml': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-p': [{
	        'scroll-p': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding X
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-px': [{
	        'scroll-px': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Y
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-py': [{
	        'scroll-py': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Start
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-ps': [{
	        'scroll-ps': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding End
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-pe': [{
	        'scroll-pe': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Top
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-pt': [{
	        'scroll-pt': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Right
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-pr': [{
	        'scroll-pr': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Bottom
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-pb': [{
	        'scroll-pb': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Padding Left
	       * @see https://tailwindcss.com/docs/scroll-padding
	       */
	      'scroll-pl': [{
	        'scroll-pl': getSpacingWithArbitrary()
	      }],
	      /**
	       * Scroll Snap Align
	       * @see https://tailwindcss.com/docs/scroll-snap-align
	       */
	      'snap-align': [{
	        snap: ['start', 'end', 'center', 'align-none']
	      }],
	      /**
	       * Scroll Snap Stop
	       * @see https://tailwindcss.com/docs/scroll-snap-stop
	       */
	      'snap-stop': [{
	        snap: ['normal', 'always']
	      }],
	      /**
	       * Scroll Snap Type
	       * @see https://tailwindcss.com/docs/scroll-snap-type
	       */
	      'snap-type': [{
	        snap: ['none', 'x', 'y', 'both']
	      }],
	      /**
	       * Scroll Snap Type Strictness
	       * @see https://tailwindcss.com/docs/scroll-snap-type
	       */
	      'snap-strictness': [{
	        snap: ['mandatory', 'proximity']
	      }],
	      /**
	       * Touch Action
	       * @see https://tailwindcss.com/docs/touch-action
	       */
	      touch: [{
	        touch: ['auto', 'none', 'pinch-zoom', 'manipulation', {
	          pan: ['x', 'left', 'right', 'y', 'up', 'down']
	        }]
	      }],
	      /**
	       * User Select
	       * @see https://tailwindcss.com/docs/user-select
	       */
	      select: [{
	        select: ['none', 'text', 'all', 'auto']
	      }],
	      /**
	       * Will Change
	       * @see https://tailwindcss.com/docs/will-change
	       */
	      'will-change': [{
	        'will-change': ['auto', 'scroll', 'contents', 'transform', isArbitraryValue]
	      }],
	      // SVG
	      /**
	       * Fill
	       * @see https://tailwindcss.com/docs/fill
	       */
	      fill: [{
	        fill: [colors, 'none']
	      }],
	      /**
	       * Stroke Width
	       * @see https://tailwindcss.com/docs/stroke-width
	       */
	      'stroke-w': [{
	        stroke: [isLength, isArbitraryNumber]
	      }],
	      /**
	       * Stroke
	       * @see https://tailwindcss.com/docs/stroke
	       */
	      stroke: [{
	        stroke: [colors, 'none']
	      }],
	      // Accessibility
	      /**
	       * Screen Readers
	       * @see https://tailwindcss.com/docs/screen-readers
	       */
	      sr: ['sr-only', 'not-sr-only']
	    },
	    conflictingClassGroups: {
	      overflow: ['overflow-x', 'overflow-y'],
	      overscroll: ['overscroll-x', 'overscroll-y'],
	      inset: ['inset-x', 'inset-y', 'start', 'end', 'top', 'right', 'bottom', 'left'],
	      'inset-x': ['right', 'left'],
	      'inset-y': ['top', 'bottom'],
	      flex: ['basis', 'grow', 'shrink'],
	      gap: ['gap-x', 'gap-y'],
	      p: ['px', 'py', 'ps', 'pe', 'pt', 'pr', 'pb', 'pl'],
	      px: ['pr', 'pl'],
	      py: ['pt', 'pb'],
	      m: ['mx', 'my', 'ms', 'me', 'mt', 'mr', 'mb', 'ml'],
	      mx: ['mr', 'ml'],
	      my: ['mt', 'mb'],
	      'font-size': ['leading'],
	      'fvn-normal': ['fvn-ordinal', 'fvn-slashed-zero', 'fvn-figure', 'fvn-spacing', 'fvn-fraction'],
	      'fvn-ordinal': ['fvn-normal'],
	      'fvn-slashed-zero': ['fvn-normal'],
	      'fvn-figure': ['fvn-normal'],
	      'fvn-spacing': ['fvn-normal'],
	      'fvn-fraction': ['fvn-normal'],
	      rounded: ['rounded-s', 'rounded-e', 'rounded-t', 'rounded-r', 'rounded-b', 'rounded-l', 'rounded-ss', 'rounded-se', 'rounded-ee', 'rounded-es', 'rounded-tl', 'rounded-tr', 'rounded-br', 'rounded-bl'],
	      'rounded-s': ['rounded-ss', 'rounded-es'],
	      'rounded-e': ['rounded-se', 'rounded-ee'],
	      'rounded-t': ['rounded-tl', 'rounded-tr'],
	      'rounded-r': ['rounded-tr', 'rounded-br'],
	      'rounded-b': ['rounded-br', 'rounded-bl'],
	      'rounded-l': ['rounded-tl', 'rounded-bl'],
	      'border-spacing': ['border-spacing-x', 'border-spacing-y'],
	      'border-w': ['border-w-s', 'border-w-e', 'border-w-t', 'border-w-r', 'border-w-b', 'border-w-l'],
	      'border-w-x': ['border-w-r', 'border-w-l'],
	      'border-w-y': ['border-w-t', 'border-w-b'],
	      'border-color': ['border-color-t', 'border-color-r', 'border-color-b', 'border-color-l'],
	      'border-color-x': ['border-color-r', 'border-color-l'],
	      'border-color-y': ['border-color-t', 'border-color-b'],
	      'scroll-m': ['scroll-mx', 'scroll-my', 'scroll-ms', 'scroll-me', 'scroll-mt', 'scroll-mr', 'scroll-mb', 'scroll-ml'],
	      'scroll-mx': ['scroll-mr', 'scroll-ml'],
	      'scroll-my': ['scroll-mt', 'scroll-mb'],
	      'scroll-p': ['scroll-px', 'scroll-py', 'scroll-ps', 'scroll-pe', 'scroll-pt', 'scroll-pr', 'scroll-pb', 'scroll-pl'],
	      'scroll-px': ['scroll-pr', 'scroll-pl'],
	      'scroll-py': ['scroll-pt', 'scroll-pb']
	    },
	    conflictingClassGroupModifiers: {
	      'font-size': ['leading']
	    }
	  };
	}

	var twMerge = /*#__PURE__*/createTailwindMerge(getDefaultConfig);

	/* node_modules\flowbite-svelte\dist\utils\Frame.svelte generated by Svelte v4.2.1 */
	const file$6 = "node_modules\\flowbite-svelte\\dist\\utils\\Frame.svelte";

	// (88:0) <svelte:element this={tag} use:use={options} bind:this={node} transition:transition={params} {...$$restProps} class={divClass} on:click on:mouseenter on:mouseleave on:focusin on:focusout {role}>
	function create_dynamic_element(ctx) {
		let svelte_element;
		let use_action;
		let svelte_element_transition;
		let current;
		let mounted;
		let dispose;
		const default_slot_template = /*#slots*/ ctx[14].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

		let svelte_element_levels = [
			/*$$restProps*/ ctx[8],
			{ class: /*divClass*/ ctx[7] },
			{ role: /*role*/ ctx[6] }
		];

		let svelte_element_data = {};

		for (let i = 0; i < svelte_element_levels.length; i += 1) {
			svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
		}

		const block = {
			c: function create() {
				svelte_element = element$1(/*tag*/ ctx[1]);
				if (default_slot) default_slot.c();
				set_dynamic_element_data(/*tag*/ ctx[1])(svelte_element, svelte_element_data);
				add_location(svelte_element, file$6, 87, 0, 4136);
			},
			m: function mount(target, anchor) {
				insert_dev(target, svelte_element, anchor);

				if (default_slot) {
					default_slot.m(svelte_element, null);
				}

				/*svelte_element_binding*/ ctx[20](svelte_element);
				current = true;

				if (!mounted) {
					dispose = [
						action_destroyer(use_action = /*use*/ ctx[4].call(null, svelte_element, /*options*/ ctx[5])),
						listen_dev(svelte_element, "click", /*click_handler*/ ctx[15], false, false, false, false),
						listen_dev(svelte_element, "mouseenter", /*mouseenter_handler*/ ctx[16], false, false, false, false),
						listen_dev(svelte_element, "mouseleave", /*mouseleave_handler*/ ctx[17], false, false, false, false),
						listen_dev(svelte_element, "focusin", /*focusin_handler*/ ctx[18], false, false, false, false),
						listen_dev(svelte_element, "focusout", /*focusout_handler*/ ctx[19], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[13],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
							null
						);
					}
				}

				set_dynamic_element_data(/*tag*/ ctx[1])(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
					dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
					(!current || dirty & /*divClass*/ 128) && { class: /*divClass*/ ctx[7] },
					(!current || dirty & /*role*/ 64) && { role: /*role*/ ctx[6] }
				]));

				if (use_action && is_function(use_action.update) && dirty & /*options*/ 32) use_action.update.call(null, /*options*/ ctx[5]);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (!svelte_element_transition) svelte_element_transition = create_bidirectional_transition(svelte_element, /*transition*/ ctx[2], /*params*/ ctx[3], true);
						svelte_element_transition.run(1);
					});
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);

				if (local) {
					if (!svelte_element_transition) svelte_element_transition = create_bidirectional_transition(svelte_element, /*transition*/ ctx[2], /*params*/ ctx[3], false);
					svelte_element_transition.run(0);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svelte_element);
				}

				if (default_slot) default_slot.d(detaching);
				/*svelte_element_binding*/ ctx[20](null);
				if (detaching && svelte_element_transition) svelte_element_transition.end();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_dynamic_element.name,
			type: "child_dynamic_element",
			source: "(88:0) <svelte:element this={tag} use:use={options} bind:this={node} transition:transition={params} {...$$restProps} class={divClass} on:click on:mouseenter on:mouseleave on:focusin on:focusout {role}>",
			ctx
		});

		return block;
	}

	function create_fragment$6(ctx) {
		let previous_tag = /*tag*/ ctx[1];
		let svelte_element_anchor;
		let tag_will_be_removed = false;
		let current;
		validate_dynamic_element(/*tag*/ ctx[1]);
		validate_void_dynamic_element(/*tag*/ ctx[1]);
		let svelte_element = /*tag*/ ctx[1] && create_dynamic_element(ctx);

		const block = {
			c: function create() {
				if (svelte_element) svelte_element.c();
				svelte_element_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (svelte_element) svelte_element.m(target, anchor);
				insert_dev(target, svelte_element_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (/*tag*/ ctx[1]) {
					if (!previous_tag) {
						svelte_element = create_dynamic_element(ctx);
						previous_tag = /*tag*/ ctx[1];
						svelte_element.c();
						transition_in(svelte_element);
						svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
					} else if (safe_not_equal(previous_tag, /*tag*/ ctx[1])) {
						svelte_element.d(1);
						validate_dynamic_element(/*tag*/ ctx[1]);
						validate_void_dynamic_element(/*tag*/ ctx[1]);
						svelte_element = create_dynamic_element(ctx);
						previous_tag = /*tag*/ ctx[1];
						svelte_element.c();

						if (tag_will_be_removed) {
							tag_will_be_removed = false;
							transition_in(svelte_element);
						}

						svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
					} else {
						if (tag_will_be_removed) {
							tag_will_be_removed = false;
							transition_in(svelte_element);
						}

						svelte_element.p(ctx, dirty);
					}
				} else if (previous_tag) {
					tag_will_be_removed = true;
					group_outros();

					transition_out(svelte_element, 1, 1, () => {
						svelte_element = null;
						previous_tag = /*tag*/ ctx[1];
						tag_will_be_removed = false;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(svelte_element, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(svelte_element, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svelte_element_anchor);
				}

				if (svelte_element) svelte_element.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$6.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$6($$self, $$props, $$invalidate) {
		const omit_props_names = [
			"tag","color","rounded","border","shadow","transition","params","node","use","options","role"
		];

		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Frame', slots, ['default']);
		const null_transition = () => ({ duration: 0 });

		const noop = () => {
			
		};

		setContext('background', true);
		let { tag = $$restProps.href ? 'a' : 'div' } = $$props;
		let { color = 'default' } = $$props;
		let { rounded = false } = $$props;
		let { border = false } = $$props;
		let { shadow = false } = $$props;
		let { transition = null_transition } = $$props;
		let { params = {} } = $$props;
		let { node = undefined } = $$props;
		let { use = noop } = $$props;
		let { options = {} } = $$props;
		let { role = undefined } = $$props;

		// your script goes here
		const bgColors = {
			gray: 'bg-gray-50 dark:bg-gray-800',
			red: 'bg-red-50 dark:bg-gray-800',
			yellow: 'bg-yellow-50 dark:bg-gray-800 ',
			green: 'bg-green-50 dark:bg-gray-800 ',
			indigo: 'bg-indigo-50 dark:bg-gray-800 ',
			purple: 'bg-purple-50 dark:bg-gray-800 ',
			pink: 'bg-pink-50 dark:bg-gray-800 ',
			blue: 'bg-blue-50 dark:bg-gray-800 ',
			light: 'bg-gray-50 dark:bg-gray-700',
			dark: 'bg-gray-50 dark:bg-gray-800',
			default: 'bg-white dark:bg-gray-800',
			dropdown: 'bg-white dark:bg-gray-700',
			navbar: 'bg-white dark:bg-gray-900',
			navbarUl: 'bg-gray-50 dark:bg-gray-800',
			form: 'bg-gray-50 dark:bg-gray-700',
			primary: 'bg-primary-50 dark:bg-gray-800 ',
			orange: 'bg-orange-50 dark:bg-orange-800',
			none: ''
		};

		const textColors = {
			gray: 'text-gray-800 dark:text-gray-300',
			red: 'text-red-800 dark:text-red-400',
			yellow: 'text-yellow-800 dark:text-yellow-300',
			green: 'text-green-800 dark:text-green-400',
			indigo: 'text-indigo-800 dark:text-indigo-400',
			purple: 'text-purple-800 dark:text-purple-400',
			pink: 'text-pink-800 dark:text-pink-400',
			blue: 'text-blue-800 dark:text-blue-400',
			light: 'text-gray-700 dark:text-gray-300',
			dark: 'text-gray-700 dark:text-gray-300',
			default: 'text-gray-500 dark:text-gray-400',
			dropdown: 'text-gray-700 dark:text-gray-200',
			navbar: 'text-gray-700 dark:text-gray-200',
			navbarUl: 'text-gray-700 dark:text-gray-400',
			form: 'text-gray-900 dark:text-white',
			primary: 'text-primary-800 dark:text-primary-400',
			orange: 'text-orange-800 dark:text-orange-400',
			none: ''
		};

		const borderColors = {
			gray: 'border-gray-300 dark:border-gray-800 divide-gray-300 dark:divide-gray-800',
			red: 'border-red-300 dark:border-red-800 divide-red-300 dark:divide-red-800',
			yellow: 'border-yellow-300 dark:border-yellow-800 divide-yellow-300 dark:divide-yellow-800',
			green: 'border-green-300 dark:border-green-800 divide-green-300 dark:divide-green-800',
			indigo: 'border-indigo-300 dark:border-indigo-800 divide-indigo-300 dark:divide-indigo-800',
			purple: 'border-purple-300 dark:border-purple-800 divide-purple-300 dark:divide-purple-800',
			pink: 'border-pink-300 dark:border-pink-800 divide-pink-300 dark:divide-pink-800',
			blue: 'border-blue-300 dark:border-blue-800 divide-blue-300 dark:divide-blue-800',
			light: 'border-gray-500 divide-gray-500',
			dark: 'border-gray-500 divide-gray-500',
			default: 'border-gray-200 dark:border-gray-700 divide-gray-200 dark:divide-gray-700',
			dropdown: 'border-gray-100 dark:border-gray-600 divide-gray-100 dark:divide-gray-600',
			navbar: 'border-gray-100 dark:border-gray-700 divide-gray-100 dark:divide-gray-700',
			navbarUl: 'border-gray-100 dark:border-gray-700 divide-gray-100 dark:divide-gray-700',
			form: 'border-gray-300 dark:border-gray-700 divide-gray-300 dark:divide-gray-700',
			primary: 'border-primary-500 dark:border-primary-200  divide-primary-500 dark:divide-primary-200 ',
			orange: 'border-orange-300 dark:border-orange-800 divide-orange-300 dark:divide-orange-800',
			none: ''
		};

		let divClass;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function mouseenter_handler(event) {
			bubble.call(this, $$self, event);
		}

		function mouseleave_handler(event) {
			bubble.call(this, $$self, event);
		}

		function focusin_handler(event) {
			bubble.call(this, $$self, event);
		}

		function focusout_handler(event) {
			bubble.call(this, $$self, event);
		}

		function svelte_element_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				node = $$value;
				$$invalidate(0, node);
			});
		}

		$$self.$$set = $$new_props => {
			$$invalidate(26, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
			$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('tag' in $$new_props) $$invalidate(1, tag = $$new_props.tag);
			if ('color' in $$new_props) $$invalidate(9, color = $$new_props.color);
			if ('rounded' in $$new_props) $$invalidate(10, rounded = $$new_props.rounded);
			if ('border' in $$new_props) $$invalidate(11, border = $$new_props.border);
			if ('shadow' in $$new_props) $$invalidate(12, shadow = $$new_props.shadow);
			if ('transition' in $$new_props) $$invalidate(2, transition = $$new_props.transition);
			if ('params' in $$new_props) $$invalidate(3, params = $$new_props.params);
			if ('node' in $$new_props) $$invalidate(0, node = $$new_props.node);
			if ('use' in $$new_props) $$invalidate(4, use = $$new_props.use);
			if ('options' in $$new_props) $$invalidate(5, options = $$new_props.options);
			if ('role' in $$new_props) $$invalidate(6, role = $$new_props.role);
			if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			twMerge,
			setContext,
			null_transition,
			noop,
			tag,
			color,
			rounded,
			border,
			shadow,
			transition,
			params,
			node,
			use,
			options,
			role,
			bgColors,
			textColors,
			borderColors,
			divClass
		});

		$$self.$inject_state = $$new_props => {
			$$invalidate(26, $$props = assign(assign({}, $$props), $$new_props));
			if ('tag' in $$props) $$invalidate(1, tag = $$new_props.tag);
			if ('color' in $$props) $$invalidate(9, color = $$new_props.color);
			if ('rounded' in $$props) $$invalidate(10, rounded = $$new_props.rounded);
			if ('border' in $$props) $$invalidate(11, border = $$new_props.border);
			if ('shadow' in $$props) $$invalidate(12, shadow = $$new_props.shadow);
			if ('transition' in $$props) $$invalidate(2, transition = $$new_props.transition);
			if ('params' in $$props) $$invalidate(3, params = $$new_props.params);
			if ('node' in $$props) $$invalidate(0, node = $$new_props.node);
			if ('use' in $$props) $$invalidate(4, use = $$new_props.use);
			if ('options' in $$props) $$invalidate(5, options = $$new_props.options);
			if ('role' in $$props) $$invalidate(6, role = $$new_props.role);
			if ('divClass' in $$props) $$invalidate(7, divClass = $$new_props.divClass);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*color*/ 512) {
				$$invalidate(9, color = color ?? 'default'); // for cases when undefined
			}

			if ($$self.$$.dirty & /*color*/ 512) {
				setContext('color', color);
			}

			$$invalidate(7, divClass = twMerge(bgColors[color], textColors[color], rounded && 'rounded-lg', border && 'border', borderColors[color], shadow && 'shadow-md', $$props.class));
		};

		$$props = exclude_internal_props($$props);

		return [
			node,
			tag,
			transition,
			params,
			use,
			options,
			role,
			divClass,
			$$restProps,
			color,
			rounded,
			border,
			shadow,
			$$scope,
			slots,
			click_handler,
			mouseenter_handler,
			mouseleave_handler,
			focusin_handler,
			focusout_handler,
			svelte_element_binding
		];
	}

	class Frame extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$6, create_fragment$6, safe_not_equal, {
				tag: 1,
				color: 9,
				rounded: 10,
				border: 11,
				shadow: 12,
				transition: 2,
				params: 3,
				node: 0,
				use: 4,
				options: 5,
				role: 6
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Frame",
				options,
				id: create_fragment$6.name
			});
		}

		get tag() {
			throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set tag(value) {
			throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get color() {
			throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get rounded() {
			throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set rounded(value) {
			throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get border() {
			throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set border(value) {
			throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get shadow() {
			throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set shadow(value) {
			throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get transition() {
			throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set transition(value) {
			throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get params() {
			throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set params(value) {
			throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get node() {
			throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set node(value) {
			throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get use() {
			throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set use(value) {
			throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get options() {
			throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set options(value) {
			throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get role() {
			throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set role(value) {
			throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* node_modules\flowbite-svelte\dist\cards\Card.svelte generated by Svelte v4.2.1 */
	const file$5 = "node_modules\\flowbite-svelte\\dist\\cards\\Card.svelte";

	// (37:2) {:else}
	function create_else_block(ctx) {
		let current;
		const default_slot_template = /*#slots*/ ctx[10].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

		const block = {
			c: function create() {
				if (default_slot) default_slot.c();
			},
			m: function mount(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[16],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
							null
						);
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block.name,
			type: "else",
			source: "(37:2) {:else}",
			ctx
		});

		return block;
	}

	// (32:2) {#if img}
	function create_if_block$1(ctx) {
		let img_1;
		let img_1_src_value;
		let t;
		let div;
		let current;
		const default_slot_template = /*#slots*/ ctx[10].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

		const block = {
			c: function create() {
				img_1 = element$1("img");
				t = space();
				div = element$1("div");
				if (default_slot) default_slot.c();
				attr_dev(img_1, "class", /*imgClass*/ ctx[4]);
				if (!src_url_equal(img_1.src, img_1_src_value = /*img*/ ctx[1])) attr_dev(img_1, "src", img_1_src_value);
				attr_dev(img_1, "alt", "");
				add_location(img_1, file$5, 32, 4, 1260);
				attr_dev(div, "class", /*innerPadding*/ ctx[2]);
				add_location(div, file$5, 33, 4, 1306);
			},
			m: function mount(target, anchor) {
				insert_dev(target, img_1, anchor);
				insert_dev(target, t, anchor);
				insert_dev(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (!current || dirty & /*imgClass*/ 16) {
					attr_dev(img_1, "class", /*imgClass*/ ctx[4]);
				}

				if (!current || dirty & /*img*/ 2 && !src_url_equal(img_1.src, img_1_src_value = /*img*/ ctx[1])) {
					attr_dev(img_1, "src", img_1_src_value);
				}

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[16],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*innerPadding*/ 4) {
					attr_dev(div, "class", /*innerPadding*/ ctx[2]);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(img_1);
					detach_dev(t);
					detach_dev(div);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$1.name,
			type: "if",
			source: "(32:2) {#if img}",
			ctx
		});

		return block;
	}

	// (31:0) <Frame tag={href ? 'a' : 'div'} rounded shadow border on:click on:focusin on:focusout on:mouseenter on:mouseleave {href} {...$$restProps} class={cardClass}>
	function create_default_slot$1(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$1, create_else_block];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*img*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot$1.name,
			type: "slot",
			source: "(31:0) <Frame tag={href ? 'a' : 'div'} rounded shadow border on:click on:focusin on:focusout on:mouseenter on:mouseleave {href} {...$$restProps} class={cardClass}>",
			ctx
		});

		return block;
	}

	function create_fragment$5(ctx) {
		let frame;
		let current;

		const frame_spread_levels = [
			{ tag: /*href*/ ctx[0] ? 'a' : 'div' },
			{ rounded: true },
			{ shadow: true },
			{ border: true },
			{ href: /*href*/ ctx[0] },
			/*$$restProps*/ ctx[5],
			{ class: /*cardClass*/ ctx[3] }
		];

		let frame_props = {
			$$slots: { default: [create_default_slot$1] },
			$$scope: { ctx }
		};

		for (let i = 0; i < frame_spread_levels.length; i += 1) {
			frame_props = assign(frame_props, frame_spread_levels[i]);
		}

		frame = new Frame({ props: frame_props, $$inline: true });
		frame.$on("click", /*click_handler*/ ctx[11]);
		frame.$on("focusin", /*focusin_handler*/ ctx[12]);
		frame.$on("focusout", /*focusout_handler*/ ctx[13]);
		frame.$on("mouseenter", /*mouseenter_handler*/ ctx[14]);
		frame.$on("mouseleave", /*mouseleave_handler*/ ctx[15]);

		const block = {
			c: function create() {
				create_component(frame.$$.fragment);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				mount_component(frame, target, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				const frame_changes = (dirty & /*href, $$restProps, cardClass*/ 41)
				? get_spread_update(frame_spread_levels, [
						dirty & /*href*/ 1 && { tag: /*href*/ ctx[0] ? 'a' : 'div' },
						frame_spread_levels[1],
						frame_spread_levels[2],
						frame_spread_levels[3],
						dirty & /*href*/ 1 && { href: /*href*/ ctx[0] },
						dirty & /*$$restProps*/ 32 && get_spread_object(/*$$restProps*/ ctx[5]),
						dirty & /*cardClass*/ 8 && { class: /*cardClass*/ ctx[3] }
					])
				: {};

				if (dirty & /*$$scope, innerPadding, imgClass, img*/ 65558) {
					frame_changes.$$scope = { dirty, ctx };
				}

				frame.$set(frame_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(frame.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(frame.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(frame, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$5.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$5($$self, $$props, $$invalidate) {
		let innerPadding;
		const omit_props_names = ["href","horizontal","reverse","img","padding","size"];
		let $$restProps = compute_rest_props($$props, omit_props_names);
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Card', slots, ['default']);
		let { href = undefined } = $$props;
		let { horizontal = false } = $$props;
		let { reverse = false } = $$props;
		let { img = undefined } = $$props;
		let { padding = 'lg' } = $$props;
		let { size = 'sm' } = $$props;

		const paddings = {
			none: 'p-0',
			sm: 'p-4 sm:p-6 md:p-8',
			md: 'p-4 sm:p-5',
			lg: 'p-4 sm:p-6',
			xl: 'p-4 sm:p-8'
		};

		const sizes = {
			xs: 'max-w-xs',
			sm: 'max-w-sm',
			md: 'max-w-lg',
			lg: 'max-w-2xl',
			xl: 'max-w-screen-xl'
		};

		let inneraPdding;
		let cardClass;
		let imgClass;

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function focusin_handler(event) {
			bubble.call(this, $$self, event);
		}

		function focusout_handler(event) {
			bubble.call(this, $$self, event);
		}

		function mouseenter_handler(event) {
			bubble.call(this, $$self, event);
		}

		function mouseleave_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$$set = $$new_props => {
			$$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
			$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
			if ('href' in $$new_props) $$invalidate(0, href = $$new_props.href);
			if ('horizontal' in $$new_props) $$invalidate(6, horizontal = $$new_props.horizontal);
			if ('reverse' in $$new_props) $$invalidate(7, reverse = $$new_props.reverse);
			if ('img' in $$new_props) $$invalidate(1, img = $$new_props.img);
			if ('padding' in $$new_props) $$invalidate(8, padding = $$new_props.padding);
			if ('size' in $$new_props) $$invalidate(9, size = $$new_props.size);
			if ('$$scope' in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
		};

		$$self.$capture_state = () => ({
			twMerge,
			Frame,
			href,
			horizontal,
			reverse,
			img,
			padding,
			size,
			paddings,
			sizes,
			inneraPdding,
			cardClass,
			imgClass,
			innerPadding
		});

		$$self.$inject_state = $$new_props => {
			$$invalidate(20, $$props = assign(assign({}, $$props), $$new_props));
			if ('href' in $$props) $$invalidate(0, href = $$new_props.href);
			if ('horizontal' in $$props) $$invalidate(6, horizontal = $$new_props.horizontal);
			if ('reverse' in $$props) $$invalidate(7, reverse = $$new_props.reverse);
			if ('img' in $$props) $$invalidate(1, img = $$new_props.img);
			if ('padding' in $$props) $$invalidate(8, padding = $$new_props.padding);
			if ('size' in $$props) $$invalidate(9, size = $$new_props.size);
			if ('inneraPdding' in $$props) inneraPdding = $$new_props.inneraPdding;
			if ('cardClass' in $$props) $$invalidate(3, cardClass = $$new_props.cardClass);
			if ('imgClass' in $$props) $$invalidate(4, imgClass = $$new_props.imgClass);
			if ('innerPadding' in $$props) $$invalidate(2, innerPadding = $$new_props.innerPadding);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*padding*/ 256) {
				$$invalidate(2, innerPadding = paddings[padding]);
			}

			$$invalidate(3, cardClass = twMerge(
				'flex',
				sizes[size],
				reverse ? 'flex-col-reverse' : 'flex-col',
				horizontal && (reverse
				? 'md:flex-row-reverse md:max-w-xl'
				: 'md:flex-row md:max-w-xl'),
				href && 'hover:bg-gray-100 dark:hover:bg-gray-700',
				!img && innerPadding,
				$$props.class
			));

			if ($$self.$$.dirty & /*reverse, horizontal*/ 192) {
				$$invalidate(4, imgClass = twMerge(reverse ? 'rounded-b-lg' : 'rounded-t-lg', horizontal && 'object-cover w-full h-96 md:h-auto md:w-48 md:rounded-none', horizontal && (reverse ? 'md:rounded-r-lg' : 'md:rounded-l-lg')));
			}
		};

		$$props = exclude_internal_props($$props);

		return [
			href,
			img,
			innerPadding,
			cardClass,
			imgClass,
			$$restProps,
			horizontal,
			reverse,
			padding,
			size,
			slots,
			click_handler,
			focusin_handler,
			focusout_handler,
			mouseenter_handler,
			mouseleave_handler,
			$$scope
		];
	}

	class Card extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$5, create_fragment$5, safe_not_equal, {
				href: 0,
				horizontal: 6,
				reverse: 7,
				img: 1,
				padding: 8,
				size: 9
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Card",
				options,
				id: create_fragment$5.name
			});
		}

		get href() {
			throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set href(value) {
			throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get horizontal() {
			throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set horizontal(value) {
			throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get reverse() {
			throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set reverse(value) {
			throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get img() {
			throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set img(value) {
			throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get padding() {
			throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set padding(value) {
			throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get size() {
			throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set size(value) {
			throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src\metric.svelte generated by Svelte v4.2.1 */

	const { console: console_1$3 } = globals;
	const file$4 = "src\\metric.svelte";

	// (59:2) {#if metrics !== null}
	function create_if_block(ctx) {
		let div0;
		let span0;
		let t1;
		let card0;
		let t2;
		let div1;
		let span1;
		let t4;
		let card1;
		let t5;
		let div2;
		let span2;
		let t7;
		let card2;
		let t8;
		let div3;
		let span3;
		let t10;
		let card3;
		let t11;
		let div4;
		let span4;
		let t13;
		let card4;
		let t14;
		let div5;
		let span5;
		let t16;
		let card5;
		let current;

		card0 = new Card({
				props: {
					$$slots: { default: [create_default_slot_5] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		card1 = new Card({
				props: {
					$$slots: { default: [create_default_slot_4] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		card2 = new Card({
				props: {
					style: "background-color:  rgb(84, 97, 243)",
					$$slots: { default: [create_default_slot_3] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		card3 = new Card({
				props: {
					$$slots: { default: [create_default_slot_2] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		card4 = new Card({
				props: {
					$$slots: { default: [create_default_slot_1] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		card5 = new Card({
				props: {
					$$slots: { default: [create_default_slot] },
					$$scope: { ctx }
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				div0 = element$1("div");
				span0 = element$1("span");
				span0.textContent = "Total Jobs";
				t1 = space();
				create_component(card0.$$.fragment);
				t2 = space();
				div1 = element$1("div");
				span1 = element$1("span");
				span1.textContent = "Total Placements";
				t4 = space();
				create_component(card1.$$.fragment);
				t5 = space();
				div2 = element$1("div");
				span2 = element$1("span");
				span2.textContent = "Total Fee/Commission";
				t7 = space();
				create_component(card2.$$.fragment);
				t8 = space();
				div3 = element$1("div");
				span3 = element$1("span");
				span3.textContent = "Total Job Board Adverts";
				t10 = space();
				create_component(card3.$$.fragment);
				t11 = space();
				div4 = element$1("div");
				span4 = element$1("span");
				span4.textContent = "Avg.Time to Fill Days";
				t13 = space();
				create_component(card4.$$.fragment);
				t14 = space();
				div5 = element$1("div");
				span5 = element$1("span");
				span5.textContent = "Avg.Candidates";
				t16 = space();
				create_component(card5.$$.fragment);
				attr_dev(span0, "class", "hover-text svelte-15ayp8h");
				add_location(span0, file$4, 60, 4, 1877);
				attr_dev(div0, "class", "card1 svelte-15ayp8h");
				add_location(div0, file$4, 59, 2, 1852);
				attr_dev(span1, "class", "hover-text2 svelte-15ayp8h");
				add_location(span1, file$4, 68, 4, 2189);
				attr_dev(div1, "class", "card2 svelte-15ayp8h");
				add_location(div1, file$4, 67, 3, 2164);
				attr_dev(span2, "class", "hover-text3 svelte-15ayp8h");
				add_location(span2, file$4, 75, 4, 2512);
				attr_dev(div2, "class", "card3 svelte-15ayp8h");
				add_location(div2, file$4, 74, 3, 2487);
				attr_dev(span3, "class", "hover-text4 svelte-15ayp8h");
				add_location(span3, file$4, 82, 4, 2883);
				attr_dev(div3, "class", "card4 svelte-15ayp8h");
				add_location(div3, file$4, 81, 3, 2858);
				attr_dev(span4, "class", "hover-text5 svelte-15ayp8h");
				add_location(span4, file$4, 89, 4, 3205);
				attr_dev(div4, "class", "card5 svelte-15ayp8h");
				add_location(div4, file$4, 88, 3, 3180);
				attr_dev(span5, "class", "hover-text6 svelte-15ayp8h");
				add_location(span5, file$4, 96, 4, 3528);
				attr_dev(div5, "class", "card6 svelte-15ayp8h");
				add_location(div5, file$4, 95, 3, 3503);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div0, anchor);
				append_dev(div0, span0);
				append_dev(div0, t1);
				mount_component(card0, div0, null);
				insert_dev(target, t2, anchor);
				insert_dev(target, div1, anchor);
				append_dev(div1, span1);
				append_dev(div1, t4);
				mount_component(card1, div1, null);
				insert_dev(target, t5, anchor);
				insert_dev(target, div2, anchor);
				append_dev(div2, span2);
				append_dev(div2, t7);
				mount_component(card2, div2, null);
				insert_dev(target, t8, anchor);
				insert_dev(target, div3, anchor);
				append_dev(div3, span3);
				append_dev(div3, t10);
				mount_component(card3, div3, null);
				insert_dev(target, t11, anchor);
				insert_dev(target, div4, anchor);
				append_dev(div4, span4);
				append_dev(div4, t13);
				mount_component(card4, div4, null);
				insert_dev(target, t14, anchor);
				insert_dev(target, div5, anchor);
				append_dev(div5, span5);
				append_dev(div5, t16);
				mount_component(card5, div5, null);
				current = true;
			},
			p: function update(ctx, dirty) {
				const card0_changes = {};

				if (dirty & /*$$scope, metrics*/ 33) {
					card0_changes.$$scope = { dirty, ctx };
				}

				card0.$set(card0_changes);
				const card1_changes = {};

				if (dirty & /*$$scope, metrics*/ 33) {
					card1_changes.$$scope = { dirty, ctx };
				}

				card1.$set(card1_changes);
				const card2_changes = {};

				if (dirty & /*$$scope, metrics*/ 33) {
					card2_changes.$$scope = { dirty, ctx };
				}

				card2.$set(card2_changes);
				const card3_changes = {};

				if (dirty & /*$$scope, metrics*/ 33) {
					card3_changes.$$scope = { dirty, ctx };
				}

				card3.$set(card3_changes);
				const card4_changes = {};

				if (dirty & /*$$scope, metrics*/ 33) {
					card4_changes.$$scope = { dirty, ctx };
				}

				card4.$set(card4_changes);
				const card5_changes = {};

				if (dirty & /*$$scope, metrics*/ 33) {
					card5_changes.$$scope = { dirty, ctx };
				}

				card5.$set(card5_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(card0.$$.fragment, local);
				transition_in(card1.$$.fragment, local);
				transition_in(card2.$$.fragment, local);
				transition_in(card3.$$.fragment, local);
				transition_in(card4.$$.fragment, local);
				transition_in(card5.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(card0.$$.fragment, local);
				transition_out(card1.$$.fragment, local);
				transition_out(card2.$$.fragment, local);
				transition_out(card3.$$.fragment, local);
				transition_out(card4.$$.fragment, local);
				transition_out(card5.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div0);
					detach_dev(t2);
					detach_dev(div1);
					detach_dev(t5);
					detach_dev(div2);
					detach_dev(t8);
					detach_dev(div3);
					detach_dev(t11);
					detach_dev(div4);
					detach_dev(t14);
					detach_dev(div5);
				}

				destroy_component(card0);
				destroy_component(card1);
				destroy_component(card2);
				destroy_component(card3);
				destroy_component(card4);
				destroy_component(card5);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block.name,
			type: "if",
			source: "(59:2) {#if metrics !== null}",
			ctx
		});

		return block;
	}

	// (62:4) <Card>
	function create_default_slot_5(ctx) {
		let h5;
		let t0_value = /*metrics*/ ctx[0].totalJobs + "";
		let t0;
		let t1;
		let p;

		const block = {
			c: function create() {
				h5 = element$1("h5");
				t0 = text(t0_value);
				t1 = space();
				p = element$1("p");
				p.textContent = "Jobs";
				attr_dev(h5, "class", "mb-2 text-2xl font-bold tracking-tight text-gray-900 dark:text-white");
				add_location(h5, file$4, 62, 8, 1941);
				attr_dev(p, "class", "font-normal text-gray-700 dark:text-gray-400 leading-tight");
				add_location(p, file$4, 63, 8, 2056);
			},
			m: function mount(target, anchor) {
				insert_dev(target, h5, anchor);
				append_dev(h5, t0);
				insert_dev(target, t1, anchor);
				insert_dev(target, p, anchor);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*metrics*/ 1 && t0_value !== (t0_value = /*metrics*/ ctx[0].totalJobs + "")) set_data_dev(t0, t0_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(h5);
					detach_dev(t1);
					detach_dev(p);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_5.name,
			type: "slot",
			source: "(62:4) <Card>",
			ctx
		});

		return block;
	}

	// (70:5) <Card  >
	function create_default_slot_4(ctx) {
		let h5;
		let t0_value = /*metrics*/ ctx[0].totalPlacements + "";
		let t0;
		let t1;
		let p;

		const block = {
			c: function create() {
				h5 = element$1("h5");
				t0 = text(t0_value);
				t1 = space();
				p = element$1("p");
				p.textContent = "Placements";
				attr_dev(h5, "class", "mb-2 text-2xl font-bold tracking-tight text-gray-900 dark:text-white");
				add_location(h5, file$4, 70, 5, 2260);
				attr_dev(p, "class", "font-normal text-gray-700 dark:text-gray-400 leading-tight");
				add_location(p, file$4, 71, 4, 2377);
			},
			m: function mount(target, anchor) {
				insert_dev(target, h5, anchor);
				append_dev(h5, t0);
				insert_dev(target, t1, anchor);
				insert_dev(target, p, anchor);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*metrics*/ 1 && t0_value !== (t0_value = /*metrics*/ ctx[0].totalPlacements + "")) set_data_dev(t0, t0_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(h5);
					detach_dev(t1);
					detach_dev(p);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_4.name,
			type: "slot",
			source: "(70:5) <Card  >",
			ctx
		});

		return block;
	}

	// (77:3) <Card style="background-color:  rgb(84, 97, 243)" >
	function create_default_slot_3(ctx) {
		let h5;
		let t0;
		let t1_value = /*metrics*/ ctx[0].totalCommission + "";
		let t1;
		let t2;
		let p;

		const block = {
			c: function create() {
				h5 = element$1("h5");
				t0 = text("GBP");
				t1 = text(t1_value);
				t2 = space();
				p = element$1("p");
				p.textContent = "Billing";
				attr_dev(h5, "class", "mb-2 text-2xl font-bold tracking-tight text-gray-900 dark:text-white");
				add_location(h5, file$4, 77, 5, 2628);
				attr_dev(p, "class", "font-normal text-gray-700 dark:text-gray-400 leading-tight");
				add_location(p, file$4, 78, 5, 2749);
			},
			m: function mount(target, anchor) {
				insert_dev(target, h5, anchor);
				append_dev(h5, t0);
				append_dev(h5, t1);
				insert_dev(target, t2, anchor);
				insert_dev(target, p, anchor);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*metrics*/ 1 && t1_value !== (t1_value = /*metrics*/ ctx[0].totalCommission + "")) set_data_dev(t1, t1_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(h5);
					detach_dev(t2);
					detach_dev(p);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_3.name,
			type: "slot",
			source: "(77:3) <Card style=\\\"background-color:  rgb(84, 97, 243)\\\" >",
			ctx
		});

		return block;
	}

	// (84:3) <Card >
	function create_default_slot_2(ctx) {
		let h5;
		let t0_value = /*metrics*/ ctx[0].totalAdverts + "";
		let t0;
		let t1;
		let p;

		const block = {
			c: function create() {
				h5 = element$1("h5");
				t0 = text(t0_value);
				t1 = space();
				p = element$1("p");
				p.textContent = "Adverts";
				attr_dev(h5, "class", "mb-2 text-2xl font-bold tracking-tight text-gray-900 dark:text-white");
				add_location(h5, file$4, 84, 5, 2958);
				attr_dev(p, "class", "font-normal text-gray-700 dark:text-gray-400 leading-tight");
				add_location(p, file$4, 85, 5, 3073);
			},
			m: function mount(target, anchor) {
				insert_dev(target, h5, anchor);
				append_dev(h5, t0);
				insert_dev(target, t1, anchor);
				insert_dev(target, p, anchor);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*metrics*/ 1 && t0_value !== (t0_value = /*metrics*/ ctx[0].totalAdverts + "")) set_data_dev(t0, t0_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(h5);
					detach_dev(t1);
					detach_dev(p);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_2.name,
			type: "slot",
			source: "(84:3) <Card >",
			ctx
		});

		return block;
	}

	// (91:3) <Card >
	function create_default_slot_1(ctx) {
		let h5;
		let t0_value = /*metrics*/ ctx[0].avgTimeToFillDays + "";
		let t0;
		let t1;
		let p;

		const block = {
			c: function create() {
				h5 = element$1("h5");
				t0 = text(t0_value);
				t1 = space();
				p = element$1("p");
				p.textContent = "TTF";
				attr_dev(h5, "class", "mb-2 text-2xl font-bold tracking-tight text-gray-900 dark:text-white");
				add_location(h5, file$4, 91, 5, 3278);
				attr_dev(p, "class", "font-normal text-gray-700 dark:text-gray-400 leading-tight");
				add_location(p, file$4, 92, 5, 3398);
			},
			m: function mount(target, anchor) {
				insert_dev(target, h5, anchor);
				append_dev(h5, t0);
				insert_dev(target, t1, anchor);
				insert_dev(target, p, anchor);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*metrics*/ 1 && t0_value !== (t0_value = /*metrics*/ ctx[0].avgTimeToFillDays + "")) set_data_dev(t0, t0_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(h5);
					detach_dev(t1);
					detach_dev(p);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot_1.name,
			type: "slot",
			source: "(91:3) <Card >",
			ctx
		});

		return block;
	}

	// (98:3) <Card >
	function create_default_slot(ctx) {
		let h5;
		let t0_value = /*metrics*/ ctx[0].avgCandidatesPerPlacement + "";
		let t0;
		let t1;
		let p;

		const block = {
			c: function create() {
				h5 = element$1("h5");
				t0 = text(t0_value);
				t1 = space();
				p = element$1("p");
				p.textContent = "Candidates/Jobs";
				attr_dev(h5, "class", "mb-2 text-2xl font-bold tracking-tight text-gray-900 dark:text-white");
				add_location(h5, file$4, 98, 5, 3594);
				attr_dev(p, "class", "font-normal text-gray-700 dark:text-gray-400 leading-tight");
				add_location(p, file$4, 99, 5, 3722);
			},
			m: function mount(target, anchor) {
				insert_dev(target, h5, anchor);
				append_dev(h5, t0);
				insert_dev(target, t1, anchor);
				insert_dev(target, p, anchor);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*metrics*/ 1 && t0_value !== (t0_value = /*metrics*/ ctx[0].avgCandidatesPerPlacement + "")) set_data_dev(t0, t0_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(h5);
					detach_dev(t1);
					detach_dev(p);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_default_slot.name,
			type: "slot",
			source: "(98:3) <Card >",
			ctx
		});

		return block;
	}

	function create_fragment$4(ctx) {
		let div;
		let current;
		let if_block = /*metrics*/ ctx[0] !== null && create_if_block(ctx);

		const block = {
			c: function create() {
				div = element$1("div");
				if (if_block) if_block.c();
				attr_dev(div, "class", "container svelte-15ayp8h");
				add_location(div, file$4, 57, 1, 1799);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				if (if_block) if_block.m(div, null);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (/*metrics*/ ctx[0] !== null) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*metrics*/ 1) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(div, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (if_block) if_block.d();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$4.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$4($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Metric', slots, []);
		let metrics = null;
		let startDate = "";
		let endDate = "";

		function getDatesFromLocalStorage() {
			const storedStartDate = localStorage.getItem('startDate');
			const storedEndDate = localStorage.getItem('endDate');

			if (storedStartDate && storedEndDate) {
				startDate = storedStartDate;
				endDate = storedEndDate;
				fetchData(startDate, endDate); // Fetch data when dates are loaded from local storage
			}
		}

		// Subscribe to the dateStore
		dateStore.subscribe(value => {
			startDate = value.startDate;
			endDate = value.endDate;
			fetchData(startDate, endDate); // Fetch data whenever the date changes
		});

		async function fetchData(startDate, endDate) {
			try {
				const apiUrl = "https://api.recruitly.io/api/dashboard/ats/metrics";
				const apiKey = "TEST45684CB2A93F41FC40869DC739BD4D126D77";
				const response = await fetch(`${apiUrl}?start=${startDate}&end=${endDate}&apiKey=${apiKey}`);

				if (response.ok) {
					$$invalidate(0, metrics = await response.json());
				} else {
					const errorText = await response.text();
					console.error("Failed to fetch data. Error:", errorText);
				}
			} catch(error) {
				console.error("Error:", error);
			}
		}

		onMount(() => {
			getDatesFromLocalStorage(); // Try to get dates from local storage
			fetchData(startDate, endDate); // Fetch data on component mount
		});

		afterUpdate(() => {
			localStorage.setItem('startDate', startDate);
			localStorage.setItem('endDate', endDate);
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<Metric> was created with unknown prop '${key}'`);
		});

		$$self.$capture_state = () => ({
			Card,
			onMount,
			afterUpdate,
			dateStore,
			metrics,
			startDate,
			endDate,
			getDatesFromLocalStorage,
			fetchData
		});

		$$self.$inject_state = $$props => {
			if ('metrics' in $$props) $$invalidate(0, metrics = $$props.metrics);
			if ('startDate' in $$props) startDate = $$props.startDate;
			if ('endDate' in $$props) endDate = $$props.endDate;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [metrics];
	}

	class Metric extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Metric",
				options,
				id: create_fragment$4.name
			});
		}
	}

	var __extends$C = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	/**
	 * Defines the appearance of the connectors
	 */
	var Connector = /** @class */ (function (_super) {
	    __extends$C(Connector, _super);
	    function Connector() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property('Line')
	    ], Connector.prototype, "type", void 0);
	    __decorate$7([
	        Property(null)
	    ], Connector.prototype, "color", void 0);
	    __decorate$7([
	        Property(1)
	    ], Connector.prototype, "width", void 0);
	    __decorate$7([
	        Property(null)
	    ], Connector.prototype, "length", void 0);
	    __decorate$7([
	        Property('')
	    ], Connector.prototype, "dashArray", void 0);
	    return Connector;
	}(ChildProperty));
	/**
	 * Configures the fonts in charts.
	 */
	var Font = /** @class */ (function (_super) {
	    __extends$C(Font, _super);
	    function Font() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property('Normal')
	    ], Font.prototype, "fontStyle", void 0);
	    __decorate$7([
	        Property('16px')
	    ], Font.prototype, "size", void 0);
	    __decorate$7([
	        Property('Normal')
	    ], Font.prototype, "fontWeight", void 0);
	    __decorate$7([
	        Property('')
	    ], Font.prototype, "color", void 0);
	    __decorate$7([
	        Property('Center')
	    ], Font.prototype, "textAlignment", void 0);
	    __decorate$7([
	        Property('Segoe UI')
	    ], Font.prototype, "fontFamily", void 0);
	    __decorate$7([
	        Property(1)
	    ], Font.prototype, "opacity", void 0);
	    __decorate$7([
	        Property('Wrap')
	    ], Font.prototype, "textOverflow", void 0);
	    return Font;
	}(ChildProperty));
	/**
	 * Configures the borders in the chart.
	 */
	var Border = /** @class */ (function (_super) {
	    __extends$C(Border, _super);
	    function Border() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property('')
	    ], Border.prototype, "color", void 0);
	    __decorate$7([
	        Property(1)
	    ], Border.prototype, "width", void 0);
	    return Border;
	}(ChildProperty));
	/**
	 * Configures the marker position in the chart.
	 */
	var Offset = /** @class */ (function (_super) {
	    __extends$C(Offset, _super);
	    function Offset() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property(0)
	    ], Offset.prototype, "x", void 0);
	    __decorate$7([
	        Property(0)
	    ], Offset.prototype, "y", void 0);
	    return Offset;
	}(ChildProperty));
	/**
	 * Configures the chart area.
	 */
	var ChartArea = /** @class */ (function (_super) {
	    __extends$C(ChartArea, _super);
	    function ChartArea() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Complex({}, Border)
	    ], ChartArea.prototype, "border", void 0);
	    __decorate$7([
	        Property('transparent')
	    ], ChartArea.prototype, "background", void 0);
	    __decorate$7([
	        Property(1)
	    ], ChartArea.prototype, "opacity", void 0);
	    __decorate$7([
	        Property(null)
	    ], ChartArea.prototype, "backgroundImage", void 0);
	    __decorate$7([
	        Property(null)
	    ], ChartArea.prototype, "width", void 0);
	    return ChartArea;
	}(ChildProperty));
	/**
	 * Configures the chart margins.
	 */
	var Margin = /** @class */ (function (_super) {
	    __extends$C(Margin, _super);
	    function Margin() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property(Browser.isDevice ? 5 : 10)
	    ], Margin.prototype, "left", void 0);
	    __decorate$7([
	        Property(Browser.isDevice ? 5 : 10)
	    ], Margin.prototype, "right", void 0);
	    __decorate$7([
	        Property(Browser.isDevice ? 5 : 10)
	    ], Margin.prototype, "top", void 0);
	    __decorate$7([
	        Property(Browser.isDevice ? 5 : 10)
	    ], Margin.prototype, "bottom", void 0);
	    return Margin;
	}(ChildProperty));
	/**
	 * Configures the chart Legend Container Padding.
	 */
	var ContainerPadding = /** @class */ (function (_super) {
	    __extends$C(ContainerPadding, _super);
	    function ContainerPadding() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property(0)
	    ], ContainerPadding.prototype, "left", void 0);
	    __decorate$7([
	        Property(0)
	    ], ContainerPadding.prototype, "right", void 0);
	    __decorate$7([
	        Property(0)
	    ], ContainerPadding.prototype, "top", void 0);
	    __decorate$7([
	        Property(0)
	    ], ContainerPadding.prototype, "bottom", void 0);
	    return ContainerPadding;
	}(ChildProperty));
	/**
	 * Configures the animation behavior for chart series.
	 */
	var Animation = /** @class */ (function (_super) {
	    __extends$C(Animation, _super);
	    function Animation() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property(true)
	    ], Animation.prototype, "enable", void 0);
	    __decorate$7([
	        Property(1000)
	    ], Animation.prototype, "duration", void 0);
	    __decorate$7([
	        Property(0)
	    ], Animation.prototype, "delay", void 0);
	    return Animation;
	}(ChildProperty));
	/**
	 * Series and point index
	 *
	 * @public
	 */
	var Indexes = /** @class */ (function (_super) {
	    __extends$C(Indexes, _super);
	    function Indexes() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property(0)
	    ], Indexes.prototype, "series", void 0);
	    __decorate$7([
	        Property(0)
	    ], Indexes.prototype, "point", void 0);
	    return Indexes;
	}(ChildProperty));
	/**
	 * Column series rounded corner options
	 */
	var CornerRadius = /** @class */ (function (_super) {
	    __extends$C(CornerRadius, _super);
	    function CornerRadius() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property(0)
	    ], CornerRadius.prototype, "topLeft", void 0);
	    __decorate$7([
	        Property(0)
	    ], CornerRadius.prototype, "topRight", void 0);
	    __decorate$7([
	        Property(0)
	    ], CornerRadius.prototype, "bottomLeft", void 0);
	    __decorate$7([
	        Property(0)
	    ], CornerRadius.prototype, "bottomRight", void 0);
	    return CornerRadius;
	}(ChildProperty));
	/**
	 * @private
	 */
	var Index = /** @class */ (function () {
	    function Index(seriesIndex, pointIndex) {
	        this.series = seriesIndex;
	        this.point = pointIndex;
	    }
	    return Index;
	}());
	/**
	 * Configures the Empty Points of series
	 */
	var EmptyPointSettings = /** @class */ (function (_super) {
	    __extends$C(EmptyPointSettings, _super);
	    function EmptyPointSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property(null)
	    ], EmptyPointSettings.prototype, "fill", void 0);
	    __decorate$7([
	        Complex({ color: 'transparent', width: 0 }, Border)
	    ], EmptyPointSettings.prototype, "border", void 0);
	    __decorate$7([
	        Property('Gap')
	    ], EmptyPointSettings.prototype, "mode", void 0);
	    return EmptyPointSettings;
	}(ChildProperty));
	/**
	 * Configures the drag settings of series
	 */
	var DragSettings = /** @class */ (function (_super) {
	    __extends$C(DragSettings, _super);
	    function DragSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property(false)
	    ], DragSettings.prototype, "enable", void 0);
	    __decorate$7([
	        Property(null)
	    ], DragSettings.prototype, "minY", void 0);
	    __decorate$7([
	        Property(null)
	    ], DragSettings.prototype, "maxY", void 0);
	    __decorate$7([
	        Property(null)
	    ], DragSettings.prototype, "fill", void 0);
	    return DragSettings;
	}(ChildProperty));
	/**
	 * Options to customize the center label of the pie and doughnut chart.
	 *
	 * @default {}
	 */
	/** @class */ ((function (_super) {
	    __extends$C(CenterLabel, _super);
	    function CenterLabel() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property(null)
	    ], CenterLabel.prototype, "text", void 0);
	    __decorate$7([
	        Complex({ fontFamily: null, size: "16px", fontStyle: 'Normal', fontWeight: '600', color: null }, Font)
	    ], CenterLabel.prototype, "textStyle", void 0);
	    __decorate$7([
	        Property(null)
	    ], CenterLabel.prototype, "hoverTextFormat", void 0);
	    return CenterLabel;
	})(ChildProperty));
	/**
	 * Configures the ToolTips in the chart.
	 *
	 * @public
	 */
	var TooltipSettings = /** @class */ (function (_super) {
	    __extends$C(TooltipSettings, _super);
	    function TooltipSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property(false)
	    ], TooltipSettings.prototype, "enable", void 0);
	    __decorate$7([
	        Property(true)
	    ], TooltipSettings.prototype, "enableMarker", void 0);
	    __decorate$7([
	        Property(false)
	    ], TooltipSettings.prototype, "shared", void 0);
	    __decorate$7([
	        Property(null)
	    ], TooltipSettings.prototype, "fill", void 0);
	    __decorate$7([
	        Property(null)
	    ], TooltipSettings.prototype, "header", void 0);
	    __decorate$7([
	        Property(null)
	    ], TooltipSettings.prototype, "opacity", void 0);
	    __decorate$7([
	        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
	    ], TooltipSettings.prototype, "textStyle", void 0);
	    __decorate$7([
	        Property(null)
	    ], TooltipSettings.prototype, "format", void 0);
	    __decorate$7([
	        Property(null)
	    ], TooltipSettings.prototype, "template", void 0);
	    __decorate$7([
	        Property(true)
	    ], TooltipSettings.prototype, "enableAnimation", void 0);
	    __decorate$7([
	        Property(300)
	    ], TooltipSettings.prototype, "duration", void 0);
	    __decorate$7([
	        Property(1000)
	    ], TooltipSettings.prototype, "fadeOutDuration", void 0);
	    __decorate$7([
	        Property('Move')
	    ], TooltipSettings.prototype, "fadeOutMode", void 0);
	    __decorate$7([
	        Property(false)
	    ], TooltipSettings.prototype, "enableTextWrap", void 0);
	    __decorate$7([
	        Property(true)
	    ], TooltipSettings.prototype, "showNearestPoint", void 0);
	    __decorate$7([
	        Complex({ color: null, width: null }, Border)
	    ], TooltipSettings.prototype, "border", void 0);
	    return TooltipSettings;
	}(ChildProperty));
	/** @class */ ((function (_super) {
	    __extends$C(StockTooltipSettings, _super);
	    function StockTooltipSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property(false)
	    ], StockTooltipSettings.prototype, "enable", void 0);
	    __decorate$7([
	        Property(true)
	    ], StockTooltipSettings.prototype, "enableMarker", void 0);
	    __decorate$7([
	        Property(false)
	    ], StockTooltipSettings.prototype, "shared", void 0);
	    __decorate$7([
	        Property(null)
	    ], StockTooltipSettings.prototype, "fill", void 0);
	    __decorate$7([
	        Property(null)
	    ], StockTooltipSettings.prototype, "header", void 0);
	    __decorate$7([
	        Property(0.75)
	    ], StockTooltipSettings.prototype, "opacity", void 0);
	    __decorate$7([
	        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
	    ], StockTooltipSettings.prototype, "textStyle", void 0);
	    __decorate$7([
	        Property(null)
	    ], StockTooltipSettings.prototype, "format", void 0);
	    __decorate$7([
	        Property(null)
	    ], StockTooltipSettings.prototype, "template", void 0);
	    __decorate$7([
	        Property(true)
	    ], StockTooltipSettings.prototype, "enableAnimation", void 0);
	    __decorate$7([
	        Property(300)
	    ], StockTooltipSettings.prototype, "duration", void 0);
	    __decorate$7([
	        Property(1000)
	    ], StockTooltipSettings.prototype, "fadeOutDuration", void 0);
	    __decorate$7([
	        Property('Move')
	    ], StockTooltipSettings.prototype, "fadeOutMode", void 0);
	    __decorate$7([
	        Property(false)
	    ], StockTooltipSettings.prototype, "enableTextWrap", void 0);
	    __decorate$7([
	        Property(true)
	    ], StockTooltipSettings.prototype, "showNearestPoint", void 0);
	    __decorate$7([
	        Complex({ color: null, width: null }, Border)
	    ], StockTooltipSettings.prototype, "border", void 0);
	    __decorate$7([
	        Property('Fixed')
	    ], StockTooltipSettings.prototype, "position", void 0);
	    return StockTooltipSettings;
	})(ChildProperty));
	/**
	 * button settings in period selector
	 */
	var Periods = /** @class */ (function (_super) {
	    __extends$C(Periods, _super);
	    function Periods() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property('Years')
	    ], Periods.prototype, "intervalType", void 0);
	    __decorate$7([
	        Property(1)
	    ], Periods.prototype, "interval", void 0);
	    __decorate$7([
	        Property(null)
	    ], Periods.prototype, "text", void 0);
	    __decorate$7([
	        Property(false)
	    ], Periods.prototype, "selected", void 0);
	    return Periods;
	}(ChildProperty));
	/**
	 * Period Selector Settings
	 */
	/** @class */ ((function (_super) {
	    __extends$C(PeriodSelectorSettings, _super);
	    function PeriodSelectorSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$7([
	        Property(43)
	    ], PeriodSelectorSettings.prototype, "height", void 0);
	    __decorate$7([
	        Property('Bottom')
	    ], PeriodSelectorSettings.prototype, "position", void 0);
	    __decorate$7([
	        Collection([], Periods)
	    ], PeriodSelectorSettings.prototype, "periods", void 0);
	    return PeriodSelectorSettings;
	})(ChildProperty));

	/* eslint-disable jsdoc/require-returns */
	/* eslint-disable valid-jsdoc */
	/* eslint-disable @typescript-eslint/no-explicit-any */
	/**
	 * To import utils
	 */
	var SvgRenderer = /** @class */ (function () {
	    /* End-Properties */
	    function SvgRenderer(rootID) {
	        //Internal Variables
	        this.svgLink = 'http://www.w3.org/2000/svg';
	        this.rootId = rootID;
	    }
	    // method to get the attributes value
	    // tslint:disable-next-line:no-any
	    SvgRenderer.prototype.getOptionValue = function (options, key) {
	        return options[key];
	    }; /* tslint:enable */
	    /**
	     * To create a Html5 SVG element
	     *
	     * @param {SVGAttributes} options - Options to create SVG
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.createSvg = function (options) {
	        if (isNullOrUndefined(options.id)) {
	            options.id = this.rootId + '_svg';
	        }
	        this.svgObj = document.getElementById(options.id);
	        if (isNullOrUndefined(document.getElementById(options.id))) {
	            this.svgObj = document.createElementNS(this.svgLink, 'svg');
	        }
	        this.svgObj = this.setElementAttributes(options, this.svgObj);
	        this.setSVGSize(options.width, options.height);
	        return this.svgObj;
	    };
	    // method to set the height and width for the SVG element
	    SvgRenderer.prototype.setSVGSize = function (width, height) {
	        var element = document.getElementById(this.rootId);
	        var size = !isNullOrUndefined(element) ? element.getBoundingClientRect() : null;
	        if (isNullOrUndefined(this.width) || this.width <= 0) {
	            this.svgObj.setAttribute('width', width ? width.toString() : size.width.toString());
	        }
	        else {
	            this.svgObj.setAttribute('width', this.width.toString());
	        }
	        if (isNullOrUndefined(this.height) || this.height <= 0) {
	            this.svgObj.setAttribute('height', height ? height.toString() : '450');
	        }
	        else {
	            this.svgObj.setAttribute('height', this.height.toString());
	        }
	    };
	    /**
	     * To draw a path
	     *
	     * @param {PathAttributes} options - Options to draw a path in SVG
	     * @returns {Element} It returns a appropriate path
	     */
	    SvgRenderer.prototype.drawPath = function (options) {
	        var path = document.getElementById(options.id);
	        if (path === null) {
	            path = document.createElementNS(this.svgLink, 'path');
	        }
	        path = this.setElementAttributes(options, path);
	        return path;
	    };
	    /**
	     * To draw a line
	     *
	     * @param {LineAttributes} options - Options to draw a line in SVG
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.drawLine = function (options) {
	        var line = document.getElementById(options.id);
	        if (line === null) {
	            line = document.createElementNS(this.svgLink, 'line');
	        }
	        line = this.setElementAttributes(options, line);
	        return line;
	    };
	    /**
	     * To draw a rectangle
	     *
	     * @param {BaseAttibutes} options - Required options to draw a rectangle in SVG
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.drawRectangle = function (options) {
	        var rectangle = document.getElementById(options.id);
	        if (rectangle === null) {
	            rectangle = document.createElementNS(this.svgLink, 'rect');
	        }
	        rectangle = this.setElementAttributes(options, rectangle);
	        return rectangle;
	    };
	    /**
	     * To draw a circle
	     *
	     * @param {CircleAttributes} options - Required options to draw a circle in SVG
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.drawCircle = function (options) {
	        var circle = document.getElementById(options.id);
	        if (circle === null) {
	            circle = document.createElementNS(this.svgLink, 'circle');
	        }
	        circle = this.setElementAttributes(options, circle);
	        return circle;
	    };
	    /**
	     * To draw a polyline
	     *
	     * @param {PolylineAttributes} options - Options required to draw a polyline
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.drawPolyline = function (options) {
	        var polyline = document.getElementById(options.id);
	        if (polyline === null) {
	            polyline = document.createElementNS(this.svgLink, 'polyline');
	        }
	        polyline = this.setElementAttributes(options, polyline);
	        return polyline;
	    };
	    /**
	     * To draw an ellipse
	     *
	     * @param {EllipseAttributes} options - Options required to draw an ellipse
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.drawEllipse = function (options) {
	        var ellipse = document.getElementById(options.id);
	        if (ellipse === null) {
	            ellipse = document.createElementNS(this.svgLink, 'ellipse');
	        }
	        ellipse = this.setElementAttributes(options, ellipse);
	        return ellipse;
	    };
	    /**
	     * To draw a polygon
	     *
	     * @param {PolylineAttributes} options - Options needed to draw a polygon in SVG
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.drawPolygon = function (options) {
	        var polygon = document.getElementById(options.id);
	        if (polygon === null) {
	            polygon = document.createElementNS(this.svgLink, 'polygon');
	        }
	        polygon = this.setElementAttributes(options, polygon);
	        return polygon;
	    };
	    /**
	     * To draw an image
	     *
	     * @param {ImageAttributes} options - Required options to draw an image in SVG
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.drawImage = function (options) {
	        var img = document.createElementNS(this.svgLink, 'image');
	        img.setAttributeNS(null, 'height', options.height.toString());
	        img.setAttributeNS(null, 'width', options.width.toString());
	        img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', options.href);
	        img.setAttributeNS(null, 'x', options.x.toString());
	        img.setAttributeNS(null, 'y', options.y.toString());
	        img.setAttributeNS(null, 'id', options.id);
	        img.setAttributeNS(null, 'visibility', options.visibility);
	        if (!isNullOrUndefined(this.getOptionValue(options, 'clip-path'))) {
	            img.setAttributeNS(null, 'clip-path', this.getOptionValue(options, 'clip-path'));
	        }
	        if (!isNullOrUndefined(options.preserveAspectRatio)) {
	            img.setAttributeNS(null, 'preserveAspectRatio', options.preserveAspectRatio);
	        }
	        return img;
	    };
	    /**
	     * To draw a text
	     *
	     * @param {TextAttributes} options - Options needed to draw a text in SVG
	     * @param {string} label - Label of the text
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.createText = function (options, label) {
	        var text = document.createElementNS(this.svgLink, 'text');
	        text = this.setElementAttributes(options, text);
	        if (!isNullOrUndefined(label)) {
	            text.textContent = label;
	        }
	        return text;
	    };
	    /**
	     * To create a tSpan
	     *
	     * @param {TextAttributes} options - Options to create tSpan
	     * @param {string} label - The text content which is to be rendered in the tSpan
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.createTSpan = function (options, label) {
	        var tSpan = document.createElementNS(this.svgLink, 'tspan');
	        tSpan = this.setElementAttributes(options, tSpan);
	        if (!isNullOrUndefined(label)) {
	            tSpan.textContent = label;
	        }
	        return tSpan;
	    };
	    /**
	     * To create a title
	     *
	     * @param {string} text - The text content which is to be rendered in the title
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.createTitle = function (text) {
	        var title = document.createElementNS(this.svgLink, 'title');
	        title.textContent = text;
	        return title;
	    };
	    /**
	     * To create defs element in SVG
	     *
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.createDefs = function () {
	        var defs = document.createElementNS(this.svgLink, 'defs');
	        return defs;
	    };
	    /**
	     * To create clip path in SVG
	     *
	     * @param {BaseAttibutes} options - Options needed to create clip path
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.createClipPath = function (options) {
	        var clipPath = document.createElementNS(this.svgLink, 'clipPath');
	        clipPath = this.setElementAttributes(options, clipPath);
	        return clipPath;
	    };
	    /**
	     * To create foreign object in SVG
	     *
	     * @param {BaseAttibutes} options - Options needed to create foreign object
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.createForeignObject = function (options) {
	        var foreignObject = document.createElementNS(this.svgLink, 'foreignObject');
	        foreignObject = this.setElementAttributes(options, foreignObject);
	        return foreignObject;
	    };
	    /**
	     * To create group element in SVG
	     *
	     * @param {BaseAttibutes} options - Options needed to create group
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.createGroup = function (options) {
	        var group = document.createElementNS(this.svgLink, 'g');
	        group = this.setElementAttributes(options, group);
	        return group;
	    };
	    /**
	     * To create pattern in SVG
	     *
	     * @param {PatternAttributes} options - Required options to create pattern in SVG
	     * @param {string} element - Specifies the name of the pattern
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.createPattern = function (options, element) {
	        var pattern = document.createElementNS(this.svgLink, element);
	        pattern = this.setElementAttributes(options, pattern);
	        return pattern;
	    };
	    /**
	     * To create radial gradient in SVG
	     *
	     * @param {string[]} colors - Specifies the colors required to create radial gradient
	     * @param {string} name - Specifies the name of the gradient
	     * @param {RadialGradient} options - value for radial gradient
	     * @returns {string} It returns color name
	     */
	    SvgRenderer.prototype.createRadialGradient = function (colors, name, options) {
	        var colorName;
	        if (!isNullOrUndefined(colors[0].colorStop)) {
	            var newOptions = {
	                'id': this.rootId + '_' + name + 'radialGradient',
	                'cx': options.cx + '%',
	                'cy': options.cy + '%',
	                'r': options.r + '%',
	                'fx': options.fx + '%',
	                'fy': options.fy + '%'
	            };
	            this.drawGradient('radialGradient', newOptions, colors);
	            colorName = 'url(#' + this.rootId + '_' + name + 'radialGradient)';
	        }
	        else {
	            colorName = colors[0].color.toString();
	        }
	        return colorName;
	    };
	    /**
	     * To create linear gradient in SVG
	     *
	     * @param {GradientColor[]} colors - Array of string specifies the values for color
	     * @param {string} name - Specifies the name of the gradient
	     * @param {LinearGradient} options - Specifies the options for gradient
	     * @returns {string} It returns color name
	     */
	    SvgRenderer.prototype.createLinearGradient = function (colors, name, options) {
	        var colorName;
	        if (!isNullOrUndefined(colors[0].colorStop)) {
	            var newOptions = {
	                'id': this.rootId + '_' + name + 'linearGradient',
	                'x1': options.x1 + '%',
	                'y1': options.y1 + '%',
	                'x2': options.x2 + '%',
	                'y2': options.y2 + '%'
	            };
	            this.drawGradient('linearGradient', newOptions, colors);
	            colorName = 'url(#' + this.rootId + '_' + name + 'linearGradient)';
	        }
	        else {
	            colorName = colors[0].color.toString();
	        }
	        return colorName;
	    };
	    /**
	     * To render the gradient element in SVG
	     *
	     * @param {string} gradientType - Specifies the type of the gradient
	     * @param {RadialGradient | LinearGradient} options - Options required to render a gradient
	     * @param {string[]} colors - Array of string specifies the values for color
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.drawGradient = function (gradientType, options, colors) {
	        var defs = this.createDefs();
	        var gradient = document.createElementNS(this.svgLink, gradientType);
	        gradient = this.setElementAttributes(options, gradient);
	        for (var i = 0; i < colors.length; i++) {
	            var stop_1 = document.createElementNS(this.svgLink, 'stop');
	            stop_1.setAttribute('offset', colors[i].colorStop);
	            stop_1.setAttribute('stop-color', colors[i].color);
	            stop_1.setAttribute('stop-opacity', colors[i].opacity ? (colors[i].opacity) : '1');
	            if (!isNullOrUndefined(colors[i].style)) {
	                stop_1.style.cssText = colors[i].style;
	            }
	            gradient.appendChild(stop_1);
	        }
	        defs.appendChild(gradient);
	        return defs;
	    };
	    /**
	     * To render a clip path
	     *
	     * @param {BaseAttibutes} options - Options required to render a clip path
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.drawClipPath = function (options) {
	        var defs = this.createDefs();
	        var clipPath = this.createClipPath({ 'id': options.id });
	        options.id = options.id + '_Rect';
	        var rect = this.drawRectangle(options);
	        clipPath.appendChild(rect);
	        defs.appendChild(clipPath);
	        return defs;
	    };
	    /**
	     * To create circular clip path in SVG
	     *
	     * @param {CircleAttributes} options - Options required to create circular clip path
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.drawCircularClipPath = function (options) {
	        var defs = this.createDefs();
	        var clipPath = this.createClipPath({ 'id': options.id });
	        options.id = options.id + '_Circle';
	        var circle = this.drawCircle(options);
	        clipPath.appendChild(circle);
	        defs.appendChild(clipPath);
	        return defs;
	    };
	    /**
	     * To set the attributes to the element
	     *
	     * @param {SVGCanvasAttributes} options - Attributes to set for the element
	     * @param {Element} element - The element to which the attributes need to be set
	     * @returns {Element} It returns a appropriate element
	     */
	    SvgRenderer.prototype.setElementAttributes = function (options, element) {
	        var keys = Object.keys(options);
	        for (var i = 0; i < keys.length; i++) {
	            if (keys[i] === 'style') {
	                element.style.cssText = options[keys[i]];
	            }
	            else {
	                element.setAttribute(keys[i], options[keys[i]]);
	            }
	        }
	        return element;
	    };
	    /**
	     * To create a Html5 canvas element
	     * Dummy method for using canvas/svg render in the same variable name in chart control
	     */
	    SvgRenderer.prototype.createCanvas = function () {
	        return null;
	    };
	    return SvgRenderer;
	}());

	/* eslint-disable no-case-declarations */
	/* eslint-disable jsdoc/require-returns */
	/* eslint-disable valid-jsdoc */
	/* eslint-disable @typescript-eslint/no-explicit-any */
	/**
	 * To import utils.
	 */
	/**
	 * @private
	 */
	var CanvasRenderer = /** @class */ (function () {
	    /* End-Properties */
	    function CanvasRenderer(rootID) {
	        this.rootId = rootID;
	    }
	    // method to get the attributes value
	    // tslint:disable-next-line:no-any
	    CanvasRenderer.prototype.getOptionValue = function (options, key) {
	        return options[key];
	    };
	    /* tslint:enable */
	    /**
	     * To create a Html5 canvas element
	     *
	     * @param {BaseAttibutes} options - Options to create canvas
	     * @returns {HTMLCanvasElement} Creating a canvas
	     */
	    CanvasRenderer.prototype.createCanvas = function (options) {
	        var canvasObj = document.createElement('canvas');
	        canvasObj.setAttribute('id', this.rootId + '_canvas');
	        this.ctx = canvasObj.getContext('2d');
	        this.canvasObj = canvasObj;
	        this.setCanvasSize(options.width, options.height);
	        return this.canvasObj;
	    };
	    /**
	     * To set the width and height for the Html5 canvas element
	     *
	     * @param {number} width - width of the canvas
	     * @param {number} height - height of the canvas
	     * @returns {void} Setting canvas size
	     */
	    CanvasRenderer.prototype.setCanvasSize = function (width, height) {
	        var element = document.getElementById(this.rootId);
	        var size = !isNullOrUndefined(element) ? element.getBoundingClientRect() : null;
	        if (isNullOrUndefined(this.width)) {
	            this.canvasObj.setAttribute('width', width ? width.toString() : size.width.toString());
	        }
	        else {
	            this.canvasObj.setAttribute('width', this.width.toString());
	        }
	        if (isNullOrUndefined(this.height)) {
	            this.canvasObj.setAttribute('height', height ? height.toString() : '450');
	        }
	        else {
	            this.canvasObj.setAttribute('height', this.height.toString());
	        }
	    };
	    // To set the values to the attributes
	    CanvasRenderer.prototype.setAttributes = function (options) {
	        this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');
	        var dashArray = this.getOptionValue(options, 'stroke-dasharray');
	        if (!isNullOrUndefined(dashArray)) {
	            var dashArrayString = dashArray.split(',');
	            this.ctx.setLineDash([parseInt(dashArrayString[0], 10), parseInt(dashArrayString[1], 10)]);
	        }
	        this.ctx.strokeStyle = this.getOptionValue(options, 'stroke');
	    };
	    /**
	     * To draw a line
	     *
	     * @param {LineAttributes} options - required options to draw a line on the canvas
	     * @returns {void} To draw a line
	     */
	    CanvasRenderer.prototype.drawLine = function (options) {
	        this.ctx.save();
	        this.ctx.beginPath();
	        this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');
	        this.ctx.strokeStyle = options.stroke;
	        this.ctx.moveTo(options.x1, options.y1);
	        this.ctx.lineTo(options.x2, options.y2);
	        this.ctx.stroke();
	        this.ctx.restore();
	    };
	    /**
	     * To draw a rectangle
	     *
	     * @param {RectAttributes} options - required options to draw a rectangle on the canvas.
	     * @param {Int32Array} canvasTranslate TO get a translate value of canvas.
	     * @returns {void} To draw rectangle.
	     */
	    CanvasRenderer.prototype.drawRectangle = function (options, canvasTranslate) {
	        var canvasCtx = this.ctx;
	        var cornerRadius = options.rx;
	        this.ctx.save();
	        this.ctx.beginPath();
	        if (canvasTranslate) {
	            this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);
	        }
	        this.ctx.globalAlpha = this.getOptionValue(options, 'opacity');
	        this.setAttributes(options);
	        this.ctx.rect(options.x, options.y, options.width, options.height);
	        if (cornerRadius !== null && cornerRadius >= 0) {
	            this.drawCornerRadius(options);
	        }
	        else {
	            if (options.fill === 'none') {
	                options.fill = 'transparent';
	            }
	            this.ctx.fillStyle = options.fill;
	            this.ctx.fillRect(options.x, options.y, options.width, options.height);
	            this.ctx.stroke();
	        }
	        this.ctx.restore();
	        this.ctx = canvasCtx;
	        return (this.canvasObj);
	    };
	    // To draw the corner of a rectangle
	    CanvasRenderer.prototype.drawCornerRadius = function (options) {
	        var cornerRadius = options.rx;
	        var x = options.x;
	        var y = options.y;
	        var width = options.width;
	        var height = options.height;
	        if (options.fill === 'none') {
	            options.fill = 'transparent';
	        }
	        this.ctx.fillStyle = options.fill;
	        if (width < 2 * cornerRadius) {
	            cornerRadius = width / 2;
	        }
	        if (height < 2 * cornerRadius) {
	            cornerRadius = height / 2;
	        }
	        this.ctx.beginPath();
	        this.ctx.moveTo(x + width - cornerRadius, y);
	        this.ctx.arcTo(x + width, y, x + width, y + height, cornerRadius);
	        this.ctx.arcTo(x + width, y + height, x, y + height, cornerRadius);
	        this.ctx.arcTo(x, y + height, x, y, cornerRadius);
	        this.ctx.arcTo(x, y, x + width, y, cornerRadius);
	        this.ctx.closePath();
	        this.ctx.fill();
	        this.ctx.stroke();
	    };
	    /**
	     * To draw a path on the canvas
	     *
	     * @param {PathAttributes} options - options needed to draw path.
	     * @param {Int32Array} canvasTranslate - Array of numbers to translate the canvas.
	     * @returns {Element} To draw a path.
	     */
	    CanvasRenderer.prototype.drawPath = function (options, canvasTranslate) {
	        var path = options.d;
	        var dataSplit = path.split(' ');
	        var borderWidth = this.getOptionValue(options, 'stroke-width');
	        var canvasCtx = this.ctx;
	        var flag = true;
	        this.ctx.save();
	        this.ctx.beginPath();
	        if (canvasTranslate) {
	            this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);
	        }
	        this.ctx.globalAlpha = options.opacity ? options.opacity : this.getOptionValue(options, 'fill-opacity');
	        this.setAttributes(options);
	        for (var i = 0; i < dataSplit.length; i = i + 3) {
	            var x1 = parseFloat(dataSplit[i + 1]);
	            var y1 = parseFloat(dataSplit[i + 2]);
	            switch (dataSplit[i]) {
	                case 'M':
	                    if (!options.innerR && !options.cx) {
	                        this.ctx.moveTo(x1, y1);
	                    }
	                    break;
	                case 'L':
	                    if (!options.innerR) {
	                        this.ctx.lineTo(x1, y1);
	                    }
	                    break;
	                case 'Q':
	                    var q1 = parseFloat(dataSplit[i + 3]);
	                    var q2 = parseFloat(dataSplit[i + 4]);
	                    this.ctx.quadraticCurveTo(x1, y1, q1, q2);
	                    i = i + 2;
	                    break;
	                case 'C':
	                    var c1 = parseFloat(dataSplit[i + 3]);
	                    var c2 = parseFloat(dataSplit[i + 4]);
	                    var c3 = parseFloat(dataSplit[i + 5]);
	                    var c4 = parseFloat(dataSplit[i + 6]);
	                    this.ctx.bezierCurveTo(x1, y1, c1, c2, c3, c4);
	                    i = i + 4;
	                    break;
	                case 'A':
	                    if (!options.innerR) {
	                        if (options.cx) {
	                            this.ctx.arc(options.cx, options.cy, options.radius, 0, 2 * Math.PI, options.counterClockWise);
	                        }
	                        else {
	                            this.ctx.moveTo(options.x, options.y);
	                            this.ctx.arc(options.x, options.y, options.radius, options.start, options.end, options.counterClockWise);
	                            this.ctx.lineTo(options.x, options.y);
	                        }
	                    }
	                    else if (flag) {
	                        this.ctx.arc(options.x, options.y, options.radius, options.start, options.end, options.counterClockWise);
	                        this.ctx.arc(options.x, options.y, options.innerR, options.end, options.start, !options.counterClockWise);
	                        flag = false;
	                    }
	                    i = i + 5;
	                    break;
	                case 'z':
	                case 'Z':
	                    this.ctx.closePath();
	                    //since for loop is incremented by 3, to get next value after 'z' i is decremented for 2.
	                    i = i - 2;
	                    break;
	            }
	        }
	        if (options.fill !== 'none' && options.fill !== undefined) {
	            this.ctx.fillStyle = options.fill;
	            this.ctx.fill();
	        }
	        if (borderWidth > 0) {
	            this.ctx.stroke();
	        }
	        this.ctx.restore();
	        this.ctx = canvasCtx;
	        return this.canvasObj;
	    };
	    /**
	     * To draw a text
	     *
	     * @param {TextAttributes} options - options required to draw text
	     * @param {string} label - Specifies the text which has to be drawn on the canvas
	     * @param {number} transX - Specifies the text of translate X
	     * @param {number} transY - Specifies the text of translate Y
	     * @param {number} dy - Specifies the text of translate dy
	     * @param {boolean} isTSpan - Specifies the boolean value of span value
	     * @returns {void}
	     */
	    CanvasRenderer.prototype.createText = function (options, label, transX, transY, dy, isTSpan) {
	        var fontWeight = this.getOptionValue(options, 'font-weight');
	        if (!isNullOrUndefined(fontWeight) && fontWeight.toLowerCase() === 'regular') {
	            fontWeight = 'normal';
	        }
	        var fontSize = this.getOptionValue(options, 'font-size');
	        var fontFamily = this.getOptionValue(options, 'font-family');
	        var fontStyle = this.getOptionValue(options, 'font-style').toLowerCase();
	        var font = (fontStyle + ' ' + fontWeight + ' ' + fontSize + ' ' + fontFamily);
	        var anchor = this.getOptionValue(options, 'text-anchor');
	        var opacity = options.opacity !== undefined ? options.opacity : 1;
	        if (anchor === 'middle') {
	            anchor = 'center';
	        }
	        this.ctx.save();
	        this.ctx.fillStyle = options.fill;
	        this.ctx.font = font;
	        this.ctx.textAlign = anchor;
	        this.ctx.globalAlpha = opacity;
	        if (options.baseline) {
	            this.ctx.textBaseline = options.baseline;
	        }
	        if (!isTSpan) {
	            var txtlngth = 0;
	            this.ctx.translate(options.x + (txtlngth / 2) + (transX ? transX : 0), options.y + (transY ? transY : 0));
	            this.ctx.rotate(options.labelRotation * Math.PI / 180);
	        }
	        this.ctx.fillText(label, isTSpan ? options.x : 0, isTSpan ? dy : 0);
	        this.ctx.restore();
	        return this.canvasObj;
	    };
	    /**
	     * To draw circle on the canvas
	     *
	     * @param {CircleAttributes} options - required options to draw the circle
	     * @param {Int32Array} canvasTranslate Translate value of canvas
	     * @returns {void}
	     */
	    CanvasRenderer.prototype.drawCircle = function (options, canvasTranslate) {
	        var canvasCtx = this.ctx;
	        this.ctx.save();
	        this.ctx.beginPath();
	        this.ctx.arc(options.cx, options.cy, options.r, 0, 2 * Math.PI);
	        this.ctx.fillStyle = options.fill;
	        this.ctx.globalAlpha = options.opacity;
	        this.ctx.fill();
	        if (canvasTranslate) {
	            this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);
	        }
	        this.setAttributes(options);
	        this.ctx.stroke();
	        this.ctx.restore();
	        this.ctx = canvasCtx;
	        return this.canvasObj;
	    };
	    /**
	     * To draw polyline
	     *
	     * @param {PolylineAttributes} options - options needed to draw polyline
	     * @returns {void}
	     */
	    CanvasRenderer.prototype.drawPolyline = function (options) {
	        this.ctx.save();
	        this.ctx.beginPath();
	        var points = options.points.split(' ');
	        for (var i = 0; i < points.length - 1; i++) {
	            var point = points[i].split(',');
	            var x = parseFloat(point[0]);
	            var y = parseFloat(point[1]);
	            if (i === 0) {
	                this.ctx.moveTo(x, y);
	            }
	            else {
	                this.ctx.lineTo(x, y);
	            }
	        }
	        this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');
	        this.ctx.strokeStyle = options.stroke;
	        this.ctx.stroke();
	        this.ctx.restore();
	    };
	    /**
	     * To draw an ellipse on the canvas
	     *
	     * @param {EllipseAttributes} options - options needed to draw ellipse
	     * @param {Int32Array} canvasTranslate Translate value of canvas
	     * @returns {void}
	     */
	    CanvasRenderer.prototype.drawEllipse = function (options, canvasTranslate) {
	        var canvasCtx = this.ctx;
	        var circumference = Math.max(options.rx, options.ry);
	        var scaleX = options.rx / circumference;
	        var scaleY = options.ry / circumference;
	        this.ctx.save();
	        this.ctx.beginPath();
	        this.ctx.translate(options.cx, options.cy);
	        if (canvasTranslate) {
	            this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);
	        }
	        this.ctx.save();
	        this.ctx.scale(scaleX, scaleY);
	        this.ctx.arc(0, 0, circumference, 0, 2 * Math.PI, false);
	        this.ctx.fillStyle = options.fill;
	        this.ctx.fill();
	        this.ctx.restore();
	        this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');
	        this.ctx.strokeStyle = options.stroke;
	        this.ctx.stroke();
	        this.ctx.restore();
	        this.ctx = canvasCtx;
	    };
	    /**
	     * To draw an image
	     *
	     * @param {ImageAttributes} options - options required to draw an image on the canvas
	     * @returns {void}
	     */
	    CanvasRenderer.prototype.drawImage = function (options) {
	        this.ctx.save();
	        var imageObj = new Image();
	        if (!isNullOrUndefined(options.href)) {
	            imageObj.src = options.href;
	            this.ctx.drawImage(imageObj, options.x, options.y, options.width, options.height);
	        }
	        this.ctx.restore();
	    };
	    /**
	     * To create a linear gradient
	     *
	     * @param {string[]} colors - Specifies the colors required to create linear gradient
	     * @returns {string} It returns color
	     */
	    CanvasRenderer.prototype.createLinearGradient = function (colors) {
	        var myGradient;
	        if (!isNullOrUndefined(colors[0].colorStop)) {
	            myGradient = this.ctx.createLinearGradient(0, 0, 0, this.canvasObj.height);
	        }
	        var color = this.setGradientValues(colors, myGradient);
	        return color;
	    };
	    /**
	     * To create a radial gradient
	     *
	     * @param {string[]} colors - Specifies the colors required to create linear gradient
	     * @returns {string} It returns gradient color
	     */
	    CanvasRenderer.prototype.createRadialGradient = function (colors) {
	        var myGradient;
	        if (!isNullOrUndefined(colors[0].colorStop)) {
	            myGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.canvasObj.height);
	        }
	        var colorName = this.setGradientValues(colors, myGradient);
	        return colorName;
	    };
	    // To set the gradient values
	    CanvasRenderer.prototype.setGradientValues = function (colors, myGradient) {
	        var colorName;
	        if (!isNullOrUndefined(colors[0].colorStop)) {
	            for (var i = 0; i <= colors.length - 1; i++) {
	                var color = colors[i].color;
	                var newColorStop = (colors[i].colorStop).slice(0, -1);
	                var stopColor = parseInt(newColorStop, 10) / 100;
	                myGradient.addColorStop(stopColor, color);
	            }
	            colorName = myGradient.toString();
	        }
	        else {
	            colorName = colors[0].color.toString();
	        }
	        return colorName;
	    };
	    /**
	     * To set the attributes to the element
	     *
	     * @param {SVGCanvasAttributes} options - Attributes to set for the element
	     * @param {HTMLElement} element - The element to which the attributes need to be set
	     * @returns {HTMLElement} It returns null value
	     */
	    CanvasRenderer.prototype.setElementAttributes = function (options, element) {
	        var keys = Object.keys(options);
	        var values = Object.keys(options).map(function (key) { return options[key]; });
	        for (var i = 0; i < keys.length; i++) {
	            element.setAttribute(keys[i], values[i]);
	        }
	        return null;
	    };
	    /**
	     * To update the values of the canvas element attributes
	     *
	     * @param {SVGCanvasAttributes} options - Specifies the colors required to create gradient
	     * @returns {void}
	     */
	    CanvasRenderer.prototype.updateCanvasAttributes = function (options) {
	        this.setElementAttributes(options, this.canvasObj);
	        var ctx = this.ctx;
	        if (!isNullOrUndefined(this.dataUrl)) {
	            var img_1 = new Image;
	            img_1.onload = function () {
	                ctx.drawImage(img_1, 0, 0);
	            };
	            img_1.src = this.dataUrl;
	        }
	    };
	    /**
	     * This method clears the given rectangle region
	     *
	     * @param {Rect} rect The rect parameter as passed
	     */
	    CanvasRenderer.prototype.clearRect = function (rect) {
	        this.ctx.restore();
	        this.ctx.clearRect(rect.x, rect.y, rect.width, rect.height);
	    };
	    /**
	     * For canvas rendering in chart
	     * Dummy method for using canvas/svg render in the same variable name in chart control
	     */
	    CanvasRenderer.prototype.createGroup = function () {
	        return null;
	    };
	    /**
	     * To render a clip path
	     *
	     * Dummy method for using canvas/svg render in the same variable name in chart control
	     */
	    CanvasRenderer.prototype.drawClipPath = function () {
	        return null;
	    };
	    /**
	     * To render a Circular clip path
	     *
	     * Dummy method for using canvas/svg render in the same variable name in chart control
	     */
	    CanvasRenderer.prototype.drawCircularClipPath = function () {
	        return null;
	    };
	    /**
	     * Clip method to perform clip in canvas mode
	     *
	     * @param {BaseAttibutes} options The canvas clip of options
	     */
	    CanvasRenderer.prototype.canvasClip = function (options) {
	        this.ctx.save();
	        this.ctx.fillStyle = 'transparent';
	        this.ctx.rect(options.x, options.y, options.width, options.height);
	        this.ctx.fill();
	        this.ctx.clip();
	    };
	    /**
	     * Tp restore the canvas
	     */
	    CanvasRenderer.prototype.canvasRestore = function () {
	        this.ctx.restore();
	    };
	    /**
	     * To draw a polygon
	     * Dummy method for using canvas/svg render in the same variable name in chart control
	     */
	    CanvasRenderer.prototype.drawPolygon = function () {
	        return null;
	    };
	    /**
	     * To create defs element in SVG
	     * Dummy method for using canvas/svg render in the same variable name in chart control
	     *
	     * @returns {Element} It returns null
	     */
	    CanvasRenderer.prototype.createDefs = function () {
	        return null;
	    };
	    /**
	     * To create clip path in SVG
	     * Dummy method for using canvas/svg render in the same variable name in chart control
	     */
	    CanvasRenderer.prototype.createClipPath = function () {
	        return null;
	    };
	    /**
	     * To create a Html5 SVG element
	     * Dummy method for using canvas/svg render in the same variable name in chart control
	     *
	     * @returns {Element} It returns null
	     */
	    CanvasRenderer.prototype.createSvg = function () {
	        return null;
	    };
	    return CanvasRenderer;
	}());

	/** @private */
	function getTooltipThemeColor(theme) {
	    var style;
	    switch (theme) {
	        case 'Highcontrast':
	        case 'HighContrast':
	            style = {
	                tooltipFill: '#ffffff',
	                tooltipBoldLabel: '#000000',
	                tooltipLightLabel: '#000000',
	                tooltipHeaderLine: '#969696',
	                textStyle: { fontFamily: 'Segoe UI', color: '#000000' }
	            };
	            break;
	        case 'MaterialDark':
	        case 'FabricDark':
	        case 'BootstrapDark':
	            style = {
	                tooltipFill: theme === 'MaterialDark' ? '#F4F4F4' : theme === 'FabricDark' ? '#A19F9D' : '#F0F0F0',
	                tooltipBoldLabel: theme === 'MaterialDark' ? 'rgba(18, 18, 18, 1)' : theme === 'FabricDark' ? '#DADADA' : '#1A1A1A',
	                tooltipLightLabel: theme === 'MaterialDark' ? 'rgba(18, 18, 18, 1)' : theme === 'FabricDark' ? '#DADADA' : '#1A1A1A',
	                tooltipHeaderLine: '#9A9A9A',
	                textStyle: theme === 'MaterialDark' ? { fontFamily: 'Roboto', color: 'rgba(18, 18, 18, 1)' } : theme === 'FabricDark' ? { fontFamily: 'Segoe UI', color: '#DADADA' } : { fontFamily: 'Helvetica', color: '#1A1A1A' }
	            };
	            break;
	        case 'Bootstrap4':
	            style = {
	                tooltipFill: '#212529',
	                tooltipBoldLabel: '#F9FAFB',
	                tooltipLightLabel: '#F9FAFB',
	                tooltipHeaderLine: 'rgba(255, 255, 255, 0.2)',
	                textStyle: { fontFamily: 'Helvetica', color: '#F9FAFB' }
	            };
	            break;
	        case 'Tailwind':
	            style = {
	                tooltipFill: '#111827',
	                tooltipBoldLabel: '#F9FAFB',
	                tooltipLightLabel: '#F9FAFB',
	                tooltipHeaderLine: '#6B7280',
	                textStyle: { fontFamily: 'Inter', color: '#F9FAFB' }
	            };
	            break;
	        case 'TailwindDark':
	            style = {
	                tooltipFill: '#E9ECEF',
	                tooltipBoldLabel: '#1F2937',
	                tooltipLightLabel: '#1F2937',
	                tooltipHeaderLine: '#9CA3AF',
	                textStyle: { fontFamily: 'Inter', color: '#1F2937' }
	            };
	            break;
	        case 'Bootstrap5':
	            style = {
	                tooltipFill: '#212529',
	                tooltipBoldLabel: '#F9FAFB',
	                tooltipLightLabel: '#F9FAFB',
	                tooltipHeaderLine: '#9CA3AF',
	                textStyle: { fontFamily: 'Helvetica', color: '#F9FAFB' }
	            };
	            break;
	        case 'Bootstrap5Dark':
	            style = {
	                tooltipFill: '#E9ECEF',
	                tooltipBoldLabel: '#212529',
	                tooltipLightLabel: '#212529',
	                tooltipHeaderLine: '#ADB5BD',
	                textStyle: { fontFamily: 'Helvetica', color: '#212529' }
	            };
	            break;
	        case 'Fluent':
	            style = {
	                tooltipFill: '#FFFFFF',
	                tooltipBoldLabel: '#323130',
	                tooltipLightLabel: '#323130',
	                tooltipHeaderLine: '#D2D0CE',
	                textStyle: { fontFamily: 'Segoe UI', color: '#323130' }
	            };
	            break;
	        case 'FluentDark':
	            style = {
	                tooltipFill: '#323130',
	                tooltipBoldLabel: '#F3F2F2',
	                tooltipLightLabel: '#F3F2F1',
	                tooltipHeaderLine: '#3B3A39',
	                textStyle: { fontFamily: 'Segoe UI', color: '#F3F2F1' }
	            };
	            break;
	        case 'Material3':
	            style = {
	                tooltipFill: '#313033',
	                tooltipBoldLabel: '#F4EFF4',
	                tooltipLightLabel: '#F4EFF4',
	                tooltipHeaderLine: '#F4EFF4',
	                textStyle: { fontFamily: 'Roboto', color: '#F4EFF4' }
	            };
	            break;
	        case 'Material3Dark':
	            style = {
	                tooltipFill: '#E6E1E5',
	                tooltipBoldLabel: '#313033',
	                tooltipLightLabel: '#313033',
	                tooltipHeaderLine: '#313033',
	                textStyle: { fontFamily: 'Roboto', color: '#313033' }
	            };
	            break;
	        default:
	            style = {
	                tooltipFill: theme === 'Material' ? '#000816' : theme === 'Fabric' ? '#FFFFFF' : '#212529',
	                tooltipBoldLabel: theme === 'Material' ? 'rgba(249, 250, 251, 1)' : theme === 'Fabric' ? '#333333' : '#F9FAFB',
	                tooltipLightLabel: theme === 'Material' ? 'rgba(249, 250, 251, 1)' : theme === 'Fabric' ? '#333333' : '#F9FAFB',
	                tooltipHeaderLine: theme === 'Fabric' ? '#D2D0CE' : '#ffffff',
	                textStyle: theme === 'Material' ? { fontFamily: 'Roboto', color: 'rgba(249, 250, 251, 1)' } : theme === 'Fabric' ? { fontFamily: 'Segoe UI', color: '#333333' } : { fontFamily: 'Helvetica', color: '#F9FAFB' }
	            };
	            break;
	    }
	    return style;
	}

	var __extends$B = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Function to measure the height and width of the text.
	 *
	 * @private
	 * @param {string} text To get a text
	 * @param {FontModel} font To get a font of the text
	 * @returns {Size} measureText
	 */
	function measureText(text, font, themeFontStyle) {
	    var breakText = text || ''; // For avoid NuLL value
	    var htmlObject = document.getElementById('chartmeasuretext');
	    if (htmlObject === null) {
	        htmlObject = createElement('text', { id: 'chartmeasuretext' });
	        document.body.appendChild(htmlObject);
	    }
	    if (typeof (text) === 'string' && (text.indexOf('<') > -1 || text.indexOf('>') > -1)) {
	        var textArray = text.split(' ');
	        for (var i = 0; i < textArray.length; i++) {
	            if (textArray[i].indexOf('<br/>') === -1) {
	                textArray[i] = textArray[i].replace(/[<>]/g, '&');
	            }
	        }
	        text = textArray.join(' ');
	    }
	    htmlObject.innerHTML = (breakText.indexOf('<br>') > -1 || breakText.indexOf('<br/>') > -1) ? breakText : text;
	    htmlObject.style.position = 'fixed';
	    htmlObject.style.fontSize = font.size;
	    htmlObject.style.fontWeight = font.fontWeight;
	    htmlObject.style.fontStyle = font.fontStyle;
	    htmlObject.style.fontFamily = font.fontFamily || themeFontStyle.fontFamily;
	    htmlObject.style.visibility = 'hidden';
	    htmlObject.style.top = '-100';
	    htmlObject.style.left = '0';
	    htmlObject.style.whiteSpace = 'nowrap';
	    // For bootstrap line height issue
	    htmlObject.style.lineHeight = 'normal';
	    return new Size(htmlObject.clientWidth, htmlObject.clientHeight);
	}
	/** @private */
	function withInAreaBounds(x, y, areaBounds, width, height) {
	    if (width === void 0) { width = 0; }
	    if (height === void 0) { height = 0; }
	    return (x >= areaBounds.x - width && x <= areaBounds.x + areaBounds.width + width && y >= areaBounds.y - height
	        && y <= areaBounds.y + areaBounds.height + height);
	}
	/** @private */
	function findDirection(rX, rY, rect, arrowLocation, arrowPadding, top, bottom, left, tipX, tipY, controlName) {
	    if (controlName === void 0) { controlName = ''; }
	    var direction = '';
	    var startX = rect.x;
	    var startY = rect.y;
	    var width = rect.x + rect.width;
	    var height = rect.y + rect.height;
	    if (top) {
	        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '
	            + startY + ' ' + (startX + rX) + ' ' + startY + ' ' +
	            ' L' + ' ' + (width - rX) + ' ' + (startY) + ' Q ' + width + ' '
	            + startY + ' ' + (width) + ' ' + (startY + rY));
	        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + width + ' '
	            + (height) + ' ' + (width - rX) + ' ' + (height));
	        if (arrowPadding !== 0) {
	            if (controlName === 'RangeNavigator') {
	                if ((arrowLocation.x - arrowPadding) > width / 2) {
	                    direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding) + ' ' + (height));
	                    direction = direction.concat(' L' + ' ' + (tipX + arrowPadding) + ' ' + (height + arrowPadding)
	                        + ' L' + ' ' + (arrowLocation.x) + ' ' + height);
	                }
	                else {
	                    direction = direction.concat(' L' + ' ' + (arrowLocation.x) + ' ' + (height));
	                    direction = direction.concat(' L' + ' ' + (tipX - arrowPadding) + ' ' + (height + arrowPadding)
	                        + ' L' + ' ' + (arrowLocation.x - arrowPadding) + ' ' + height);
	                }
	            }
	            else {
	                direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding) + ' ' + (height));
	                direction = direction.concat(' L' + ' ' + (tipX) + ' ' + (height + arrowPadding)
	                    + ' L' + ' ' + (arrowLocation.x - arrowPadding) + ' ' + height);
	            }
	        }
	        if ((arrowLocation.x - arrowPadding) > startX) {
	            direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' '
	                + height + ' ' + (startX) + ' ' + (height - rY) + ' z');
	        }
	        else {
	            if (arrowPadding === 0) {
	                direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' '
	                    + height + ' ' + (startX) + ' ' + (height - rY) + ' z');
	            }
	            else {
	                direction = direction.concat(' L' + ' ' + (startX) + ' ' + (height + rY) + ' z');
	            }
	        }
	    }
	    else if (bottom) {
	        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '
	            + (startY) + ' ' + (startX + rX) + ' ' + (startY) + ' L' + ' ' + (arrowLocation.x - arrowPadding) + ' ' + (startY));
	        direction = direction.concat(' L' + ' ' + (tipX) + ' ' + (arrowLocation.y));
	        direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding) + ' ' + (startY));
	        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (startY)
	            + ' Q ' + (width) + ' ' + (startY) + ' ' + (width) + ' ' + (startY + rY));
	        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + (width) + ' '
	            + (height) + ' ' + (width - rX) + ' ' + (height) +
	            ' L' + ' ' + (startX + rX) + ' ' + (height) + ' Q ' + (startX) + ' '
	            + (height) + ' ' + (startX) + ' ' + (height - rY) + ' z');
	    }
	    else if (left) {
	        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '
	            + (startY) + ' ' + (startX + rX) + ' ' + (startY));
	        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (startY) + ' Q ' + (width) + ' '
	            + (startY) + ' ' + (width) + ' ' + ((controlName === 'RangeNavigator' ? 0 : (startY + rY)) + ' L' + ' ' + (width) + ' ' + (controlName === 'RangeNavigator' ? 0 : (arrowLocation.y - arrowPadding))));
	        direction = (controlName === 'RangeNavigator') ? direction.concat(' L' + ' ' + (width + arrowPadding) + ' ' + 0) :
	            direction.concat(' L' + ' ' + (width + arrowPadding) + ' ' + (tipY));
	        direction = (controlName === 'RangeNavigator') ? direction.concat(' L' + ' ' + (width) + ' ' + (arrowLocation.y - rY)) :
	            direction.concat(' L' + ' ' + (width) + ' ' + (arrowLocation.y + arrowPadding));
	        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + width + ' ' + (height) + ' ' + (width - rX) + ' ' + (height));
	        direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + (height) + ' Q ' + startX + ' '
	            + (height) + ' ' + (startX) + ' ' + (height - rY) + ' z');
	    }
	    else {
	        direction = direction.concat('M' + ' ' + (startX + rX) + ' ' + (startY) + ' Q ' + (startX) + ' '
	            + (startY) + ' ' + (startX) + ' ' + ((controlName === 'RangeNavigator' ? 0 : (startY + rY)) + ' L' + ' ' + (startX) + ' ' + (controlName === 'RangeNavigator' ? 0 : (arrowLocation.y - arrowPadding))));
	        direction = (controlName === 'RangeNavigator') ? direction.concat(' L' + ' ' + (startX - arrowPadding) + ' ' + 0) :
	            direction.concat(' L' + ' ' + (startX - arrowPadding) + ' ' + (tipY));
	        direction = (controlName === 'RangeNavigator') ? direction.concat(' L' + ' ' + (startX) + ' ' + (arrowLocation.y - rY)) :
	            direction.concat(' L' + ' ' + (startX) + ' ' + (arrowLocation.y + arrowPadding));
	        direction = direction.concat(' L' + ' ' + (startX) + ' ' + (height - rY) + ' Q ' + startX + ' '
	            + (height) + ' ' + (startX + rX) + ' ' + (height));
	        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (height) + ' Q ' + width + ' '
	            + (height) + ' ' + (width) + ' ' + (height - rY) +
	            ' L' + ' ' + (width) + ' ' + (startY + rY) + ' Q ' + width + ' '
	            + (startY) + ' ' + (width - rX) + ' ' + (startY) + ' z');
	    }
	    return direction;
	}
	/** @private */
	var Size = /** @class */ (function () {
	    function Size(width, height) {
	        this.width = width;
	        this.height = height;
	    }
	    return Size;
	}());
	/** @private */
	var Rect = /** @class */ (function () {
	    function Rect(x, y, width, height) {
	        this.x = x;
	        this.y = y;
	        this.width = width;
	        this.height = height;
	    }
	    return Rect;
	}());
	var Side = /** @class */ (function () {
	    function Side(bottom, right) {
	        this.isRight = right;
	        this.isBottom = bottom;
	    }
	    return Side;
	}());
	/** @private */
	var CustomizeOption = /** @class */ (function () {
	    function CustomizeOption(id) {
	        this.id = id;
	    }
	    return CustomizeOption;
	}());
	/** @private */
	var TextOption = /** @class */ (function (_super) {
	    __extends$B(TextOption, _super);
	    function TextOption(id, x, y, anchor, text, transform, baseLine, labelRotation) {
	        if (transform === void 0) { transform = ''; }
	        var _this = _super.call(this, id) || this;
	        _this.transform = '';
	        _this.baseLine = 'auto';
	        _this.labelRotation = 0;
	        _this.x = x;
	        _this.y = y;
	        _this.anchor = anchor;
	        _this.text = text;
	        _this.transform = transform;
	        _this.baseLine = baseLine;
	        _this.labelRotation = labelRotation;
	        return _this;
	    }
	    return TextOption;
	}(CustomizeOption));
	/** @private */
	function getElement$1(id) {
	    return document.getElementById(id);
	}
	/** @private */
	function removeElement$1(id) {
	    var element = getElement$1(id);
	    if (element) {
	        remove(element);
	    }
	}
	/** @private */
	function drawSymbol$1(location, shape, size, url, options, label) {
	    var renderer = new SvgRenderer('');
	    var temp = calculateShapes$1(location, size, shape, options, url);
	    var htmlObject = renderer['draw' + temp.functionName](temp.renderOption);
	    htmlObject.setAttribute('aria-label', label);
	    return htmlObject;
	}
	/** @private */
	function calculateShapes$1(location, size, shape, options, url) {
	    var path;
	    var functionName = 'Path';
	    var width = size.width;
	    var height = size.height;
	    var locX = location.x;
	    var locY = location.y;
	    var x = location.x + (-width / 2);
	    var y = location.y + (-height / 2);
	    switch (shape) {
	        case 'Circle':
	        case 'Bubble':
	            functionName = 'Ellipse';
	            merge(options, { 'rx': width / 2, 'ry': height / 2, 'cx': locX, 'cy': locY });
	            break;
	        case 'Plus':
	            path = 'M' + ' ' + x + ' ' + locY + ' ' + 'L' + ' ' + (locX + (width / 2)) + ' ' + locY + ' ' +
	                'M' + ' ' + locX + ' ' + (locY + (height / 2)) + ' ' + 'L' + ' ' + locX + ' ' +
	                (locY + (-height / 2));
	            merge(options, { 'd': path, stroke: options.fill });
	            break;
	        case 'Cross':
	            path = 'M' + ' ' + x + ' ' + (locY + (-height / 2)) + ' ' + 'L' + ' ' + (locX + (width / 2)) + ' ' + (locY + (height / 2)) + ' ' +
	                'M' + ' ' + x + ' ' + (locY + (height / 2)) + ' ' + 'L' + ' ' + (locX + (width / 2)) + ' ' +
	                (locY + (-height / 2));
	            merge(options, { 'd': path, stroke: options.fill });
	            break;
	        case 'HorizontalLine':
	            path = 'M' + ' ' + x + ' ' + locY + ' ' + 'L' + ' ' + (locX + (width / 2)) + ' ' + locY;
	            merge(options, { 'd': path, stroke: options.fill });
	            break;
	        case 'VerticalLine':
	            path = 'M' + ' ' + locX + ' ' + (locY + (height / 2)) + ' ' + 'L' + ' ' + locX + ' ' + (locY + (-height / 2));
	            merge(options, { 'd': path, stroke: options.fill });
	            break;
	        case 'Diamond':
	            path = 'M' + ' ' + x + ' ' + locY + ' ' +
	                'L' + ' ' + locX + ' ' + (locY + (-height / 2)) + ' ' +
	                'L' + ' ' + (locX + (width / 2)) + ' ' + locY + ' ' +
	                'L' + ' ' + locX + ' ' + (locY + (height / 2)) + ' ' +
	                'L' + ' ' + x + ' ' + locY + ' z';
	            merge(options, { 'd': path });
	            break;
	        case 'Rectangle':
	            path = 'M' + ' ' + x + ' ' + (locY + (-height / 2)) + ' ' +
	                'L' + ' ' + (locX + (width / 2)) + ' ' + (locY + (-height / 2)) + ' ' +
	                'L' + ' ' + (locX + (width / 2)) + ' ' + (locY + (height / 2)) + ' ' +
	                'L' + ' ' + x + ' ' + (locY + (height / 2)) + ' ' +
	                'L' + ' ' + x + ' ' + (locY + (-height / 2)) + ' z';
	            merge(options, { 'd': path });
	            break;
	        case 'Triangle':
	            path = 'M' + ' ' + x + ' ' + (locY + (height / 2)) + ' ' +
	                'L' + ' ' + locX + ' ' + (locY + (-height / 2)) + ' ' +
	                'L' + ' ' + (locX + (width / 2)) + ' ' + (locY + (height / 2)) + ' ' +
	                'L' + ' ' + x + ' ' + (locY + (height / 2)) + ' z';
	            merge(options, { 'd': path });
	            break;
	        case 'InvertedTriangle':
	            path = 'M' + ' ' + (locX + (width / 2)) + ' ' + (locY - (height / 2)) + ' ' +
	                'L' + ' ' + locX + ' ' + (locY + (height / 2)) + ' ' +
	                'L' + ' ' + (locX - (width / 2)) + ' ' + (locY - (height / 2)) + ' ' +
	                'L' + ' ' + (locX + (width / 2)) + ' ' + (locY - (height / 2)) + ' z';
	            merge(options, { 'd': path });
	            break;
	        case 'Pentagon':
	            var eq = 72;
	            var xValue = void 0;
	            var yValue = void 0;
	            for (var i = 0; i <= 5; i++) {
	                xValue = (width / 2) * Math.cos((Math.PI / 180) * (i * eq));
	                yValue = (height / 2) * Math.sin((Math.PI / 180) * (i * eq));
	                if (i === 0) {
	                    path = 'M' + ' ' + (locX + xValue) + ' ' + (locY + yValue) + ' ';
	                }
	                else {
	                    path = path.concat('L' + ' ' + (locX + xValue) + ' ' + (locY + yValue) + ' ');
	                }
	            }
	            path = path.concat('Z');
	            merge(options, { 'd': path });
	            break;
	        case 'Image':
	            functionName = 'Image';
	            merge(options, { 'href': url, 'height': height, 'width': width, x: x, y: y });
	            break;
	    }
	    return { renderOption: options, functionName: functionName };
	}
	/** @private */
	var PathOption = /** @class */ (function (_super) {
	    __extends$B(PathOption, _super);
	    function PathOption(id, fill, width, color, opacity, dashArray, d) {
	        var _this = _super.call(this, id) || this;
	        _this.opacity = opacity;
	        _this.fill = fill;
	        _this.stroke = color;
	        _this['stroke-width'] = width;
	        _this['stroke-dasharray'] = dashArray;
	        _this.d = d;
	        return _this;
	    }
	    return PathOption;
	}(CustomizeOption));
	/** @private */
	function textElement$1(options, font, color, parent, themeStyle) {
	    var renderOptions = {};
	    var renderer = new SvgRenderer('');
	    renderOptions = {
	        'id': options.id,
	        'x': options.x,
	        'y': options.y,
	        'fill': color,
	        'font-size': font.size,
	        'font-style': font.fontStyle,
	        'font-family': font.fontFamily || themeStyle.fontFamily,
	        'font-weight': font.fontWeight,
	        'text-anchor': options.anchor,
	        'transform': options.transform,
	        'opacity': font.opacity,
	        'dominant-baseline': options.baseLine
	    };
	    var text = typeof options.text === 'string' ? options.text : options.text[0];
	    var htmlObject = renderer.createText(renderOptions, text);
	    if (parent) {
	        parent.appendChild(htmlObject);
	    }
	    return htmlObject;
	}
	var TooltipLocation = /** @class */ (function () {
	    function TooltipLocation(x, y) {
	        this.x = x;
	        this.y = y;
	    }
	    return TooltipLocation;
	}());

	var __extends$A = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	/**
	 * Configures the fonts in charts.
	 *
	 * @private
	 */
	var TextStyle = /** @class */ (function (_super) {
	    __extends$A(TextStyle, _super);
	    function TextStyle() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$6([
	        Property(null)
	    ], TextStyle.prototype, "size", void 0);
	    __decorate$6([
	        Property('')
	    ], TextStyle.prototype, "color", void 0);
	    __decorate$6([
	        Property('Segoe UI')
	    ], TextStyle.prototype, "fontFamily", void 0);
	    __decorate$6([
	        Property('Normal')
	    ], TextStyle.prototype, "fontWeight", void 0);
	    __decorate$6([
	        Property('Normal')
	    ], TextStyle.prototype, "fontStyle", void 0);
	    __decorate$6([
	        Property(1)
	    ], TextStyle.prototype, "opacity", void 0);
	    return TextStyle;
	}(ChildProperty));
	/**
	 * Configures the borders in the chart.
	 *
	 * @private
	 */
	var TooltipBorder = /** @class */ (function (_super) {
	    __extends$A(TooltipBorder, _super);
	    function TooltipBorder() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$6([
	        Property('')
	    ], TooltipBorder.prototype, "color", void 0);
	    __decorate$6([
	        Property(1)
	    ], TooltipBorder.prototype, "width", void 0);
	    __decorate$6([
	        Property('')
	    ], TooltipBorder.prototype, "dashArray", void 0);
	    return TooltipBorder;
	}(ChildProperty));
	/**
	 * Configures the borders in the chart.
	 *
	 * @private
	 */
	var AreaBounds = /** @class */ (function (_super) {
	    __extends$A(AreaBounds, _super);
	    function AreaBounds() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$6([
	        Property(0)
	    ], AreaBounds.prototype, "x", void 0);
	    __decorate$6([
	        Property(0)
	    ], AreaBounds.prototype, "y", void 0);
	    __decorate$6([
	        Property(0)
	    ], AreaBounds.prototype, "width", void 0);
	    __decorate$6([
	        Property(0)
	    ], AreaBounds.prototype, "height", void 0);
	    return AreaBounds;
	}(ChildProperty));
	/**
	 * Configures the borders in the chart.
	 *
	 * @private
	 */
	var ToolLocation = /** @class */ (function (_super) {
	    __extends$A(ToolLocation, _super);
	    function ToolLocation() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$6([
	        Property(0)
	    ], ToolLocation.prototype, "x", void 0);
	    __decorate$6([
	        Property(0)
	    ], ToolLocation.prototype, "y", void 0);
	    return ToolLocation;
	}(ChildProperty));
	/**
	 * Represents the Tooltip control.
	 * ```html
	 * <div id="tooltip"/>
	 * <script>
	 *   var tooltipObj = new Tooltip({ isResponsive : true });
	 *   tooltipObj.appendTo("#tooltip");
	 * </script>
	 * ```
	 *
	 * @private
	 */
	var Tooltip$1 = /** @class */ (function (_super) {
	    __extends$A(Tooltip, _super);
	    /**
	     * Constructor for creating the widget
	     *
	     * @hidden
	     */
	    function Tooltip(options, element) {
	        return _super.call(this, options, element) || this;
	    }
	    /**
	     * Initialize the event handler.
	     *
	     * @private
	     */
	    Tooltip.prototype.preRender = function () {
	        this.allowServerDataBinding = false;
	        this.initPrivateVariable();
	        if (!this.isCanvas) {
	            this.removeSVG();
	        }
	        this.createTooltipElement();
	    };
	    Tooltip.prototype.initPrivateVariable = function () {
	        this.renderer = new SvgRenderer(this.element.id);
	        this.themeStyle = getTooltipThemeColor(this.theme);
	        this.formattedText = [];
	        this.padding = 5;
	        this.highlightPadding = 3;
	        this.areaMargin = 10;
	        this.isFirst = true;
	        this.markerPoint = [];
	    };
	    Tooltip.prototype.removeSVG = function () {
	        var svgObject = document.getElementById(this.element.id + '_svg');
	        var templateObject = document.getElementById(this.element.id + 'parent_template');
	        if (this.blazorTemplate) {
	            resetBlazorTemplate(this.element.id + 'parent_template' + '_blazorTemplate');
	        }
	        if (svgObject && svgObject.parentNode) {
	            remove(svgObject);
	        }
	        if (templateObject && templateObject.parentNode) {
	            remove(templateObject);
	        }
	    };
	    /**
	     * To Initialize the control rendering.
	     */
	    Tooltip.prototype.render = function () {
	        this.fadeOuted = false;
	        if (!this.template) {
	            this.renderText(this.isFirst);
	            var argsData = {
	                cancel: false, name: 'tooltipRender', tooltip: this
	            };
	            this.trigger('tooltipRender', argsData);
	            var markerSide = this.renderTooltipElement(this.areaBounds, this.location);
	            this.drawMarker(markerSide.isBottom, markerSide.isRight, this.markerSize);
	        }
	        else {
	            this.updateTemplateFn();
	            this.createTemplate(this.areaBounds, this.location);
	        }
	        this.trigger('loaded', { tooltip: this });
	        var element = document.getElementById('chartmeasuretext');
	        if (element) {
	            remove(element);
	        }
	        this.allowServerDataBinding = true;
	    };
	    Tooltip.prototype.createTooltipElement = function () {
	        this.textElements = [];
	        if (!this.template || this.shared) {
	            // SVG element for tooltip
	            if (this.enableRTL) {
	                this.element.setAttribute('dir', 'ltr');
	            }
	            var svgObject = this.renderer.createSvg({ id: this.element.id + '_svg' });
	            this.element.appendChild(svgObject);
	            // Group to hold text and path.
	            var groupElement = document.getElementById(this.element.id + '_group');
	            if (!groupElement) {
	                groupElement = this.renderer.createGroup({ id: this.element.id + '_group' });
	                groupElement.setAttribute('transform', 'translate(0,0)');
	            }
	            svgObject.appendChild(groupElement);
	            var pathElement = this.renderer.drawPath({
	                'id': this.element.id + '_path', 'stroke-width': ((this.theme === 'Fabric' || this.theme === 'Fluent') && !this.border.width) ? 1 : this.border.width,
	                'fill': this.fill || this.themeStyle.tooltipFill, 'opacity': ((this.theme === 'TailwindDark' || this.theme === 'Tailwind' || this.theme === 'Bootstrap5' || this.theme === 'Bootstrap5Dark') && this.opacity === 0.75) ?
	                    1 : this.opacity,
	                'stroke': this.border.color || (this.theme === 'Fabric' || this.theme === 'Fluent' ? '#D2D0CE' : this.border.color)
	            });
	            groupElement.appendChild(pathElement);
	        }
	    };
	    Tooltip.prototype.drawMarker = function (isBottom, isRight, size) {
	        if (this.shapes.length <= 0) {
	            return null;
	        }
	        var shapeOption;
	        var count = 0;
	        var markerGroup = this.renderer.createGroup({ id: this.element.id + '_trackball_group' });
	        var groupElement = getElement$1(this.element.id + '_group');
	        var x = ((this.enableRTL) ? this.elementSize.width - (size / 2) :
	            (this.marginX * 2) + (size / 2)) + (isRight ? this.arrowPadding : 0);
	        for (var _i = 0, _a = this.shapes; _i < _a.length; _i++) {
	            var shape = _a[_i];
	            if (shape !== 'None') {
	                shapeOption = new PathOption(this.element.id + '_Trackball_' + count, this.palette[count], 1, '#cccccc', 1, null);
	                if (this.markerPoint[count]) {
	                    var padding = 0;
	                    if (this.header.indexOf('<br') > -1) {
	                        padding = this.header.split(/<br.*?>/g).length + count;
	                    }
	                    markerGroup.appendChild(drawSymbol$1(new TooltipLocation(x, this.markerPoint[count] - this.padding + (isBottom ? this.arrowPadding : padding)), shape, new Size(size, size), '', shapeOption, null));
	                }
	                count++;
	            }
	        }
	        groupElement.appendChild(markerGroup);
	    };
	    Tooltip.prototype.renderTooltipElement = function (areaBounds, location) {
	        var tooltipDiv = getElement$1(this.element.id);
	        var arrowLocation = new TooltipLocation(0, 0);
	        var tipLocation = new TooltipLocation(0, 0);
	        var svgObject = getElement$1(this.element.id + '_svg');
	        var groupElement = getElement$1(this.element.id + '_group');
	        var pathElement = getElement$1(this.element.id + '_path');
	        var rect;
	        var isTop = false;
	        var isLeft = false;
	        var isBottom = false;
	        var x = 0;
	        var y = 0;
	        if (this.header !== '') {
	            this.elementSize.height += this.marginY;
	        }
	        if (this.content.length > 1) {
	            rect = this.sharedTooltipLocation(areaBounds, this.location.x, this.location.y);
	            isTop = true;
	        }
	        else {
	            rect = this.tooltipLocation(areaBounds, location, arrowLocation, tipLocation);
	            if (!this.inverted) {
	                isTop = (rect.y < (location.y + this.clipBounds.y));
	                isBottom = !isTop;
	                y = (isTop ? 0 : this.arrowPadding);
	            }
	            else {
	                isLeft = (rect.x < (location.x + this.clipBounds.x));
	                x = (isLeft ? 0 : this.arrowPadding);
	                if (this.allowHighlight) {
	                    rect.x += isLeft ? this.highlightPadding : -(2 * this.highlightPadding);
	                }
	            }
	        }
	        if (this.header !== '') {
	            var wrapPadding = 2;
	            var padding = 0;
	            var wrapHeader = this.isWrap ? this.wrappedText : this.header;
	            if (this.isWrap && typeof (wrapHeader) === 'string' && (wrapHeader.indexOf('<') > -1 || wrapHeader.indexOf('>') > -1)) {
	                var textArray = wrapHeader.split('<br>');
	                wrapPadding = textArray.length;
	            }
	            if (this.header.indexOf('<br') > -1) {
	                padding = 5 * (this.header.split(/<br.*?>/g).length - 1);
	            }
	            var key = 'properties';
	            var font = extend({}, this.textStyle, null, true)[key];
	            font.fontWeight = '600';
	            var headerSize = measureText(this.isWrap ? this.wrappedText : this.header, font, this.themeStyle.textStyle).height +
	                (this.marginY * wrapPadding) + (isBottom ? this.arrowPadding : 0) + (this.isWrap ? 5 : padding); //header padding;
	            var xLength = (this.marginX * 3) + (!isLeft && !isTop && !isBottom ? this.arrowPadding : 0);
	            var direction = 'M ' + xLength + ' ' + headerSize +
	                'L ' + (rect.width + (!isLeft && !isTop && !isBottom ? this.arrowPadding : 0) - (this.marginX * 2)) +
	                ' ' + headerSize;
	            var pathElement_1 = this.renderer.drawPath({
	                'id': this.element.id + '_header_path', 'stroke-width': 1,
	                'fill': null, 'opacity': this.theme === ('Material3' ) ? 0.2 : 0.8, 'stroke': this.themeStyle.tooltipHeaderLine, 'd': direction
	            });
	            groupElement.appendChild(pathElement_1);
	        }
	        var start = this.border.width / 2;
	        var pointRect = new Rect(start + x, start + y, rect.width - start, rect.height - start);
	        groupElement.setAttribute('opacity', '1');
	        if (this.enableAnimation && !this.isFirst && !this.crosshair) {
	            this.animateTooltipDiv(tooltipDiv, rect);
	        }
	        else {
	            this.updateDiv(tooltipDiv, rect.x, rect.y);
	        }
	        // eslint-disable-next-line no-extra-boolean-cast
	        svgObject.setAttribute('height', (rect.height + this.border.width + (!((!this.inverted)) ? 0 : this.arrowPadding) + 5).toString());
	        svgObject.setAttribute('width', (rect.width + this.border.width + (((!this.inverted)) ? 0 : this.arrowPadding) + 5).toString());
	        svgObject.setAttribute('opacity', '1');
	        if (!isNullOrUndefined(this.tooltipPlacement)) {
	            isTop = this.tooltipPlacement.indexOf('Top') > -1;
	            isBottom = this.tooltipPlacement.indexOf('Bottom') > -1;
	            isLeft = this.tooltipPlacement.indexOf('Left') > -1;
	        }
	        pathElement.setAttribute('d', findDirection(this.rx, this.ry, pointRect, arrowLocation, this.arrowPadding, isTop, isBottom, isLeft, tipLocation.x, tipLocation.y, this.controlName));
	        if (this.enableShadow && this.theme !== 'Bootstrap4') {
	            // To fix next chart initial tooltip opacity issue in tab control
	            var shadowId = this.element.id + '_shadow';
	            if (this.theme === 'Tailwind' || this.theme === 'TailwindDark'
	                || this.theme === 'Bootstrap5' || this.theme === 'Bootstrap5Dark') {
	                pathElement.setAttribute('box-shadow', '0px 1px 2px rgba(0, 0, 0, 0.06), 0px 1px 3px rgba(0, 0, 0, 0.1)');
	            }
	            else {
	                pathElement.setAttribute('filter', Browser.isIE ? '' : 'url(#' + shadowId + ')');
	            }
	            var shadow = '<filter id="' + shadowId + '" height="130%"><feGaussianBlur in="SourceAlpha" stdDeviation="3"/>';
	            shadow += '<feOffset dx="3" dy="3" result="offsetblur"/><feComponentTransfer><feFuncA type="linear" slope="0.5"/>';
	            shadow += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
	            var defElement = this.renderer.createDefs();
	            defElement.setAttribute('id', this.element.id + 'SVG_tooltip_definition');
	            groupElement.appendChild(defElement);
	            defElement.innerHTML = shadow;
	        }
	        var borderColor = ((this.theme === 'Fabric' || this.theme === 'Fluent') && !this.border.color) ? '#D2D0CE' : this.border.color;
	        pathElement.setAttribute('stroke', borderColor);
	        if (!isNullOrUndefined(this.border.dashArray)) {
	            pathElement.setAttribute('stroke-dasharray', this.border.dashArray);
	        }
	        this.changeText(new TooltipLocation(x, y), isBottom, !isLeft && !isTop && !isBottom);
	        if (this.revert) {
	            this.inverted = !this.inverted;
	            this.revert = false;
	        }
	        return new Side(isBottom, !isLeft && !isTop && !isBottom);
	    };
	    Tooltip.prototype.changeText = function (point, isBottom, isRight) {
	        var element = document.getElementById(this.element.id + '_text');
	        if (isBottom) {
	            element.setAttribute('transform', 'translate(0,' + this.arrowPadding + ')');
	        }
	        if (isRight) {
	            element.setAttribute('transform', 'translate(' + this.arrowPadding + ' 0)');
	        }
	    };
	    Tooltip.prototype.findFormattedText = function () {
	        this.formattedText = [];
	        if (this.header.replace(/<b>/g, '').replace(/<\/b>/g, '').trim() !== '') {
	            this.formattedText = this.formattedText.concat(this.header);
	        }
	        this.formattedText = this.formattedText.concat(this.content);
	    };
	    // tslint:disable-next-line:max-func-body-length
	    Tooltip.prototype.renderText = function (isRender) {
	        var height = 0;
	        var width = 0; // Padding for text;
	        var subWidth = 0;
	        var lines;
	        var key = 'properties';
	        var font = extend({}, this.textStyle, null, true)[key];
	        var groupElement = getElement$1(this.element.id + '_group');
	        var tspanElement;
	        var textCollection;
	        var tspanStyle = '';
	        var line;
	        var tspanOption;
	        this.findFormattedText();
	        this.isWrap = false;
	        var isRtlEnabled = document.body.getAttribute('dir') === 'rtl';
	        var anchor = isRtlEnabled && !this.enableRTL ? 'end' : 'start';
	        this.leftSpace = this.areaBounds.x + this.location.x;
	        this.rightSpace = (this.areaBounds.x + this.areaBounds.width) - this.leftSpace;
	        var headerContent = this.header.replace(/<b>/g, '').replace(/<\/b>/g, '').trim();
	        var isBoldTag = this.header.indexOf('<b>') > -1 && this.header.indexOf('</b>') > -1;
	        font.fontWeight = '600';
	        var headerWidth = measureText(this.formattedText[0], font, this.themeStyle.textStyle).width
	            + (2 * this.marginX) + this.arrowPadding;
	        var isLeftSpace = (this.location.x - headerWidth) < this.location.x;
	        var isRightSpace = (this.areaBounds.x + this.areaBounds.width) < (this.location.x + headerWidth);
	        var header;
	        var headerSpace = (headerContent !== '') ? this.marginY : 0;
	        var isRow = true;
	        var isColumn = true;
	        this.markerPoint = [];
	        var markerSize = (this.shapes.length > 0) ? 10 : 0;
	        var markerPadding = (this.shapes.length > 0) ? 5 : 0;
	        var spaceWidth = 4;
	        var subStringLength;
	        var fontSize = '12px';
	        var fontWeight = '400';
	        var labelColor = this.themeStyle.tooltipLightLabel;
	        var dy = (22 / parseFloat(fontSize)) * (parseFloat(font.size));
	        var contentWidth = [];
	        if (!isRender || this.isCanvas) {
	            removeElement$1(this.element.id + '_text');
	            removeElement$1(this.element.id + '_header_path');
	            removeElement$1(this.element.id + '_trackball_group');
	            removeElement$1(this.element.id + 'SVG_tooltip_definition');
	        }
	        var options = new TextOption(this.element.id + '_text', this.marginX * 2, (this.marginY * 2 + this.padding * 2 + (this.marginY === 2 ? this.controlName === 'RangeNavigator' ? 5 : 3 : 0)), anchor, '');
	        var parentElement = textElement$1(options, font, font.color || this.themeStyle.tooltipBoldLabel, groupElement, this.themeStyle.textStyle);
	        var withoutHeader = this.formattedText.length === 1 && this.formattedText[0].indexOf(' : <b>') > -1;
	        var isHeader = this.header !== '';
	        var size = isHeader && isBoldTag ? 16 : 13;
	        for (var k = 0, pointsLength = this.formattedText.length; k < pointsLength; k++) {
	            textCollection = this.formattedText[k].replace(/<(b|strong)>/g, '<b>')
	                .replace(/<\/(b|strong)>/g, '</b>')
	                .split(/<br.*?>/g);
	            if (this.isTextWrap && this.header !== this.formattedText[k] && this.formattedText[k].indexOf('<br') === -1) {
	                subStringLength = Math.round(this.leftSpace > this.rightSpace ? (this.leftSpace / size) : (this.rightSpace / size));
	                textCollection = this.formattedText[k].match(new RegExp('.{1,' + subStringLength + '}', 'g'));
	            }
	            if (k === 0 && !withoutHeader && this.isTextWrap &&
	                (this.leftSpace < headerWidth || isLeftSpace) &&
	                (this.rightSpace < headerWidth || isRightSpace)) {
	                subStringLength = Math.round(this.leftSpace > this.rightSpace ? (this.leftSpace / size) : (this.rightSpace / size));
	                header = headerContent !== '' ? headerContent : this.formattedText[k];
	                textCollection = header.match(new RegExp('.{1,' + subStringLength + '}', 'g'));
	                this.wrappedText = isBoldTag ? '<b>' + textCollection.join('<br>') + '</b>' : textCollection.join('<br>');
	                this.isWrap = textCollection.length > 1;
	            }
	            if (textCollection[0] === '') {
	                continue;
	            }
	            if ((k !== 0) || (headerContent === '')) {
	                this.markerPoint.push((headerContent !== '' ? (this.marginY) : 0) + options.y + height);
	            }
	            for (var i = 0, len = textCollection.length; i < len; i++) { // string value of unicode for LTR is \u200E
	                lines = textCollection[i].replace(/<b>/g, '<br><b>').replace(/<\/b>/g, '</b><br>').replace(/:/g, (this.enableRTL) ? '<br>\u200E: <br>' : '<br>\u200E:<br>')
	                    .split('<br>');
	                if (this.enableRTL && lines.length > 0 && textCollection[i].match(/:/g)) {
	                    lines[0] = lines[0].trim();
	                    lines.reverse();
	                }
	                subWidth = 0;
	                isColumn = true;
	                height += dy;
	                for (var j = 0, len_1 = lines.length; j < len_1; j++) {
	                    line = lines[j];
	                    if (this.enableRTL && line !== '' && this.isRTLText(line)) {
	                        line = line.concat('\u200E');
	                    }
	                    if (!/\S/.test(line) && line !== '') {
	                        line = ' '; //to trim multiple white spaces to single white space
	                    }
	                    if ((!isColumn && line === ' ') || (line.replace(/<b>/g, '').replace(/<\/b>/g, '').trim() !== '')) {
	                        subWidth += line !== ' ' ? spaceWidth : 0;
	                        if (isColumn && !isRow) {
	                            if (this.header.indexOf('<br') > -1 && k !== 0) {
	                                headerSpace += this.header.split(/<br.*?>/g).length;
	                            }
	                            tspanOption = {
	                                x: (this.marginX * 2) + (markerSize + markerPadding),
	                                dy: dy + ((isColumn) ? headerSpace : 0), fill: ''
	                            };
	                            headerSpace = null;
	                        }
	                        else {
	                            if (isRow && isColumn) {
	                                tspanOption = {
	                                    x: (headerContent === '') ? ((this.marginX * 2) + (markerSize + markerPadding))
	                                        : (this.marginX * 2) + (this.isWrap ? (markerSize + markerPadding) : 0)
	                                };
	                            }
	                            else {
	                                tspanOption = {};
	                            }
	                        }
	                        isColumn = false;
	                        tspanElement = this.renderer.createTSpan(tspanOption, '');
	                        parentElement.appendChild(tspanElement);
	                        if (line.indexOf('<b>') > -1 || ((isBoldTag && j === 0 && k === 0) && (isHeader || this.isWrap))) {
	                            fontWeight = '600';
	                            labelColor = this.themeStyle.tooltipBoldLabel;
	                            tspanStyle = 'font-weight:' + fontWeight;
	                            font.fontWeight = fontWeight;
	                            (tspanElement).setAttribute('fill', this.textStyle.color || labelColor);
	                        }
	                        else {
	                            tspanStyle = fontWeight === '600' ? 'font-weight:' + fontWeight : '';
	                            font.fontWeight = fontWeight;
	                            (tspanElement).setAttribute('fill', this.textStyle.color || labelColor);
	                        }
	                        if (line.indexOf('</b>') > -1 || ((isBoldTag && j === len_1 - 1 && k === 0) && (isHeader || this.isWrap))) {
	                            fontWeight = 'Normal';
	                            labelColor = this.themeStyle.tooltipLightLabel;
	                        }
	                        // eslint-disable-next-line no-useless-escape
	                        if (tspanStyle !== '') {
	                            tspanElement.style.fontWeight = tspanStyle.split('font-weight:')[1];
	                            tspanElement.style.color = tspanElement.getAttribute('fill');
	                        }
	                        // 'inherit' will apply css style from parent element.
	                        tspanElement.style.fontFamily = 'inherit';
	                        tspanElement.style.fontStyle = 'inherit';
	                        tspanElement.style.fontSize = (this.header === this.formattedText[k]) ? font.size : this.textStyle.size;
	                        tspanElement.style.fontWeight = (this.header === this.formattedText[k] && (this.header.indexOf('<b>') || this.header.indexOf('</b>')) === -1) ? '600' : line.indexOf('<b>') > -1 || line.indexOf('</b>') > -1 ? 'bold' : this.textStyle.fontWeight;
	                        var textFont = extend({}, this.textStyle, null, true)[key];
	                        textFont.fontWeight = tspanElement.style.fontWeight;
	                        isRow = false;
	                        (tspanElement).textContent = line = this.getTooltipTextContent(line);
	                        subWidth += measureText(line, textFont, this.themeStyle.textStyle).width;
	                    }
	                }
	                subWidth -= spaceWidth;
	                width = Math.max(width, subWidth);
	                contentWidth.push(subWidth);
	            }
	        }
	        this.elementSize = new Size(width + (width > 0 ? (2 * this.marginX) : 0), height);
	        this.elementSize.width += (markerSize + markerPadding); // marker size + marker Spacing
	        var element = (parentElement.childNodes[0]);
	        if (headerContent !== '' && element && !this.isWrap) {
	            font.fontWeight = '600';
	            var width_1 = (this.elementSize.width + (2 * this.padding)) / 2 - measureText(headerContent, font, this.themeStyle.textStyle).width / 2;
	            element.setAttribute('x', width_1.toString());
	        }
	        this.renderContentRTL(parentElement, isHeader, markerSize + markerPadding, contentWidth);
	    };
	    Tooltip.prototype.renderContentRTL = function (textElement, isHeader, markerSize, contentWidth) {
	        if (this.enableRTL) {
	            var tspanElement = void 0;
	            var contentWidthIndex = isHeader ? 1 : 0;
	            for (var i = 0; i < textElement.childNodes.length; i++) {
	                tspanElement = (textElement.childNodes[i]);
	                if ((!isHeader || i > 0) && !isNullOrUndefined(tspanElement.getAttribute('x'))) {
	                    tspanElement.setAttribute('x', (this.elementSize.width - (markerSize + contentWidth[contentWidthIndex])).toString());
	                    contentWidthIndex++;
	                }
	            }
	        }
	    };
	    Tooltip.prototype.getTooltipTextContent = function (tooltipText) {
	        var characterCollection = tooltipText.match(/<[a-zA-Z\/](.|\n)*?>/g);
	        if (isNullOrUndefined(characterCollection)) {
	            return tooltipText;
	        }
	        var isRtlText = this.isRTLText(tooltipText);
	        for (var i = 0; i < characterCollection.length; i++) {
	            if (this.isValidHTMLElement(characterCollection[i].replace('<', '').replace('/', '').replace('>', '').trim())) {
	                tooltipText = tooltipText.replace(characterCollection[i], isRtlText ? '\u200E' : '');
	            }
	        }
	        return tooltipText;
	    };
	    Tooltip.prototype.isValidHTMLElement = function (element) {
	        return document.createElement(element).toString() !== '[object HTMLUnknownElement]';
	    };
	    Tooltip.prototype.isRTLText = function (tooltipContent) {
	        return /[\u0590-\u07FF\u200F\u202B\u202E\uFB1D-\uFDFD\uFE70-\uFEFC]/.test(tooltipContent);
	    };
	    Tooltip.prototype.createTemplate = function (areaBounds, location) {
	        var argsData = { cancel: false, name: 'tooltipRender', tooltip: this };
	        this.trigger('tooltipRender', argsData);
	        var parent = document.getElementById(this.element.id);
	        if (this.isCanvas) {
	            this.removeSVG();
	        }
	        var firstElement = parent.firstElementChild;
	        if (firstElement) {
	            remove(firstElement);
	        }
	        if (!argsData.cancel) {
	            var elem = createElement('div', { id: this.element.id + 'parent_template' });
	            var templateElement = void 0;
	            if (this.controlName === 'Chart' && this.shared) {
	                for (var i = 0; i < this.data.length; i++) {
	                    var sharedTemplateElement = this.templateFn(this.data[i], this.controlInstance, elem.id, elem.id + '_blazorTemplate', '');
	                    if (i === 0) {
	                        templateElement = sharedTemplateElement;
	                    }
	                    else {
	                        templateElement[0].outerHTML += '<br>' + sharedTemplateElement[0].outerHTML;
	                    }
	                }
	            }
	            else {
	                templateElement = this.templateFn(this.data, this.controlInstance, elem.id, elem.id + '_blazorTemplate', '');
	            }
	            while (templateElement && templateElement.length > 0) {
	                if (templateElement.length === 1) {
	                    elem.appendChild(templateElement[0]);
	                    templateElement = null;
	                }
	                else {
	                    elem.appendChild(templateElement[0]);
	                }
	            }
	            parent.appendChild(elem);
	            var element = this.isCanvas ? elem : this.element;
	            var rect = element.getBoundingClientRect();
	            this.padding = 0;
	            this.elementSize = new Size(rect.width, rect.height);
	            var tooltipRect = this.shared ? this.sharedTooltipLocation(areaBounds, this.location.x, this.location.y)
	                : this.tooltipLocation(areaBounds, location, new TooltipLocation(0, 0), new TooltipLocation(0, 0));
	            if (this.enableAnimation && !this.isFirst && !this.crosshair) {
	                this.animateTooltipDiv(this.element, tooltipRect);
	            }
	            else {
	                this.updateDiv(element, tooltipRect.x, tooltipRect.y);
	            }
	            if (this.blazorTemplate) {
	                //Customer issue - F149037  Call back function to handle the blazor tooltip alignment issues
	                var tooltipRendered = function () {
	                    var rect1 = getElement$1(thisObject_1.element.id).getBoundingClientRect();
	                    thisObject_1.elementSize = new Size(rect1.width, rect1.height);
	                    var tooltipRect1 = thisObject_1.tooltipLocation(areaBounds, location, new TooltipLocation(0, 0), new TooltipLocation(0, 0));
	                    thisObject_1.updateDiv(getElement$1(thisObject_1.element.id), tooltipRect1.x, tooltipRect1.y);
	                };
	                // eslint-disable-next-line @typescript-eslint/no-this-alias
	                var thisObject_1 = this;
	                tooltipRendered.bind(thisObject_1, areaBounds, location);
	                updateBlazorTemplate(this.element.id + 'parent_template' + '_blazorTemplate', this.blazorTemplate.name, this.blazorTemplate.parent);
	            }
	        }
	        else {
	            remove(getElement$1(this.element.id + '_tooltip'));
	        }
	    };
	    Tooltip.prototype.sharedTooltipLocation = function (bounds, x, y) {
	        var width = this.elementSize.width + (2 * this.marginX);
	        var height = this.elementSize.height + (2 * this.marginY);
	        var tooltipRect = new Rect(x + 2 * this.padding, y - height - this.padding, width, height);
	        if (tooltipRect.y < bounds.y) {
	            tooltipRect.y += (tooltipRect.height + 2 * this.padding);
	        }
	        if (tooltipRect.y + tooltipRect.height > bounds.y + bounds.height) {
	            tooltipRect.y = Math.max((bounds.y + bounds.height) - (tooltipRect.height + 2 * this.padding), bounds.y);
	        }
	        if (tooltipRect.x + tooltipRect.width > bounds.x + bounds.width) {
	            tooltipRect.x = (bounds.x + bounds.width) - (tooltipRect.width + 4 * this.padding);
	        }
	        if (tooltipRect.x < bounds.x) {
	            tooltipRect.x = bounds.x;
	        }
	        return tooltipRect;
	    };
	    Tooltip.prototype.getCurrentPosition = function (bounds, symbolLocation, arrowLocation, tipLocation) {
	        var position = this.tooltipPlacement;
	        var clipX = this.clipBounds.x;
	        var clipY = this.clipBounds.y;
	        var markerHeight = this.offset;
	        var width = this.elementSize.width + (2 * this.marginX);
	        var height = this.elementSize.height + (2 * this.marginY);
	        var location = new TooltipLocation(symbolLocation.x, symbolLocation.y);
	        if (position === 'Top' || position === 'Bottom') {
	            location = new TooltipLocation(location.x + clipX - this.elementSize.width / 2 - this.padding, location.y + clipY - this.elementSize.height - (2 * this.padding) - this.arrowPadding - markerHeight);
	            arrowLocation.x = tipLocation.x = width / 2;
	            if (position === 'Bottom') {
	                location.y = symbolLocation.y + clipY + markerHeight;
	            }
	            if (bounds.x + bounds.width < location.x + width) {
	                location.x = (bounds.width > width) ? ((bounds.x + bounds.width) - width + 6) : bounds.x;
	                arrowLocation.x = tipLocation.x = (bounds.width > width) ? (bounds.x + symbolLocation.x - location.x) : symbolLocation.x;
	            }
	            else if (bounds.x > location.x) {
	                location.x = bounds.x;
	                arrowLocation.x = tipLocation.x = symbolLocation.x;
	            }
	        }
	        else {
	            location = new TooltipLocation(location.x + clipX + markerHeight, location.y + clipY - this.elementSize.height / 2 - (this.padding));
	            arrowLocation.y = tipLocation.y = height / 2;
	            if (position === 'Left') {
	                location.x = symbolLocation.x + clipX - markerHeight - (width + this.arrowPadding);
	            }
	            if (bounds.y + bounds.height < location.y + height) {
	                location.y = (bounds.height > height) ? ((bounds.y + bounds.height) - height + 6) : bounds.y;
	                arrowLocation.y = tipLocation.y = (bounds.height > height) ? (bounds.y + symbolLocation.y - location.y) : symbolLocation.y;
	            }
	            else if (bounds.y > location.y) {
	                location.y = bounds.y;
	                arrowLocation.y = tipLocation.y = symbolLocation.y;
	            }
	        }
	        return new Rect(location.x, location.y, width, height);
	    };
	    // tslint:disable-next-line:max-func-body-length
	    Tooltip.prototype.tooltipLocation = function (bounds, symbolLocation, arrowLocation, tipLocation) {
	        if (!isNullOrUndefined(this.tooltipPlacement)) {
	            var tooltipRect = this.getCurrentPosition(bounds, symbolLocation, arrowLocation, tipLocation);
	            return tooltipRect;
	        }
	        var location = new TooltipLocation(symbolLocation.x, symbolLocation.y);
	        var width = this.elementSize.width + (2 * this.marginX);
	        var height = this.elementSize.height + (2 * this.marginY);
	        var markerHeight = this.offset;
	        var clipX = this.clipBounds.x;
	        var clipY = this.clipBounds.y;
	        var boundsX = bounds.x;
	        var boundsY = bounds.y;
	        this.outOfBounds = false;
	        if (!this.inverted) {
	            location = new TooltipLocation(location.x + clipX - this.elementSize.width / 2 - this.padding, location.y + clipY - this.elementSize.height - (2 * (this.allowHighlight ? this.highlightPadding : this.padding)) -
	                this.arrowPadding - markerHeight);
	            arrowLocation.x = tipLocation.x = width / 2;
	            if ((location.y < boundsY || (this.isNegative)) && !(this.controlName === 'Progressbar')) {
	                location.y = (symbolLocation.y < 0 ? 0 : symbolLocation.y) + clipY + markerHeight;
	            }
	            if (location.y + height + this.arrowPadding > boundsY + bounds.height) {
	                location.y = Math.min(symbolLocation.y, boundsY + bounds.height) + clipY
	                    - this.elementSize.height - (2 * this.padding) - this.arrowPadding - markerHeight;
	            }
	            if (((location.x + width > boundsX + bounds.width) && location.y < boundsY || (this.isNegative)) && !(this.controlName === 'Progressbar')) {
	                location.y = (symbolLocation.y < 0 ? 0 : symbolLocation.y) + clipY + markerHeight;
	            }
	            tipLocation.x = width / 2;
	            if (location.x < boundsX && !(this.controlName === 'Progressbar')) {
	                arrowLocation.x -= (boundsX - location.x);
	                tipLocation.x -= (boundsX - location.x);
	                location.x = boundsX;
	            }
	            if (location.x + width > boundsX + bounds.width && !(this.controlName === 'Progressbar')) {
	                arrowLocation.x += ((location.x + width) - (boundsX + bounds.width));
	                tipLocation.x += ((location.x + width) - (boundsX + bounds.width));
	                location.x -= ((location.x + width) - (boundsX + bounds.width));
	            }
	            if (location.x < boundsX && !(this.controlName === 'Progressbar')) {
	                arrowLocation.x -= (boundsX - location.x);
	                tipLocation.x -= (boundsX - location.x);
	                location.x = boundsX;
	            }
	            if (arrowLocation.x + this.arrowPadding > width - this.rx) {
	                arrowLocation.x = width - this.rx - this.arrowPadding;
	                tipLocation.x = width - this.rx - this.arrowPadding;
	            }
	            if (arrowLocation.x - this.arrowPadding < this.rx) {
	                arrowLocation.x = tipLocation.x = this.rx + this.arrowPadding;
	            }
	            if (this.controlName === 'Chart') {
	                if (((bounds.x + bounds.width) - (location.x + arrowLocation.x)) < this.areaMargin + this.arrowPadding ||
	                    (location.x + arrowLocation.x) < this.areaMargin + this.arrowPadding) {
	                    this.outOfBounds = true;
	                }
	                if (!withInAreaBounds(location.x, location.y, bounds) || this.outOfBounds) {
	                    this.inverted = !this.inverted;
	                    this.revert = true;
	                    location = new TooltipLocation(symbolLocation.x + markerHeight + clipX, symbolLocation.y + clipY - this.elementSize.height / 2 - (this.padding));
	                    tipLocation.x = arrowLocation.x = 0;
	                    tipLocation.y = arrowLocation.y = height / 2;
	                    if ((location.x + this.arrowPadding + width > boundsX + bounds.width) || (this.isNegative)) {
	                        location.x = (symbolLocation.x > bounds.width ? bounds.width : symbolLocation.x)
	                            + clipX - markerHeight - (this.arrowPadding + width);
	                    }
	                    if (location.x < boundsX) {
	                        location.x = (symbolLocation.x < 0 ? 0 : symbolLocation.x) + markerHeight + clipX;
	                    }
	                    if (location.y <= boundsY) {
	                        tipLocation.y -= (boundsY - location.y);
	                        arrowLocation.y -= (boundsY - location.y);
	                        location.y = boundsY;
	                    }
	                    if (location.y + height >= bounds.height + boundsY) {
	                        arrowLocation.y += ((location.y + height) - (bounds.height + boundsY));
	                        tipLocation.y += ((location.y + height) - (bounds.height + boundsY));
	                        location.y -= ((location.y + height) - (bounds.height + boundsY));
	                    }
	                    if ((this.arrowPadding) + arrowLocation.y > height - this.ry) {
	                        arrowLocation.y = height - this.arrowPadding - this.ry;
	                        tipLocation.y = height;
	                    }
	                    if (arrowLocation.y - this.arrowPadding < this.ry) {
	                        arrowLocation.y = (this.arrowPadding) + this.ry;
	                        tipLocation.y = 0;
	                    }
	                }
	            }
	        }
	        else {
	            location = new TooltipLocation(location.x + clipX + markerHeight, location.y + clipY - this.elementSize.height / 2 - (this.padding));
	            arrowLocation.y = tipLocation.y = height / 2;
	            if ((location.x + width + this.arrowPadding > boundsX + bounds.width) || (this.isNegative)) {
	                location.x = (symbolLocation.x > bounds.width + bounds.x ? bounds.width : symbolLocation.x)
	                    + clipX - markerHeight - (width + this.arrowPadding);
	            }
	            if (location.x < boundsX) {
	                location.x = (symbolLocation.x < 0 ? 0 : symbolLocation.x) + clipX + markerHeight;
	            }
	            if ((location.x + width + this.arrowPadding > boundsX + bounds.width)) {
	                location.x = (symbolLocation.x > bounds.width + bounds.x ? bounds.width : symbolLocation.x)
	                    + clipX - markerHeight - (width + this.arrowPadding);
	            }
	            if (location.y <= boundsY) {
	                arrowLocation.y -= (boundsY - location.y);
	                tipLocation.y -= (boundsY - location.y);
	                location.y = boundsY;
	            }
	            if (location.y + height >= boundsY + bounds.height) {
	                arrowLocation.y += ((location.y + height) - (boundsY + bounds.height));
	                tipLocation.y += ((location.y + height) - (boundsY + bounds.height));
	                location.y -= ((location.y + height) - (boundsY + bounds.height));
	            }
	            if (arrowLocation.y + this.arrowPadding > height - this.ry) {
	                arrowLocation.y = height - this.ry - this.arrowPadding;
	                tipLocation.y = height;
	            }
	            if (arrowLocation.y - this.arrowPadding < this.ry) {
	                arrowLocation.y = tipLocation.y = this.ry + this.arrowPadding;
	            }
	            if (this.controlName === 'Chart') {
	                if ((location.y + arrowLocation.y) < this.areaMargin + this.arrowPadding ||
	                    ((bounds.y + bounds.height) - (location.y + arrowLocation.y)) < this.areaMargin + this.arrowPadding) {
	                    this.outOfBounds = true;
	                }
	                if (!withInAreaBounds(location.x, location.y, bounds) || this.outOfBounds) {
	                    this.inverted = !this.inverted;
	                    location = new TooltipLocation(symbolLocation.x + clipX - this.padding - this.elementSize.width / 2, symbolLocation.y + clipY - this.elementSize.height - (2 * this.padding) - markerHeight - this.arrowPadding);
	                    this.revert = true;
	                    tipLocation.x = arrowLocation.x = width / 2;
	                    tipLocation.y = arrowLocation.y = 0;
	                    if (location.y < boundsY || (this.isNegative)) {
	                        location.y = (symbolLocation.y < 0 ? 0 : symbolLocation.y) + markerHeight + clipY;
	                    }
	                    if (location.y + this.arrowPadding + height > boundsY + bounds.height) {
	                        location.y = Math.min(symbolLocation.y, boundsY + bounds.height) + clipY
	                            - this.elementSize.height - (2 * this.padding) - markerHeight - this.arrowPadding;
	                    }
	                    tipLocation.x = width / 2;
	                    if (location.x < boundsX) {
	                        tipLocation.x -= (boundsX - location.x);
	                        arrowLocation.x -= (boundsX - location.x);
	                        location.x = boundsX;
	                    }
	                    if (location.x + width > bounds.width + boundsX) {
	                        arrowLocation.x += ((location.x + width) - (bounds.width + boundsX));
	                        tipLocation.x += ((location.x + width) - (bounds.width + boundsX));
	                        location.x -= ((location.x + width) - (bounds.width + boundsX));
	                    }
	                    if ((this.arrowPadding) + arrowLocation.x > width - this.rx) {
	                        tipLocation.x = width - this.rx - (this.arrowPadding);
	                        arrowLocation.x = width - this.rx - (this.arrowPadding);
	                    }
	                    if (arrowLocation.x - (this.arrowPadding) < this.rx) {
	                        arrowLocation.x = tipLocation.x = this.rx + (this.arrowPadding);
	                    }
	                }
	            }
	        }
	        return new Rect(location.x, location.y, width, height);
	    };
	    Tooltip.prototype.animateTooltipDiv = function (tooltipDiv, rect) {
	        var _this = this;
	        var x = parseFloat(tooltipDiv.style.left);
	        var y = parseFloat(tooltipDiv.style.top);
	        var currenDiff;
	        new Animation$1({}).animate(tooltipDiv, {
	            duration: (this.duration === 0 && animationMode === 'Enable') ? 300 : this.duration,
	            progress: function (args) {
	                currenDiff = (args.timeStamp / args.duration);
	                tooltipDiv.style.animation = null;
	                if ((_this.controlName === 'Chart' && _this.shared) && !_this.enableRTL) {
	                    tooltipDiv.style.transition = 'transform 0.1s';
	                    tooltipDiv.style.transform = 'translate(' + (x + currenDiff * (rect.x - x)) + 'px,' + (y + currenDiff * (rect.y - y)) + 'px)';
	                }
	                else {
	                    tooltipDiv.style.left = (x + currenDiff * (rect.x - x)) + 'px';
	                    tooltipDiv.style.top = (y + currenDiff * (rect.y - y)) + 'px';
	                }
	            },
	            end: function (model) {
	                _this.updateDiv(tooltipDiv, rect.x, rect.y);
	                _this.trigger('animationComplete', { tooltip: _this });
	            }
	        });
	    };
	    Tooltip.prototype.updateDiv = function (tooltipDiv, x, y) {
	        if ((this.controlName === 'Chart' && this.shared && !this.crosshair) && !this.enableRTL) {
	            tooltipDiv.style.transform = 'translate(' + x + 'px,' + y + 'px)';
	        }
	        else {
	            tooltipDiv.style.left = x + 'px';
	            tooltipDiv.style.top = y + 'px';
	        }
	    };
	    Tooltip.prototype.updateTemplateFn = function () {
	        if (this.template) {
	            try {
	                if (typeof this.template !== 'function' && document.querySelectorAll(this.template).length) {
	                    this.templateFn = compile(document.querySelector(this.template).innerHTML.trim());
	                }
	                else {
	                    this.templateFn = compile(this.template);
	                }
	            }
	            catch (e) {
	                this.templateFn = compile(this.template);
	            }
	        }
	    };
	    /** @private */
	    Tooltip.prototype.fadeOut = function () {
	        var _this = this;
	        var tooltipElement = (this.isCanvas && !this.template) ? getElement$1(this.element.id + '_svg') :
	            getElement$1(this.element.id);
	        var tooltipDiv = getElement$1(this.element.id);
	        if (tooltipElement) {
	            var tooltipGroup_1 = tooltipElement.firstChild;
	            if (tooltipGroup_1.nodeType !== Node.ELEMENT_NODE) {
	                tooltipGroup_1 = tooltipElement.firstElementChild;
	            }
	            if (this.isCanvas && !this.template) {
	                tooltipGroup_1 = document.getElementById(this.element.id + '_group') ? document.getElementById(this.element.id + '_group') :
	                    tooltipGroup_1;
	            }
	            if (!tooltipGroup_1) {
	                return null;
	            }
	            var opacity_1 = parseFloat(tooltipGroup_1.getAttribute('opacity'));
	            opacity_1 = !isNullOrUndefined(opacity_1) ? opacity_1 : 1;
	            new Animation$1({}).animate(tooltipGroup_1, {
	                duration: 200,
	                progress: function (args) {
	                    //  tooltipGroup.removeAttribute('e-animate');
	                    _this.progressAnimation(tooltipGroup_1, opacity_1, (args.timeStamp / args.duration));
	                },
	                end: function () {
	                    _this.fadeOuted = true;
	                    _this.endAnimation(tooltipGroup_1);
	                    tooltipDiv.style.transition = '';
	                }
	            });
	        }
	    };
	    Tooltip.prototype.progressAnimation = function (tooltipGroup, opacity, timeStamp) {
	        tooltipGroup.style.animation = '';
	        tooltipGroup.setAttribute('opacity', (opacity - timeStamp).toString());
	    };
	    /*
	     * @hidden
	     */
	    Tooltip.prototype.endAnimation = function (tooltipGroup) {
	        tooltipGroup.setAttribute('opacity', '0');
	        if (this.template) {
	            tooltipGroup.style.display = 'none';
	        }
	        this.trigger('animationComplete', { tooltip: this });
	    };
	    /**
	     * Get the properties to be maintained in the persisted state.
	     *
	     * @private
	     */
	    Tooltip.prototype.getPersistData = function () {
	        var keyEntity = [];
	        return this.addOnPersist(keyEntity);
	    };
	    /**
	     * Get component name
	     *
	     *  @private
	     */
	    Tooltip.prototype.getModuleName = function () {
	        return 'tooltip';
	    };
	    /**
	     * To destroy the accumulationcharts
	     *
	     * @private
	     */
	    Tooltip.prototype.destroy = function () {
	        _super.prototype.destroy.call(this);
	        this.element.classList.remove('e-tooltip');
	    };
	    /**
	     * Called internally if any of the property value changed.
	     *
	     * @returns {void}
	     * @private
	     */
	    Tooltip.prototype.onPropertyChanged = function (newProp, oldProp) {
	        if (this.blazorTemplate) {
	            resetBlazorTemplate(this.element.id + 'parent_template' + '_blazorTemplate');
	        }
	        this.isFirst = false;
	        this.render();
	    };
	    __decorate$6([
	        Property(false)
	    ], Tooltip.prototype, "enable", void 0);
	    __decorate$6([
	        Property(false)
	    ], Tooltip.prototype, "shared", void 0);
	    __decorate$6([
	        Property(false)
	    ], Tooltip.prototype, "crosshair", void 0);
	    __decorate$6([
	        Property(false)
	    ], Tooltip.prototype, "enableShadow", void 0);
	    __decorate$6([
	        Property(null)
	    ], Tooltip.prototype, "fill", void 0);
	    __decorate$6([
	        Property('')
	    ], Tooltip.prototype, "header", void 0);
	    __decorate$6([
	        Property(0.75)
	    ], Tooltip.prototype, "opacity", void 0);
	    __decorate$6([
	        Complex({ size: '12px', fontWeight: '400', color: null, fontStyle: 'Normal', fontFamily: null }, TextStyle)
	    ], Tooltip.prototype, "textStyle", void 0);
	    __decorate$6([
	        Property(null)
	    ], Tooltip.prototype, "template", void 0);
	    __decorate$6([
	        Property(true)
	    ], Tooltip.prototype, "enableAnimation", void 0);
	    __decorate$6([
	        Property(300)
	    ], Tooltip.prototype, "duration", void 0);
	    __decorate$6([
	        Property(false)
	    ], Tooltip.prototype, "inverted", void 0);
	    __decorate$6([
	        Property(false)
	    ], Tooltip.prototype, "isNegative", void 0);
	    __decorate$6([
	        Complex({ color: null, width: null }, TooltipBorder)
	    ], Tooltip.prototype, "border", void 0);
	    __decorate$6([
	        Property([])
	    ], Tooltip.prototype, "content", void 0);
	    __decorate$6([
	        Property(10)
	    ], Tooltip.prototype, "markerSize", void 0);
	    __decorate$6([
	        Complex({ x: 0, y: 0 }, ToolLocation)
	    ], Tooltip.prototype, "clipBounds", void 0);
	    __decorate$6([
	        Property([])
	    ], Tooltip.prototype, "palette", void 0);
	    __decorate$6([
	        Property([])
	    ], Tooltip.prototype, "shapes", void 0);
	    __decorate$6([
	        Complex({ x: 0, y: 0 }, ToolLocation)
	    ], Tooltip.prototype, "location", void 0);
	    __decorate$6([
	        Property(0)
	    ], Tooltip.prototype, "offset", void 0);
	    __decorate$6([
	        Property(4)
	    ], Tooltip.prototype, "rx", void 0);
	    __decorate$6([
	        Property(4)
	    ], Tooltip.prototype, "ry", void 0);
	    __decorate$6([
	        Property(5)
	    ], Tooltip.prototype, "marginX", void 0);
	    __decorate$6([
	        Property(5)
	    ], Tooltip.prototype, "marginY", void 0);
	    __decorate$6([
	        Property(7)
	    ], Tooltip.prototype, "arrowPadding", void 0);
	    __decorate$6([
	        Property(null)
	    ], Tooltip.prototype, "data", void 0);
	    __decorate$6([
	        Property('Material')
	    ], Tooltip.prototype, "theme", void 0);
	    __decorate$6([
	        Complex({ x: 0, y: 0, width: 0, height: 0 }, AreaBounds)
	    ], Tooltip.prototype, "areaBounds", void 0);
	    __decorate$6([
	        Property(null)
	    ], Tooltip.prototype, "availableSize", void 0);
	    __decorate$6([
	        Property()
	    ], Tooltip.prototype, "blazorTemplate", void 0);
	    __decorate$6([
	        Property(false)
	    ], Tooltip.prototype, "isCanvas", void 0);
	    __decorate$6([
	        Property(false)
	    ], Tooltip.prototype, "isTextWrap", void 0);
	    __decorate$6([
	        Property(null)
	    ], Tooltip.prototype, "tooltipPlacement", void 0);
	    __decorate$6([
	        Property(null)
	    ], Tooltip.prototype, "controlInstance", void 0);
	    __decorate$6([
	        Property('')
	    ], Tooltip.prototype, "controlName", void 0);
	    __decorate$6([
	        Event()
	    ], Tooltip.prototype, "tooltipRender", void 0);
	    __decorate$6([
	        Event()
	    ], Tooltip.prototype, "loaded", void 0);
	    __decorate$6([
	        Event()
	    ], Tooltip.prototype, "animationComplete", void 0);
	    __decorate$6([
	        Property(false)
	    ], Tooltip.prototype, "enableRTL", void 0);
	    __decorate$6([
	        Property(false)
	    ], Tooltip.prototype, "allowHighlight", void 0);
	    Tooltip = __decorate$6([
	        NotifyPropertyChanges
	    ], Tooltip);
	    return Tooltip;
	}(Component));

	/* eslint-disable jsdoc/require-returns */
	/**
	 * Numeric Range.
	 *
	 * @private
	 */
	var DoubleRange = /** @class */ (function () {
	    function DoubleRange(start, end) {
	        /*
	          if (!isNaN(start) && !isNaN(end)) {
	           this.mIsEmpty = true;
	          } else {
	              this.mIsEmpty = false;
	          }*/
	        if (start < end) {
	            this.mStart = start;
	            this.mEnd = end;
	        }
	        else {
	            this.mStart = end;
	            this.mEnd = start;
	        }
	    }
	    Object.defineProperty(DoubleRange.prototype, "start", {
	        //private mIsEmpty: boolean;
	        /** @private */
	        get: function () {
	            return this.mStart;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DoubleRange.prototype, "end", {
	        /** @private */
	        get: function () {
	            return this.mEnd;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DoubleRange.prototype, "delta", {
	        /*
	          get isEmpty(): boolean {
	             return this.mIsEmpty;
	         }*/
	        /** @private */
	        get: function () {
	            return (this.mEnd - this.mStart);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DoubleRange.prototype, "median", {
	        /** @private */
	        get: function () {
	            return this.mStart + (this.mEnd - this.mStart) / 2;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return DoubleRange;
	}());

	/**
	 * Numeric module is used to render numeric axis.
	 */
	var Double = /** @class */ (function () {
	    /**
	     * Constructor for the dateTime module.
	     *
	     * @private
	     */
	    function Double(chart) {
	        this.isColumn = 0;
	        this.isStacking = false;
	        this.chart = chart;
	    }
	    /**
	     * Numeric Nice Interval for the axis.
	     *
	     * @private
	     */
	    Double.prototype.calculateNumericNiceInterval = function (axis, delta, size) {
	        var actualDesiredIntervalsCount = getActualDesiredIntervalsCount(size, axis);
	        var niceInterval = delta / actualDesiredIntervalsCount;
	        if (!isNullOrUndefined(axis.desiredIntervals)) {
	            if (this.isAutoIntervalOnBothAxis(axis)) {
	                return niceInterval;
	            }
	        }
	        var minInterval = Math.pow(10, Math.floor(logBase(niceInterval, 10)));
	        for (var _i = 0, _a = axis.intervalDivs; _i < _a.length; _i++) {
	            var interval = _a[_i];
	            var currentInterval = minInterval * interval;
	            if (actualDesiredIntervalsCount < (delta / currentInterval)) {
	                break;
	            }
	            niceInterval = currentInterval;
	        }
	        return niceInterval;
	    };
	    /**
	     * Actual Range for the axis.
	     *
	     * @private
	     */
	    Double.prototype.isAutoIntervalOnBothAxis = function (axis) {
	        if (((axis.zoomFactor < 1 || axis.zoomPosition > 0) && axis.enableAutoIntervalOnZooming)) {
	            return false;
	        }
	        else {
	            return true;
	        }
	    };
	    Double.prototype.getActualRange = function (axis, size) {
	        this.initializeDoubleRange(axis);
	        if ((!axis.startFromZero) && (this.isColumn > 0)) {
	            axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);
	            axis.actualRange.max = axis.doubleRange.end + axis.actualRange.interval;
	            if ((axis.doubleRange.start - axis.actualRange.interval < 0 && axis.doubleRange.start > 0)) {
	                axis.actualRange.min = 0;
	            }
	            else {
	                axis.actualRange.min = axis.doubleRange.start - (this.isStacking ? 0 : axis.actualRange.interval);
	            }
	        }
	        else {
	            axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);
	            axis.actualRange.min = axis.doubleRange.start;
	            axis.actualRange.max = axis.doubleRange.end;
	        }
	    };
	    /**
	     * Range for the axis.
	     *
	     * @private
	     */
	    Double.prototype.initializeDoubleRange = function (axis) {
	        //Axis Min
	        if (axis.minimum !== null) {
	            this.min = axis.minimum;
	        }
	        else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {
	            this.min = 0;
	        }
	        // Axis Max
	        if (axis.maximum !== null) {
	            this.max = axis.maximum;
	        }
	        else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {
	            this.max = 5;
	        }
	        if (this.min === this.max) {
	            this.max = axis.valueType.indexOf('Category') > -1 ? this.max : this.min + 1;
	        }
	        axis.doubleRange = new DoubleRange(this.min, this.max);
	        axis.actualRange = {};
	    };
	    /**
	     * The function to calculate the range and labels for the axis.
	     *
	     * @returns {void}
	     * @private
	     */
	    Double.prototype.calculateRangeAndInterval = function (size, axis) {
	        this.calculateRange(axis);
	        this.getActualRange(axis, size);
	        this.applyRangePadding(axis, size);
	        this.calculateVisibleLabels(axis, this.chart);
	    };
	    /**
	     * Calculate Range for the axis.
	     *
	     * @private
	     */
	    Double.prototype.calculateRange = function (axis) {
	        /*! Generate axis range */
	        this.min = null;
	        this.max = null;
	        if (!setRange(axis)) {
	            for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {
	                var series = _a[_i];
	                if (!series.visible) {
	                    continue;
	                }
	                this.paddingInterval = 0;
	                if (!isNullOrUndefined(series.points)) {
	                    axis.maxPointLength = series.points.length;
	                }
	                axis.maxPointLength = series.points.length;
	                if (((series.type.indexOf('Column') > -1 || series.type.indexOf('Histogram') > -1) && axis.orientation === 'Horizontal')
	                    || (series.type.indexOf('Bar') > -1 && axis.orientation === 'Vertical')) {
	                    if ((series.xAxis.valueType === 'Double' || series.xAxis.valueType === 'DateTime')
	                        && series.xAxis.rangePadding === 'Auto') {
	                        this.paddingInterval = getMinPointsDelta(series.xAxis, axis.series) * 0.5;
	                    }
	                }
	                //For xRange
	                if (axis.orientation === 'Horizontal') {
	                    if (this.chart.requireInvertedAxis) {
	                        this.yAxisRange(axis, series);
	                    }
	                    else {
	                        this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);
	                    }
	                }
	                // For yRange
	                if (axis.orientation === 'Vertical') {
	                    this.isColumn += (series.type.indexOf('Column') !== -1 || series.type.indexOf('Bar') !== -1 || series.drawType === 'Column') ? 1 : 0;
	                    this.isStacking = series.type.indexOf('Stacking') !== -1;
	                    if (this.chart.requireInvertedAxis) {
	                        this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);
	                    }
	                    else {
	                        this.yAxisRange(axis, series);
	                    }
	                }
	            }
	        }
	    };
	    Double.prototype.yAxisRange = function (axis, series) {
	        if (series.dragSettings.enable && this.chart.dragY) {
	            if (this.chart.dragY >= axis.visibleRange.max) {
	                series.yMax = this.chart.dragY + axis.visibleRange.interval;
	            }
	            if (this.chart.dragY <= axis.visibleRange.min) {
	                series.yMin = this.chart.dragY - axis.visibleRange.interval;
	            }
	        }
	        this.findMinMax(series.yMin, series.yMax);
	    };
	    Double.prototype.findMinMax = function (min, max) {
	        if (this.min === null || this.min > min) {
	            this.min = min;
	        }
	        if (this.max === null || this.max < max) {
	            this.max = max;
	        }
	        if ((this.max === this.min) && this.max < 0 && this.min < 0) { // max == min
	            this.max = 0;
	        }
	    };
	    /**
	     * Apply padding for the range.
	     *
	     * @private
	     */
	    Double.prototype.applyRangePadding = function (axis, size) {
	        var start = axis.actualRange.min;
	        var end = axis.actualRange.max;
	        if (!setRange(axis)) {
	            var interval = axis.actualRange.interval;
	            var padding = axis.getRangePadding(this.chart);
	            if (padding === 'Additional' || padding === 'Round') {
	                this.findAdditional(axis, start, end, interval, size);
	            }
	            else if (padding === 'Normal') {
	                this.findNormal(axis, start, end, interval, size);
	            }
	            else {
	                this.updateActualRange(axis, start, end, interval);
	            }
	        }
	        axis.actualRange.delta = axis.actualRange.max - axis.actualRange.min;
	        this.calculateVisibleRange(size, axis);
	    };
	    Double.prototype.updateActualRange = function (axis, minimum, maximum, interval) {
	        axis.actualRange = {
	            min: axis.minimum != null ? axis.minimum : minimum,
	            max: axis.maximum != null ? axis.maximum : maximum,
	            interval: axis.interval != null ? axis.interval : interval,
	            delta: axis.actualRange.delta
	        };
	    };
	    Double.prototype.findAdditional = function (axis, start, end, interval, size) {
	        var minimum;
	        var maximum;
	        minimum = Math.floor(start / interval) * interval;
	        maximum = Math.ceil(end / interval) * interval;
	        if (axis.rangePadding === 'Additional') {
	            minimum -= interval;
	            maximum += interval;
	        }
	        if (!isNullOrUndefined(axis.desiredIntervals)) {
	            var delta = maximum - minimum;
	            interval = this.calculateNumericNiceInterval(axis, delta, size);
	        }
	        this.updateActualRange(axis, minimum, maximum, interval);
	    };
	    Double.prototype.findNormal = function (axis, start, end, interval, size) {
	        var remaining;
	        var minimum;
	        var maximum;
	        var startValue = start;
	        if (start < 0) {
	            startValue = 0;
	            minimum = start + (start * 0.05);
	            remaining = interval + (minimum % interval);
	            if ((0.365 * interval) >= remaining) {
	                minimum -= interval;
	            }
	            if (minimum % interval < 0) {
	                minimum = (minimum - interval) - (minimum % interval);
	            }
	        }
	        else {
	            minimum = start < ((5.0 / 6.0) * end) ? 0 : (start - (end - start) * 0.5);
	            if (minimum % interval > 0) {
	                minimum -= (minimum % interval);
	            }
	        }
	        maximum = (end > 0) ? (end + (end - startValue) * 0.05) : (end - (end - startValue) * 0.05);
	        remaining = interval - (maximum % interval);
	        if ((0.365 * interval) >= remaining) {
	            maximum += interval;
	        }
	        if (maximum % interval > 0) {
	            maximum = (maximum + interval) - (maximum % interval);
	        }
	        axis.doubleRange = new DoubleRange(minimum, maximum);
	        if (minimum === 0 || (minimum < 0 && maximum < 0)) {
	            interval = this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);
	            maximum = Math.ceil(maximum / interval) * interval;
	        }
	        this.updateActualRange(axis, minimum, maximum, interval);
	    };
	    /**
	     * Calculate visible range for axis.
	     *
	     * @private
	     */
	    Double.prototype.calculateVisibleRange = function (size, axis) {
	        axis.visibleRange = {
	            max: axis.actualRange.max, min: axis.actualRange.min,
	            delta: axis.actualRange.delta, interval: axis.actualRange.interval
	        };
	        if (this.chart.chartAreaType === 'Cartesian') {
	            var isLazyLoad = isNullOrUndefined(axis.zoomingScrollBar) ? false : axis.zoomingScrollBar.isLazyLoad;
	            if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && !isLazyLoad) {
	                axis.calculateVisibleRangeOnZooming(size);
	                axis.visibleRange.interval = (axis.enableAutoIntervalOnZooming) ?
	                    this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size)
	                    : axis.visibleRange.interval;
	            }
	        }
	        if (axis.maximum && axis.orientation === 'Vertical' && axis.rangePadding === 'Auto') {
	            var duplicateTempInterval = void 0;
	            var tempInterval = axis.visibleRange.min;
	            for (; (tempInterval <= axis.visibleRange.max) && (duplicateTempInterval !== tempInterval); tempInterval += axis.visibleRange.interval) {
	                duplicateTempInterval = tempInterval;
	            }
	            if (duplicateTempInterval < axis.visibleRange.max) {
	                axis.visibleRange.max = duplicateTempInterval + axis.visibleRange.interval;
	            }
	        }
	        axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);
	    };
	    /**
	     * Calculate label for the axis.
	     *
	     * @private
	     */
	    Double.prototype.calculateVisibleLabels = function (axis, chart) {
	        /*! Generate axis labels */
	        axis.visibleLabels = [];
	        var tempInterval = axis.visibleRange.min;
	        var labelStyle;
	        var controlName = chart.getModuleName();
	        var isPolarRadar = controlName === 'chart' && chart.chartAreaType === 'PolarRadar';
	        if (!isPolarRadar && (axis.zoomFactor < 1 || axis.zoomPosition > 0 || this.paddingInterval)) {
	            tempInterval = axis.visibleRange.min - (axis.visibleRange.min % axis.visibleRange.interval);
	        }
	        var format = this.getFormat(axis);
	        var isCustom = format.match('{value}') !== null;
	        var intervalDigits = 0;
	        var formatDigits = 0;
	        if (axis.labelFormat && axis.labelFormat.indexOf('n') > -1) {
	            formatDigits = parseInt(axis.labelFormat.substring(1, axis.labelFormat.length), 10);
	        }
	        axis.format = chart.intl.getNumberFormat({
	            format: isCustom ? '' : format,
	            useGrouping: chart.useGroupingSeparator
	        });
	        axis.startLabel = axis.format(axis.visibleRange.min);
	        axis.endLabel = axis.format(axis.visibleRange.max);
	        if (axis.visibleRange.interval && (axis.visibleRange.interval + '').indexOf('.') >= 0) {
	            intervalDigits = (axis.visibleRange.interval + '').split('.')[1].length;
	        }
	        var duplicateTempInterval;
	        for (; (tempInterval <= axis.visibleRange.max) && (duplicateTempInterval !== tempInterval); tempInterval += axis.visibleRange.interval) {
	            duplicateTempInterval = tempInterval;
	            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));
	            if (withIn(tempInterval, axis.visibleRange)) {
	                triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);
	            }
	        }
	        if (tempInterval && (tempInterval + '').indexOf('.') >= 0 && (tempInterval + '').split('.')[1].length > 10) {
	            tempInterval = (tempInterval + '').split('.')[1].length > (formatDigits || intervalDigits) ?
	                +tempInterval.toFixed(formatDigits || intervalDigits) : tempInterval;
	            if (tempInterval <= axis.visibleRange.max) {
	                triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);
	            }
	        }
	        if (axis.getMaxLabelWidth) {
	            axis.getMaxLabelWidth(this.chart);
	        }
	    };
	    /**
	     * Format of the axis label.
	     *
	     * @private
	     */
	    Double.prototype.getFormat = function (axis) {
	        if (axis.labelFormat) {
	            if (axis.labelFormat.indexOf('p') === 0 && axis.labelFormat.indexOf('{value}') === -1 && axis.isStack100) {
	                return '{value}%';
	            }
	            return axis.labelFormat;
	        }
	        return axis.isStack100 ? '{value}%' : '';
	    };
	    /**
	     * Formatted the axis label.
	     *
	     * @private
	     */
	    Double.prototype.formatValue = function (axis, isCustom, format, tempInterval) {
	        var labelValue = !(tempInterval % 1) ? tempInterval : Number(tempInterval.toLocaleString().split(',').join(''));
	        return isCustom ? format.replace('{value}', axis.format(labelValue))
	            : format ? axis.format(tempInterval) : axis.format(labelValue);
	    };
	    return Double;
	}());

	/**
	 * Specifies the chart constant value
	 */
	/** @private */
	/** @private */
	var legendClick = 'legendClick';
	/** @private */
	var load = 'load';
	/** @private */
	var legendRender = 'legendRender';
	/** @private */
	var textRender = 'textRender';
	/** @private */
	var pointRender = 'pointRender';
	/** @private */
	var sharedTooltipRender = 'sharedTooltipRender';
	/** @private */
	var seriesRender = 'seriesRender';
	/** @private */
	var axisLabelRender = 'axisLabelRender';
	/** @private */
	var axisLabelClick = 'axisLabelClick';
	/** @private */
	var axisRangeCalculated = 'axisRangeCalculated';
	/** @private */
	var tooltipRender = 'tooltipRender';
	/** @private */
	var chartMouseMove = 'chartMouseMove';
	/** @private */
	var chartMouseClick = 'chartMouseClick';
	/** @private */
	var chartDoubleClick = 'chartDoubleClick';
	/** @private */
	var pointClick = 'pointClick';
	/** @private */
	var pointDoubleClick = 'pointDoubleClick';
	/** @private */
	var pointMove = 'pointMove';
	/** @private */
	var chartMouseLeave = 'chartMouseLeave';
	/** @private */
	var chartMouseDown = 'chartMouseDown';
	/** @private */
	var chartMouseUp = 'chartMouseUp';
	/** @private */
	var dragComplete = 'dragComplete';
	/** @private */
	var selectionComplete = 'selectionComplete';
	/** @private */
	var resized = 'resized';
	/** @private */
	var beforeResize = 'beforeResize';
	/** @private */
	var beforePrint = 'beforePrint';
	/*** @private*/
	var regSub = /~\d+~/g;
	/*** @private*/
	var regSup = /\^\d+\^/g;
	/** @private */
	var afterExport = 'afterExport';

	var __extends$z = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	/**
	 * Configures the Annotation for chart.
	 */
	var ChartAnnotationSettings = /** @class */ (function (_super) {
	    __extends$z(ChartAnnotationSettings, _super);
	    function ChartAnnotationSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$5([
	        Property('0')
	    ], ChartAnnotationSettings.prototype, "x", void 0);
	    __decorate$5([
	        Property('0')
	    ], ChartAnnotationSettings.prototype, "y", void 0);
	    __decorate$5([
	        Property(null)
	    ], ChartAnnotationSettings.prototype, "content", void 0);
	    __decorate$5([
	        Property('Center')
	    ], ChartAnnotationSettings.prototype, "horizontalAlignment", void 0);
	    __decorate$5([
	        Property('Pixel')
	    ], ChartAnnotationSettings.prototype, "coordinateUnits", void 0);
	    __decorate$5([
	        Property('Chart')
	    ], ChartAnnotationSettings.prototype, "region", void 0);
	    __decorate$5([
	        Property('Middle')
	    ], ChartAnnotationSettings.prototype, "verticalAlignment", void 0);
	    __decorate$5([
	        Property(null)
	    ], ChartAnnotationSettings.prototype, "xAxisName", void 0);
	    __decorate$5([
	        Property(null)
	    ], ChartAnnotationSettings.prototype, "yAxisName", void 0);
	    __decorate$5([
	        Property(null)
	    ], ChartAnnotationSettings.prototype, "description", void 0);
	    return ChartAnnotationSettings;
	}(ChildProperty));
	/**
	 * label border properties.
	 */
	var LabelBorder = /** @class */ (function (_super) {
	    __extends$z(LabelBorder, _super);
	    function LabelBorder() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$5([
	        Property('')
	    ], LabelBorder.prototype, "color", void 0);
	    __decorate$5([
	        Property(1)
	    ], LabelBorder.prototype, "width", void 0);
	    __decorate$5([
	        Property('Rectangle')
	    ], LabelBorder.prototype, "type", void 0);
	    return LabelBorder;
	}(ChildProperty));
	/**
	 * categories for multi level labels
	 */
	var MultiLevelCategories = /** @class */ (function (_super) {
	    __extends$z(MultiLevelCategories, _super);
	    function MultiLevelCategories() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$5([
	        Property(null)
	    ], MultiLevelCategories.prototype, "start", void 0);
	    __decorate$5([
	        Property(null)
	    ], MultiLevelCategories.prototype, "end", void 0);
	    __decorate$5([
	        Property('')
	    ], MultiLevelCategories.prototype, "text", void 0);
	    __decorate$5([
	        Property(null)
	    ], MultiLevelCategories.prototype, "maximumTextWidth", void 0);
	    __decorate$5([
	        Property(null)
	    ], MultiLevelCategories.prototype, "customAttributes", void 0);
	    __decorate$5([
	        Property('')
	    ], MultiLevelCategories.prototype, "type", void 0);
	    return MultiLevelCategories;
	}(ChildProperty));
	/**
	 * Strip line properties
	 */
	var StripLineSettings = /** @class */ (function (_super) {
	    __extends$z(StripLineSettings, _super);
	    function StripLineSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$5([
	        Property(true)
	    ], StripLineSettings.prototype, "visible", void 0);
	    __decorate$5([
	        Property(false)
	    ], StripLineSettings.prototype, "startFromAxis", void 0);
	    __decorate$5([
	        Property(null)
	    ], StripLineSettings.prototype, "start", void 0);
	    __decorate$5([
	        Property(null)
	    ], StripLineSettings.prototype, "end", void 0);
	    __decorate$5([
	        Property(null)
	    ], StripLineSettings.prototype, "size", void 0);
	    __decorate$5([
	        Property('#808080')
	    ], StripLineSettings.prototype, "color", void 0);
	    __decorate$5([
	        Property(null)
	    ], StripLineSettings.prototype, "dashArray", void 0);
	    __decorate$5([
	        Property('Auto')
	    ], StripLineSettings.prototype, "sizeType", void 0);
	    __decorate$5([
	        Property(false)
	    ], StripLineSettings.prototype, "isRepeat", void 0);
	    __decorate$5([
	        Property(null)
	    ], StripLineSettings.prototype, "repeatEvery", void 0);
	    __decorate$5([
	        Property(null)
	    ], StripLineSettings.prototype, "repeatUntil", void 0);
	    __decorate$5([
	        Property(false)
	    ], StripLineSettings.prototype, "isSegmented", void 0);
	    __decorate$5([
	        Property(null)
	    ], StripLineSettings.prototype, "segmentStart", void 0);
	    __decorate$5([
	        Property(null)
	    ], StripLineSettings.prototype, "segmentEnd", void 0);
	    __decorate$5([
	        Property(null)
	    ], StripLineSettings.prototype, "segmentAxisName", void 0);
	    __decorate$5([
	        Complex({ color: 'transparent', width: 1 }, Border)
	    ], StripLineSettings.prototype, "border", void 0);
	    __decorate$5([
	        Property('')
	    ], StripLineSettings.prototype, "text", void 0);
	    __decorate$5([
	        Property(null)
	    ], StripLineSettings.prototype, "rotation", void 0);
	    __decorate$5([
	        Property('Middle')
	    ], StripLineSettings.prototype, "horizontalAlignment", void 0);
	    __decorate$5([
	        Property('Middle')
	    ], StripLineSettings.prototype, "verticalAlignment", void 0);
	    __decorate$5([
	        Complex({ size: '12px', color: null, fontStyle: 'Normal', fontWeight: '400', fontFamily: null }, Font)
	    ], StripLineSettings.prototype, "textStyle", void 0);
	    __decorate$5([
	        Property('Behind')
	    ], StripLineSettings.prototype, "zIndex", void 0);
	    __decorate$5([
	        Property(1)
	    ], StripLineSettings.prototype, "opacity", void 0);
	    __decorate$5([
	        Property('')
	    ], StripLineSettings.prototype, "imageUrl", void 0);
	    return StripLineSettings;
	}(ChildProperty));
	/**
	 * MultiLevelLabels properties
	 */
	var MultiLevelLabels = /** @class */ (function (_super) {
	    __extends$z(MultiLevelLabels, _super);
	    function MultiLevelLabels() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$5([
	        Property('Center')
	    ], MultiLevelLabels.prototype, "alignment", void 0);
	    __decorate$5([
	        Property('Wrap')
	    ], MultiLevelLabels.prototype, "overflow", void 0);
	    __decorate$5([
	        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
	    ], MultiLevelLabels.prototype, "textStyle", void 0);
	    __decorate$5([
	        Complex({ color: null, width: 1, type: 'Rectangle' }, LabelBorder)
	    ], MultiLevelLabels.prototype, "border", void 0);
	    __decorate$5([
	        Collection([], MultiLevelCategories)
	    ], MultiLevelLabels.prototype, "categories", void 0);
	    return MultiLevelLabels;
	}(ChildProperty));
	/**
	 * Specifies range for scrollbarSettings property
	 *
	 * @public
	 */
	var ScrollbarSettingsRange = /** @class */ (function (_super) {
	    __extends$z(ScrollbarSettingsRange, _super);
	    function ScrollbarSettingsRange() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$5([
	        Property(null)
	    ], ScrollbarSettingsRange.prototype, "minimum", void 0);
	    __decorate$5([
	        Property(null)
	    ], ScrollbarSettingsRange.prototype, "maximum", void 0);
	    return ScrollbarSettingsRange;
	}(ChildProperty));
	/**
	 * Scrollbar Settings Properties for Lazy Loading
	 */
	var ScrollbarSettings = /** @class */ (function (_super) {
	    __extends$z(ScrollbarSettings, _super);
	    function ScrollbarSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$5([
	        Property(false)
	    ], ScrollbarSettings.prototype, "enable", void 0);
	    __decorate$5([
	        Property(null)
	    ], ScrollbarSettings.prototype, "pointsLength", void 0);
	    __decorate$5([
	        Complex({}, ScrollbarSettingsRange)
	    ], ScrollbarSettings.prototype, "range", void 0);
	    __decorate$5([
	        Property(null)
	    ], ScrollbarSettings.prototype, "trackColor", void 0);
	    __decorate$5([
	        Property(0)
	    ], ScrollbarSettings.prototype, "scrollbarRadius", void 0);
	    __decorate$5([
	        Property(null)
	    ], ScrollbarSettings.prototype, "scrollbarColor", void 0);
	    __decorate$5([
	        Property(0)
	    ], ScrollbarSettings.prototype, "trackRadius", void 0);
	    __decorate$5([
	        Property(null)
	    ], ScrollbarSettings.prototype, "gripColor", void 0);
	    __decorate$5([
	        Property(16)
	    ], ScrollbarSettings.prototype, "height", void 0);
	    __decorate$5([
	        Property(true)
	    ], ScrollbarSettings.prototype, "enableZoom", void 0);
	    return ScrollbarSettings;
	}(ChildProperty));

	var __extends$y = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	/**
	 * Configures the `rows` of the chart.
	 */
	var Row = /** @class */ (function (_super) {
	    __extends$y(Row, _super);
	    function Row() {
	        /**
	         * The height of the row as a string accept input both as '100px' and '100%'.
	         * If specified as '100%, row renders to the full height of its chart.
	         *
	         * @default '100%'
	         */
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /** @private */
	        _this.axes = [];
	        /** @private */
	        _this.nearSizes = [];
	        /** @private */
	        _this.farSizes = [];
	        /** @private */
	        _this.insideFarSizes = [];
	        /** @private */
	        _this.insideNearSizes = [];
	        return _this;
	    }
	    /**
	     * Measure the row size
	     *
	     * @returns {void}
	     * @private
	     */
	    Row.prototype.computeSize = function (axis, scrollBarHeight, definition, chart) {
	        var width = 0;
	        var innerPadding = (axis.labelPosition === 'Inside' && (chart.axes.indexOf(axis) > -1)) ? -5 : 5;
	        if (axis.visible && axis.internalVisibility) {
	            width += (axis.findTickSize(axis.crossInAxis) + scrollBarHeight +
	                axis.findLabelSize(axis.crossInAxis, innerPadding, definition, chart) + axis.lineStyle.width * 0.5);
	        }
	        if (axis.isAxisOpposedPosition) {
	            this.farSizes.push(width);
	        }
	        else {
	            this.nearSizes.push(width);
	        }
	    };
	    __decorate$4([
	        Property('100%')
	    ], Row.prototype, "height", void 0);
	    __decorate$4([
	        Complex({}, Border)
	    ], Row.prototype, "border", void 0);
	    return Row;
	}(ChildProperty));
	/**
	 * Configures the `columns` of the chart.
	 */
	var Column = /** @class */ (function (_super) {
	    __extends$y(Column, _super);
	    function Column() {
	        /**
	         * The width of the column as a string accepts input both as like '100px' or '100%'.
	         * If specified as '100%, column renders to the full width of its chart.
	         *
	         * @default '100%'
	         */
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /** @private */
	        _this.axes = [];
	        /** @private */
	        _this.nearSizes = [];
	        /** @private */
	        _this.farSizes = [];
	        /** @private */
	        _this.insideFarSizes = [];
	        /** @private */
	        _this.insideNearSizes = [];
	        /** @private */
	        _this.padding = 0;
	        return _this;
	    }
	    /**
	     * Measure the column size
	     *
	     * @returns {void}
	     * @private
	     */
	    Column.prototype.computeSize = function (axis, scrollBarHeight, definition, chart) {
	        var height = 0;
	        var innerPadding = 5;
	        if (axis.visible && axis.internalVisibility) {
	            height += (axis.findTickSize(axis.crossInAxis) + scrollBarHeight +
	                axis.findLabelSize(axis.crossInAxis, innerPadding, definition, chart) + axis.lineStyle.width * 0.5);
	        }
	        if (axis.isAxisOpposedPosition) {
	            this.farSizes.push(height);
	        }
	        else {
	            this.nearSizes.push(height);
	        }
	    };
	    __decorate$4([
	        Property('100%')
	    ], Column.prototype, "width", void 0);
	    __decorate$4([
	        Complex({}, Border)
	    ], Column.prototype, "border", void 0);
	    return Column;
	}(ChildProperty));
	/**
	 * Configures the major grid lines in the `axis`.
	 */
	var MajorGridLines = /** @class */ (function (_super) {
	    __extends$y(MajorGridLines, _super);
	    function MajorGridLines() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$4([
	        Property(1)
	    ], MajorGridLines.prototype, "width", void 0);
	    __decorate$4([
	        Property('')
	    ], MajorGridLines.prototype, "dashArray", void 0);
	    __decorate$4([
	        Property(null)
	    ], MajorGridLines.prototype, "color", void 0);
	    return MajorGridLines;
	}(ChildProperty));
	/**
	 * Configures the minor grid lines in the `axis`.
	 */
	var MinorGridLines = /** @class */ (function (_super) {
	    __extends$y(MinorGridLines, _super);
	    function MinorGridLines() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$4([
	        Property(0.7)
	    ], MinorGridLines.prototype, "width", void 0);
	    __decorate$4([
	        Property('')
	    ], MinorGridLines.prototype, "dashArray", void 0);
	    __decorate$4([
	        Property(null)
	    ], MinorGridLines.prototype, "color", void 0);
	    return MinorGridLines;
	}(ChildProperty));
	/**
	 * Configures the axis line of a chart.
	 */
	var AxisLine = /** @class */ (function (_super) {
	    __extends$y(AxisLine, _super);
	    function AxisLine() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$4([
	        Property(1)
	    ], AxisLine.prototype, "width", void 0);
	    __decorate$4([
	        Property('')
	    ], AxisLine.prototype, "dashArray", void 0);
	    __decorate$4([
	        Property(null)
	    ], AxisLine.prototype, "color", void 0);
	    return AxisLine;
	}(ChildProperty));
	/**
	 * Configures the major tick lines.
	 */
	var MajorTickLines = /** @class */ (function (_super) {
	    __extends$y(MajorTickLines, _super);
	    function MajorTickLines() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$4([
	        Property(1)
	    ], MajorTickLines.prototype, "width", void 0);
	    __decorate$4([
	        Property(5)
	    ], MajorTickLines.prototype, "height", void 0);
	    __decorate$4([
	        Property(null)
	    ], MajorTickLines.prototype, "color", void 0);
	    return MajorTickLines;
	}(ChildProperty));
	/**
	 * Configures the minor tick lines.
	 */
	var MinorTickLines = /** @class */ (function (_super) {
	    __extends$y(MinorTickLines, _super);
	    function MinorTickLines() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$4([
	        Property(0.7)
	    ], MinorTickLines.prototype, "width", void 0);
	    __decorate$4([
	        Property(5)
	    ], MinorTickLines.prototype, "height", void 0);
	    __decorate$4([
	        Property(null)
	    ], MinorTickLines.prototype, "color", void 0);
	    return MinorTickLines;
	}(ChildProperty));
	/**
	 * Configures the crosshair ToolTip.
	 */
	var CrosshairTooltip = /** @class */ (function (_super) {
	    __extends$y(CrosshairTooltip, _super);
	    function CrosshairTooltip() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$4([
	        Property(false)
	    ], CrosshairTooltip.prototype, "enable", void 0);
	    __decorate$4([
	        Property(null)
	    ], CrosshairTooltip.prototype, "fill", void 0);
	    __decorate$4([
	        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
	    ], CrosshairTooltip.prototype, "textStyle", void 0);
	    return CrosshairTooltip;
	}(ChildProperty));
	/**
	 * Configures the axes in the chart.
	 *
	 * @public
	 */
	var Axis = /** @class */ (function (_super) {
	    __extends$y(Axis, _super);
	    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
	    function Axis(parent, propName, defaultValue, isArray) {
	        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
	        /** @private */
	        _this.visibleLabels = [];
	        /** @private */
	        _this.series = [];
	        /** @private */
	        _this.rect = new Rect(undefined, undefined, 0, 0);
	        /** @private */
	        _this.axisBottomLine = null;
	        /** @private */
	        _this.intervalDivs = [10, 5, 2, 1];
	        /** @private */
	        _this.isStack100 = false;
	        /** @private */
	        _this.crossAt = null;
	        /** @private */
	        _this.updatedRect = null;
	        /** @private */
	        _this.multiLevelLabelHeight = 0;
	        /** @private */
	        _this.isChart = true;
	        /** @private */
	        _this.isIntervalInDecimal = true;
	        /** @private */
	        _this.titleCollection = [];
	        /** @private */
	        _this.titleSize = new Size(0, 0);
	        /**
	         * Task: BLAZ-2044
	         * This property used to hide the axis when series hide from legend click
	         *
	         * @private
	         */
	        _this.internalVisibility = true;
	        /**
	         * This property is used to place the vertical axis in opposed position and horizontal axis in inversed
	         * when RTL is enabled in chart
	         *
	         * @private */
	        _this.isRTLEnabled = false;
	        _this.angle = _this.labelRotation;
	        return _this;
	    }
	    /**
	     * The function used to find tick size.
	     *
	     * @returns {number} tick line size
	     * @private
	     */
	    Axis.prototype.findTickSize = function (crossAxis) {
	        if (this.tickPosition === 'Inside') {
	            return 0;
	        }
	        if (crossAxis && (!crossAxis.visibleRange || this.isInside(crossAxis.visibleRange))) {
	            return 0;
	        }
	        return this.majorTickLines.height;
	    };
	    /**
	     * The function used to find axis position.
	     *
	     * @returns {number}
	     * @private
	     */
	    Axis.prototype.isInside = function (range) {
	        return (inside(this.crossAt, range) ||
	            (!this.isAxisOpposedPosition && this.crossAt >= range.max) || (this.isAxisOpposedPosition && this.crossAt <= range.min));
	    };
	    /**
	     * The function used to find label Size.
	     *
	     * @returns {number} labelSize
	     * @private
	     */
	    Axis.prototype.findLabelSize = function (crossAxis, innerPadding, definition, chart) {
	        var titleSize = 0;
	        var isHorizontal = this.orientation === 'Horizontal';
	        if (this.title) {
	            var angle = this.titleRotation;
	            if ((isNullOrUndefined(angle))) {
	                this.titleSize = measureText(this.title, this.titleStyle, chart.themeStyle.axisTitleFont);
	                titleSize = this.titleSize.height + innerPadding;
	            }
	            else {
	                this.titleSize = rotateTextSize(this.titleStyle, this.title, angle, chart);
	                titleSize = (this.orientation === 'Vertical' ? this.titleSize.width : this.titleSize.height) + innerPadding;
	            }
	            if (this.rect.width || this.rect.height) {
	                var length_1 = isHorizontal ? this.rect.width : this.rect.height;
	                this.titleCollection = getTitle(this.title, this.titleStyle, length_1, chart.themeStyle.legendLabelFont);
	                titleSize = (titleSize * this.titleCollection.length);
	            }
	        }
	        var diff;
	        var value;
	        var labelSize = titleSize + innerPadding + this.titlePadding + this.labelPadding +
	            ((this.orientation === 'Vertical') ? this.maxLabelSize.width : this.maxLabelSize.height) + this.multiLevelLabelHeight;
	        if (crossAxis && this.placeNextToAxisLine) {
	            var range = crossAxis.visibleRange;
	            var size = (crossAxis.orientation === 'Horizontal') ? crossAxis.rect.width : crossAxis.rect.height;
	            if (!range || !size) {
	                return 0;
	            }
	            else if (this.isInside(range)) {
	                value = this.findDifference(crossAxis);
	                diff = (value) * (size / range.delta);
	                diff = (value) * ((size - (diff < labelSize ? (labelSize - diff) : 0)) / range.delta);
	                labelSize = (diff < labelSize) ? (labelSize - diff) : 0;
	            }
	        }
	        if (this.isAxisOpposedPosition) {
	            definition.insideFarSizes.push(labelSize);
	        }
	        else {
	            definition.insideNearSizes.push(labelSize);
	        }
	        if (this.labelPosition === 'Inside') {
	            return titleSize + innerPadding;
	        }
	        return labelSize;
	    };
	    /**
	     * The function used to find axis position.
	     *
	     * @returns {void}
	     * @private
	     */
	    Axis.prototype.updateCrossValue = function () {
	        var value = this.crossAt;
	        if (value === null || !this.isInside(this.crossInAxis.visibleRange)) {
	            this.updatedRect = this.rect;
	            return null;
	        }
	        var range = this.crossInAxis.visibleRange;
	        if (!this.isAxisOpposedPosition) {
	            if (this.crossAt > range.max) {
	                value = range.max;
	            }
	        }
	        else {
	            if (this.crossAt < range.min) {
	                value = range.min;
	            }
	        }
	        this.updatedRect = extend({}, this.rect, null, true);
	        if (this.orientation === 'Horizontal') {
	            value = this.crossInAxis.rect.height - (valueToCoefficient(value, this.crossInAxis) * this.crossInAxis.rect.height);
	            this.updatedRect.y = this.crossInAxis.rect.y + value;
	        }
	        else {
	            value = valueToCoefficient(value, this.crossInAxis) * this.crossInAxis.rect.width;
	            this.updatedRect.x = this.crossInAxis.rect.x + value;
	        }
	    };
	    Axis.prototype.findDifference = function (crossAxis) {
	        var value = 0;
	        if (this.isAxisOpposedPosition) {
	            value = crossAxis.isAxisInverse ? crossAxis.visibleRange.min : crossAxis.visibleRange.max;
	        }
	        else {
	            value = crossAxis.isAxisInverse ? crossAxis.visibleRange.max : crossAxis.visibleRange.min;
	        }
	        return Math.abs(this.crossAt - value);
	    };
	    /**
	     * Calculate visible range for axis.
	     *
	     * @returns {void}
	     * @private
	     */
	    Axis.prototype.calculateVisibleRangeOnZooming = function (size) {
	        if (isZoomSet(this)) {
	            var baseRange = this.actualRange;
	            var start = void 0;
	            var end = void 0;
	            if (!this.isAxisInverse) {
	                start = this.actualRange.min + this.zoomPosition * this.actualRange.delta;
	                end = start + this.zoomFactor * this.actualRange.delta;
	            }
	            else {
	                start = this.actualRange.max - (this.zoomPosition * this.actualRange.delta);
	                end = start - (this.zoomFactor * this.actualRange.delta);
	            }
	            if (start < baseRange.min) {
	                end = end + (baseRange.min - start);
	                start = baseRange.min;
	            }
	            if (end > baseRange.max) {
	                start = start - (end - baseRange.max);
	                end = baseRange.max;
	            }
	            this.doubleRange = new DoubleRange(start, end);
	            this.visibleRange = { min: this.doubleRange.start, max: this.doubleRange.end,
	                delta: this.doubleRange.delta, interval: this.visibleRange.interval };
	        }
	    };
	    /**
	     * Triggers the event.
	     *
	     * @returns {void}
	     * @private
	     */
	    Axis.prototype.triggerRangeRender = function (chart, minimum, maximum, interval) {
	        var argsData = {
	            cancel: false, name: axisRangeCalculated, axis: this,
	            minimum: minimum, maximum: maximum, interval: interval
	        };
	        chart.trigger(axisRangeCalculated, argsData);
	        if (!argsData.cancel) {
	            this.visibleRange = { min: argsData.minimum, max: argsData.maximum, interval: argsData.interval,
	                delta: argsData.maximum - argsData.minimum };
	        }
	    };
	    /**
	     * Calculate padding for the axis.
	     *
	     * @returns {string}
	     * @private
	     */
	    Axis.prototype.getRangePadding = function (chart) {
	        var padding = this.rangePadding;
	        if (padding !== 'Auto') {
	            return padding;
	        }
	        switch (this.orientation) {
	            case 'Horizontal':
	                if (chart.requireInvertedAxis) {
	                    padding = (this.isStack100 || this.baseModule.chart.stockChart ? 'Round' : 'Normal');
	                }
	                else {
	                    padding = 'None';
	                }
	                break;
	            case 'Vertical':
	                if (!chart.requireInvertedAxis) {
	                    padding = (this.isStack100 || this.baseModule.chart.stockChart ? 'Round' : 'Normal');
	                }
	                else {
	                    padding = 'None';
	                }
	                break;
	        }
	        return padding;
	    };
	    /**
	     * Calculate maximum label width for the axis.
	     *
	     * @returns {void}
	     * @private
	     */
	    Axis.prototype.getMaxLabelWidth = function (chart) {
	        var pointX;
	        var previousEnd = 0;
	        var isIntersect = false;
	        var isAxisLabelBreak;
	        this.angle = this.labelRotation;
	        this.maxLabelSize = new Size(0, 0);
	        var action = this.labelIntersectAction;
	        var label;
	        for (var i = 0, len = this.visibleLabels.length; i < len; i++) {
	            label = this.visibleLabels[i];
	            isAxisLabelBreak = isBreakLabel(label.originalText);
	            if (isAxisLabelBreak) {
	                label.size = measureText(label.originalText.replace(/<br>/g, ' '), this.labelStyle, chart.themeStyle.axisLabelFont);
	                label.breakLabelSize = measureText(this.enableTrim ? label.text.join('<br>') : label.originalText, this.labelStyle, chart.themeStyle.axisLabelFont);
	            }
	            else {
	                label.size = measureText(label.text, this.labelStyle, chart.themeStyle.axisLabelFont);
	            }
	            var width = isAxisLabelBreak ? label.breakLabelSize.width : label.size.width;
	            if (width > this.maxLabelSize.width) {
	                this.maxLabelSize.width = width;
	                this.rotatedLabel = label.text;
	            }
	            var height = isAxisLabelBreak ? label.breakLabelSize.height : label.size.height;
	            if (height > this.maxLabelSize.height) {
	                this.maxLabelSize.height = height;
	            }
	            if (isAxisLabelBreak) {
	                label.text = this.enableTrim ? label.text : label.originalText.split('<br>');
	            }
	            if (action === 'None' || action === 'Hide' || action === 'Trim') {
	                continue;
	            }
	            if ((action !== 'None' || this.angle % 360 === 0) && this.orientation === 'Horizontal' &&
	                this.rect.width > 0 && !isIntersect) {
	                var width1 = isAxisLabelBreak ? label.breakLabelSize.width : label.size.width;
	                pointX = (valueToCoefficient(label.value, this) * this.rect.width) + this.rect.x;
	                pointX -= width1 / 2;
	                if (this.edgeLabelPlacement === 'Shift') {
	                    if (i === 0 && pointX < this.rect.x) {
	                        pointX = this.rect.x;
	                    }
	                    if (i === this.visibleLabels.length - 1 && ((pointX + width1) > (this.rect.x + this.rect.width))) {
	                        pointX = this.rect.x + this.rect.width - width1;
	                    }
	                }
	                switch (action) {
	                    case 'MultipleRows':
	                        if (i > 0) {
	                            this.findMultiRows(i, pointX, label, isAxisLabelBreak);
	                        }
	                        break;
	                    case 'Rotate45':
	                    case 'Rotate90':
	                        if (i > 0 && (!this.isAxisInverse ? pointX <= previousEnd : pointX + width1 >= previousEnd)) {
	                            this.angle = (action === 'Rotate45') ? 45 : 90;
	                            isIntersect = true;
	                        }
	                        break;
	                    default:
	                        if (isAxisLabelBreak) {
	                            var result = void 0;
	                            var result1 = [];
	                            var str = void 0;
	                            for (var index = 0; index < label.text.length; index++) {
	                                result = textWrap(label.text[index], this.rect.width / this.visibleLabels.length, this.labelStyle, null, null, chart.themeStyle.axisLabelFont);
	                                if (result.length > 1) {
	                                    for (var j = 0; j < result.length; j++) {
	                                        str = result[j];
	                                        result1.push(str);
	                                    }
	                                }
	                                else {
	                                    result1.push(result[0]);
	                                }
	                            }
	                            label.text = result1;
	                        }
	                        else {
	                            label.text = textWrap(label.text, this.rect.width / this.visibleLabels.length, this.labelStyle, null, null, chart.themeStyle.axisLabelFont);
	                        }
	                        // eslint-disable-next-line no-case-declarations
	                        var height_1 = (label.size.height * label.text.length);
	                        if (height_1 > this.maxLabelSize.height) {
	                            this.maxLabelSize.height = height_1;
	                        }
	                        break;
	                }
	                previousEnd = this.isAxisInverse ? pointX : pointX + width1;
	            }
	        }
	        if (this.angle !== 0 && this.orientation === 'Horizontal') {
	            //I264474: Fix for datasource bind im mounted console error ocurred
	            this.rotatedLabel = isNullOrUndefined(this.rotatedLabel) ? '' : this.rotatedLabel;
	            var isHorizontalAngle = this.angle === -360 || this.angle === 0 || this.angle === -180 ||
	                this.angle === 180 || this.angle === 360;
	            // To avoid overlap axis label with chart title or chart legend when it is outside.
	            if (this.labelPosition === 'Outside' && !isHorizontalAngle && isBreakLabel(this.rotatedLabel)) {
	                this.maxLabelSize = new Size(this.maxLabelSize.height, this.maxLabelSize.width);
	            }
	            else if (!chart.stockChart) {
	                this.maxLabelSize = rotateTextSize(this.labelStyle, this.rotatedLabel, this.angle, chart);
	            }
	        }
	        else if (this.angle !== 0 && this.orientation === 'Vertical') {
	            //I264474: Fix for datasource bind im mounted console error ocurred
	            this.rotatedLabel = isNullOrUndefined(this.rotatedLabel) ? '' : this.rotatedLabel;
	            var isHorizontalAngle = this.angle === -360 || this.angle === 0 || this.angle === -180 ||
	                this.angle === 180 || this.angle === 360;
	            // To avoid overlap axis label with chart title or chart legend when it is outside.
	            if (this.labelPosition === 'Outside' && !isHorizontalAngle && isBreakLabel(this.rotatedLabel)) {
	                this.maxLabelSize = new Size(this.maxLabelSize.height, this.maxLabelSize.width);
	            }
	            else if (!chart.stockChart) {
	                this.maxLabelSize = rotateTextSize(this.labelStyle, this.rotatedLabel, this.angle, chart);
	            }
	        }
	        if (chart.multiLevelLabelModule && this.multiLevelLabels.length > 0) {
	            chart.multiLevelLabelModule.getMultilevelLabelsHeight(this);
	        }
	    };
	    /**
	     * Finds the multiple rows for axis.
	     *
	     * @returns {void}
	     */
	    Axis.prototype.findMultiRows = function (length, currentX, currentLabel, isBreakLabels) {
	        var label;
	        var pointX;
	        var width2;
	        var store = [];
	        var isMultiRows;
	        for (var i = length - 1; i >= 0; i--) {
	            label = this.visibleLabels[i];
	            width2 = isBreakLabels ? label.breakLabelSize.width : label.size.width;
	            pointX = (valueToCoefficient(label.value, this) * this.rect.width) + this.rect.x;
	            isMultiRows = !this.isAxisInverse ? currentX < (pointX + width2 * 0.5) :
	                currentX + currentLabel.size.width > (pointX - width2 * 0.5);
	            if (isMultiRows) {
	                store.push(label.index);
	                currentLabel.index = (currentLabel.index > label.index) ? currentLabel.index : label.index + 1;
	            }
	            else {
	                currentLabel.index = store.indexOf(label.index) > -1 ? currentLabel.index : label.index;
	            }
	        }
	        var height = ((isBreakLabels ? currentLabel.breakLabelSize.height : currentLabel.size.height) * currentLabel.index) +
	            (5 * (currentLabel.index - 1));
	        if (height > this.maxLabelSize.height) {
	            this.maxLabelSize.height = height;
	        }
	    };
	    /**
	     * Finds the default module for axis.
	     *
	     * @returns {void}
	     * @private
	     */
	    Axis.prototype.getModule = function (chart) {
	        if (this.valueType === 'Double') {
	            this.baseModule = new Double(chart);
	        }
	        else {
	            this.baseModule = chart[firstToLowerCase(this.valueType) + 'Module'];
	        }
	    };
	    /**
	     * Set the axis `opposedPosition` and `isInversed` properties.
	     *
	     * @returns {void}
	     * @private
	     */
	    Axis.prototype.setIsInversedAndOpposedPosition = function (isPolar) {
	        if (isPolar === void 0) { isPolar = false; }
	        this.isAxisOpposedPosition = this.opposedPosition || (!isPolar && this.isRTLEnabled && this.orientation === 'Vertical');
	        this.isAxisInverse = this.isInversed || (this.isRTLEnabled && this.orientation === 'Horizontal');
	    };
	    __decorate$4([
	        Complex({ fontFamily: null, size: "12px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
	    ], Axis.prototype, "labelStyle", void 0);
	    __decorate$4([
	        Complex({}, CrosshairTooltip)
	    ], Axis.prototype, "crosshairTooltip", void 0);
	    __decorate$4([
	        Property('')
	    ], Axis.prototype, "title", void 0);
	    __decorate$4([
	        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '600', color: null }, Font)
	    ], Axis.prototype, "titleStyle", void 0);
	    __decorate$4([
	        Property('')
	    ], Axis.prototype, "labelFormat", void 0);
	    __decorate$4([
	        Property('')
	    ], Axis.prototype, "skeleton", void 0);
	    __decorate$4([
	        Property('DateTime')
	    ], Axis.prototype, "skeletonType", void 0);
	    __decorate$4([
	        Property('Center')
	    ], Axis.prototype, "lineBreakAlignment", void 0);
	    __decorate$4([
	        Property(0)
	    ], Axis.prototype, "plotOffset", void 0);
	    __decorate$4([
	        Property(null)
	    ], Axis.prototype, "plotOffsetLeft", void 0);
	    __decorate$4([
	        Property(null)
	    ], Axis.prototype, "plotOffsetTop", void 0);
	    __decorate$4([
	        Property(null)
	    ], Axis.prototype, "plotOffsetRight", void 0);
	    __decorate$4([
	        Property(null)
	    ], Axis.prototype, "plotOffsetBottom", void 0);
	    __decorate$4([
	        Property(false)
	    ], Axis.prototype, "isIndexed", void 0);
	    __decorate$4([
	        Property(10)
	    ], Axis.prototype, "logBase", void 0);
	    __decorate$4([
	        Property(0)
	    ], Axis.prototype, "columnIndex", void 0);
	    __decorate$4([
	        Property(0)
	    ], Axis.prototype, "rowIndex", void 0);
	    __decorate$4([
	        Property(1)
	    ], Axis.prototype, "span", void 0);
	    __decorate$4([
	        Property(null)
	    ], Axis.prototype, "desiredIntervals", void 0);
	    __decorate$4([
	        Property(3)
	    ], Axis.prototype, "maximumLabels", void 0);
	    __decorate$4([
	        Property(1)
	    ], Axis.prototype, "zoomFactor", void 0);
	    __decorate$4([
	        Property(0)
	    ], Axis.prototype, "zoomPosition", void 0);
	    __decorate$4([
	        Property(true)
	    ], Axis.prototype, "enableScrollbarOnZooming", void 0);
	    __decorate$4([
	        Property(false)
	    ], Axis.prototype, "opposedPosition", void 0);
	    __decorate$4([
	        Property(true)
	    ], Axis.prototype, "enableAutoIntervalOnZooming", void 0);
	    __decorate$4([
	        Property('Auto')
	    ], Axis.prototype, "rangePadding", void 0);
	    __decorate$4([
	        Property('Double')
	    ], Axis.prototype, "valueType", void 0);
	    __decorate$4([
	        Property('None')
	    ], Axis.prototype, "edgeLabelPlacement", void 0);
	    __decorate$4([
	        Property('Auto')
	    ], Axis.prototype, "intervalType", void 0);
	    __decorate$4([
	        Property('BetweenTicks')
	    ], Axis.prototype, "labelPlacement", void 0);
	    __decorate$4([
	        Property('Outside')
	    ], Axis.prototype, "tickPosition", void 0);
	    __decorate$4([
	        Property('Outside')
	    ], Axis.prototype, "labelPosition", void 0);
	    __decorate$4([
	        Property('')
	    ], Axis.prototype, "name", void 0);
	    __decorate$4([
	        Property(true)
	    ], Axis.prototype, "visible", void 0);
	    __decorate$4([
	        Property(0)
	    ], Axis.prototype, "minorTicksPerInterval", void 0);
	    __decorate$4([
	        Property(0)
	    ], Axis.prototype, "labelRotation", void 0);
	    __decorate$4([
	        Property(null)
	    ], Axis.prototype, "titleRotation", void 0);
	    __decorate$4([
	        Property(null)
	    ], Axis.prototype, "crossesAt", void 0);
	    __decorate$4([
	        Property(true)
	    ], Axis.prototype, "placeNextToAxisLine", void 0);
	    __decorate$4([
	        Property(null)
	    ], Axis.prototype, "crossesInAxis", void 0);
	    __decorate$4([
	        Property(null)
	    ], Axis.prototype, "minimum", void 0);
	    __decorate$4([
	        Property(null)
	    ], Axis.prototype, "maximum", void 0);
	    __decorate$4([
	        Property(null)
	    ], Axis.prototype, "interval", void 0);
	    __decorate$4([
	        Property(34)
	    ], Axis.prototype, "maximumLabelWidth", void 0);
	    __decorate$4([
	        Property(false)
	    ], Axis.prototype, "enableTrim", void 0);
	    __decorate$4([
	        Property(5)
	    ], Axis.prototype, "labelPadding", void 0);
	    __decorate$4([
	        Property(5)
	    ], Axis.prototype, "titlePadding", void 0);
	    __decorate$4([
	        Complex({}, MajorTickLines)
	    ], Axis.prototype, "majorTickLines", void 0);
	    __decorate$4([
	        Complex({}, MinorTickLines)
	    ], Axis.prototype, "minorTickLines", void 0);
	    __decorate$4([
	        Complex({}, MajorGridLines)
	    ], Axis.prototype, "majorGridLines", void 0);
	    __decorate$4([
	        Complex({}, MinorGridLines)
	    ], Axis.prototype, "minorGridLines", void 0);
	    __decorate$4([
	        Complex({}, AxisLine)
	    ], Axis.prototype, "lineStyle", void 0);
	    __decorate$4([
	        Property(Browser.isDevice ? 'Rotate45' : 'Trim')
	    ], Axis.prototype, "labelIntersectAction", void 0);
	    __decorate$4([
	        Property(false)
	    ], Axis.prototype, "isInversed", void 0);
	    __decorate$4([
	        Property(100)
	    ], Axis.prototype, "coefficient", void 0);
	    __decorate$4([
	        Property(0)
	    ], Axis.prototype, "startAngle", void 0);
	    __decorate$4([
	        Property(true)
	    ], Axis.prototype, "startFromZero", void 0);
	    __decorate$4([
	        Property(null)
	    ], Axis.prototype, "description", void 0);
	    __decorate$4([
	        Property(2)
	    ], Axis.prototype, "tabIndex", void 0);
	    __decorate$4([
	        Collection([], StripLineSettings)
	    ], Axis.prototype, "stripLines", void 0);
	    __decorate$4([
	        Collection([], MultiLevelLabels)
	    ], Axis.prototype, "multiLevelLabels", void 0);
	    __decorate$4([
	        Complex({ color: null, width: 0, type: 'Rectangle' }, LabelBorder)
	    ], Axis.prototype, "border", void 0);
	    __decorate$4([
	        Complex({}, ScrollbarSettings)
	    ], Axis.prototype, "scrollbarSettings", void 0);
	    return Axis;
	}(ChildProperty));
	/** @private */
	var VisibleLabels = /** @class */ (function () {
	    function VisibleLabels(text, value, labelStyle, originalText, size, breakLabelSize, index) {
	        if (size === void 0) { size = new Size(0, 0); }
	        if (breakLabelSize === void 0) { breakLabelSize = new Size(0, 0); }
	        if (index === void 0) { index = 1; }
	        this.text = text;
	        this.originalText = originalText;
	        this.value = value;
	        this.labelStyle = labelStyle;
	        this.size = size;
	        this.breakLabelSize = breakLabelSize;
	        this.index = index;
	    }
	    return VisibleLabels;
	}());

	var __extends$x = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Function to sort the dataSource, by default it sort the data in ascending order.
	 *
	 * @param  {Object} data chart data
	 * @param  {string} fields date fields
	 * @param  {boolean} isDescending boolean values of descending
	 * @returns {Object[]} It returns chart data which be sorted.
	 */
	function sort(data, fields, isDescending) {
	    var sortData = extend([], data, null);
	    for (var i = 0; i < sortData.length; i++) {
	        for (var j = 0; j < fields.length; j++) {
	            if (sortData[i][fields[j]] instanceof Date) {
	                sortData[i][fields[j]] = sortData[i][fields[j]].getTime();
	            }
	        }
	    }
	    sortData.sort(function (a, b) {
	        var first = 0;
	        var second = 0;
	        for (var i = 0; i < fields.length; i++) {
	            first += a[fields[i]];
	            second += b[fields[i]];
	        }
	        if ((!isDescending && first < second) || (isDescending && first > second)) {
	            return -1;
	        }
	        else if (first === second) {
	            return 0;
	        }
	        return 1;
	    });
	    return sortData;
	}
	/** @private */
	function isBreakLabel(label) {
	    return label.indexOf('<br>') !== -1;
	}
	/** @private */
	function getVisiblePoints(series) {
	    var points = extend([], series.points, null, true);
	    var tempPoints = [];
	    var tempPoint;
	    var pointIndex = 0;
	    for (var i = 0; i < points.length; i++) {
	        tempPoint = points[i];
	        if (isNullOrUndefined(tempPoint.x)) {
	            continue;
	        }
	        else {
	            tempPoint.index = pointIndex++;
	            tempPoints.push(tempPoint);
	        }
	    }
	    return tempPoints;
	}
	/** @private */
	function rotateTextSize(font, text, angle, chart) {
	    var transformValue = chart.element.style.transform;
	    if (transformValue) {
	        chart.element.style.transform = '';
	    }
	    var renderer = new SvgRenderer(chart.element.id);
	    var labelText;
	    var textCollection = [];
	    var height;
	    var dy;
	    var label;
	    var tspanElement;
	    var options = {
	        id: 'rotate_text',
	        x: chart.initialClipRect.x,
	        y: chart.initialClipRect.y,
	        'font-size': font.size,
	        'font-style': font.fontStyle,
	        'font-family': font.fontFamily,
	        'font-weight': font.fontWeight,
	        'transform': 'rotate(' + angle + ', 0, 0)',
	        'text-anchor': 'middle'
	    };
	    if (isBreakLabel(text)) {
	        textCollection = text.split('<br>');
	        labelText = textCollection[0];
	    }
	    else {
	        labelText = text;
	    }
	    var htmlObject = renderer.createText(options, labelText);
	    if (!chart.delayRedraw && !chart.redraw) {
	        chart.element.appendChild(chart.svgObject);
	    }
	    // for line break label
	    if (typeof textCollection !== 'string' && textCollection.length > 1) {
	        for (var i = 1, len = textCollection.length; i < len; i++) {
	            height = (measureText(textCollection[i], font, chart.themeStyle.axisLabelFont).height);
	            dy = (options.y) + ((i * height));
	            label = textCollection[i];
	            tspanElement = renderer.createTSpan({
	                'x': options.x, 'id': options.id,
	                'y': dy
	            }, label);
	            htmlObject.appendChild(tspanElement);
	        }
	    }
	    chart.svgObject.appendChild(htmlObject);
	    var box = htmlObject.getBoundingClientRect();
	    if (transformValue) {
	        chart.element.style.transform = transformValue;
	    }
	    remove(htmlObject);
	    if (!chart.delayRedraw && !chart.redraw) {
	        remove(chart.svgObject);
	    }
	    if (chart.enableCanvas) {
	        var textWidth = measureText(text, font, chart.themeStyle.axisLabelFont).width;
	        var textHeight = measureText(text, font, chart.themeStyle.axisLabelFont).height;
	        var angleInRadians = (angle * Math.PI) / 180; // Convert the rotation angle to radians
	        var rotatedTextWidth = Math.abs(Math.cos(angleInRadians) * textWidth) + Math.abs(Math.sin(angleInRadians) * textHeight);
	        var rotatedTextHeight = Math.abs(Math.sin(angleInRadians) * textWidth) + Math.abs(Math.cos(angleInRadians) * textHeight);
	        return new Size(rotatedTextWidth, rotatedTextHeight);
	    }
	    return new Size((box.right - box.left), (box.bottom - box.top));
	}
	/** @private */
	function removeElement(id) {
	    if (!id) {
	        return null;
	    }
	    var element = typeof id === 'string' ? getElement(id) : id;
	    if (element) {
	        remove(element);
	    }
	}
	/** @private */
	function logBase(value, base) {
	    return Math.log(value) / Math.log(base);
	}
	/** @private */
	function showTooltip(text, x, y, areaWidth, id, element, isTouch, isTitleOrLegendEnabled) {
	    //let id1: string = 'EJ2_legend_tooltip';
	    var tooltip = document.getElementById(id);
	    var size = measureText(text, {
	        fontFamily: 'Segoe UI', size: '12px',
	        fontStyle: 'Normal', fontWeight: 'Regular'
	    });
	    var width = size.width + 5;
	    x = (x + width > areaWidth) ? x - (width + 15) : x;
	    y = isTitleOrLegendEnabled ? (y - size.height / 2) : y + 15;
	    if (!tooltip) {
	        tooltip = createElement('div', {
	            id: id,
	            styles: 'top:' + (y).toString() + 'px;left:' + (x + 15).toString() +
	                'px;background-color: rgb(255, 255, 255) !important; color:black !important; ' +
	                'position:absolute;border:1px solid rgb(112, 112, 112); padding-left : 3px; padding-right : 2px;' +
	                'padding-bottom : 2px; padding-top : 2px; font-size:12px; font-family: "Segoe UI"'
	        });
	        tooltip.innerText = text;
	        element.appendChild(tooltip);
	        var left = parseInt(tooltip.style.left.replace('px', ''), 10);
	        if (left < 0) {
	            tooltip.style.left = '0px';
	        }
	    }
	    else {
	        tooltip.innerText = text;
	        tooltip.style.top = (y).toString() + 'px';
	        tooltip.style.left = (x + 15).toString() + 'px';
	    }
	    if (isTouch) {
	        setTimeout(function () { removeElement(id); }, 1500);
	    }
	}
	/** @private */
	function inside(value, range) {
	    return (value < range.max) && (value > range.min);
	}
	/** @private */
	function withIn(value, range) {
	    return (value <= range.max) && (value >= range.min);
	}
	/** @private */
	function logWithIn(value, axis) {
	    return axis.valueType === 'Logarithmic' ? logBase(value, axis.logBase) : value;
	}
	/** @private */
	function withInRange(previousPoint, currentPoint, nextPoint, series) {
	    var mX2 = logWithIn(currentPoint.xValue, series.xAxis);
	    var mX1 = previousPoint ? logWithIn(previousPoint.xValue, series.xAxis) : mX2;
	    var mX3 = nextPoint ? logWithIn(nextPoint.xValue, series.xAxis) : mX2;
	    var xStart = Math.floor(series.xAxis.visibleRange.min);
	    var xEnd = Math.ceil(series.xAxis.visibleRange.max);
	    return ((mX1 >= xStart && mX1 <= xEnd) || (mX2 >= xStart && mX2 <= xEnd) ||
	        (mX3 >= xStart && mX3 <= xEnd) || (xStart >= mX1 && xStart <= mX3));
	}
	/** @private */
	function sum(values) {
	    var sum = 0;
	    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
	        var value = values_1[_i];
	        sum += value;
	    }
	    return sum;
	}
	/** @private */
	function subtractThickness(rect, thickness) {
	    rect.x += thickness.left;
	    rect.y += thickness.top;
	    rect.width -= thickness.left + thickness.right;
	    rect.height -= thickness.top + thickness.bottom;
	    return rect;
	}
	/** @private */
	function degreeToLocation(degree, radius, center) {
	    var radian = (degree * Math.PI) / 180;
	    return new ChartLocation(Math.cos(radian) * radius + center.x, Math.sin(radian) * radius + center.y);
	}
	/** @private */
	function degreeToRadian(degree) {
	    return degree * (Math.PI / 180);
	}
	/** @private */
	function getRotatedRectangleCoordinates(actualPoints, centerX, centerY, angle) {
	    var coordinatesAfterRotation = [];
	    for (var i = 0; i < 4; i++) {
	        var point = actualPoints[i];
	        // translate point to origin
	        var tempX = point.x - centerX;
	        var tempY = point.y - centerY;
	        // now apply rotation
	        var rotatedX = tempX * Math.cos(degreeToRadian(angle)) - tempY * Math.sin(degreeToRadian(angle));
	        var rotatedY = tempX * Math.sin(degreeToRadian(angle)) + tempY * Math.cos(degreeToRadian(angle));
	        // translate back
	        point.x = rotatedX + centerX;
	        point.y = rotatedY + centerY;
	        coordinatesAfterRotation.push(new ChartLocation(point.x, point.y));
	    }
	    return coordinatesAfterRotation;
	}
	/**
	 * Helper function to determine whether there is an intersection between the two polygons described
	 * by the lists of vertices. Uses the Separating Axis Theorem
	 *
	 * @param {ChartLocation[]} a an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
	 * @param {ChartLocation[]} b an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
	 * @returns {boolean} if there is any intersection between the 2 polygons, false otherwise
	 */
	function isRotatedRectIntersect(a, b) {
	    var polygons = [a, b];
	    var minA;
	    var maxA;
	    var projected;
	    var i;
	    var i1;
	    var j;
	    var minB;
	    var maxB;
	    for (i = 0; i < polygons.length; i++) {
	        // for each polygon, look at each edge of the polygon, and determine if it separates
	        // the two shapes
	        var polygon = polygons[i];
	        for (i1 = 0; i1 < polygon.length; i1++) {
	            // grab 2 vertices to create an edge
	            var i2 = (i1 + 1) % polygon.length;
	            var p1 = polygon[i1];
	            var p2 = polygon[i2];
	            // find the line perpendicular to this edge
	            var normal = new ChartLocation(p2.y - p1.y, p1.x - p2.x);
	            minA = maxA = undefined;
	            // for each vertex in the first shape, project it onto the line perpendicular to the edge
	            // and keep track of the min and max of these values
	            for (j = 0; j < a.length; j++) {
	                projected = normal.x * a[j].x + normal.y * a[j].y;
	                if (isNullOrUndefined(minA) || projected < minA) {
	                    minA = projected;
	                }
	                if (isNullOrUndefined(maxA) || projected > maxA) {
	                    maxA = projected;
	                }
	            }
	            // for each vertex in the second shape, project it onto the line perpendicular to the edge
	            // and keep track of the min and max of these values
	            minB = maxB = undefined;
	            for (j = 0; j < b.length; j++) {
	                projected = normal.x * b[j].x + normal.y * b[j].y;
	                if (isNullOrUndefined(minB) || projected < minB) {
	                    minB = projected;
	                }
	                if (isNullOrUndefined(maxB) || projected > maxB) {
	                    maxB = projected;
	                }
	            }
	            // if there is no overlap between the projects, the edge we are looking at separates the two
	            // polygons, and we know there is no overlap
	            if (maxA < minB || maxB < minA) {
	                return false;
	            }
	        }
	    }
	    return true;
	}
	/** @private */
	function getAccumulationLegend(locX, locY, r, height, width, mode) {
	    var cartesianlarge = degreeToLocation(270, r, new ChartLocation(locX, locY));
	    var cartesiansmall = degreeToLocation(270, r, new ChartLocation(locX + (width / 10), locY));
	    return 'M' + ' ' + locX + ' ' + locY + ' ' + 'L' + ' ' + (locX + r) + ' ' + (locY) + ' ' + 'A' + ' ' + (r) + ' ' + (r) +
	        ' ' + 0 + ' ' + 1 + ' ' + 1 + ' ' + cartesianlarge.x + ' ' + cartesianlarge.y + ' ' + 'Z' + ' ' + 'M' + ' ' + (locX +
	        (width / 10)) + ' ' + (locY - (height / 10)) + ' ' + 'L' + (locX + (r)) + ' ' + (locY - height / 10) + ' ' + 'A' + ' '
	        + (r) + ' ' + (r) + ' ' + 0 + ' ' + 0 + ' ' + 0 + ' ' + cartesiansmall.x + ' ' + cartesiansmall.y + ' ' + 'Z';
	}
	/** @private */
	function subArray(values, index) {
	    var subArray = [];
	    for (var i = 0; i <= index - 1; i++) {
	        subArray.push(values[i]);
	    }
	    return subArray;
	}
	/** @private */
	function valueToCoefficient(value, axis) {
	    var range = axis.visibleRange;
	    var result = (value - range.min) / (range.delta);
	    var isInverse = axis.isChart ? axis.isAxisInverse : axis.isInversed;
	    return isInverse ? (1 - result) : result;
	}
	/** @private */
	function TransformToVisible(x, y, xAxis, yAxis, isInverted, series) {
	    x = (xAxis.valueType === 'Logarithmic' ? logBase(x > 1 ? x : 1, xAxis.logBase) : x);
	    y = (yAxis.valueType === 'Logarithmic' ?
	        logBase(y > 1 ? y : 1, yAxis.logBase) : y);
	    x += xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks' && series.type !== 'Radar' ? 0.5 : 0;
	    var radius = series.chart.radius * valueToCoefficient(y, yAxis);
	    var point = CoefficientToVector(valueToPolarCoefficient(x, xAxis), series.chart.primaryXAxis.startAngle);
	    return {
	        x: (series.clipRect.width / 2 + series.clipRect.x) + radius * point.x,
	        y: (series.clipRect.height / 2 + series.clipRect.y) + radius * point.y
	    };
	}
	/** @private */
	function CoefficientToVector(coefficient, startAngle) {
	    startAngle = startAngle < 0 ? startAngle + 360 : startAngle;
	    var angle = Math.PI * (1.5 - 2 * coefficient);
	    angle = angle + (startAngle * Math.PI) / 180;
	    return { x: Math.cos(angle), y: Math.sin(angle) };
	}
	/** @private */
	function valueToPolarCoefficient(value, axis) {
	    var range = axis.visibleRange;
	    var delta;
	    var length;
	    if (axis.valueType !== 'Category') {
	        delta = (range.max - (axis.valueType === 'DateTime' ? axis.dateTimeInterval : range.interval)) - range.min;
	        length = axis.visibleLabels.length - 1;
	        delta = delta === 0 ? 1 : delta;
	    }
	    else {
	        // To split an interval equally based on visible labels count
	        delta = axis.visibleLabels.length === 1 ? 1 :
	            (axis.visibleLabels[axis.visibleLabels.length - 1].value - axis.visibleLabels[0].value);
	        length = axis.visibleLabels.length;
	    }
	    return axis.isAxisInverse ? ((value - range.min) / delta) * (1 - 1 / (length)) :
	        1 - ((value - range.min) / delta) * (1 - 1 / (length));
	}
	/** @private */
	function createZoomingLabels(chart, axis, parent, index, isVertical, rect) {
	    var margin = 5;
	    var opposedPosition = axis.isAxisOpposedPosition;
	    var anchor = isVertical ? 'start' : 'auto';
	    var size;
	    var chartRect = chart.availableSize.width;
	    var pathElement;
	    var x;
	    var y;
	    var rx = 3;
	    var arrowLocation;
	    var direction;
	    var scrollBarHeight = axis.scrollbarSettings.enable || (axis.zoomingScrollBar && axis.zoomingScrollBar.svgObject)
	        ? axis.scrollBarHeight : 0;
	    for (var i = 0; i < 2; i++) {
	        size = measureText(i ? axis.endLabel : axis.startLabel, axis.labelStyle, chart.themeStyle.axisLabelFont);
	        if (isVertical) {
	            arrowLocation = i ? new ChartLocation(rect.x - scrollBarHeight, rect.y + rx) :
	                new ChartLocation(axis.rect.x - scrollBarHeight, (rect.y + rect.height - rx));
	            x = (rect.x + (opposedPosition ? (rect.width + margin + scrollBarHeight) : -(size.width + margin + margin + scrollBarHeight)));
	            y = (rect.y + (i ? 0 : rect.height - size.height - margin));
	            x += (x < 0 || ((chartRect) < (x + size.width + margin))) ? (opposedPosition ? -(size.width / 2) : size.width / 2) : 0;
	            direction = findCrosshairDirection(rx, rx, new Rect(x, y, size.width + margin, size.height + margin), arrowLocation, margin, false, false, !opposedPosition, arrowLocation.x, arrowLocation.y + (i ? -rx : rx));
	        }
	        else {
	            arrowLocation = i ? new ChartLocation((rect.x + rect.width - rx), (rect.y + rect.height + scrollBarHeight)) :
	                new ChartLocation(rect.x + rx, (rect.y + rect.height + scrollBarHeight));
	            x = (rect.x + (i ? (rect.width - size.width - margin) : 0));
	            y = (opposedPosition ? (rect.y - size.height - 10 - scrollBarHeight) : (rect.y + rect.height + margin + scrollBarHeight));
	            direction = findCrosshairDirection(rx, rx, new Rect(x, y, size.width + margin, size.height + margin), arrowLocation, margin, opposedPosition, !opposedPosition, false, arrowLocation.x + (i ? rx : -rx), arrowLocation.y);
	        }
	        x = x + (margin / 2);
	        y = y + (3 * (size.height / 4)) + (margin / 2);
	        pathElement = chart.renderer.drawPath({
	            'id': chart.element.id + '_Zoom_' + index + '_AxisLabel_Shape_' + i,
	            'fill': chart.themeStyle.crosshairFill, 'width': 2, 'color': chart.themeStyle.crosshairFill,
	            'opacity': 1, 'stroke-dasharray': null, 'd': direction
	        }, null);
	        parent.appendChild(pathElement);
	        if (chart.theme === 'Fluent' || chart.theme === 'FluentDark') {
	            var shadowId = chart.element.id + '_shadow';
	            pathElement.setAttribute('filter', Browser.isIE ? '' : 'url(#' + shadowId + ')');
	            var shadow = '<filter id="' + shadowId + '" height="130%"><feGaussianBlur in="SourceAlpha" stdDeviation="3"/>';
	            shadow += '<feOffset dx="3" dy="3" result="offsetblur"/><feComponentTransfer><feFuncA type="linear" slope="0.5"/>';
	            shadow += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
	            var defElement = chart.renderer.createDefs();
	            defElement.setAttribute('id', chart.element.id + 'SVG_tooltip_definition');
	            parent.appendChild(defElement);
	            defElement.innerHTML = shadow;
	            pathElement.setAttribute('stroke', '#cccccc');
	            pathElement.setAttribute('stroke-width', '0.5');
	        }
	        textElement(chart.renderer, new TextOption(chart.element.id + '_Zoom_' + index + '_AxisLabel_' + i, x, y, anchor, i ? axis.endLabel : axis.startLabel), { color: chart.themeStyle.crosshairLabelFont.color, fontFamily: 'Segoe UI', fontWeight: 'Regular', size: '11px' }, chart.themeStyle.crosshairLabelFont.color, parent, null, null, null, null, null, null, null, null, null, null, chart.themeStyle.crosshairLabelFont);
	    }
	    return parent;
	}
	/** @private */
	function findCrosshairDirection(rX, rY, rect, arrowLocation, arrowPadding, top, bottom, left, tipX, tipY) {
	    var direction = '';
	    var startX = rect.x;
	    var startY = rect.y;
	    var width = rect.x + rect.width;
	    var height = rect.y + rect.height;
	    if (top) {
	        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '
	            + startY + ' ' + (startX + rX) + ' ' + startY);
	        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (startY) + ' Q ' + width + ' '
	            + startY + ' ' + (width) + ' ' + (startY + rY));
	        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + width + ' '
	            + (height) + ' ' + (width - rX) + ' ' + (height));
	        if (arrowPadding !== 0) {
	            direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding / 2) + ' ' + (height));
	            direction = direction.concat(' L' + ' ' + (tipX) + ' ' + (height + arrowPadding)
	                + ' L' + ' ' + (arrowLocation.x - arrowPadding / 2) + ' ' + height);
	        }
	        if ((arrowLocation.x - arrowPadding / 2) > startX) {
	            direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' '
	                + height + ' ' + (startX) + ' ' + (height - rY) + ' z');
	        }
	        else {
	            if (arrowPadding === 0) {
	                direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' '
	                    + height + ' ' + (startX) + ' ' + (height - rY) + ' z');
	            }
	            else {
	                direction = direction.concat(' L' + ' ' + (startX) + ' ' + (height + rY) + ' z');
	            }
	        }
	    }
	    else if (bottom) {
	        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '
	            + (startY) + ' ' + (startX + rX) + ' ' + (startY) + ' L' + ' ' + (arrowLocation.x - arrowPadding / 2) + ' ' + (startY));
	        direction = direction.concat(' L' + ' ' + (tipX) + ' ' + (arrowLocation.y));
	        direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding / 2) + ' ' + (startY));
	        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (startY)
	            + ' Q ' + (width) + ' ' + (startY) + ' ' + (width) + ' ' + (startY + rY));
	        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + (width) + ' '
	            + (height) + ' ' + (width - rX) + ' ' + (height));
	        direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + (height) + ' Q ' + (startX) + ' '
	            + (height) + ' ' + (startX) + ' ' + (height - rY) + ' z');
	    }
	    else if (left) {
	        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '
	            + (startY) + ' ' + (startX + rX) + ' ' + (startY));
	        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (startY) + ' Q ' + (width) + ' '
	            + (startY) + ' ' + (width) + ' ' + (startY + rY) + ' L' + ' ' + (width) + ' ' + (arrowLocation.y - arrowPadding / 2));
	        direction = direction.concat(' L' + ' ' + (width + arrowPadding) + ' ' + (tipY));
	        direction = direction.concat(' L' + ' ' + (width) + ' ' + (arrowLocation.y + arrowPadding / 2));
	        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + width + ' ' + (height) + ' ' + (width - rX) + ' ' + (height));
	        direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + (height) + ' Q ' + startX + ' '
	            + (height) + ' ' + (startX) + ' ' + (height - rY) + ' z');
	    }
	    else {
	        direction = direction.concat('M' + ' ' + (startX + rX) + ' ' + (startY) + ' Q ' + (startX) + ' '
	            + (startY) + ' ' + (startX) + ' ' + (startY + rY) + ' L' + ' ' + (startX) + ' ' + (arrowLocation.y - arrowPadding / 2));
	        direction = direction.concat(' L' + ' ' + (startX - arrowPadding) + ' ' + (tipY));
	        direction = direction.concat(' L' + ' ' + (startX) + ' ' + (arrowLocation.y + arrowPadding / 2));
	        direction = direction.concat(' L' + ' ' + (startX) + ' ' + (height - rY) + ' Q ' + startX + ' '
	            + (height) + ' ' + (startX + rX) + ' ' + (height));
	        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (height) + ' Q ' + width + ' '
	            + (height) + ' ' + (width) + ' ' + (height - rY));
	        direction = direction.concat(' L' + ' ' + (width) + ' ' + (startY + rY) + ' Q ' + width + ' '
	            + (startY) + ' ' + (width - rX) + ' ' + (startY) + ' z');
	    }
	    return direction;
	}
	//Within bounds
	/** @private */
	function withInBounds(x, y, bounds, width, height) {
	    if (width === void 0) { width = 0; }
	    if (height === void 0) { height = 0; }
	    return (x >= bounds.x - width && x <= bounds.x + bounds.width + width && y >= bounds.y - height
	        && y <= bounds.y + bounds.height + height);
	}
	/** @private */
	function getValueXByPoint(value, size, axis) {
	    var actualValue = !axis.isAxisInverse ? value / size : (1 - (value / size));
	    return actualValue * (axis.visibleRange.delta) + axis.visibleRange.min;
	}
	/** @private */
	function getValueYByPoint(value, size, axis) {
	    var actualValue = axis.isAxisInverse ? value / size : (1 - (value / size));
	    return actualValue * (axis.visibleRange.delta) + axis.visibleRange.min;
	}
	/** @private */
	function findClipRect(series, isCanvas) {
	    if (isCanvas === void 0) { isCanvas = false; }
	    var rect = series.clipRect;
	    if (isCanvas && (series.type === 'Polar' || series.type === 'Radar')) {
	        if (series.drawType === 'Scatter') {
	            rect.x = series.xAxis.rect.x;
	            rect.y = series.yAxis.rect.y;
	            rect.width = series.xAxis.rect.width;
	            rect.height = series.yAxis.rect.height;
	        }
	        else {
	            rect.x = series.xAxis.rect.x / 2;
	            rect.y = series.yAxis.rect.y / 2;
	            rect.width = series.xAxis.rect.width;
	            rect.height = series.yAxis.rect.height;
	        }
	    }
	    else {
	        if (series.chart.requireInvertedAxis) {
	            rect.x = series.yAxis.rect.x;
	            rect.y = series.xAxis.rect.y;
	            rect.width = series.yAxis.rect.width;
	            rect.height = series.xAxis.rect.height;
	        }
	        else {
	            rect.x = series.xAxis.rect.x;
	            rect.y = series.yAxis.rect.y;
	            rect.width = series.xAxis.rect.width;
	            rect.height = series.yAxis.rect.height;
	        }
	    }
	}
	/** @private */
	function firstToLowerCase(str) {
	    return str.substr(0, 1).toLowerCase() + str.substr(1);
	}
	/** @private */
	function getMinPointsDelta(axis, seriesCollection) {
	    var minDelta = Number.MAX_VALUE;
	    var xValues;
	    var minVal;
	    var seriesMin;
	    for (var index = 0; index < seriesCollection.length; index++) {
	        var series = seriesCollection[index];
	        xValues = [];
	        if (series.visible &&
	            (axis.name === series.xAxisName || (axis.name === 'primaryXAxis' && series.xAxisName === null)
	                || (axis.name === series.chart.primaryXAxis.name && !series.xAxisName))) {
	            xValues = series.points.map(function (point) {
	                return point.xValue;
	            });
	            xValues.sort(function (first, second) { return first - second; });
	            if (xValues.length === 1) {
	                seriesMin = (axis.valueType === 'DateTime' && series.xMin === series.xMax) ? (series.xMin - 25920000) : series.xMin;
	                minVal = xValues[0] - (!isNullOrUndefined(seriesMin) ?
	                    seriesMin : axis.visibleRange.min);
	                if (minVal !== 0) {
	                    minDelta = Math.min(minDelta, minVal);
	                }
	            }
	            else {
	                for (var index_1 = 0; index_1 < xValues.length; index_1++) {
	                    var value = xValues[index_1];
	                    if (index_1 > 0 && value) {
	                        minVal = value - xValues[index_1 - 1];
	                        if (minVal !== 0) {
	                            minDelta = Math.min(minDelta, minVal);
	                        }
	                    }
	                }
	            }
	        }
	    }
	    if (minDelta === Number.MAX_VALUE) {
	        minDelta = 1;
	    }
	    return minDelta;
	}
	/** @private */
	function getAnimationFunction(effect) {
	    var functionName;
	    switch (effect) {
	        case 'Linear':
	            functionName = linear;
	            break;
	    }
	    return functionName;
	}
	/**
	 * Animation Effect Calculation Started Here
	 *
	 * @param {number} currentTime currentTime
	 * @param {number} startValue startValue of the animation
	 * @param {number} endValue endValue of the animation
	 * @param {number} duration duration of the animation
	 * @private
	 */
	function linear(currentTime, startValue, endValue, duration) {
	    return -endValue * Math.cos(currentTime / duration * (Math.PI / 2)) + endValue + startValue;
	}
	/**
	 * Animation Effect Calculation End
	 *
	 * @private
	 */
	function markerAnimate(element, delay, duration, series, pointIndex, point, isLabel) {
	    var centerX = point.x;
	    var centerY = point.y;
	    var height = 0;
	    element.style.visibility = 'hidden';
	    new Animation$1({}).animate(element, {
	        duration: duration,
	        delay: delay,
	        progress: function (args) {
	            if (args.timeStamp > args.delay) {
	                args.element.style.visibility = 'visible';
	                height = ((args.timeStamp - args.delay) / args.duration);
	                element.setAttribute('transform', 'translate(' + centerX
	                    + ' ' + centerY + ') scale(' + height + ') translate(' + (-centerX) + ' ' + (-centerY) + ')');
	            }
	        },
	        end: function () {
	            element.style.visibility = '';
	            if ((series.type === 'Scatter' || series.type === 'Bubble') && !isLabel && (pointIndex === series.points.length - 1)) {
	                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });
	            }
	        }
	    });
	}
	/**
	 * Animate the rect element.
	 */
	function animateRectElement(element, delay, duration, currentRect, previousRect) {
	    var setStyle = function (rect) {
	        element.setAttribute('x', rect.x + '');
	        element.setAttribute('y', rect.y + '');
	        element.setAttribute('width', rect.width + '');
	        element.setAttribute('height', rect.height + '');
	    };
	    new Animation$1({}).animate(createElement('div'), {
	        duration: duration,
	        delay: delay,
	        //name: name,
	        progress: function (args) {
	            setStyle(new Rect(linear(args.timeStamp, previousRect.x, currentRect.x - previousRect.x, args.duration), linear(args.timeStamp, previousRect.y, currentRect.y - previousRect.y, args.duration), linear(args.timeStamp, previousRect.width, currentRect.width - previousRect.width, args.duration), linear(args.timeStamp, previousRect.height, currentRect.height - previousRect.height, args.duration)));
	        },
	        end: function () {
	            setStyle(currentRect);
	        }
	    });
	}
	/**
	 * Animation after legend click a path.
	 *
	 * @param {Element} element element to be animated
	 * @param {string} direction current direction of the path
	 * @param {boolean} redraw chart redraw
	 * @param {string} previousDirection previous direction of the path
	 * @param {number} animateDuration animateDuration of the path
	 */
	function pathAnimation(element, direction, redraw, previousDirection, animateDuration) {
	    if (!redraw || (!previousDirection && !element)) {
	        return null;
	    }
	    var duration = 300;
	    if (animateDuration) {
	        duration = animateDuration;
	    }
	    var startDirections = previousDirection || element.getAttribute('d');
	    var splitDirections = startDirections.split(/(?=[LMCZAQ])/);
	    var endDirections = direction.split(/(?=[LMCZAQ])/);
	    var currentDireciton;
	    var startPath = [];
	    var endPath = [];
	    var c;
	    var end;
	    element.setAttribute('d', startDirections);
	    new Animation$1({}).animate(createElement('div'), {
	        duration: duration,
	        progress: function (args) {
	            currentDireciton = '';
	            splitDirections.map(function (directions, index) {
	                startPath = directions.split(' ');
	                endPath = endDirections[index] ? endDirections[index].split(' ') : startPath;
	                if (startPath[0] === 'Z') {
	                    currentDireciton += 'Z' + ' ';
	                }
	                else if (startPath[0] === '') {
	                    currentDireciton = '';
	                }
	                else {
	                    currentDireciton += startPath[0] + ' ' +
	                        linear(args.timeStamp, +startPath[1], (+endPath[1] - +startPath[1]), args.duration) + ' ' +
	                        linear(args.timeStamp, +startPath[2], (+endPath[2] - +startPath[2]), args.duration) + ' ';
	                }
	                if (startPath[0] === 'C' || startPath[0] === 'Q') {
	                    c = 3;
	                    end = startPath[0] === 'Q' ? 4 : 6;
	                    while (c < end) {
	                        currentDireciton += linear(args.timeStamp, +startPath[c], (+endPath[c] - +startPath[c]), args.duration) + ' ' +
	                            linear(args.timeStamp, +startPath[++c], (+endPath[c] - +startPath[c]), args.duration) + ' ';
	                        ++c;
	                    }
	                }
	                if (startPath[0] === 'A') {
	                    currentDireciton += 0 + ' ' + 0 + ' ' + 1 + ' ' +
	                        linear(args.timeStamp, +startPath[6], (+endPath[6] - +startPath[6]), args.duration) + ' ' +
	                        linear(args.timeStamp, +startPath[7], (+endPath[7] - +startPath[7]), args.duration) + ' ';
	                }
	            });
	            element.setAttribute('d', currentDireciton);
	        },
	        end: function () {
	            element.setAttribute('d', direction);
	        }
	    });
	}
	/**
	 * To append the clip rect element.
	 *
	 * @param {boolean} redraw chart redraw value
	 * @param {BaseAttibutes} options element options
	 * @param {SvgRenderer} renderer svg renderer values
	 * @param {string} clipPath clipPath of the element
	 */
	function appendClipElement(redraw, options, renderer, clipPath) {
	    if (clipPath === void 0) { clipPath = 'drawClipPath'; }
	    var clipElement = redrawElement(redraw, options.id, options, renderer);
	    if (clipElement) {
	        var def = renderer.createDefs();
	        def.appendChild(clipElement);
	        return def;
	    }
	    else {
	        return renderer[clipPath](options);
	    }
	}
	/**
	 * Triggers the event.
	 *
	 * @returns {void}
	 * @private
	 */
	function triggerLabelRender(chart, tempInterval, text, labelStyle, axis) {
	    var argsData = {
	        cancel: false, name: axisLabelRender, axis: axis,
	        text: text, value: tempInterval, labelStyle: labelStyle
	    };
	    chart.trigger(axisLabelRender, argsData);
	    if (!argsData.cancel) {
	        var isLineBreakLabels = argsData.text.indexOf('<br>') !== -1;
	        var text_1 = (axis.enableTrim) ? (isLineBreakLabels ?
	            lineBreakLabelTrim(axis.maximumLabelWidth, argsData.text, axis.labelStyle, chart.themeStyle.axisLabelFont) :
	            textTrim(axis.maximumLabelWidth, argsData.text, axis.labelStyle, chart.themeStyle.axisLabelFont)) : argsData.text;
	        axis.visibleLabels.push(new VisibleLabels(text_1, argsData.value, argsData.labelStyle, argsData.text));
	    }
	}
	/**
	 * The function used to find whether the range is set.
	 *
	 * @returns {boolean} It returns true if the axis range is set otherwise false.
	 * @private
	 */
	function setRange(axis) {
	    return (axis.minimum != null && axis.maximum != null);
	}
	/**
	 * To check whether the axis is zoomed or not.
	 *
	 * @param {Axis} axis axis model
	 */
	function isZoomSet(axis) {
	    return (axis.zoomFactor < 1 && axis.zoomPosition >= 0);
	}
	/**
	 * Calculate desired interval for the axis.
	 *
	 * @returns {void} It returns desired interval count.
	 * @private
	 */
	function getActualDesiredIntervalsCount(availableSize, axis) {
	    var size = axis.orientation === 'Horizontal' ? availableSize.width : availableSize.height;
	    if (isNullOrUndefined(axis.desiredIntervals)) {
	        var desiredIntervalsCount = (axis.orientation === 'Horizontal' ? 0.533 : 1) * axis.maximumLabels;
	        desiredIntervalsCount = Math.max((size * (desiredIntervalsCount / 100)), 1);
	        return desiredIntervalsCount;
	    }
	    else {
	        return axis.desiredIntervals;
	    }
	}
	/**
	 * Animation for template
	 *
	 * @private
	 */
	function templateAnimate(element, delay, duration, name, isRemove) {
	    new Animation$1({}).animate(element, {
	        duration: duration,
	        delay: delay,
	        name: name,
	        progress: function (args) {
	            args.element.style.visibility = 'visible';
	        },
	        end: function (args) {
	            if (isRemove) {
	                remove(args.element);
	            }
	            else {
	                args.element.style.visibility = 'visible';
	            }
	        }
	    });
	}
	/** @private */
	function drawSymbol(location, shape, size, url, options, label, renderer, clipRect, isChartControl, control) {
	    var chartRenderer = renderer ? renderer : new SvgRenderer('');
	    var shapeOption = calculateShapes(location, size, shape, options, url, isChartControl, control);
	    var drawElement = chartRenderer['draw' + shapeOption.functionName](shapeOption.renderOption, clipRect ? new Int32Array([clipRect.x, clipRect.y]) : null);
	    //drawElement.setAttribute('aria-label', label);
	    return drawElement;
	}
	/** @private */
	function calculateShapes(location, size, shape, options, url, isChart, control) {
	    var dir;
	    var functionName = 'Path';
	    var isBulletChart = isChart;
	    var width = (isBulletChart && shape === 'Circle') ? (size.width - 2) : size.width;
	    var height = (isBulletChart && shape === 'Circle') ? (size.height - 2) : size.height;
	    var sizeBullet = (isBulletChart) ? control.targetWidth : 0;
	    var lx = location.x;
	    var ly = location.y;
	    var y = location.y + (-height / 2);
	    var x = location.x + (-width / 2);
	    var eq = 72;
	    var xVal;
	    var yVal;
	    switch (shape) {
	        case 'Bubble':
	        case 'Circle':
	            functionName = 'Ellipse';
	            merge(options, { 'rx': width / 2, 'ry': height / 2, 'cx': lx, 'cy': ly });
	            break;
	        case 'Plus':
	            dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + ly + ' ' +
	                'M' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + lx + ' ' +
	                (ly + (-height / 2));
	            merge(options, { 'd': dir });
	            break;
	        case 'Cross':
	            dir = 'M' + ' ' + x + ' ' + (ly + (-height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' +
	                'M' + ' ' + x + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (-height / 2));
	            merge(options, { 'd': dir });
	            break;
	        case 'Multiply':
	            dir = 'M ' + (lx - sizeBullet) + ' ' + (ly - sizeBullet) + ' L ' +
	                (lx + sizeBullet) + ' ' + (ly + sizeBullet) + ' M ' +
	                (lx - sizeBullet) + ' ' + (ly + sizeBullet) + ' L ' + (lx + sizeBullet) + ' ' + (ly - sizeBullet);
	            merge(options, { 'd': dir, stroke: options.fill });
	            break;
	        case 'HorizontalLine':
	            dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + ly;
	            merge(options, { 'd': dir });
	            break;
	        case 'VerticalLine':
	            dir = 'M' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + lx + ' ' + (ly + (-height / 2));
	            merge(options, { 'd': dir });
	            break;
	        case 'Diamond':
	            dir = 'M' + ' ' + x + ' ' + ly + ' ' +
	                'L' + ' ' + lx + ' ' + (ly + (-height / 2)) + ' ' +
	                'L' + ' ' + (lx + (width / 2)) + ' ' + ly + ' ' +
	                'L' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' +
	                'L' + ' ' + x + ' ' + ly + ' z';
	            merge(options, { 'd': dir });
	            break;
	        case 'ActualRect':
	            dir = 'M' + ' ' + x + ' ' + (ly + (-height / 8)) + ' ' +
	                'L' + ' ' + (lx + (sizeBullet)) + ' ' + (ly + (-height / 8)) + ' ' +
	                'L' + ' ' + (lx + (sizeBullet)) + ' ' + (ly + (height / 8)) + ' ' +
	                'L' + ' ' + x + ' ' + (ly + (height / 8)) + ' ' +
	                'L' + ' ' + x + ' ' + (ly + (-height / 8)) + ' z';
	            merge(options, { 'd': dir });
	            break;
	        case 'TargetRect':
	            dir = 'M' + ' ' + (x + (sizeBullet)) + ' ' + (ly + (-height / 2)) + ' ' +
	                'L' + ' ' + (lx + (sizeBullet / 2)) + ' ' + (ly + (-height / 2)) + ' ' +
	                'L' + ' ' + (lx + (sizeBullet / 2)) + ' ' + (ly + (height / 2)) + ' ' +
	                'L' + ' ' + (x + (sizeBullet)) + ' ' + (ly + (height / 2)) + ' ' +
	                'L' + ' ' + (x + (sizeBullet)) + ' ' + (ly + (-height / 2)) + ' z';
	            merge(options, { 'd': dir });
	            break;
	        case 'Rectangle':
	        case 'Hilo':
	        case 'HiloOpenClose':
	        case 'Candle':
	        case 'Waterfall':
	        case 'BoxAndWhisker':
	        case 'StepArea':
	        case 'RangeStepArea':
	        case 'StackingStepArea':
	        case 'Square':
	        case 'Flag':
	            dir = 'M' + ' ' + x + ' ' + (ly + (-height / 2)) + ' ' +
	                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (-height / 2)) + ' ' +
	                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' +
	                'L' + ' ' + x + ' ' + (ly + (height / 2)) + ' ' +
	                'L' + ' ' + x + ' ' + (ly + (-height / 2)) + ' z';
	            merge(options, { 'd': dir });
	            break;
	        case 'Pyramid':
	        case 'Triangle':
	            dir = 'M' + ' ' + x + ' ' + (ly + (height / 2)) + ' ' +
	                'L' + ' ' + lx + ' ' + (ly + (-height / 2)) + ' ' +
	                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' +
	                'L' + ' ' + x + ' ' + (ly + (height / 2)) + ' z';
	            merge(options, { 'd': dir });
	            break;
	        case 'Funnel':
	        case 'InvertedTriangle':
	            dir = 'M' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +
	                'L' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' +
	                'L' + ' ' + (lx - (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +
	                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) + ' z';
	            merge(options, { 'd': dir });
	            break;
	        case 'Pentagon':
	            for (var i = 0; i <= 5; i++) {
	                xVal = (width / 2) * Math.cos((Math.PI / 180) * (i * eq));
	                yVal = (height / 2) * Math.sin((Math.PI / 180) * (i * eq));
	                if (i === 0) {
	                    dir = 'M' + ' ' + (lx + xVal) + ' ' + (ly + yVal) + ' ';
	                }
	                else {
	                    dir = dir.concat('L' + ' ' + (lx + xVal) + ' ' + (ly + yVal) + ' ');
	                }
	            }
	            dir = dir.concat('Z');
	            merge(options, { 'd': dir });
	            break;
	        case 'Image':
	            functionName = 'Image';
	            merge(options, { 'href': url, 'height': height, 'width': width, x: x, y: y });
	            break;
	    }
	    options = calculateLegendShapes(location, new Size(width, height), shape, options).renderOption;
	    return { renderOption: options, functionName: functionName };
	}
	/** @private */
	function getElement(id) {
	    return document.getElementById(id);
	}
	/** @private */
	function getTemplateFunction(template) {
	    var templateFn = null;
	    try {
	        if (typeof template !== 'function' && document.querySelectorAll(template).length) {
	            templateFn = compile(document.querySelector(template).innerHTML.trim());
	        }
	        else {
	            templateFn = compile(template);
	        }
	    }
	    catch (e) {
	        templateFn = compile(template);
	    }
	    return templateFn;
	}
	/** @private */
	function accReactTemplate(childElement, chart, isTemplate, points, argsData, point, datalabelGroup, id, dataLabel, redraw) {
	    var clientRect = childElement.getBoundingClientRect();
	    chart.accumulationDataLabelModule.calculateLabelSize(isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw, clientRect, true);
	}
	/** @private */
	function chartReactTemplate(childElement, chart, point, series, labelIndex, redraw) {
	    var parentElement = document.getElementById(chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabelCollections');
	    if (parentElement) {
	        if (point.index === 0) {
	            chart.dataLabelCollections = []; // clear old datalabel bounds for react callback
	        }
	        chart.dataLabelModule.calculateTemplateLabelSize(parentElement, childElement, point, series, series.marker.dataLabel, labelIndex, series.clipRect, redraw, true);
	    }
	}
	/** @private */
	function createTemplate(childElement, pointIndex, content, chart, point, series, dataLabelId, labelIndex, argsData, isTemplate, points, datalabelGroup, id, dataLabel, redraw) {
	    var templateFn = getTemplateFunction(content);
	    var templateElement;
	    try {
	        var blazor = 'Blazor';
	        var tempObject = window[blazor] ? (dataLabelId ? point : { point: point }) :
	            { chart: chart, series: series, point: point };
	        var templateId = dataLabelId ? dataLabelId + '_template' : 'template';
	        var elementData = templateFn ? templateFn(tempObject, chart, templateId, dataLabelId ||
	            childElement.id.replace(/[^a-zA-Z0-9]/g, '')) : [];
	        if (elementData.length) {
	            templateElement = Array.prototype.slice.call(elementData);
	            var len = templateElement.length;
	            for (var i = 0; i < len; i++) {
	                childElement.appendChild(templateElement[i]);
	            }
	        }
	        var reactCallback = void 0;
	        if (chart.getModuleName() === 'accumulationchart') {
	            reactCallback = accReactTemplate.bind(this, childElement, chart, isTemplate, points, argsData, points[pointIndex], datalabelGroup, id, dataLabel, redraw);
	            // tslint:disable-next-line:no-any
	            if (chart.isReact) {
	                chart.renderReactTemplates(reactCallback);
	            }
	        }
	        else if (chart.getModuleName() === 'chart') {
	            reactCallback = (point && series) ? chartReactTemplate.bind(this, childElement, chart, point, series, labelIndex, redraw) : reactCallback;
	            // tslint:disable-next-line:no-any
	            if (chart.isReact) {
	                chart.renderReactTemplates(reactCallback);
	            }
	        }
	    }
	    catch (e) {
	        return childElement;
	    }
	    return childElement;
	}
	/** @private */
	function getFontStyle(font) {
	    var style = '';
	    style = 'font-size:' + font.size +
	        '; font-style:' + font.fontStyle + '; font-weight:' + font.fontWeight +
	        '; font-family:' + font.fontFamily + ';opacity:' + font.opacity +
	        '; color:' + font.color + ';';
	    return style;
	}
	/** @private */
	function measureElementRect(element, redraw, isReactCallback) {
	    if (redraw === void 0) { redraw = false; }
	    if (!isReactCallback) { // If the element is already in DOM, no need to append in the body.
	        document.body.appendChild(element);
	    }
	    var bounds = element.getBoundingClientRect();
	    if (redraw) {
	        remove(element);
	    }
	    else if (!isReactCallback) { // for react chart data label template - (callback function)
	        removeElement(element.id);
	    }
	    return bounds;
	}
	/** @private */
	function findlElement(elements, id) {
	    var element;
	    for (var i = 0, length_1 = elements.length; i < length_1; i++) {
	        if (elements[i].id.indexOf(id) > -1) {
	            element = elements[i];
	            continue;
	        }
	    }
	    return element;
	}
	/** @private */
	function getPoint(x, y, xAxis, yAxis, isInverted) {
	    x = ((xAxis.valueType === 'Logarithmic') ?
	        logBase(((x > 0) ? x : Math.pow(xAxis.logBase, xAxis.visibleRange.min)), xAxis.logBase) : x);
	    y = ((yAxis.valueType === 'Logarithmic') ?
	        logBase(((y > 0) ? y : Math.pow(yAxis.logBase, yAxis.visibleRange.min)), yAxis.logBase) : y);
	    x = valueToCoefficient(x, xAxis);
	    y = valueToCoefficient(y, yAxis);
	    var xLength = (isInverted ? xAxis.rect.height : xAxis.rect.width);
	    var yLength = (isInverted ? yAxis.rect.width : yAxis.rect.height);
	    var locationX = isInverted ? y * (yLength) : x * (xLength);
	    var locationY = isInverted ? (1 - x) * (xLength) : (1 - y) * (yLength);
	    return new ChartLocation(locationX, locationY);
	}
	/**
	 * Method to append child element.
	 *
	 * @param {boolean} isCanvas canvas mode value
	 * @param {Element} parent parent element
	 * @param {Element} childElement childElement element
	 * @param {boolean} redraw chart redraw value
	 * @param {boolean} isAnimate animation value
	 * @param {string} x x position
	 * @param {string} y y position
	 * @param {ChartLocation} start start location value
	 * @param {string} direction direction of the element
	 * @param {boolean} forceAnimate forceAnimate
	 * @param {boolean} isRect isRect
	 * @param {Rect} previousRect previousRect
	 * @param {number} animateDuration duration of the animation
	 */
	function appendChildElement(isCanvas, parent, childElement, redraw, isAnimate, x, y, start, direction, forceAnimate, isRect, previousRect, animateDuration) {
	    if (isAnimate === void 0) { isAnimate = false; }
	    if (x === void 0) { x = 'x'; }
	    if (y === void 0) { y = 'y'; }
	    if (forceAnimate === void 0) { forceAnimate = false; }
	    if (isRect === void 0) { isRect = false; }
	    if (previousRect === void 0) { previousRect = null; }
	    if (isCanvas) {
	        return null;
	    }
	    var existChild = parent.querySelector('#' + childElement.id);
	    var element = (existChild || getElement(childElement.id));
	    var child = childElement;
	    var duration = animateDuration ? animateDuration : 300;
	    if (redraw && isAnimate && element) {
	        start = start || (element.tagName === 'DIV' ?
	            new ChartLocation(+(element.style[x].split('px')[0]), +(element.style[y].split('px')[0])) :
	            new ChartLocation(+element.getAttribute(x), +element.getAttribute(y)));
	        if (direction && direction !== 'undefined') {
	            pathAnimation(childElement, childElement.getAttribute('d'), redraw, direction, duration);
	        }
	        else if (isRect && previousRect) {
	            animateRectElement(child, 0, duration, new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')), previousRect);
	        }
	        else {
	            var end = child.tagName === 'DIV' ?
	                new ChartLocation(+(child.style[x].split('px')[0]), +(child.style[y].split('px')[0])) :
	                new ChartLocation(+child.getAttribute(x), +child.getAttribute(y));
	            animateRedrawElement(child, duration, start, end, x, y);
	        }
	    }
	    else if (redraw && isAnimate && !element && forceAnimate) {
	        templateAnimate(child, 0, 600, 'FadeIn');
	    }
	    if (existChild) {
	        parent.replaceChild(child, element);
	    }
	    else {
	        parent.appendChild(child);
	    }
	}
	/** @private */
	function getDraggedRectLocation(x1, y1, x2, y2, outerRect) {
	    var width = Math.abs(x1 - x2);
	    var height = Math.abs(y1 - y2);
	    var x = Math.max(checkBounds(Math.min(x1, x2), width, outerRect.x, outerRect.width), outerRect.x);
	    var y = Math.max(checkBounds(Math.min(y1, y2), height, outerRect.y, outerRect.height), outerRect.y);
	    return new Rect(x, y, Math.min(width, outerRect.width), Math.min(height, outerRect.height));
	}
	/** @private */
	function checkBounds(start, size, min, max) {
	    if (start < min) {
	        start = min;
	    }
	    else if ((start + size) > (max + min)) {
	        start = (max + min) - size;
	    }
	    return start;
	}
	/** @private */
	function getLabelText(currentPoint, series, chart) {
	    var labelFormat = series.marker.dataLabel.format ? series.marker.dataLabel.format : series.yAxis.labelFormat;
	    var text = [];
	    var customLabelFormat = labelFormat.match('{value}') !== null;
	    switch (series.seriesType) {
	        case 'XY':
	            /**
	             * I255790
	             * For Polar radar series, the dataLabel appears out of range when axis range is given for yaxis
	             * Cause: Since symbol location for the points which did not lies in within range, lies outside of seriesRect.
	             * Fix: DataLabel rendered after checking WithIn for the points
	             */
	            if (series.chart.chartAreaType === 'PolarRadar') {
	                if (series.drawType.indexOf('Stacking') !== -1) {
	                    if ((series.yAxis.valueType === 'Logarithmic' &&
	                        logWithIn(series.stackedValues.endValues[currentPoint.index], series.yAxis)) ||
	                        withIn(series.stackedValues.endValues[currentPoint.index], series.yAxis.visibleRange)) {
	                        text.push(currentPoint.text || currentPoint.yValue.toString());
	                    }
	                }
	                else {
	                    if ((series.yAxis.valueType === 'Logarithmic' && logWithIn(currentPoint.yValue, series.yAxis)) ||
	                        withIn(currentPoint.yValue, series.yAxis.visibleRange)) {
	                        text.push(currentPoint.text || currentPoint.yValue.toString());
	                    }
	                }
	            }
	            else {
	                text.push(currentPoint.text || currentPoint.yValue.toString());
	            }
	            break;
	        case 'HighLow':
	            text.push(currentPoint.text || Math.max(currentPoint.high, currentPoint.low).toString());
	            text.push(currentPoint.text || Math.min(currentPoint.high, currentPoint.low).toString());
	            break;
	        case 'HighLowOpenClose':
	            text.push(currentPoint.text || Math.max(currentPoint.high, currentPoint.low).toString());
	            text.push(currentPoint.text || Math.min(currentPoint.high, currentPoint.low).toString());
	            text.push(currentPoint.text || Math.max(currentPoint.open, currentPoint.close).toString());
	            text.push(currentPoint.text || Math.min(currentPoint.open, currentPoint.close).toString());
	            break;
	        case 'BoxPlot':
	            text.push(currentPoint.text || currentPoint.median.toString());
	            text.push(currentPoint.text || currentPoint.maximum.toString());
	            text.push(currentPoint.text || currentPoint.minimum.toString());
	            text.push(currentPoint.text || currentPoint.upperQuartile.toString());
	            text.push(currentPoint.text || currentPoint.lowerQuartile.toString());
	            for (var _i = 0, _a = currentPoint.outliers; _i < _a.length; _i++) {
	                var liers = _a[_i];
	                text.push(currentPoint.text || liers.toString());
	            }
	            break;
	    }
	    if ((labelFormat || chart.useGroupingSeparator) && !currentPoint.text) {
	        series.yAxis.format = chart.intl.getNumberFormat({
	            format: customLabelFormat ? '' : labelFormat,
	            useGrouping: chart.useGroupingSeparator
	        });
	        for (var i = 0; i < text.length; i++) {
	            text[i] = customLabelFormat ? labelFormat.replace('{value}', series.yAxis.format(parseFloat(text[i]))) :
	                series.yAxis.format(parseFloat(text[i]));
	        }
	    }
	    return text;
	}
	/** @private */
	function stopTimer(timer) {
	    window.clearInterval(timer);
	}
	/** @private */
	function isCollide(rect, collections, clipRect) {
	    var currentRect = new Rect(rect.x + clipRect.x, rect.y + clipRect.y, rect.width, rect.height);
	    var isCollide = collections.some(function (rect) {
	        return (currentRect.x < rect.x + rect.width && currentRect.x + currentRect.width > rect.x &&
	            currentRect.y < rect.y + rect.height && currentRect.height + currentRect.y > rect.y);
	    });
	    return isCollide;
	}
	/** @private */
	function isOverlap(currentRect, rect) {
	    return (currentRect.x < rect.x + rect.width && currentRect.x + currentRect.width > rect.x &&
	        currentRect.y < rect.y + rect.height && currentRect.height + currentRect.y > rect.y);
	}
	/** @private */
	function calculateRect(location, textSize, margin) {
	    return new Rect((location.x - (textSize.width / 2) - margin.left), (location.y - (textSize.height / 2) - margin.top), textSize.width + margin.left + margin.right, textSize.height + margin.top + margin.bottom);
	}
	/** @private */
	function convertToHexCode(value) {
	    return '#' + componentToHex(value.r) + componentToHex(value.g) + componentToHex(value.b);
	}
	/** @private */
	function componentToHex(value) {
	    var hex = value.toString(16);
	    return hex.length === 1 ? '0' + hex : hex;
	}
	/** @private */
	function convertHexToColor(hex) {
	    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	    return result ? new ColorValue(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)) :
	        new ColorValue(255, 255, 255);
	}
	/** @private */
	function colorNameToHex(color) {
	    color = color === 'transparent' ? 'white' : color;
	    document.body.appendChild(createElement('text', { id: 'chartmeasuretext' }));
	    var element = document.getElementById('chartmeasuretext');
	    element.style.color = color;
	    color = window.getComputedStyle(element).color;
	    remove(element);
	    // eslint-disable-next-line security/detect-unsafe-regex
	    var exp = /^(rgb|hsl)(a?)[(]\s*([\d.]+\s*%?)\s*,\s*([\d.]+\s*%?)\s*,\s*([\d.]+\s*%?)\s*(?:,\s*([\d.]+)\s*)?[)]$/;
	    var isRGBValue = exp.exec(color);
	    return convertToHexCode(new ColorValue(parseInt(isRGBValue[3], 10), parseInt(isRGBValue[4], 10), parseInt(isRGBValue[5], 10)));
	}
	/** @private */
	function checkColorFormat(color) {
	    // eslint-disable-next-line security/detect-unsafe-regex
	    return /(rgba?\((?:\d{1,3}[,)]){3}(?:\d+\.\d+\))?)|(^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$)/gmi.test(color);
	}
	/** @private */
	function getSaturationColor(color, factor) {
	    color = colorNameToHex(color);
	    color = color.replace(/[^0-9a-f]/gi, '');
	    if (color.length < 6) {
	        color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];
	    }
	    factor = factor || 0;
	    // convert to decimal and change luminosity
	    var rgb = '#';
	    var colorCode;
	    for (var i = 0; i < 3; i++) {
	        colorCode = parseInt(color.substr(i * 2, 2), 16);
	        colorCode = Math.round(Math.min(Math.max(0, colorCode + (colorCode * factor)), 255));
	        rgb += ('00' + colorCode.toString(16)).substr(colorCode.toString(16).length);
	    }
	    return rgb;
	}
	/** @private */
	function applyZLight(color, value) {
	    var RGB = convertHexToColor(color);
	    RGB.r = parseInt(Math.floor(RGB.r * value).toString(), 10);
	    RGB.g = parseInt(Math.floor(RGB.g * value).toString(), 10);
	    RGB.b = parseInt(Math.floor(RGB.b * value).toString(), 10);
	    return '#' + componentToHex(RGB.r).toUpperCase() + componentToHex(RGB.g).toUpperCase() + componentToHex(RGB.b).toUpperCase();
	}
	/** @private */
	function calculateLegendShapes(location, size, shape, options) {
	    var padding = 10;
	    var dir = '';
	    var space = 2;
	    var height = size.height;
	    var width = size.width;
	    var lx = location.x;
	    var ly = location.y;
	    switch (shape) {
	        case 'MultiColoredLine':
	        case 'Line':
	        case 'StackingLine':
	        case 'StackingLine100':
	            dir = 'M' + ' ' + (lx + (-width * (3 / 4))) + ' ' + (ly) + ' ' +
	                'L' + ' ' + (lx + (width * (3 / 4))) + ' ' + (ly);
	            merge(options, { 'd': dir });
	            break;
	        case 'StepLine':
	            options.fill = 'transparent';
	            dir = 'M' + ' ' + (lx + (-width / 2) - (padding / 4)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx +
	                (-width / 2) + (width / 10)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx + (-width / 2) + (width / 10))
	                + ' ' + (ly) + ' ' + 'L' + ' ' + (lx + (-width / 10)) + ' ' + (ly) + ' ' + 'L' + ' ' + (lx + (-width / 10))
	                + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 5)) + ' ' + (ly + (height / 2)) + ' ' + 'L' +
	                ' ' + (lx + (width / 5)) + ' ' + (ly + (-height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly +
	                (-height / 2)) + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + '' + (lx + (width / 2)
	                + (padding / 4)) + ' ' + (ly + (height / 2));
	            merge(options, { 'd': dir });
	            break;
	        case 'UpArrow':
	            options.fill = options.stroke;
	            options.stroke = 'transparent';
	            dir = 'M' + ' ' + (lx + (-width / 2)) + ' ' + (ly + (height / 2)) + ' ' +
	                'L' + ' ' + (lx) + ' ' + (ly - (height / 2)) + ' ' +
	                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) +
	                'L' + ' ' + (lx + (width / 2) - space) + ' ' + (ly + (height / 2)) + ' ' +
	                'L' + ' ' + (lx) + ' ' + (ly - (height / 2) + (2 * space)) +
	                'L' + (lx - (width / 2) + space) + ' ' + (ly + (height / 2)) + ' Z';
	            merge(options, { 'd': dir });
	            break;
	        case 'DownArrow':
	            dir = 'M' + ' ' + (lx - (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +
	                'L' + ' ' + (lx) + ' ' + (ly + (height / 2)) + ' ' +
	                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) +
	                'L' + ' ' + (lx + (width / 2) - space) + ' ' + (ly - (height / 2)) + ' ' +
	                'L' + ' ' + (lx) + ' ' + (ly + (height / 2) - (2 * space)) +
	                'L' + (lx - (width / 2) + space) + ' ' + (ly - (height / 2)) + ' Z';
	            merge(options, { 'd': dir });
	            break;
	        case 'RightArrow':
	            dir = 'M' + ' ' + (lx + (-width / 2)) + ' ' + (ly - (height / 2)) + ' ' +
	                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly) + ' ' + 'L' + ' ' +
	                (lx + (-width / 2)) + ' ' + (ly + (height / 2)) + ' L' + ' ' + (lx + (-width / 2)) + ' ' +
	                (ly + (height / 2) - space) + ' ' + 'L' + ' ' + (lx + (width / 2) - (2 * space)) + ' ' + (ly) +
	                ' L' + (lx + (-width / 2)) + ' ' + (ly - (height / 2) + space) + ' Z';
	            merge(options, { 'd': dir });
	            break;
	        case 'LeftArrow':
	            options.fill = options.stroke;
	            options.stroke = 'transparent';
	            dir = 'M' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +
	                'L' + ' ' + (lx + (-width / 2)) + ' ' + (ly) + ' ' + 'L' + ' ' +
	                (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' +
	                (lx + (width / 2)) + ' ' + (ly + (height / 2) - space) + ' L' + ' ' + (lx + (-width / 2) + (2 * space))
	                + ' ' + (ly) + ' L' + (lx + (width / 2)) + ' ' + (ly - (height / 2) + space) + ' Z';
	            merge(options, { 'd': dir });
	            break;
	        case 'Column':
	        case 'Pareto':
	        case 'StackingColumn':
	        case 'StackingColumn100':
	        case 'RangeColumn':
	        case 'Histogram':
	            dir = 'M' + ' ' + (lx - 3 * (width / 5)) + ' ' + (ly - (height / 5)) + ' ' + 'L' + ' ' +
	                (lx + 3 * (-width / 10)) + ' ' + (ly - (height / 5)) + ' ' + 'L' + ' ' +
	                (lx + 3 * (-width / 10)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx - 3 *
	                (width / 5)) + ' ' + (ly + (height / 2)) + ' ' + 'Z' + ' ' + 'M' + ' ' +
	                (lx + (-width / 10) - (width / 20)) + ' ' + (ly - (height / 4) - (padding / 2))
	                + ' ' + 'L' + ' ' + (lx + (width / 10) + (width / 20)) + ' ' + (ly - (height / 4) -
	                (padding / 2)) + ' ' + 'L' + ' ' + (lx + (width / 10) + (width / 20)) + ' ' + (ly
	                + (height / 2)) + ' ' + 'L' + ' ' + (lx + (-width / 10) - (width / 20)) + ' ' + (ly +
	                (height / 2)) + ' ' + 'Z' + ' ' + 'M' + ' ' + (lx + 3 * (width / 10)) + ' ' + (ly) + ' ' +
	                'L' + ' ' + (lx + 3 * (width / 5)) + ' ' + (ly) + ' ' + 'L' + ' '
	                + (lx + 3 * (width / 5)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' '
	                + (lx + 3 * (width / 10)) + ' ' + (ly + (height / 2)) + ' ' + 'Z';
	            merge(options, { 'd': dir });
	            break;
	        case 'Bar':
	        case 'StackingBar':
	        case 'StackingBar100':
	            dir = 'M' + ' ' + (lx + (-width / 2) + (-padding / 4)) + ' ' + (ly - 3 * (height / 5)) + ' '
	                + 'L' + ' ' + (lx + 3 * (width / 10)) + ' ' + (ly - 3 * (height / 5)) + ' ' + 'L' + ' ' +
	                (lx + 3 * (width / 10)) + ' ' + (ly - 3 * (height / 10)) + ' ' + 'L' + ' ' +
	                (lx - (width / 2) + (-padding / 4)) + ' ' + (ly - 3 * (height / 10)) + ' ' + 'Z' + ' '
	                + 'M' + ' ' + (lx + (-width / 2) + (-padding / 4)) + ' ' + (ly - (height / 5)
	                + (padding / 20)) + ' ' + 'L' + ' ' + (lx + (width / 2) + (padding / 4)) + ' ' + (ly
	                - (height / 5) + (padding / 20)) + ' ' + 'L' + ' ' + (lx + (width / 2) + (padding / 4))
	                + ' ' + (ly + (height / 10) + (padding / 20)) + ' ' + 'L' + ' ' + (lx - (width / 2)
	                + (-padding / 4)) + ' ' + (ly + (height / 10) + (padding / 20)) + ' ' + 'Z' + ' ' + 'M'
	                + ' ' + (lx - (width / 2) + (-padding / 4)) + ' ' + (ly + (height / 5)
	                + (padding / 10)) + ' ' + 'L' + ' ' + (lx + (-width / 4)) + ' ' + (ly + (height / 5)
	                + (padding / 10)) + ' ' + 'L' + ' ' + (lx + (-width / 4)) + ' ' + (ly + (height / 2)
	                + (padding / 10)) + ' ' + 'L' + ' ' + (lx - (width / 2) + (-padding / 4))
	                + ' ' + (ly + (height / 2) + (padding / 10)) + ' ' + 'Z';
	            merge(options, { 'd': dir });
	            break;
	        case 'Spline':
	            options.fill = 'transparent';
	            dir = 'M' + ' ' + (lx - (width / 2)) + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' '
	                + lx + ' ' + (ly - height) + ' ' + lx + ' ' + (ly + (height / 5))
	                + ' ' + 'M' + ' ' + lx + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' ' + (lx
	                + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' + (lx + (width / 2)) + ' '
	                + (ly - (height / 2));
	            merge(options, { 'd': dir });
	            break;
	        case 'Area':
	        case 'MultiColoredArea':
	        case 'RangeArea':
	        case 'StackingArea':
	        case 'StackingArea100':
	            dir = 'M' + ' ' + (lx - (width / 2) - (padding / 4)) + ' ' + (ly + (height / 2))
	                + ' ' + 'L' + ' ' + (lx + (-width / 4) + (-padding / 8)) + ' ' + (ly - (height / 2))
	                + ' ' + 'L' + ' ' + (lx) + ' ' + (ly + (height / 4)) + ' ' + 'L' + ' ' + (lx
	                + (width / 4) + (padding / 8)) + ' ' + (ly + (-height / 2) + (height / 4)) + ' '
	                + 'L' + ' ' + (lx + (height / 2) + (padding / 4)) + ' ' + (ly + (height / 2)) + ' ' + 'Z';
	            merge(options, { 'd': dir });
	            break;
	        case 'SplineArea':
	        case 'SplineRangeArea':
	            dir = 'M' + ' ' + (lx - (width / 2)) + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' ' + lx
	                + ' ' + (ly - height) + ' ' + lx + ' ' + (ly + (height / 5)) + ' ' + 'Z' + ' ' + 'M'
	                + ' ' + lx + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' ' + (lx + (width / 2)) + ' '
	                + (ly + (height / 2)) + ' ' + (lx + (width / 2)) + ' '
	                + (ly - (height / 2)) + ' ' + ' Z';
	            merge(options, { 'd': dir });
	            break;
	        case 'Pie':
	        case 'Doughnut':
	            options.stroke = 'transparent';
	            // eslint-disable-next-line no-case-declarations
	            var r = Math.min(height, width) / 2;
	            dir = getAccumulationLegend(lx, ly, r, height, width);
	            merge(options, { 'd': dir });
	            break;
	    }
	    return { renderOption: options };
	}
	/** @private */
	function textTrim(maxWidth, text, font, themeFontStyle) {
	    var label = text;
	    var size = measureText(text, font, themeFontStyle).width;
	    if (size > maxWidth) {
	        var textLength = text.length;
	        for (var i = textLength - 1; i >= 0; --i) {
	            label = text.substring(0, i) + '...';
	            size = measureText(label, font, themeFontStyle).width;
	            if (size <= maxWidth) {
	                return label;
	            }
	        }
	    }
	    return label;
	}
	/** @private */
	function lineBreakLabelTrim(maxWidth, text, font, themeFontStyle) {
	    var labelCollection = [];
	    var breakLabels = text.split('<br>');
	    for (var i = 0; i < breakLabels.length; i++) {
	        text = breakLabels[i];
	        var size = measureText(text, font, themeFontStyle).width;
	        if (size > maxWidth) {
	            var textLength = text.length;
	            for (var i_1 = textLength - 1; i_1 >= 0; --i_1) {
	                text = text.substring(0, i_1) + '...';
	                size = measureText(text, font, themeFontStyle).width;
	                if (size <= maxWidth) {
	                    labelCollection.push(text);
	                    break;
	                }
	            }
	        }
	        else {
	            labelCollection.push(text);
	        }
	    }
	    return labelCollection;
	}
	/** @private */
	function stringToNumber(value, containerSize) {
	    if (value !== null && value !== undefined) {
	        return value.indexOf('%') !== -1 ? (containerSize / 100) * parseInt(value, 10) : parseInt(value, 10);
	    }
	    return null;
	}
	/** @private */
	function redrawElement(redraw, id, options, renderer) {
	    if (!redraw) {
	        return null;
	    }
	    var element = getElement(id);
	    if (element && options) {
	        renderer.setElementAttributes(options, element.tagName === 'clipPath' ? element.childNodes[0] : element);
	    }
	    return element;
	}
	/** @private */
	function animateRedrawElement(element, duration, start, end, x, y) {
	    if (x === void 0) { x = 'x'; }
	    if (y === void 0) { y = 'y'; }
	    var isDiv = element.tagName === 'DIV';
	    var setStyle = function (xValue, yValue) {
	        if (isDiv) {
	            element.style[x] = xValue + 'px';
	            element.style[y] = yValue + 'px';
	        }
	        else {
	            element.setAttribute(x, xValue + '');
	            element.setAttribute(y, yValue + '');
	        }
	    };
	    setStyle(start.x, start.y);
	    new Animation$1({}).animate(createElement('div'), {
	        duration: duration,
	        progress: function (args) {
	            setStyle(linear(args.timeStamp, start.x, end.x - start.x, args.duration), linear(args.timeStamp, start.y, end.y - start.y, args.duration));
	        },
	        end: function () {
	            setStyle(end.x, end.y);
	        }
	    });
	}
	/** @private */
	function textElement(renderer, option, font, color, parent, isMinus, redraw, isAnimate, forceAnimate, animateDuration, seriesClipRect, labelSize, isRotatedLabelIntersect, isCanvas, isDataLabelWrap, themeFontStyle) {
	    if (isMinus === void 0) { isMinus = false; }
	    if (forceAnimate === void 0) { forceAnimate = false; }
	    var renderOptions = {};
	    var tspanElement;
	    //let renderer: SvgRenderer = new SvgRenderer('');
	    var height;
	    var dy;
	    var label;
	    var width = 0;
	    var dx;
	    var maxWidth = 0;
	    if (option.text.length > 1 && isDataLabelWrap) {
	        for (var i = 0, len = option.text.length; i < len; i++) {
	            maxWidth = Math.max(maxWidth, measureText(option.text[i], font, themeFontStyle).width);
	        }
	        width = measureText(option.text[0], font, themeFontStyle).width;
	    }
	    dx = (option.text.length > 1 && isDataLabelWrap) ? (option.x + maxWidth / 2 - width / 2) : option.x;
	    renderOptions = {
	        'id': option.id,
	        'x': dx,
	        'y': option.y,
	        'fill': color ? color : 'black',
	        'font-size': font.size,
	        'font-style': font.fontStyle,
	        'font-family': font.fontFamily || themeFontStyle.fontFamily,
	        'font-weight': font.fontWeight,
	        'text-anchor': option.anchor,
	        'labelRotation': option.labelRotation,
	        'transform': option.transform,
	        'opacity': font.opacity,
	        'dominant-baseline': option.baseLine
	    };
	    var text = typeof option.text === 'string' ? option.text : isMinus ? option.text[option.text.length - 1] : option.text[0];
	    var transX = seriesClipRect ? seriesClipRect.x : 0;
	    var transY = seriesClipRect ? seriesClipRect.y : 0;
	    var htmlObject = renderer.createText(renderOptions, text, transX, transY);
	    if (typeof option.text !== 'string' && option.text.length > 1) {
	        for (var i = 1, len = option.text.length; i < len; i++) {
	            height = (measureText(option.text[i], font, themeFontStyle).height);
	            width = measureText(option.text[i], font, themeFontStyle).width;
	            dy = (option.y) + ((isMinus) ? -(i * height) : (i * height));
	            dx = isDataLabelWrap ? (option.x + maxWidth / 2 - width / 2) : option.x;
	            label = isMinus ? option.text[option.text.length - (i + 1)] : option.text[i];
	            if (isCanvas) {
	                tspanElement = renderer.createText(renderOptions, label, null, null, dy, true);
	            }
	            else {
	                tspanElement = renderer.createTSpan({
	                    'x': dx, 'id': option.id,
	                    'y': dy
	                }, label);
	                htmlObject.appendChild(tspanElement);
	            }
	        }
	    }
	    if (!isRotatedLabelIntersect) {
	        appendChildElement(renderer instanceof CanvasRenderer, parent, htmlObject, redraw, isAnimate, 'x', 'y', null, null, forceAnimate, false, null, animateDuration);
	    }
	    return htmlObject;
	}
	/**
	 * Method to calculate the width and height of the chart.
	 */
	function calculateSize(chart) {
	    // fix for Chart rendered with default width in IE issue
	    var containerWidth = chart.element.clientWidth || chart.element.offsetWidth;
	    var containerHeight = chart.element.clientHeight;
	    if (chart.stockChart) {
	        containerWidth = chart.stockChart.availableSize.width;
	        containerHeight = chart.stockChart.availableSize.height;
	    }
	    var height = 450;
	    var marginHeight;
	    if (chart.getModuleName() === 'rangeNavigator') {
	        var range = chart;
	        var tooltipSpace = range.tooltip.enable ? 35 : 0;
	        var periodHeight = range.periodSelectorSettings.periods.length ?
	            range.periodSelectorSettings.height : 0;
	        marginHeight = range.margin.top + range.margin.bottom + tooltipSpace;
	        var labelSize = measureText('tempString', range.labelStyle, range.themeStyle.axisLabelFont).height;
	        var labelPadding = 15;
	        height = (chart.series.length ? (Browser.isDevice ? 80 : 120) : ((range.enableGrouping ? (40 + labelPadding + labelSize) : 40)
	            + marginHeight)) + periodHeight;
	        if (range.disableRangeSelector) {
	            height = periodHeight;
	        }
	    }
	    chart.availableSize = new Size(stringToNumber(chart.width, containerWidth) || containerWidth || 600, stringToNumber(chart.height, containerHeight || height) || containerHeight || height);
	    if (chart.getModuleName() === 'chart') {
	        var scaleX = 1;
	        var scaleY = 1;
	        if (chart.width === '' || chart.width === null || chart.width === '100%') {
	            scaleX = chart.element.getBoundingClientRect().width > 0 ?
	                chart.element.getBoundingClientRect().width / chart.availableSize.width : 1;
	            scaleY = chart.element.getBoundingClientRect().height > 0 ?
	                chart.element.getBoundingClientRect().height / chart.availableSize.height : 1;
	            var transformValue = chart.element.style.transform;
	            if (transformValue) {
	                var scaleValue = parseFloat(transformValue.match(/scale\((.*?)\)/)[1]);
	                scaleX = scaleValue ? scaleX / scaleValue : scaleX;
	                scaleY = scaleValue ? scaleY / scaleValue : scaleY;
	            }
	            chart.availableSize.width = chart.availableSize.width * scaleX;
	            chart.availableSize.height = chart.availableSize.height * scaleY;
	            chart.scaleX = scaleX;
	            chart.scaleY = scaleY;
	        }
	    }
	}
	/**
	 * To create svg element.
	 *
	 * @param {Chart} chart chart instance
	 */
	function createSvg(chart) {
	    chart.canvasRender = new CanvasRenderer(chart.element.id);
	    chart.renderer = chart.enableCanvas ? chart.canvasRender : new SvgRenderer(chart.element.id);
	    calculateSize(chart);
	    if (chart.stockChart && chart.getModuleName() === 'chart') {
	        chart.svgObject = chart.stockChart.chartObject;
	    }
	    else if (chart.stockChart && chart.getModuleName() === 'rangeNavigator') {
	        chart.svgObject = chart.stockChart.selectorObject;
	    }
	    else {
	        if (chart.enableCanvas) {
	            chart.svgObject = chart.renderer.createCanvas({
	                id: chart.element.id + '_canvas',
	                width: chart.availableSize.width,
	                height: chart.availableSize.height
	            });
	        }
	        else {
	            chart.svgObject = chart.renderer.createSvg({
	                id: chart.element.id + '_svg',
	                width: chart.availableSize.width,
	                height: chart.availableSize.height
	            });
	        }
	    }
	    if (chart.enableCanvas) {
	        chart.renderer.ctx.direction = chart.enableRtl ? 'rtl' : 'ltr';
	    }
	}
	/**
	 * To calculate chart title and height.
	 *
	 * @param {string} title text of the title
	 * @param {FontModel} style style of the title
	 * @param {number} width width of the title
	 */
	function getTitle(title, style, width, themeFontStyle) {
	    var titleCollection = [];
	    switch (style.textOverflow) {
	        case 'Wrap':
	            titleCollection = textWrap(title, width, style, null, null, themeFontStyle);
	            break;
	        case 'Trim':
	            titleCollection.push(textTrim(width, title, style, themeFontStyle));
	            break;
	        default:
	            titleCollection.push(title);
	            break;
	    }
	    return titleCollection;
	}
	/**
	 * Method to calculate x position of title.
	 */
	function titlePositionX(rect, titleStyle) {
	    var positionX;
	    if (titleStyle.textAlignment === 'Near') {
	        positionX = rect.x;
	    }
	    else if (titleStyle.textAlignment === 'Center') {
	        positionX = rect.x + rect.width / 2;
	    }
	    else {
	        positionX = rect.x + rect.width;
	    }
	    return positionX;
	}
	/**
	 * Method to find new text and element size based on textOverflow.
	 */
	function textWrap(currentLabel, maximumWidth, font, wrapAnyWhere, clip, themeFontStyle) {
	    if (wrapAnyWhere) {
	        return (textWrapAnyWhere(currentLabel, maximumWidth, font, themeFontStyle));
	    }
	    else {
	        var textCollection = currentLabel.split(' ');
	        var label = '';
	        var labelCollection = [];
	        var text = void 0;
	        for (var i = 0, len = textCollection.length; i < len; i++) {
	            text = textCollection[i];
	            if (measureText(label.concat(label === '' ? '' : ' ' + text), font, themeFontStyle).width < maximumWidth) {
	                label = label.concat((label === '' ? '' : ' ') + text);
	            }
	            else {
	                if (label !== '') {
	                    labelCollection.push(clip ? label : textTrim(maximumWidth, label, font, themeFontStyle));
	                    label = text;
	                }
	                else {
	                    labelCollection.push(clip ? text : textTrim(maximumWidth, text, font, themeFontStyle));
	                    text = '';
	                }
	            }
	            if (label && i === len - 1) {
	                labelCollection.push(clip ? label : textTrim(maximumWidth, label, font, themeFontStyle));
	            }
	        }
	        return labelCollection;
	    }
	}
	/**
	 * Method to find new text and element size based on textWrap.
	 */
	function textWrapAnyWhere(currentLabel, maximumWidth, font, themeFontStyle) {
	    var size = measureText(currentLabel, font, themeFontStyle).width;
	    var labelCollection = [];
	    if (size > maximumWidth) {
	        var label = '';
	        var startIndex = 0;
	        var labelIndex = 1;
	        while (labelIndex < currentLabel.length) {
	            label = currentLabel.substring(startIndex, labelIndex);
	            size = measureText(label, font, themeFontStyle).width;
	            if (size < maximumWidth) {
	                labelIndex++;
	            }
	            else if (size === maximumWidth) {
	                startIndex = labelIndex;
	                labelCollection.push(label);
	                labelIndex++;
	                label = '';
	            }
	            else if (size > maximumWidth) {
	                label = label.slice(0, -1);
	                startIndex = labelIndex - 1;
	                labelCollection.push(label);
	                label = '';
	            }
	        }
	        if (label.length > 0) {
	            labelCollection.push(label);
	        }
	    }
	    else {
	        labelCollection.push(currentLabel);
	    }
	    return labelCollection;
	}
	/**
	 * Method to support the subscript and superscript value to text.
	 */
	function getUnicodeText(text, regexp) {
	    var title = text.replace(regexp, ' ');
	    var digit = text.match(regexp);
	    var digitSpecific = ' ';
	    var convertedText = ' ';
	    var k = 0;
	    var unicodeSub = {
	        '0': '\u2080', '1': '\u2081', '2': '\u2082', '3': '\u2083', '4': '\u2084',
	        '5': '\u2085', '6': '\u2086', '7': '\u2087', '8': '\u2088', '9': '\u2089'
	    };
	    var unicodeSup = {
	        '0': '\u2070', '1': '\u00B9', '2': '\u00B2', '3': '\u00B3', '4': '\u2074',
	        '5': '\u2075', '6': '\u2076', '7': '\u2077', '8': '\u2078', '9': '\u2079'
	    };
	    for (var i = 0; i <= title.length - 1; i++) {
	        if (title[i] === ' ') {
	            digitSpecific = (regexp === regSub) ? digit[k].replace(/~/g, '') : digit[k].replace(/\^/g, '');
	            for (var j = 0; j < digitSpecific.length; j++) {
	                convertedText += (regexp === regSub) ? unicodeSub[digitSpecific[j]] : unicodeSup[digitSpecific[j]];
	            }
	            k++;
	        }
	        else {
	            convertedText += title[i];
	        }
	    }
	    return convertedText.trim();
	}
	/**
	 * Method to reset the blazor templates.
	 */
	function blazorTemplatesReset(control) {
	    for (var i = 0; i < control.annotations.length; i++) {
	        resetBlazorTemplate((control.element.id + '_Annotation_' + i).replace(/[^a-zA-Z0-9]/g, ''));
	    }
	    //This reset the tooltip templates
	    resetBlazorTemplate(control.element.id + '_tooltipparent_template' + '_blazorTemplate');
	    //Datalabel templates reset
	    resetBlazorTemplate(control.element.id + '_DataLabel');
	}
	/** @private */
	var StackValues = /** @class */ (function () {
	    function StackValues(startValue, endValue) {
	        this.startValues = startValue;
	        this.endValues = endValue;
	    }
	    return StackValues;
	}());
	/** @private */
	var RectOption = /** @class */ (function (_super) {
	    __extends$x(RectOption, _super);
	    function RectOption(id, fill, border, opacity, rect, rx, ry, transform, dashArray) {
	        var _this = _super.call(this, id, fill, border.width, border.color, opacity, dashArray) || this;
	        _this.y = rect.y;
	        _this.x = rect.x;
	        _this.height = rect.height;
	        _this.width = rect.width;
	        _this.rx = rx ? rx : 0;
	        _this.ry = ry ? ry : 0;
	        _this.transform = transform ? transform : '';
	        _this.stroke = (border.width !== 0 && _this.stroke !== '') ? border.color === null ? '' : border.color : 'transparent';
	        return _this;
	    }
	    return RectOption;
	}(PathOption));
	/** @private */
	var ImageOption = /** @class */ (function () {
	    function ImageOption(height, width, href, x, y, id, visibility, preserveAspectRatio) {
	        this.height = height;
	        this.width = width;
	        this.href = href;
	        this.x = x;
	        this.y = y;
	        this.id = id;
	        this.visibility = visibility;
	        this.preserveAspectRatio = preserveAspectRatio;
	    }
	    return ImageOption;
	}());
	/** @private */
	var CircleOption = /** @class */ (function (_super) {
	    __extends$x(CircleOption, _super);
	    function CircleOption(id, fill, border, opacity, cx, cy, r) {
	        var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;
	        _this.cy = cy;
	        _this.cx = cx;
	        _this.r = r;
	        return _this;
	    }
	    return CircleOption;
	}(PathOption));
	/** @private */
	var ChartLocation = /** @class */ (function () {
	    function ChartLocation(x, y) {
	        this.x = x;
	        this.y = y;
	    }
	    return ChartLocation;
	}());
	/** @private */
	var Thickness = /** @class */ (function () {
	    function Thickness(left, right, top, bottom) {
	        this.left = left;
	        this.right = right;
	        this.top = top;
	        this.bottom = bottom;
	    }
	    return Thickness;
	}());
	/** @private */
	var ColorValue = /** @class */ (function () {
	    function ColorValue(r, g, b) {
	        this.r = r;
	        this.g = g;
	        this.b = b;
	    }
	    return ColorValue;
	}());
	/** @private */
	var PointData = /** @class */ (function () {
	    function PointData(point, series, index) {
	        if (index === void 0) { index = 0; }
	        this.point = point;
	        this.series = series;
	        this.lierIndex = index;
	    }
	    return PointData;
	}());
	/** @private */
	var ControlPoints = /** @class */ (function () {
	    function ControlPoints(controlPoint1, controlPoint2) {
	        this.controlPoint1 = controlPoint1;
	        this.controlPoint2 = controlPoint2;
	    }
	    return ControlPoints;
	}());
	/** @private */
	function getColorByValue(colorMap, value) {
	    var color = '';
	    var rbgColorValue;
	    if (Number(value) === colorMap.start) {
	        color = colorMap.colors[0];
	    }
	    else if (Number(value) === colorMap.end) {
	        color = colorMap.colors[colorMap.colors.length - 1];
	    }
	    else {
	        rbgColorValue = getGradientColor(Number(value), colorMap);
	        color = convertToHexCode(rbgColorValue);
	    }
	    return color;
	}
	/** @private */
	function getGradientColor(value, colorMap) {
	    var previousOffset = colorMap.start;
	    var nextOffset = colorMap.end;
	    var percent = 0;
	    var full = nextOffset - previousOffset;
	    var midColor;
	    percent = (value - previousOffset) / full;
	    var previousColor;
	    var nextColor;
	    if (colorMap.colors.length <= 2) {
	        previousColor = colorMap.colors[0].charAt(0) === '#' ? colorMap.colors[0] : colorNameToHex(colorMap.colors[0]);
	        nextColor = colorMap.colors[colorMap.colors.length - 1].charAt(0) === '#' ?
	            colorMap.colors[colorMap.colors.length - 1] : colorNameToHex(colorMap.colors[colorMap.colors.length - 1]);
	    }
	    else {
	        previousColor = colorMap.colors[0].charAt(0) === '#' ? colorMap.colors[0] : colorNameToHex(colorMap.colors[0]);
	        nextColor = colorMap.colors[colorMap.colors.length - 1].charAt(0) === '#' ?
	            colorMap.colors[colorMap.colors.length - 1] : colorNameToHex(colorMap.colors[colorMap.colors.length - 1]);
	        var a = full / (colorMap.colors.length - 1);
	        var b = void 0;
	        var c = void 0;
	        var length_2 = colorMap.colors.length - 1;
	        var splitColorValueOffset = [];
	        var splitColor = {};
	        for (var j = 1; j < length_2; j++) {
	            c = j * a;
	            b = previousOffset + c;
	            splitColor = { b: b, color: colorMap.colors[j] };
	            splitColorValueOffset.push(splitColor);
	        }
	        for (var i = 0; i < splitColorValueOffset.length; i++) {
	            if (previousOffset <= value && value <= splitColorValueOffset[i]['b'] && i === 0) {
	                midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ?
	                    splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);
	                nextColor = midColor;
	                percent = value <= splitColorValueOffset[i]['b'] ? 1 - Math.abs((value - splitColorValueOffset[i]['b']) / a)
	                    : (value - splitColorValueOffset[i]['b']) / a;
	            }
	            else if (splitColorValueOffset[i]['b'] <= value && value <= nextOffset && i === (splitColorValueOffset.length - 1)) {
	                midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ?
	                    splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);
	                previousColor = midColor;
	                percent = value < splitColorValueOffset[i]['b'] ?
	                    1 - Math.abs((value - splitColorValueOffset[i]['b']) / a) : (value - splitColorValueOffset[i]['b']) / a;
	            }
	            if (i !== splitColorValueOffset.length - 1 && i < splitColorValueOffset.length) {
	                if (splitColorValueOffset[i]['b'] <= value && value <= splitColorValueOffset[i + 1]['b']) {
	                    midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ?
	                        splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);
	                    previousColor = midColor;
	                    nextColor = splitColorValueOffset[i + 1]['color'].charAt(0) === '#' ?
	                        splitColorValueOffset[i + 1]['color'] : colorNameToHex(splitColorValueOffset[i + 1]['color']);
	                    percent = Math.abs((value - splitColorValueOffset[i + 1]['b'])) / a;
	                }
	            }
	        }
	    }
	    return getPercentageColor(percent, previousColor, nextColor);
	}
	/** @private */
	function getPercentageColor(percent, previous, next) {
	    var nextColor = next.split('#')[1];
	    var prevColor = previous.split('#')[1];
	    var r = getPercentage(percent, parseInt(prevColor.substr(0, 2), 16), parseInt(nextColor.substr(0, 2), 16));
	    var g = getPercentage(percent, parseInt(prevColor.substr(2, 2), 16), parseInt(nextColor.substr(2, 2), 16));
	    var b = getPercentage(percent, parseInt(prevColor.substr(4, 2), 16), parseInt(nextColor.substr(4, 2), 16));
	    return new ColorValue(r, g, b);
	}
	/** @private */
	function getPercentage(percent, previous, next) {
	    var full = next - previous;
	    return Math.round((previous + (full * percent)));
	}
	/** @private */
	function getTextAnchor(alignment, enableRTL) {
	    switch (alignment) {
	        case 'Near':
	            return enableRTL ? 'end' : 'start';
	        case 'Far':
	            return enableRTL ? 'start' : 'end';
	        default:
	            return 'middle';
	    }
	}

	/**
	 * Specifies Chart Themes
	 */
	// eslint-disable-next-line @typescript-eslint/no-namespace
	var Theme;
	(function (Theme) {
	    /** @private */
	    Theme.stockEventFont = {
	        size: '13px',
	        fontWeight: '400',
	        color: null,
	        fontStyle: 'Normal',
	        fontFamily: 'Segoe UI'
	    };
	})(Theme || (Theme = {}));
	/** @private */
	function getSeriesColor(theme) {
	    var palette;
	    switch (theme) {
	        case 'Fabric':
	            palette = ['#4472c4', '#ed7d31', '#ffc000', '#70ad47', '#5b9bd5',
	                '#c1c1c1', '#6f6fe2', '#e269ae', '#9e480e', '#997300'];
	            break;
	        case 'Bootstrap4':
	            palette = ['#a16ee5', '#f7ce69', '#55a5c2', '#7ddf1e', '#ff6ea6',
	                '#7953ac', '#b99b4f', '#407c92', '#5ea716', '#b91c52'];
	            break;
	        case 'Bootstrap':
	            palette = ['#a16ee5', '#f7ce69', '#55a5c2', '#7ddf1e', '#ff6ea6',
	                '#7953ac', '#b99b4f', '#407c92', '#5ea716', '#b91c52'];
	            break;
	        case 'HighContrastLight':
	        case 'HighContrast':
	            palette = ['#79ECE4', '#E98272', '#DFE6B6', '#C6E773', '#BA98FF',
	                '#FA83C3', '#00C27A', '#43ACEF', '#D681EF', '#D8BC6E'];
	            break;
	        case 'MaterialDark':
	            palette = ['#9ECB08', '#56AEFF', '#C57AFF', '#61EAA9', '#EBBB3E',
	                '#F45C5C', '#8A77FF', '#63C7FF', '#FF84B0', '#F7C928'];
	            break;
	        case 'FabricDark':
	            palette = ['#4472c4', '#ed7d31', '#ffc000', '#70ad47', '#5b9bd5',
	                '#c1c1c1', '#6f6fe2', '#e269ae', '#9e480e', '#997300'];
	            break;
	        case 'BootstrapDark':
	            palette = ['#a16ee5', '#f7ce69', '#55a5c2', '#7ddf1e', '#ff6ea6',
	                '#7953ac', '#b99b4f', '#407c92', '#5ea716', '#b91c52'];
	            break;
	        case 'Tailwind':
	            palette = ['#5A61F6', '#65A30D', '#334155', '#14B8A6', '#8B5CF6',
	                '#0369A1', '#F97316', '#9333EA', '#F59E0B', '#15803D'];
	            break;
	        case 'TailwindDark':
	            palette = ['#8B5CF6', '#22D3EE', '#F87171', '#4ADE80', '#E879F9',
	                '#FCD34D', '#F97316', '#2DD4BF', '#F472B6', '#10B981'];
	            break;
	        case 'Bootstrap5':
	            palette = ['#6355C7', '#FFB400', '#2196F5', '#F7523F', '#963C70',
	                '#4BE0BC', '#FD7400', '#C9E422', '#DE3D8A', '#162F88'];
	            break;
	        case 'Bootstrap5Dark':
	            palette = ['#8F80F4', '#FFD46D', '#6CBDFF', '#FF7F71', '#FF6DB3',
	                '#63F5D2', '#FCAA65', '#ECFF77', '#EF8EFF', '#5F82FD'];
	            break;
	        case 'FluentDark':
	            palette = ['#1AC9E6', '#DA4CB2', '#EDBB40', '#AF4BCF', '#FF7266',
	                '#1BD565', '#EE993D', '#5887FF', '#EC548D', '#7D39C0'];
	            break;
	        case 'Fluent':
	            palette = ['#1AC9E6', '#DA4CB2', '#EDBB40', '#AF4BCF', '#FF7266',
	                '#1BD565', '#EE993D', '#5887FF', '#EC548D', '#7D39C0'];
	            break;
	        case 'Material3':
	            palette = ['#6355C7', '#00AEE0', '#FFB400', '#F7523F', '#963C70',
	                '#FD7400', '#4BE0BC', '#2196F5', '#DE3D8A', '#162F88'];
	            break;
	        case 'Material3Dark':
	            palette = ['#4EAAFF', '#FA4EAB', '#FFF500', '#17EA58', '#38FFE7',
	                '#FF9E45', '#B3F32F', '#B93CE4', '#FC5664', '#9B55FF'];
	            break;
	        default:
	            palette = ['#00bdae', '#404041', '#357cd2', '#e56590', '#f8b883',
	                '#70ad47', '#dd8abd', '#7f84e8', '#7bb4eb', '#ea7a57'];
	            break;
	    }
	    return palette;
	}
	/** @private */
	// tslint:disable-next-line:max-func-body-length
	function getThemeColor(theme, canvas) {
	    var style;
	    var darkBackground = theme === 'MaterialDark' ? '#383838' : (theme === 'FabricDark' ? '#242424' : '#1b1b1b');
	    switch (theme) {
	        case 'HighContrastLight':
	        case 'HighContrast':
	            style = {
	                axisLabel: '#ffffff',
	                axisTitle: '#ffffff',
	                axisLine: '#ffffff',
	                majorGridLine: '#BFBFBF',
	                minorGridLine: '#969696',
	                majorTickLine: '#BFBFBF',
	                minorTickLine: '#969696',
	                chartTitle: '#ffffff',
	                legendLabel: '#ffffff',
	                background: canvas ? '#000000' : 'transparent',
	                areaBorder: '#ffffff',
	                errorBar: '#ffffff',
	                crosshairLine: '#ffffff',
	                crosshairFill: '#ffffff',
	                crosshairLabel: '#000000',
	                tooltipFill: '#ffffff',
	                tooltipBoldLabel: '#000000',
	                tooltipLightLabel: '#000000',
	                tooltipHeaderLine: '#969696',
	                markerShadow: '#BFBFBF',
	                selectionRectFill: 'rgba(255, 217, 57, 0.3)',
	                selectionRectStroke: '#ffffff',
	                selectionCircleStroke: '#FFD939',
	                tabColor: '#FFD939',
	                bearFillColor: '#2ecd71',
	                bullFillColor: '#e74c3d',
	                toolkitSelectionColor: '#FFD939',
	                toolkitFill: '#737373',
	                toolkitIconRectOverFill: 'transparent',
	                toolkitIconRectSelectionFill: 'transparent',
	                toolkitIconRect: new Rect(0, 0, 16, 16),
	                chartTitleFont: {
	                    color: '#FFFFFF', fontFamily: 'Segoe UI'
	                },
	                axisLabelFont: {
	                    color: '#969696', fontFamily: 'Segoe UI'
	                },
	                legendTitleFont: {
	                    color: '#FFFFFF', fontFamily: 'Segoe UI'
	                },
	                legendLabelFont: {
	                    color: '#969696', fontFamily: 'Segoe UI'
	                },
	                tooltipLabelFont: {
	                    color: '#000000', fontFamily: 'Segoe UI'
	                },
	                axisTitleFont: {
	                    color: '#FFFFFF', fontFamily: 'Segoe UI'
	                },
	                datalabelFont: {
	                    color: '#969696', fontFamily: 'Segoe UI'
	                },
	                chartSubTitleFont: {
	                    color: '#FFFFFF', fontFamily: 'Segoe UI'
	                },
	                crosshairLabelFont: {
	                    color: '#000000', fontFamily: 'Segoe UI'
	                },
	                stripLineLabelFont: {
	                    color: '#969696', fontFamily: 'Segoe UI'
	                }
	            };
	            break;
	        case 'MaterialDark':
	        case 'FabricDark':
	        case 'BootstrapDark':
	            style = {
	                axisLabel: '#DADADA', axisTitle: '#ffffff',
	                axisLine: ' #6F6C6C',
	                majorGridLine: '#414040',
	                minorGridLine: '#514F4F',
	                majorTickLine: '#414040',
	                minorTickLine: ' #4A4848',
	                chartTitle: '#ffffff',
	                legendLabel: '#DADADA',
	                background: canvas ? darkBackground : 'transparent',
	                areaBorder: ' #9A9A9A',
	                errorBar: '#ffffff',
	                crosshairLine: '#F4F4F4',
	                crosshairFill: theme === 'MaterialDark' ? '#F4F4F4' : theme === 'FabricDark' ? '#A19F9D' : '#F0F0F0',
	                crosshairLabel: '#282727',
	                tooltipFill: '#F4F4F4',
	                tooltipBoldLabel: '#282727',
	                tooltipLightLabel: '#333232',
	                tooltipHeaderLine: '#9A9A9A',
	                markerShadow: null,
	                selectionRectFill: 'rgba(56,169,255, 0.1)',
	                selectionRectStroke: '#38A9FF',
	                selectionCircleStroke: '#282727',
	                tabColor: theme === 'MaterialDark' ? '#00B0FF' : theme === 'FabricDark' ? '#0074CC' : '#0070F0',
	                bearFillColor: '#2ecd71',
	                bullFillColor: '#e74c3d',
	                toolkitSelectionColor: theme === 'MaterialDark' ? '#00B0FF' : theme === 'FabricDark' ? '#0074CC' : '#0070F0',
	                toolkitFill: '#737373',
	                toolkitIconRectOverFill: 'transparent',
	                toolkitIconRectSelectionFill: 'transparent',
	                toolkitIconRect: new Rect(0, 0, 16, 16),
	                chartTitleFont: {
	                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'FabricDark' ? '#DADADA' : '#FFFFFF', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
	                },
	                axisLabelFont: {
	                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'FabricDark' ? '#A19F9D' : '#CED4DA', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
	                },
	                legendTitleFont: {
	                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'FabricDark' ? '#DADADA' : '#FFFFFF', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
	                },
	                legendLabelFont: {
	                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'FabricDark' ? '#A19F9D' : '#676767', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
	                },
	                tooltipLabelFont: {
	                    color: theme === 'MaterialDark' ? 'rgba(18, 18, 18, 1)' : theme === 'FabricDark' ? '#DADADA' : '#1A1A1A', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
	                },
	                axisTitleFont: {
	                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'FabricDark' ? '#DADADA' : '#FFFFFF', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
	                },
	                datalabelFont: {
	                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.6)' : theme === 'FabricDark' ? '#A19F9D' : '#676767', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
	                },
	                chartSubTitleFont: {
	                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.87)' : theme === 'FabricDark' ? '#DADADA' : '#FFFFFF', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
	                },
	                crosshairLabelFont: {
	                    color: theme === 'MaterialDark' ? 'rgba(18, 18, 18, 1)' : theme === 'FabricDark' ? '#DADADA' : '#1A1A1A', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
	                },
	                stripLineLabelFont: {
	                    color: theme === 'MaterialDark' ? 'rgba(255, 255, 255, 0.24)' : theme === 'FabricDark' ? '#6F6C6C' : '#414141', fontFamily: theme === 'MaterialDark' ? 'Roboto' : theme === 'FabricDark' ? 'Segoe UI' : 'Helvetica'
	                }
	            };
	            break;
	        case 'Bootstrap4':
	            style = {
	                axisLabel: '#212529', axisTitle: '#212529', axisLine: '#CED4DA', majorGridLine: '#CED4DA',
	                minorGridLine: '#DEE2E6', majorTickLine: '#ADB5BD', minorTickLine: '#CED4DA', chartTitle: '#212529', legendLabel: '#212529',
	                background: canvas ? '#FFFFFF' : 'transparent', areaBorder: '#DEE2E6', errorBar: '#000000', crosshairLine: '#6C757D', crosshairFill: '#212529',
	                crosshairLabel: '#FFFFFF', tooltipFill: '#020202', tooltipBoldLabel: 'rgba(255,255,255)',
	                tooltipLightLabel: 'rgba(255,255,255, 0.9)', tooltipHeaderLine: 'rgba(255,255,255, 0.2)', markerShadow: null,
	                selectionRectFill: 'rgba(255,255,255, 0.1)', selectionRectStroke: 'rgba(0, 123, 255)', selectionCircleStroke: '#495057', tabColor: '#007BFF', bearFillColor: '#2ecd71', bullFillColor: '#e74c3d',
	                toolkitSelectionColor: '#007BFF',
	                toolkitFill: '#495057',
	                toolkitIconRectOverFill: 'transparent',
	                toolkitIconRectSelectionFill: 'transparent',
	                toolkitIconRect: new Rect(-5, -5, 26, 26),
	                chartTitleFont: {
	                    color: '#212529', fontFamily: 'Helvetica'
	                },
	                axisLabelFont: {
	                    color: '#495057', fontFamily: 'Helvetica'
	                },
	                legendTitleFont: {
	                    color: '#212529', fontFamily: 'Helvetica'
	                },
	                legendLabelFont: {
	                    color: '#666666', fontFamily: 'Helvetica'
	                },
	                tooltipLabelFont: {
	                    color: '#F9FAFB', fontFamily: 'Helvetica'
	                },
	                axisTitleFont: {
	                    color: '#212529', fontFamily: 'Helvetica'
	                },
	                datalabelFont: {
	                    color: '#495057', fontFamily: 'Helvetica'
	                },
	                chartSubTitleFont: {
	                    color: '#212529', fontFamily: 'Helvetica'
	                },
	                crosshairLabelFont: {
	                    color: '#F9FAFB', fontFamily: 'Helvetica'
	                },
	                stripLineLabelFont: {
	                    color: '#6C757D', fontFamily: 'Helvetica'
	                }
	            };
	            break;
	        case 'Tailwind':
	            style = {
	                axisLabel: '#6B728', axisTitle: '#374151',
	                axisLine: ' #D1D5DB',
	                majorGridLine: '#E5E7EB',
	                minorGridLine: '#E5E7EB',
	                majorTickLine: '#D1D5DB',
	                minorTickLine: ' #D1D5DB',
	                chartTitle: '#374151',
	                legendLabel: '#374151',
	                background: canvas ? 'rgba(255,255,255, 0.0)' : 'transparent',
	                areaBorder: ' #E5E7EB',
	                errorBar: '#374151',
	                crosshairLine: '#1F2937',
	                crosshairFill: '#111827',
	                crosshairLabel: '#F9FAFB',
	                tooltipFill: '#111827',
	                tooltipBoldLabel: '#D1D5DB',
	                tooltipLightLabel: '#F9FAFB',
	                tooltipHeaderLine: '#6B7280',
	                markerShadow: null,
	                selectionRectFill: 'rgba(79,70,229, 0.1)',
	                selectionRectStroke: '#4F46E5',
	                selectionCircleStroke: '#6B7280',
	                tabColor: '#4F46E5',
	                bearFillColor: '#2ecd71',
	                bullFillColor: '#e74c3d',
	                toolkitSelectionColor: '#4F46E5',
	                toolkitFill: '#6B7280',
	                toolkitIconRectOverFill: 'transparent',
	                toolkitIconRectSelectionFill: 'transparent',
	                toolkitIconRect: new Rect(0, 0, 16, 16),
	                chartTitleFont: {
	                    color: '#374151', fontFamily: 'Inter'
	                },
	                axisLabelFont: {
	                    color: '#6B7280', fontFamily: 'Inter'
	                },
	                legendTitleFont: {
	                    color: '#374151', fontFamily: 'Inter'
	                },
	                legendLabelFont: {
	                    color: '#374151', fontFamily: 'Inter'
	                },
	                tooltipLabelFont: {
	                    color: '#F9FAFB', fontFamily: 'Inter'
	                },
	                axisTitleFont: {
	                    color: '#374151', fontFamily: 'Inter'
	                },
	                datalabelFont: {
	                    color: '#6B7280', fontFamily: 'Inter'
	                },
	                chartSubTitleFont: {
	                    color: '#374151', fontFamily: 'Inter'
	                },
	                crosshairLabelFont: {
	                    color: '#F9FAFB', fontFamily: 'Inter'
	                },
	                stripLineLabelFont: {
	                    color: '#D1D5DB', fontFamily: 'Inter'
	                }
	            };
	            break;
	        case 'TailwindDark':
	            style = {
	                axisLabel: '#9CA3AF', axisTitle: '#9CA3AF',
	                axisLine: ' #4B5563',
	                majorGridLine: '#374151',
	                minorGridLine: '#374151',
	                majorTickLine: '#4B5563',
	                minorTickLine: ' #4B5563',
	                chartTitle: '#D1D5DB',
	                legendLabel: '#D1D5DB',
	                background: canvas ? '#1f2937' : 'transparent',
	                areaBorder: ' #374151',
	                errorBar: '#ffffff',
	                crosshairLine: '#9CA3AF',
	                crosshairFill: '#F9FAFB',
	                crosshairLabel: '#1F2937',
	                tooltipFill: '#F9FAFB',
	                tooltipBoldLabel: '#6B7280',
	                tooltipLightLabel: '#1F2937',
	                tooltipHeaderLine: '#9CA3AF',
	                markerShadow: null,
	                selectionRectFill: 'rgba(34,211,238, 0.1)',
	                selectionRectStroke: '#22D3EE',
	                selectionCircleStroke: '#282727',
	                tabColor: '#22D3EE',
	                bearFillColor: '#2ecd71',
	                bullFillColor: '#e74c3d',
	                toolkitSelectionColor: '#22D3EE',
	                toolkitFill: '#D1D5DB',
	                toolkitIconRectOverFill: 'transparent',
	                toolkitIconRectSelectionFill: 'transparent',
	                toolkitIconRect: new Rect(0, 0, 16, 16),
	                chartTitleFont: {
	                    color: '#D1D5DB', fontFamily: 'Inter'
	                },
	                axisLabelFont: {
	                    color: '#9CA3AF', fontFamily: 'Inter'
	                },
	                legendTitleFont: {
	                    color: '#D1D5DB', fontFamily: 'Inter'
	                },
	                legendLabelFont: {
	                    color: '#D1D5DB', fontFamily: 'Inter'
	                },
	                tooltipLabelFont: {
	                    color: '#1F2937', fontFamily: 'Inter'
	                },
	                axisTitleFont: {
	                    color: '#D1D5DB', fontFamily: 'Inter'
	                },
	                datalabelFont: {
	                    color: '#9CA3AF', fontFamily: 'Inter'
	                },
	                chartSubTitleFont: {
	                    color: '#D1D5DB', fontFamily: 'Inter'
	                },
	                crosshairLabelFont: {
	                    color: '#1F2937', fontFamily: 'Inter'
	                },
	                stripLineLabelFont: {
	                    color: '#6B7280', fontFamily: 'Inter'
	                }
	            };
	            break;
	        case 'Bootstrap5':
	            style = {
	                axisLabel: '#495057',
	                axisTitle: '#343A40',
	                axisLine: '#D1D5DB',
	                majorGridLine: '#E5E7EB',
	                minorGridLine: '#E5E7EB',
	                majorTickLine: '#D1D5DB',
	                minorTickLine: ' #D1D5DB',
	                chartTitle: '#343A40',
	                legendLabel: '#343A40',
	                background: canvas ? '#FFFFFF' : 'transparent',
	                areaBorder: ' #DEE2E6',
	                errorBar: '#1F2937',
	                crosshairLine: '#1F2937',
	                crosshairFill: '#212529',
	                crosshairLabel: '#F9FAFB',
	                tooltipFill: '#212529',
	                tooltipBoldLabel: '#F9FAFB',
	                tooltipLightLabel: '#F9FAFB',
	                tooltipHeaderLine: '#9CA3AF',
	                markerShadow: null,
	                selectionRectFill: 'rgba(79,70,229, 0.1)',
	                selectionRectStroke: '#4F46E5',
	                selectionCircleStroke: '#6B7280',
	                tabColor: '#0D6EFD',
	                bearFillColor: '#2ecd71',
	                bullFillColor: '#e74c3d',
	                toolkitSelectionColor: '#0D6EFD',
	                toolkitFill: '#737373',
	                toolkitIconRectOverFill: 'transparent',
	                toolkitIconRectSelectionFill: 'transparent',
	                toolkitIconRect: new Rect(0, 0, 16, 16),
	                chartTitleFont: {
	                    color: '#343A40', fontFamily: 'Helvetica'
	                },
	                axisLabelFont: {
	                    color: '#495057', fontFamily: 'Helvetica'
	                },
	                legendTitleFont: {
	                    color: '#343A40', fontFamily: 'Helvetica'
	                },
	                legendLabelFont: {
	                    color: '#343A40', fontFamily: 'Helvetica'
	                },
	                tooltipLabelFont: {
	                    color: '#F9FAFB', fontFamily: 'Helvetica'
	                },
	                axisTitleFont: {
	                    color: '#343A40', fontFamily: 'Helvetica'
	                },
	                datalabelFont: {
	                    color: '#495057', fontFamily: 'Helvetica'
	                },
	                chartSubTitleFont: {
	                    color: '#343A40', fontFamily: 'Helvetica'
	                },
	                crosshairLabelFont: {
	                    color: '#F9FAFB', fontFamily: 'Helvetica'
	                },
	                stripLineLabelFont: {
	                    color: '#ADB5BD', fontFamily: 'Helvetica'
	                }
	            };
	            break;
	        case 'Bootstrap5Dark':
	            style = {
	                axisLabel: '#CED4DA',
	                axisTitle: '#E9ECEF',
	                axisLine: '#495057',
	                majorGridLine: '#343A40',
	                minorGridLine: '#343A40',
	                majorTickLine: '#495057',
	                minorTickLine: ' #495057',
	                chartTitle: '#E9ECEF',
	                legendLabel: '#E9ECEF',
	                background: canvas ? '#212529' : 'transparent',
	                areaBorder: ' #444C54',
	                errorBar: '#ADB5BD',
	                crosshairLine: '#ADB5BD',
	                crosshairFill: '#E9ECEF',
	                crosshairLabel: '#212529',
	                tooltipFill: '#E9ECEF',
	                tooltipBoldLabel: '#212529',
	                tooltipLightLabel: '#212529',
	                tooltipHeaderLine: '#ADB5BD',
	                markerShadow: null,
	                selectionRectFill: 'rgba(79,70,229, 0.1)',
	                selectionRectStroke: '#4F46E5',
	                selectionCircleStroke: '#6B7280',
	                tabColor: '#0D6EFD',
	                bearFillColor: '#2ecd71',
	                bullFillColor: '#e74c3d',
	                toolkitSelectionColor: '#0D6EFD',
	                toolkitFill: '#737373',
	                toolkitIconRectOverFill: 'transparent',
	                toolkitIconRectSelectionFill: 'transparent',
	                toolkitIconRect: new Rect(0, 0, 16, 16),
	                chartTitleFont: {
	                    color: '#E9ECEF', fontFamily: 'Helvetica'
	                },
	                axisLabelFont: {
	                    color: '#CED4DA', fontFamily: 'Helvetica'
	                },
	                legendTitleFont: {
	                    color: '#E9ECEF', fontFamily: 'Helvetica'
	                },
	                legendLabelFont: {
	                    color: '#E9ECEF', fontFamily: 'Helvetica'
	                },
	                tooltipLabelFont: {
	                    color: '#212529', fontFamily: 'Helvetica'
	                },
	                axisTitleFont: {
	                    color: '#E9ECEF', fontFamily: 'Helvetica'
	                },
	                datalabelFont: {
	                    color: '#E9ECEF', fontFamily: 'Helvetica'
	                },
	                chartSubTitleFont: {
	                    color: '#E9ECEF', fontFamily: 'Helvetica'
	                },
	                crosshairLabelFont: {
	                    color: '#212529', fontFamily: 'Helvetica'
	                },
	                stripLineLabelFont: {
	                    color: '#6C757D', fontFamily: 'Helvetica'
	                }
	            };
	            break;
	        case 'Fluent':
	            style = {
	                axisLabel: '#3B3A39',
	                axisTitle: '#201F1E',
	                axisLine: '#D2D0CE',
	                majorGridLine: '#EDEBE9',
	                minorGridLine: '#EDEBE9',
	                majorTickLine: '#D2D0CE',
	                minorTickLine: ' #D2D0CE',
	                chartTitle: '#201F1E',
	                legendLabel: '#323130',
	                background: canvas ? '#FFFFFF' : 'transparent',
	                areaBorder: '#EDEBE9',
	                errorBar: '#A19F9D',
	                crosshairLine: '#A19F9D',
	                crosshairFill: '#FFFFFF',
	                crosshairLabel: '#323130',
	                tooltipFill: '#FFFFFF',
	                tooltipBoldLabel: '#323130',
	                tooltipLightLabel: '#323130',
	                tooltipHeaderLine: '#D2D0CE',
	                markerShadow: null,
	                selectionRectFill: 'rgba(79,70,229, 0.1)',
	                selectionRectStroke: '#4F46E5',
	                selectionCircleStroke: '#6B7280',
	                tabColor: '#0078D4',
	                bearFillColor: '#2ecd71',
	                bullFillColor: '#e74c3d',
	                toolkitSelectionColor: '#0078D4',
	                toolkitFill: '#A19F9D',
	                toolkitIconRectOverFill: 'transparent',
	                toolkitIconRectSelectionFill: 'transparent',
	                toolkitIconRect: new Rect(0, 0, 16, 16),
	                chartTitleFont: {
	                    color: '#201F1E', fontFamily: 'Segoe UI'
	                },
	                axisLabelFont: {
	                    color: '#3B3A39', fontFamily: 'Segoe UI'
	                },
	                legendTitleFont: {
	                    color: '#201F1E', fontFamily: 'Segoe UI'
	                },
	                legendLabelFont: {
	                    color: '#49454E', fontFamily: 'Segoe UI'
	                },
	                tooltipLabelFont: {
	                    color: '#323130', fontFamily: 'Segoe UI'
	                },
	                axisTitleFont: {
	                    color: '#201F1E', fontFamily: 'Segoe UI'
	                },
	                datalabelFont: {
	                    color: '#3B3A39', fontFamily: 'Segoe UI'
	                },
	                chartSubTitleFont: {
	                    color: '#323129', fontFamily: 'Segoe UI'
	                },
	                crosshairLabelFont: {
	                    color: '#323130', fontFamily: 'Segoe UI'
	                },
	                stripLineLabelFont: {
	                    color: '#A19F9D', fontFamily: 'Segoe UI'
	                }
	            };
	            break;
	        case 'FluentDark':
	            style = {
	                axisLabel: '#C8C6C4',
	                axisTitle: '#F3F2F1',
	                axisLine: '#3B3A39',
	                majorGridLine: '#414040',
	                minorGridLine: '#414040',
	                majorTickLine: '#3B3A39',
	                minorTickLine: '#3B3A39',
	                chartTitle: '#F3F2F1',
	                legendLabel: '#D2D0CE',
	                background: canvas ? '#383838' : 'transparent',
	                areaBorder: '#414040',
	                errorBar: '#D2D0CE',
	                crosshairLine: '#D2D0CE',
	                crosshairFill: '#323130',
	                crosshairLabel: '#F3F2F1',
	                tooltipFill: '#252423',
	                tooltipBoldLabel: '#F3F2F1',
	                tooltipLightLabel: '#F3F2F1',
	                tooltipHeaderLine: '#3B3A39',
	                markerShadow: null,
	                selectionRectFill: 'rgba(79,70,229, 0.1)',
	                selectionRectStroke: '#4F46E5',
	                selectionCircleStroke: '#6B7280',
	                tabColor: '#0078D4',
	                bearFillColor: '#2ecd71',
	                bullFillColor: '#e74c3d',
	                toolkitSelectionColor: '#0078D4',
	                toolkitFill: '#484644',
	                toolkitIconRectOverFill: 'transparent',
	                toolkitIconRectSelectionFill: 'transparent',
	                toolkitIconRect: new Rect(0, 0, 16, 16),
	                chartTitleFont: {
	                    color: '#C8C6C4', fontFamily: 'Segoe UI'
	                },
	                axisLabelFont: {
	                    color: '#C8C6C4', fontFamily: 'Segoe UI'
	                },
	                legendTitleFont: {
	                    color: '#F3F2F1', fontFamily: 'Segoe UI'
	                },
	                legendLabelFont: {
	                    color: '#D2D0CE', fontFamily: 'Segoe UI'
	                },
	                tooltipLabelFont: {
	                    color: '#F3F2F1', fontFamily: 'Segoe UI'
	                },
	                axisTitleFont: {
	                    color: '#F3F2F2', fontFamily: 'Segoe UI'
	                },
	                datalabelFont: {
	                    color: '#D2D0CE', fontFamily: 'Segoe UI'
	                },
	                chartSubTitleFont: {
	                    color: '#F3F2F1', fontFamily: 'Segoe UI'
	                },
	                crosshairLabelFont: {
	                    color: '#F3F2F1', fontFamily: 'Segoe UI'
	                },
	                stripLineLabelFont: {
	                    color: '#484644', fontFamily: 'Segoe UI'
	                }
	            };
	            break;
	        case 'Material3':
	            style = {
	                axisLabel: '#1E192B',
	                axisTitle: '#1C1B1F',
	                axisLine: '#C4C7C5',
	                majorGridLine: '#C4C7C5',
	                minorGridLine: '#C4C7C5',
	                majorTickLine: '#C4C7C5',
	                minorTickLine: ' #C4C7C5',
	                chartTitle: '#1C1B1F',
	                legendLabel: '#49454E',
	                background: canvas ? '#FFFFFF' : 'transparent',
	                areaBorder: '#E7E0EC',
	                errorBar: '#79747E',
	                crosshairLine: '#49454E',
	                crosshairFill: '#313033',
	                crosshairLabel: '#F4EFF4',
	                tooltipFill: '#313033',
	                tooltipBoldLabel: '#F4EFF4',
	                tooltipLightLabel: '#F4EFF4',
	                tooltipHeaderLine: '#F4EFF4',
	                markerShadow: null,
	                selectionRectFill: 'rgb(98, 0, 238, 0.06)',
	                selectionRectStroke: '#6200EE',
	                selectionCircleStroke: '#79747E',
	                tabColor: '#49454E',
	                bearFillColor: '#5887FF',
	                bullFillColor: '#F7523F',
	                toolkitSelectionColor: '#49454E',
	                toolkitFill: '#49454E',
	                toolkitIconRectOverFill: '#EADDFF',
	                toolkitIconRectSelectionFill: '#EADDFF',
	                toolkitIconRect: new Rect(-4, -5, 26, 26),
	                histogram: '#D21020',
	                chartTitleFont: {
	                    color: '#1C1B1F', fontFamily: 'Roboto'
	                },
	                axisLabelFont: {
	                    color: '#1E192B', fontFamily: 'Roboto'
	                },
	                legendTitleFont: {
	                    color: '#1C1B1F', fontFamily: 'Roboto'
	                },
	                legendLabelFont: {
	                    color: '#49454E', fontFamily: 'Roboto'
	                },
	                tooltipLabelFont: {
	                    color: '#F4EFF4', fontFamily: 'Roboto'
	                },
	                axisTitleFont: {
	                    color: '#1C1B1F', fontFamily: 'Roboto'
	                },
	                datalabelFont: {
	                    color: '#49454E', fontFamily: 'Roboto'
	                },
	                chartSubTitleFont: {
	                    color: '#49454E', fontFamily: 'Roboto'
	                },
	                crosshairLabelFont: {
	                    color: '#F4EFF4', fontFamily: 'Roboto'
	                },
	                stripLineLabelFont: {
	                    color: '#79747E', fontFamily: 'Roboto'
	                }
	            };
	            break;
	        case 'Material3Dark':
	            style = {
	                axisLabel: '#E6E1E5',
	                axisTitle: '#E6E1E5',
	                axisLine: '#49454F',
	                majorGridLine: '#444746',
	                minorGridLine: '#444746',
	                majorTickLine: '#444746',
	                minorTickLine: ' #444746',
	                chartTitle: '#E6E1E5',
	                legendLabel: '#CAC4D0',
	                background: canvas ? '#FFFFFF' : 'transparent',
	                areaBorder: '#49454F',
	                errorBar: '#938F99',
	                crosshairLine: '#CAC4D0',
	                crosshairFill: '#E6E1E5',
	                crosshairLabel: '#313033',
	                tooltipFill: '#E6E1E5',
	                tooltipBoldLabel: '#313033',
	                tooltipLightLabel: '#313033',
	                tooltipHeaderLine: '#313033',
	                markerShadow: null,
	                selectionRectFill: 'rgba(78, 170, 255, 0.06)',
	                selectionRectStroke: '#4EAAFF',
	                selectionCircleStroke: '#938F99',
	                tabColor: '#CAC4D0',
	                bearFillColor: '#B3F32F',
	                bullFillColor: '#FF9E45',
	                toolkitSelectionColor: '#CAC4D0',
	                toolkitFill: '#CAC4D0',
	                toolkitIconRectOverFill: '#4F378B',
	                toolkitIconRectSelectionFill: '#4F378B',
	                toolkitIconRect: new Rect(-4, -5, 26, 26),
	                histogram: '#FF9E45',
	                chartTitleFont: {
	                    color: '#E6E1E5', fontFamily: 'Roboto'
	                },
	                axisLabelFont: {
	                    color: '#CAC4D0', fontFamily: 'Roboto'
	                },
	                legendTitleFont: {
	                    color: '#E6E1E5', fontFamily: 'Roboto'
	                },
	                legendLabelFont: {
	                    color: '#CAC4D0', fontFamily: 'Roboto'
	                },
	                tooltipLabelFont: {
	                    color: '#313033', fontFamily: 'Roboto'
	                },
	                axisTitleFont: {
	                    color: '#E6E1E5', fontFamily: 'Roboto'
	                },
	                datalabelFont: {
	                    color: '#CAC4D0', fontFamily: 'Roboto'
	                },
	                chartSubTitleFont: {
	                    color: '#CAC4D0', fontFamily: 'Roboto'
	                },
	                crosshairLabelFont: {
	                    color: '#313033', fontFamily: 'Roboto'
	                },
	                stripLineLabelFont: {
	                    color: '#938F99', fontFamily: 'Roboto'
	                }
	            };
	            break;
	        default:
	            style = {
	                axisLabel: '#686868',
	                axisTitle: '#424242',
	                axisLine: '#b5b5b5',
	                majorGridLine: '#dbdbdb',
	                minorGridLine: '#eaeaea',
	                majorTickLine: '#b5b5b5',
	                minorTickLine: '#d6d6d6',
	                chartTitle: '#424242',
	                legendLabel: '#353535',
	                background: canvas ? '#FFFFFF' : 'transparent',
	                areaBorder: 'Gray',
	                errorBar: '#000000',
	                crosshairLine: '#4f4f4f',
	                crosshairFill: theme === 'Material' ? '#000816' : theme === 'Fabric' ? '#FFFFFF' : '#212529',
	                crosshairLabel: '#e5e5e5',
	                tooltipFill: '#000816',
	                tooltipBoldLabel: '#ffffff',
	                tooltipLightLabel: '#dbdbdb',
	                tooltipHeaderLine: '#ffffff',
	                markerShadow: null,
	                selectionRectFill: 'rgba(41, 171, 226, 0.1)',
	                selectionRectStroke: '#29abe2',
	                selectionCircleStroke: '#29abe2',
	                tabColor: theme === 'Material' ? '#ff4081' : theme === 'Fabric' ? '#0078D6' : '#317AB9',
	                bearFillColor: '#2ecd71',
	                bullFillColor: '#e74c3d',
	                toolkitSelectionColor: theme === 'Material' ? '#ff4081' : theme === 'Fabric' ? '#0078D6' : '#317AB9',
	                toolkitFill: '#737373',
	                toolkitIconRectOverFill: 'transparent',
	                toolkitIconRectSelectionFill: 'transparent',
	                toolkitIconRect: new Rect(0, 0, 16, 16),
	                chartTitleFont: {
	                    color: theme === 'Material' ? 'rgba(0, 0, 0, 1)' : theme === 'Fabric' ? '#333333' : '#212529', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
	                },
	                axisLabelFont: {
	                    color: theme === 'Material' ? 'rgba(97, 97, 97, 1)' : theme === 'Fabric' ? '#666666' : '#676767', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
	                },
	                legendTitleFont: {
	                    color: theme === 'Material' ? 'rgba(0, 0, 0, 1)' : theme === 'Fabric' ? '#333333' : '#212529', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
	                },
	                legendLabelFont: {
	                    color: theme === 'Material' ? 'rgba(97, 97, 97, 1)' : theme === 'Fabric' ? '#666666' : '#666666', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
	                },
	                tooltipLabelFont: {
	                    color: theme === 'Material' ? 'rgba(249, 250, 251, 1)' : theme === 'Fabric' ? '#333333' : '#F9FAFB', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
	                },
	                axisTitleFont: {
	                    color: theme === 'Material' ? 'rgba(0, 0, 0, 1)' : theme === 'Fabric' ? '#333333' : '#212529', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
	                },
	                datalabelFont: {
	                    color: theme === 'Material' ? 'rgba(97, 97, 97, 1)' : theme === 'Fabric' ? '#666666' : '#676767', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
	                },
	                chartSubTitleFont: {
	                    color: theme === 'Material' ? 'rgba(0, 0, 0, 1)' : theme === 'Fabric' ? '#333333' : '#212529', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
	                },
	                crosshairLabelFont: {
	                    color: theme === 'Material' ? 'rgba(249, 250, 251, 1)' : theme === 'Fabric' ? '#333333' : '#F9FAFB', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
	                },
	                stripLineLabelFont: {
	                    color: theme === 'Material' ? 'rgba(158, 158, 158, 1)' : theme === 'Fabric' ? '#A6A6A6' : '#676767', fontFamily: theme === 'Material' ? 'Roboto' : theme === 'Fabric' ? 'Segoe UI' : 'Helvetica'
	                }
	            };
	            break;
	    }
	    return style;
	}

	/**
	 * Specifies the Cartesian Axis Layout.
	 */
	var axisPadding = 10;
	var CartesianAxisLayoutPanel = /** @class */ (function () {
	    /** @private */
	    function CartesianAxisLayoutPanel(chartModule) {
	        this.chart = chartModule;
	        this.padding = 5;
	    }
	    /**
	     * Measure the axis size.
	     *
	     * @returns {void}
	     * @private
	     */
	    CartesianAxisLayoutPanel.prototype.measureAxis = function (rect) {
	        var chart = this.chart;
	        var chartAreaWidth = chart.chartArea.width ? stringToNumber(chart.chartArea.width, chart.availableSize.width) : null;
	        this.crossAt(chart);
	        this.seriesClipRect = new Rect(rect.x, rect.y, rect.width, rect.height);
	        this.initialClipRect = rect;
	        this.leftSize = 0;
	        this.rightSize = 0;
	        this.topSize = 0;
	        this.bottomSize = 0;
	        //Measure Axis size with initial Rect
	        this.measureRowAxis(chart, this.initialClipRect);
	        this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));
	        this.measureColumnAxis(chart, this.initialClipRect);
	        this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));
	        if (!this.chart.delayRedraw) {
	            this.calculateAxisSize(this.initialClipRect);
	        }
	        this.leftSize = 0;
	        this.rightSize = 0;
	        this.topSize = 0;
	        this.bottomSize = 0;
	        //Measure Axis size with series Rect
	        this.measureRowAxis(chart, this.initialClipRect);
	        this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));
	        this.measureColumnAxis(chart, this.initialClipRect);
	        this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));
	        if (chartAreaWidth) {
	            this.calculateFixedChartArea(chart, chartAreaWidth);
	        }
	        if (!this.chart.delayRedraw) {
	            chart.refreshAxis();
	            this.calculateAxisSize(this.seriesClipRect);
	        }
	    };
	    CartesianAxisLayoutPanel.prototype.calculateFixedChartArea = function (chart, chartAreaWidth) {
	        this.seriesClipRect.width = chartAreaWidth;
	        this.seriesClipRect.x = chart.availableSize.width - chart.margin.right - chartAreaWidth -
	            (chart.legendSettings.position === 'Right' ? chart.legendModule.legendBounds.width : 0);
	        for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {
	            var item = _a[_i];
	            this.seriesClipRect.x -= sum(item.farSizes);
	        }
	    };
	    CartesianAxisLayoutPanel.prototype.measureRowAxis = function (chart, rect) {
	        var row;
	        this.calculateRowSize(rect);
	        for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {
	            var item = _a[_i];
	            row = item;
	            row.nearSizes = [];
	            row.farSizes = [];
	            row.insideNearSizes = [];
	            row.insideFarSizes = [];
	            this.arrangeAxis(row);
	            this.measureDefinition(row, chart, new Size(chart.availableSize.width, row.computedHeight));
	            if (this.leftSize < sum(row.nearSizes)) {
	                this.leftSize = sum(row.nearSizes);
	            }
	            if (this.rightSize < sum(row.farSizes)) {
	                this.rightSize = sum(row.farSizes);
	            }
	        }
	    };
	    CartesianAxisLayoutPanel.prototype.measureColumnAxis = function (chart, rect) {
	        var column;
	        this.calculateColumnSize(rect);
	        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {
	            var item = _a[_i];
	            column = item;
	            column.farSizes = [];
	            column.nearSizes = [];
	            column.insideNearSizes = [];
	            column.insideFarSizes = [];
	            this.arrangeAxis(column);
	            this.measureDefinition(column, chart, new Size(column.computedWidth, chart.availableSize.height));
	            if (this.bottomSize < sum(column.nearSizes)) {
	                this.bottomSize = sum(column.nearSizes);
	            }
	            if (this.topSize < sum(column.farSizes)) {
	                this.topSize = sum(column.farSizes);
	            }
	        }
	    };
	    /**
	     * Measure the column and row in chart.
	     *
	     * @returns {void}
	     * @private
	     */
	    CartesianAxisLayoutPanel.prototype.measureDefinition = function (definition, chart, size) {
	        var ele;
	        for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {
	            var axis = _a[_i];
	            ele = axis.scrollbarSettings.height;
	            axis.scrollBarHeight = chart.scrollBarModule && chart.zoomModule && chart.zoomSettings.enableScrollbar &&
	                axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? ele : 0;
	            axis.scrollBarHeight = chart.scrollBarModule && (chart.zoomModule && chart.zoomSettings.enableScrollbar &&
	                axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0)
	                || axis.scrollbarSettings.enable) ? ele : 0;
	            axis.getModule(chart);
	            axis.baseModule.calculateRangeAndInterval(size, axis);
	            definition.computeSize(axis, axis.scrollBarHeight, definition, chart);
	        }
	        if (definition.farSizes.length > 0) {
	            definition.farSizes[definition.farSizes.length - 1] -= axisPadding;
	        }
	        if (definition.nearSizes.length > 0) {
	            definition.nearSizes[definition.nearSizes.length - 1] -= axisPadding;
	        }
	    };
	    /**
	     * Measure the axis.
	     *
	     * @returns {void}
	     * @private
	     */
	    CartesianAxisLayoutPanel.prototype.calculateAxisSize = function (rect) {
	        var chart = this.chart;
	        var row;
	        var column;
	        var definition;
	        var axis;
	        var nearCount = 0;
	        var farCount = 0;
	        var size = 0;
	        var x;
	        var y;
	        var axisOffset;
	        this.calculateRowSize(rect);
	        for (var i = 0, len = chart.rows.length; i < len; i++) {
	            row = chart.rows[i];
	            nearCount = 0;
	            farCount = 0;
	            for (var j = 0, len_1 = row.axes.length; j < len_1; j++) {
	                axis = row.axes[j];
	                axisOffset = axis.plotOffset;
	                if (axis.rect.height === 0) {
	                    axis.rect.height = row.computedHeight;
	                    size = 0;
	                    for (var k = i + 1, len_2 = i + axis.span; k < len_2; k++) {
	                        definition = chart.rows[k];
	                        size += definition.computedHeight;
	                    }
	                    axis.rect.y = (row.computedTop - size) + (axis.plotOffsetTop ? axis.plotOffsetTop : axisOffset);
	                    axis.rect.height = (axis.rect.height + size) -
	                        (this.getAxisOffsetValue(axis.plotOffsetTop, axis.plotOffsetBottom, axis.plotOffset));
	                    axis.rect.width = 0;
	                }
	                if (axis.isAxisOpposedPosition) {
	                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Vertical') {
	                        x = rect.x + rect.width - sum(subArray(row.insideFarSizes, farCount));
	                    }
	                    else {
	                        x = rect.x + rect.width + sum(subArray(row.farSizes, farCount));
	                    }
	                    axis.rect.x = axis.rect.x >= x ? axis.rect.x : x;
	                    farCount++;
	                }
	                else {
	                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Vertical') {
	                        x = rect.x + sum(subArray(row.insideNearSizes, nearCount));
	                    }
	                    else {
	                        x = rect.x - sum(subArray(row.nearSizes, nearCount));
	                    }
	                    axis.rect.x = axis.rect.x <= x ? axis.rect.x : x;
	                    nearCount++;
	                }
	            }
	        }
	        this.calculateColumnSize(rect);
	        for (var i = 0, len = chart.columns.length; i < len; i++) {
	            column = chart.columns[i];
	            nearCount = 0;
	            farCount = 0;
	            for (var j = 0, len_3 = column.axes.length; j < len_3; j++) {
	                axis = column.axes[j];
	                axisOffset = axis.plotOffset;
	                if (axis.rect.width === 0) {
	                    for (var k = i, len_4 = (i + axis.span); k < len_4; k++) {
	                        definition = chart.columns[k];
	                        axis.rect.width += definition.computedWidth;
	                    }
	                    axis.rect.x = column.computedLeft + (axis.plotOffsetLeft ? axis.plotOffsetLeft : axisOffset);
	                    axis.rect.width -= (this.getAxisOffsetValue(axis.plotOffsetLeft, axis.plotOffsetRight, axis.plotOffset));
	                    axis.rect.height = 0;
	                }
	                if (axis.isAxisOpposedPosition) {
	                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Horizontal') {
	                        y = rect.y + sum(subArray(column.insideFarSizes, farCount));
	                    }
	                    else {
	                        y = rect.y - sum(subArray(column.farSizes, farCount));
	                    }
	                    axis.rect.y = axis.rect.y <= y ? axis.rect.y : y;
	                    farCount++;
	                }
	                else {
	                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Horizontal') {
	                        y = rect.y + rect.height - sum(subArray(column.insideNearSizes, nearCount));
	                    }
	                    else {
	                        y = rect.y + rect.height + sum(subArray(column.nearSizes, nearCount));
	                    }
	                    axis.rect.y = axis.rect.y >= y ? axis.rect.y : y;
	                    nearCount++;
	                }
	            }
	        }
	    };
	    /**
	     * Measure the axis.
	     *
	     * @returns {void}
	     * @private
	     */
	    CartesianAxisLayoutPanel.prototype.measure = function () {
	        var chart = this.chart;
	        var row;
	        var column;
	        var definition;
	        var actualIndex;
	        var span;
	        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {
	            var axis = _a[_i];
	            //definition.Axes = axis;
	            if (axis.orientation === 'Vertical') {
	                chart.verticalAxes.push(axis);
	                actualIndex = this.getActualRow(axis);
	                row = chart.rows[actualIndex];
	                this.pushAxis(row, axis);
	                span = ((actualIndex + axis.span) > chart.rows.length ? chart.rows.length : (actualIndex + axis.span));
	                for (var j = actualIndex + 1; j < span; j++) {
	                    definition = chart.rows[j];
	                    definition.axes[row.axes.length - 1] = axis;
	                    chart.rows[j] = definition;
	                }
	                chart.rows[actualIndex] = row;
	            }
	            else {
	                chart.horizontalAxes.push(axis);
	                actualIndex = this.getActualColumn(axis);
	                column = chart.columns[actualIndex];
	                this.pushAxis(column, axis);
	                span = ((actualIndex + axis.span) > chart.columns.length ? chart.columns.length : (actualIndex + axis.span));
	                for (var j = actualIndex + 1; j < span; j++) {
	                    definition = chart.columns[j];
	                    definition.axes[column.axes.length - 1] = axis;
	                    chart.columns[j] = definition;
	                }
	                chart.columns[actualIndex] = column;
	            }
	            axis.isRTLEnabled = chart.enableRtl;
	            axis.setIsInversedAndOpposedPosition();
	        }
	    };
	    CartesianAxisLayoutPanel.prototype.getAxisOffsetValue = function (position1, position2, plotOffset) {
	        var rangeOffset = position1 ? (position1 + (position2 ? position2 :
	            plotOffset)) : (position2 ? position2 + plotOffset : 2 * plotOffset);
	        return rangeOffset;
	    };
	    CartesianAxisLayoutPanel.prototype.crossAt = function (chart) {
	        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {
	            var axis = _a[_i];
	            if (axis.crossesAt === null) {
	                continue;
	            }
	            if (!axis.crossesInAxis) {
	                if (chart.requireInvertedAxis) {
	                    axis.crossInAxis = ((axis.orientation === 'Horizontal')) ? chart.primaryXAxis : chart.primaryYAxis;
	                }
	                else {
	                    axis.crossInAxis = ((axis.orientation === 'Horizontal')) ? chart.primaryYAxis : chart.primaryXAxis;
	                }
	                axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);
	                continue;
	            }
	            else {
	                for (var i = 2, len = chart.axisCollections.length; i < len; i++) {
	                    if (axis.crossesInAxis === chart.axisCollections[i].name) {
	                        axis.crossInAxis = chart.axisCollections[i];
	                        axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);
	                        continue;
	                    }
	                }
	            }
	        }
	    };
	    CartesianAxisLayoutPanel.prototype.updateCrossAt = function (axis, crossAt) {
	        switch (axis.valueType) {
	            case 'DateTime':
	                var option = {
	                    skeleton: 'full',
	                    type: 'dateTime'
	                };
	                var dateParser = this.chart.intl.getDateParser(option);
	                var dateFormatter = this.chart.intl.getDateFormat(option);
	                return Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: crossAt }).val))));
	            case 'Category':
	                return parseFloat(crossAt) ? parseFloat(crossAt) : axis.labels.indexOf(crossAt);
	            case 'Logarithmic':
	                return logBase(crossAt, axis.logBase);
	            default:
	                return crossAt;
	        }
	    };
	    CartesianAxisLayoutPanel.prototype.pushAxis = function (definition, axis) {
	        for (var i = 0, len = definition.axes.length; i <= len; i++) {
	            if (!definition.axes[i]) {
	                definition.axes[i] = axis;
	                break;
	            }
	        }
	    };
	    CartesianAxisLayoutPanel.prototype.arrangeAxis = function (definition) {
	        var axisCollection = [];
	        for (var i = 0, len = definition.axes.length; i <= len; i++) {
	            if (definition.axes[i]) {
	                axisCollection.push(definition.axes[i]);
	            }
	        }
	        definition.axes = axisCollection;
	    };
	    CartesianAxisLayoutPanel.prototype.getActualColumn = function (axis) {
	        var actualLength = this.chart.columns.length;
	        var pos = axis.columnIndex;
	        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);
	        return result;
	    };
	    CartesianAxisLayoutPanel.prototype.getActualRow = function (axis) {
	        var actualLength = this.chart.rows.length;
	        var pos = axis.rowIndex;
	        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);
	        return result;
	    };
	    /**
	     * Measure the row size.
	     *
	     * @returns {void}
	     */
	    CartesianAxisLayoutPanel.prototype.calculateRowSize = function (rect) {
	        /*! Calculate row size */
	        var chart = this.chart;
	        var row;
	        var rowTop = rect.y + rect.height;
	        var height = 0;
	        var remainingHeight = Math.max(0, rect.height);
	        for (var i = 0, len = chart.rows.length; i < len; i++) {
	            row = chart.rows[i];
	            if (row.height.indexOf('%') !== -1) {
	                height = Math.min(remainingHeight, (rect.height * parseInt(row.height, 10) / 100));
	            }
	            else {
	                height = Math.min(remainingHeight, parseInt(row.height, 10));
	            }
	            height = (i !== (len - 1)) ? height : remainingHeight;
	            row.computedHeight = height;
	            rowTop -= height;
	            row.computedTop = rowTop;
	            remainingHeight -= height;
	        }
	    };
	    /**
	     * Measure the row size.
	     *
	     * @param {Rect} rect rect
	     * @returns {void}
	     */
	    CartesianAxisLayoutPanel.prototype.calculateColumnSize = function (rect) {
	        /*! Calculate column size */
	        var chart = this.chart;
	        var column;
	        var columnLeft = rect.x;
	        var width = 0;
	        var remainingWidth = Math.max(0, rect.width);
	        for (var i = 0, len = chart.columns.length; i < len; i++) {
	            column = chart.columns[i];
	            if (column.width.indexOf('%') !== -1) {
	                width = Math.min(remainingWidth, (rect.width * parseInt(column.width, 10) / 100));
	            }
	            else {
	                width = Math.min(remainingWidth, parseInt(column.width, 10));
	            }
	            width = (i !== (len - 1)) ? width : remainingWidth;
	            column.computedWidth = width;
	            column.computedLeft = columnLeft;
	            columnLeft += width;
	            remainingWidth -= width;
	        }
	    };
	    /**
	     * To render the axis element.
	     *
	     * @returns {void}
	     * @private
	     */
	    // tslint:disable-next-line:max-func-body-length
	    CartesianAxisLayoutPanel.prototype.renderAxes = function () {
	        var chart = this.chart;
	        var axis;
	        var axisElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisInsideCollection' });
	        var axisLineElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisOutsideCollection' });
	        if (axisLineElement) {
	            axisLineElement.setAttribute('aria-hidden', 'true');
	        }
	        var outsideElement;
	        var isInside;
	        for (var i = 0, len = chart.axisCollections.length; i < len; i++) {
	            var axisVisibility = true;
	            axis = chart.axisCollections[i];
	            this.element = chart.renderer.createGroup({ id: chart.element.id + 'AxisGroup' + i + 'Inside' });
	            if (this.element) {
	                this.element.setAttribute('aria-hidden', 'true');
	            }
	            outsideElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisGroup' + i + 'Outside' });
	            if (outsideElement) {
	                outsideElement.setAttribute('aria-hidden', 'true');
	            }
	            for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {
	                var series = _a[_i];
	                if (axis.name === series.yAxisName || axis.name === series.xAxisName) {
	                    axisVisibility = series.visible;
	                    if (series.category === 'Pareto' && !series.paretoOptions.showAxis && series.type === 'Line') {
	                        axisVisibility = false;
	                    }
	                    if (!axisVisibility) {
	                        continue;
	                    }
	                    else {
	                        break;
	                    }
	                }
	            }
	            if (!axisVisibility) {
	                continue;
	            }
	            isInside = this.findAxisPosition(axis);
	            if (axis.orientation === 'Horizontal') {
	                axis.updateCrossValue();
	                if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {
	                    this.drawAxisLine(axis, i, axis.plotOffset, 0, 0, 0, axis.plotOffsetLeft, axis.plotOffsetRight, isInside ? outsideElement : this.element, axis.updatedRect);
	                }
	                if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0 || axis.minorTickLines.width > 0 || axis.minorGridLines.width > 0) {
	                    this.drawXAxisGridLine(axis, i, (isInside || axis.tickPosition === 'Inside') ? outsideElement : this.element, axis.updatedRect);
	                }
	                if (axis.visible && axis.internalVisibility) {
	                    this.drawXAxisLabels(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));
	                    this.drawXAxisBorder(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));
	                    this.drawXAxisTitle(axis, i, isInside ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));
	                }
	            }
	            else {
	                axis.updateCrossValue();
	                if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {
	                    this.drawAxisLine(axis, i, 0, axis.plotOffset, axis.plotOffsetBottom, axis.plotOffsetTop, 0, 0, isInside ? outsideElement : this.element, axis.updatedRect);
	                }
	                if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0 || axis.minorTickLines.width > 0 || axis.minorGridLines.width > 0) {
	                    this.drawYAxisGridLine(axis, i, (isInside || axis.tickPosition === 'Inside') ? outsideElement : this.element, axis.updatedRect);
	                }
	                if (axis.visible && axis.internalVisibility) {
	                    this.drawYAxisLabels(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));
	                    this.drawYAxisBorder(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));
	                    this.drawYAxisTitle(axis, i, isInside ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));
	                }
	            }
	            if (!this.chart.enableCanvas) {
	                axisElement.appendChild(this.element);
	                if (outsideElement && outsideElement.childNodes.length > 0) {
	                    axisLineElement.appendChild(outsideElement);
	                }
	            }
	            if (chart.scrollBarModule && ((chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming) ||
	                axis.scrollbarSettings.enable)) {
	                this.renderScrollbar(chart, axis);
	            }
	        }
	        this.element = chart.renderer.createGroup({ id: chart.element.id + 'DefinitionLine' });
	        for (var j = 0, len = chart.rows.length; j < len; j++) {
	            var row = chart.rows[j];
	            if (row.border.color) {
	                this.drawBottomLine(row, j, true);
	            }
	        }
	        for (var j = 0, len = chart.columns.length; j < len; j++) {
	            var column = chart.columns[j];
	            if (column.border.color) {
	                this.drawBottomLine(column, j, false);
	            }
	        }
	        if (!this.chart.enableCanvas) {
	            axisElement.appendChild(this.element);
	        }
	        appendChildElement(chart.enableCanvas, chart.svgObject, axisElement, chart.redraw);
	        return axisLineElement;
	    };
	    /**
	     * To render the axis scrollbar
	     *
	     * @param {Chart} chart chart
	     * @param {Axis} axis axis
	     * @returns {void}
	     */
	    CartesianAxisLayoutPanel.prototype.renderScrollbar = function (chart, axis) {
	        var isZoomed = isNullOrUndefined(chart.zoomModule) ? false : chart.zoomModule.isZoomed;
	        if (((isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0)) || (axis.scrollbarSettings.enable &&
	            (axis.zoomFactor <= 1 || axis.zoomPosition >= 0))) &&
	            (!axis.zoomingScrollBar.isScrollUI)) {
	            if (!chart.scrollElement) {
	                chart.scrollElement = redrawElement(chart.redraw, chart.element.id + '_scrollElement') || createElement('div', { id: chart.element.id + '_scrollElement' });
	            }
	            appendChildElement(false, chart.scrollElement, axis.zoomingScrollBar.render(true), true);
	        }
	        else if (axis.zoomFactor === 1 && axis.zoomPosition === 0 && axis.zoomingScrollBar.svgObject && !axis.scrollbarSettings.enable) {
	            axis.zoomingScrollBar.destroy();
	        }
	        if (axis.zoomingScrollBar.isScrollUI) {
	            axis.zoomingScrollBar.isScrollUI = false;
	        }
	    };
	    /**
	     * To find the axis position
	     *
	     * @param {Axis} axis axis
	     * @returns {boolean} axis position
	     */
	    CartesianAxisLayoutPanel.prototype.findAxisPosition = function (axis) {
	        return axis.crossAt !== null && axis.isInside(axis.crossInAxis.visibleRange);
	    };
	    /**
	     * To render the bootom line of the columns and rows
	     *
	     * @param {Row | Column} definition definition
	     * @param {number} index index
	     * @param {boolean} isRow isRow
	     * @returns {void}
	     */
	    CartesianAxisLayoutPanel.prototype.drawBottomLine = function (definition, index, isRow) {
	        var chart = this.chart;
	        var optionsLine = {};
	        var x1;
	        var x2;
	        var y1;
	        var y2;
	        var definitionName;
	        if (isRow) {
	            definition = definition;
	            y1 = y2 = definition.computedTop + definition.computedHeight;
	            x1 = this.seriesClipRect.x;
	            x2 = x1 + this.seriesClipRect.width;
	            definitionName = 'Row';
	        }
	        else {
	            definition = definition;
	            x1 = x2 = definition.computedLeft;
	            y1 = this.seriesClipRect.y;
	            y2 = y1 + this.seriesClipRect.height;
	            definitionName = 'Column';
	        }
	        optionsLine = {
	            'id': chart.element.id + '_AxisBottom_' + definitionName + index,
	            x1: x1,
	            y1: y1,
	            x2: x2,
	            y2: y2,
	            'stroke-width': definition.border.width,
	            'stroke': definition.border.color
	        };
	        this.htmlObject = chart.renderer.drawLine(optionsLine);
	        this.element.appendChild(this.htmlObject);
	    };
	    /**
	     * To render the axis line
	     *
	     * @param {Axis} axis axis
	     * @param {number} index index
	     * @param {number} plotX plotX
	     * @param {number} plotY plotY
	     * @param {Element} parent parent
	     * @param {Rect} rect rect
	     * @returns {void}
	     */
	    CartesianAxisLayoutPanel.prototype.drawAxisLine = function (axis, index, plotX, plotY, plotBottom, plotTop, plotLeft, plotRight, parent, rect) {
	        var chart = this.chart;
	        var optionsLine = {};
	        var element = getElement(chart.element.id + 'AxisLine_' + index);
	        var direction = element ? element.getAttribute('d') : '';
	        element = null;
	        optionsLine = {
	            'id': chart.element.id + 'AxisLine_' + index,
	            'd': 'M ' + (rect.x - plotX - plotLeft) + ' ' + (rect.y - plotY - plotTop) +
	                ' L ' + (rect.x + rect.width + plotX + plotRight) + ' ' + (rect.y + rect.height + plotY + plotBottom),
	            'stroke-dasharray': axis.lineStyle.dashArray,
	            'stroke-width': axis.lineStyle.width,
	            'stroke': axis.lineStyle.color || chart.themeStyle.axisLine
	        };
	        this.htmlObject = chart.renderer.drawPath(optionsLine);
	        appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction);
	    };
	    /**
	     * To render the yAxis grid line
	     *
	     * @param {Axis} axis axis
	     * @param {number} index index
	     * @param {Element} parent parent
	     * @param {Rect} rect rect
	     * @returns {void}
	     */
	    CartesianAxisLayoutPanel.prototype.drawYAxisGridLine = function (axis, index, parent, rect) {
	        var isLogAxis = axis.valueType === 'Logarithmic';
	        var isCategoryAxis = axis.valueType.indexOf('Category') > -1;
	        var tempInterval;
	        var pointY = 0;
	        var majorGrid = '';
	        var majorTick = '';
	        var minorGridDirection;
	        var isOpposed = axis.isAxisOpposedPosition;
	        var tickSize = isOpposed ? axis.majorTickLines.height : -axis.majorTickLines.height;
	        var axisLineSize = (isOpposed) ? axis.lineStyle.width * 0.5 : -axis.lineStyle.width * 0.5;
	        var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ?
	            0.5 : 0;
	        var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? isOpposed ? axis.scrollBarHeight :
	            -axis.scrollBarHeight : 0;
	        var isTickInside = axis.tickPosition === 'Inside';
	        var ticks = isTickInside ? (rect.x - tickSize - axisLineSize) : (rect.x + tickSize + axisLineSize + scrollBarHeight);
	        var length = axis.visibleLabels.length;
	        var chartThemeStyle = this.chart.themeStyle;
	        if (axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' && length > 0 && !this.chart.stockChart) {
	            length += 1;
	        }
	        var minorGridLines = axis.minorGridLines;
	        var minorTickLines = axis.minorTickLines;
	        //Gridlines
	        for (var i = 0; i < length; i++) {
	            tempInterval = !axis.visibleLabels[i] ? (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel
	                : axis.visibleLabels[i].value - ticksbwtLabel;
	            pointY = valueToCoefficient(tempInterval, axis) * rect.height;
	            pointY = (pointY * -1) + (rect.y + rect.height);
	            if (pointY >= rect.y && (rect.y + rect.height) >= pointY) {
	                if ((inside(tempInterval, axis.visibleRange)) || this.isBorder(axis, i, pointY)) {
	                    majorGrid = 'M ' + this.seriesClipRect.x + ' ' + (pointY) +
	                        ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + pointY;
	                    this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);
	                }
	                majorTick = 'M ' + (rect.x + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' ' + pointY +
	                    ' L ' + (ticks) + ' ' + pointY;
	                this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);
	                if ((minorGridLines.width > 0 || minorTickLines.width > 0) && axis.minorTicksPerInterval > 0) {
	                    if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {
	                        this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);
	                    }
	                    minorGridDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);
	                    this.renderGridLine(axis, index, minorGridDirection[0], minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, minorGridLines.dashArray);
	                    this.renderGridLine(axis, index, minorGridDirection[1], minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);
	                    if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {
	                        this.renderMinorGridOnZooming(axis, (tempInterval + axis.visibleRange.interval), rect, i, index, chartThemeStyle, parent);
	                    }
	                }
	            }
	        }
	    };
	    /**
	     * To check the border of the axis
	     *
	     * @param {Axis} axis axis
	     * @param {number} index index
	     * @param {number} value value
	     * @returns {boolean} check the border of the axis
	     */
	    CartesianAxisLayoutPanel.prototype.isBorder = function (axis, index, value) {
	        var border = this.chart.chartArea.border;
	        var rect = this.seriesClipRect;
	        var orientation = axis.orientation;
	        var start = (orientation === 'Horizontal') ? rect.x : rect.y;
	        var size = (orientation === 'Horizontal') ? rect.width : rect.height;
	        var startIndex = (orientation === 'Horizontal') ? 0 : axis.visibleLabels.length - 1;
	        var endIndex = (orientation === 'Horizontal') ? axis.visibleLabels.length - 1 : 0;
	        if (axis.plotOffset > 0) {
	            return true;
	        }
	        else if ((value === start || value === (start + size)) && (border.width <= 0 || border.color === 'transparent')) {
	            return true;
	        }
	        else if ((value !== start && index === startIndex) || (value !== (start + size) && index === endIndex)) {
	            return true;
	        }
	        return false;
	    };
	    /**
	     * To render the yAxis label
	     *
	     * @param {Axis} axis axis
	     * @param {number} index index
	     * @param {Element} parent parent
	     * @param {Rect} rect rect
	     * @returns {void}
	     * @private
	     */
	    CartesianAxisLayoutPanel.prototype.drawYAxisLabels = function (axis, index, parent, rect) {
	        var chart = this.chart;
	        var label;
	        var pointX = 0;
	        var pointY = 0;
	        var elementSize;
	        var labelSpace = axis.labelPadding;
	        var options;
	        var isAxisBreakLabel;
	        var isLabelInside = axis.labelPosition === 'Inside';
	        var isOpposed = axis.isAxisOpposedPosition;
	        var RotatedWidth;
	        var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;
	        var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;
	        var angle = axis.angle % 360;
	        var isVerticalAngle = (angle === -90 || angle === 90 || angle === 270 || angle === -270);
	        padding += (isVerticalAngle) ? (isLabelInside ? 5 : -5) : 0;
	        padding = (isOpposed) ? padding : -padding;
	        var labelElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisLabels' + index });
	        var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight * (isOpposed ? 1 : -1) : 0;
	        var textHeight;
	        var textPadding;
	        var maxLineWidth;
	        var pixel = 10;
	        var isInverse = axis.isAxisInverse;
	        var previousEnd = isInverse ? rect.y : (rect.y + rect.height);
	        var labelPadding;
	        var intervalLength;
	        var labelHeight;
	        var yAxisLabelX;
	        var isLabelOnAxisLineLeft = ((!isOpposed && !isLabelInside) || (isOpposed && isLabelInside));
	        if (isLabelInside) {
	            labelPadding = !isLabelOnAxisLineLeft ? -padding : padding;
	        }
	        else {
	            labelPadding = !isLabelOnAxisLineLeft ? -padding + scrollBarHeight : padding + scrollBarHeight;
	        }
	        var sizeWidth = [];
	        var breakLabelSizeWidth = [];
	        axis.visibleLabels.map(function (item) {
	            sizeWidth.push(item.size['width']);
	            breakLabelSizeWidth.push(item.breakLabelSize['width']);
	        });
	        var LabelMaxWidth = Math.max.apply(Math, sizeWidth);
	        var breakLabelMaxWidth = Math.max.apply(Math, breakLabelSizeWidth);
	        RotatedWidth = LabelMaxWidth;
	        if (angle >= -45 && angle <= 45 && angle !== 0) {
	            RotatedWidth = LabelMaxWidth * Math.cos(angle * Math.PI / 180);
	            if (RotatedWidth < 0) {
	                RotatedWidth = -RotatedWidth;
	            }
	        }
	        for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {
	            label = axis.visibleLabels[i];
	            isAxisBreakLabel = isBreakLabel(axis.visibleLabels[i].originalText);
	            elementSize = isAxisBreakLabel ? axis.visibleLabels[i].breakLabelSize : axis.visibleLabels[i].size;
	            pointY = (valueToCoefficient(axis.visibleLabels[i].value, axis) * rect.height) + (chart.stockChart ? 7 : 0);
	            pointY = Math.floor((pointY * -1) + (rect.y + rect.height));
	            textHeight = ((elementSize.height / 8) * axis.visibleLabels[i].text.length / 2);
	            textPadding = (chart.requireInvertedAxis && axis.labelPosition === 'Inside') ? 0 : ((elementSize.height / 4) * 3) + 3;
	            intervalLength = rect.height / axis.visibleLabels.length;
	            labelHeight = ((axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle !== 0 &&
	                elementSize.width > intervalLength) ? intervalLength : elementSize.width;
	            pointY = (isAxisBreakLabel ? (axis.labelPosition === 'Inside' ? (pointY - (elementSize.height / 2) - textHeight + textPadding)
	                : (pointY - textHeight)) : (axis.labelPosition === 'Inside' ? pointY + textPadding : pointY));
	            if (axis.labelPosition === 'Inside' && ((i === 0 && !axis.isInversed) || (i === len - 1 && axis.isInversed))) {
	                if (chart.stockChart) {
	                    pointY -= (textPadding);
	                }
	                else {
	                    pointY -= (textPadding - ((chart.requireInvertedAxis && axis.labelPosition === 'Inside') ? 0 : (axis.opposedPosition ? -padding : padding)));
	                }
	            }
	            if (axis.majorGridLines.width > axis.majorTickLines.width) {
	                maxLineWidth = axis.majorGridLines.width;
	            }
	            else {
	                maxLineWidth = axis.majorTickLines.width;
	            }
	            if (axis.labelStyle.textAlignment === 'Far') {
	                pointY = pointY - maxLineWidth - pixel;
	            }
	            else if (axis.labelStyle.textAlignment === 'Near') {
	                pointY = pointY + maxLineWidth + pixel;
	            }
	            else if (axis.labelStyle.textAlignment === 'Center') {
	                // eslint-disable-next-line no-self-assign
	                pointY = pointY;
	            }
	            // label X value adjustment (Start)
	            if (isLabelInside) {
	                yAxisLabelX = labelPadding + ((angle === 0 ? elementSize.width : (isAxisBreakLabel ? breakLabelMaxWidth : LabelMaxWidth)) / 2);
	            }
	            else {
	                yAxisLabelX = labelPadding - ((angle === 0 ? elementSize.width : (isAxisBreakLabel ? breakLabelMaxWidth : RotatedWidth)) / 2);
	            }
	            pointX = isOpposed ? (rect.x - yAxisLabelX) : (rect.x + yAxisLabelX);
	            if (isVerticalAngle) {
	                pointX += (isOpposed) ? -10 : 10;
	            }
	            yAxisLabelX = labelPadding;
	            options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, 'middle', label.text, '', 'middle', angle);
	            switch (axis.edgeLabelPlacement) {
	                case 'None':
	                    break;
	                case 'Hide':
	                    if (((i === 0 || (isInverse && i === len - 1)) && options.y > rect.y) ||
	                        (((i === len - 1) || (isInverse && i === 0)) && options.y - elementSize.height * 0.5 < rect.y)) {
	                        options.text = '';
	                    }
	                    break;
	                case 'Shift':
	                    if ((i === 0 || (isInverse && i === len - 1)) && options.y > rect.y + rect.height) {
	                        options.y = pointY = rect.y + rect.height;
	                    }
	                    else if (((i === len - 1) || (isInverse && i === 0)) && (options.y < rect.y)) {
	                        options.y = pointY = rect.y + elementSize.height * 0.5;
	                    }
	                    break;
	            }
	            // ------- Hide Calculation (Start) -------------
	            var previousYValue = options.y;
	            var currentYValue = options.y - labelHeight;
	            if (isAxisBreakLabel) {
	                previousYValue = (options.y - (labelHeight / 2));
	                currentYValue = options.y + (labelHeight / 2);
	            }
	            if ((angle === 90 || angle === 270) && axis.labelIntersectAction === 'Hide' && i !== 0 &&
	                (!isInverse ? previousYValue >= previousEnd : currentYValue <= previousEnd)) {
	                continue;
	            }
	            previousEnd = isInverse ? previousYValue : currentYValue;
	            // ------- Hide Calculation (End) -------------
	            options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';
	            textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, false, chart.redraw, true, true, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisLabelFont);
	        }
	        if (!this.chart.enableCanvas) {
	            if (!chart.delayRedraw) {
	                appendChildElement(chart.enableCanvas, parent, labelElement, chart.redraw);
	            }
	            else if (axis.visible && axis.internalVisibility) {
	                this.createZoomingLabel(this.chart, labelElement, axis, index, rect);
	            }
	        }
	    };
	    /**
	     * To get X value based on lineBreakAlignment for Y axis line break labels only.
	     *
	     * @param {number} x text x position
	     * @param {Axis} axis y axis values
	     * @param {number} textWidth axis label width
	     * @returns {number} returns suitable axis label x position
	     */
	    CartesianAxisLayoutPanel.prototype.getAxisLabelXvalue = function (x, axis, textWidth) {
	        var anchor = axis.lineBreakAlignment;
	        var isLabelInside = axis.labelPosition === 'Inside';
	        var isOpposed = axis.isAxisOpposedPosition;
	        if ((isOpposed && isLabelInside) || (!isOpposed && !isLabelInside)) {
	            return (anchor === 'Right' ? x : (anchor === 'Center' ? (x - textWidth / 2) : (x - textWidth)));
	        }
	        else {
	            return (anchor === 'Left' ? x : (anchor === 'Center' ? (x + textWidth / 2) : (x + textWidth)));
	        }
	    };
	    /**
	     * To render the yAxis label border.
	     *
	     * @param {Axis} axis axis
	     * @param {number} index index
	     * @param {Element} parent parent
	     * @param {Rect} rect rect
	     * @returns {void}
	     */
	    CartesianAxisLayoutPanel.prototype.drawYAxisBorder = function (axis, index, parent, rect) {
	        if (axis.border.width > 0) {
	            var startY = void 0;
	            var pointY = void 0;
	            var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;
	            var isOpposed = axis.isAxisOpposedPosition;
	            scrollBarHeight = (isOpposed ? 1 : -1) * scrollBarHeight;
	            var gap = (rect.height / axis.visibleRange.delta) * (axis.valueType === 'DateTime' ? axis.dateTimeInterval
	                : axis.visibleRange.interval);
	            var endY = void 0;
	            var length_1 = axis.maxLabelSize.width + 10 + ((axis.tickPosition === axis.labelPosition) ?
	                axis.majorTickLines.height : 0);
	            var labelBorder = '';
	            var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? -0.5 : 0;
	            var endX = ((isOpposed && axis.labelPosition === 'Inside') || (!isOpposed
	                && axis.labelPosition === 'Outside')) ? rect.x - length_1 + scrollBarHeight : rect.x + length_1 + scrollBarHeight;
	            for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {
	                pointY = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);
	                pointY = (axis.isAxisInverse ? (1 - pointY) : pointY) * rect.height;
	                if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {
	                    startY = (pointY * -1) + (rect.y + rect.height);
	                    endY = (pointY * -1) - (gap) + (rect.y + rect.height);
	                }
	                else {
	                    startY = (pointY * -1) + gap / 2 + (rect.y + rect.height);
	                    endY = (pointY * -1) - gap / 2 + (rect.y + rect.height);
	                }
	                switch (axis.border.type) {
	                    case 'Rectangle':
	                    case 'WithoutTopBorder':
	                        if (startY > (rect.y + rect.height)) {
	                            labelBorder += ('M' + ' ' + endX + ' ' + (rect.y + rect.height) + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');
	                        }
	                        else if (Math.floor(rect.y) > (endY)) {
	                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX
	                                + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + (rect.y) + ' ');
	                        }
	                        else {
	                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX +
	                                ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');
	                            if (i === axis.visibleLabels.length - 1) {
	                                labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY + ' ' + 'L' + ' ' +
	                                    endX + ' ' + endY + ' ');
	                            }
	                        }
	                        break;
	                    case 'WithoutTopandBottomBorder':
	                        if (!(startY > rect.y + rect.height) && !((endY) < Math.floor(rect.y))) {
	                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX +
	                                ' ' + startY + ' ' + 'M' + ' ' + endX + ' ' + endY + ' ' +
	                                'L' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY);
	                        }
	                        break;
	                }
	            }
	            labelBorder += (axis.border.type === 'Rectangle') ? ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + rect.y + ' ' + 'L' + ' ' +
	                (rect.x + scrollBarHeight) + ' ' + (rect.y + rect.height) + ' ') : '';
	            if (labelBorder !== '') {
	                this.createAxisBorderElement(axis, index, labelBorder, parent);
	            }
	        }
	        if (axis.multiLevelLabels.length > 0 && this.chart.multiLevelLabelModule) {
	            this.chart.multiLevelLabelModule.renderYAxisMultiLevelLabels(axis, index, parent, rect);
	        }
	    };
	    /**
	     * To render the yAxis title
	     *
	     * @param {Axis} axis axis
	     * @param {number} index index
	     * @param {Element} parent parent
	     * @param {Rect} rect rect
	     * @returns {void}
	     */
	    CartesianAxisLayoutPanel.prototype.drawYAxisTitle = function (axis, index, parent, rect) {
	        if (axis.title) {
	            var chart = this.chart;
	            var isRotated = false;
	            var isOpposed = axis.isAxisOpposedPosition;
	            var labelRotation = (axis.titleRotation == null ? (isOpposed ? 90 : -90) : axis.titleRotation) % 360;
	            var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) +
	                (axis.labelPosition === 'Inside' ? 0 :
	                    (axis.maxLabelSize.width + axis.multiLevelLabelHeight + this.padding));
	            padding = isOpposed ? padding + axis.scrollBarHeight : -padding - axis.scrollBarHeight;
	            if ((labelRotation !== -90 && !isOpposed) || (labelRotation !== 90 && isOpposed)) {
	                padding += axis.isAxisOpposedPosition ? axis.titleSize.width / 2 + axis.labelPadding : -axis.titleSize.width / 2 - axis.labelPadding;
	                isRotated = true;
	            }
	            var x = rect.x + padding;
	            var y = rect.y + rect.height * 0.5;
	            var titleSize = (axis.titleSize.height * (axis.titleCollection.length - 1));
	            var options = new TextOption(chart.element.id + '_AxisTitle_' + index, x, y + (isRotated ? -titleSize : -axis.labelPadding - titleSize), 'middle', axis.titleCollection, 'rotate(' + labelRotation + ',' + (x) + ',' + (y) + ')', null, labelRotation);
	            var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitleFont.color, parent, null, null, null, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisTitleFont);
	            element.setAttribute('aria-hidden', 'true');
	        }
	    };
	    /**
	     * xAxis grid line calculation performed here
	     *
	     * @param {Axis} axis axis
	     * @param {number} index index
	     * @param {Element} parent parent
	     * @param {Rect} rect rect
	     * @returns {void}
	     */
	    CartesianAxisLayoutPanel.prototype.drawXAxisGridLine = function (axis, index, parent, rect) {
	        var isLogAxis = axis.valueType === 'Logarithmic';
	        var isCategoryAxis = axis.valueType.indexOf('Category') > -1;
	        var tempInterval;
	        var pointX = 0;
	        var majorGrid = '';
	        var majorTick = '';
	        var minorDirection;
	        var isOpposed = axis.isAxisOpposedPosition;
	        var tickSize = (isOpposed) ? -axis.majorTickLines.height : axis.majorTickLines.height;
	        var axisLineSize = (isOpposed) ? -axis.lineStyle.width * 0.5 : axis.lineStyle.width * 0.5;
	        var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? isOpposed ? -axis.scrollBarHeight :
	            axis.scrollBarHeight : 0;
	        var ticksbwtLabel = (axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' && !this.chart.stockChart) ?
	            0.5 : 0;
	        var length = axis.visibleLabels.length;
	        var isTickInside = axis.tickPosition === 'Inside';
	        var ticks = isTickInside ? (rect.y - tickSize - axisLineSize) : (rect.y + tickSize + axisLineSize + scrollBarHeight);
	        var chartThemeStyle = this.chart.themeStyle;
	        if (axis.valueType.indexOf('Category') > -1 && length > 0 && axis.labelPlacement === 'BetweenTicks' && !this.chart.stockChart) {
	            length += 1;
	        }
	        //Gridlines
	        for (var i = 0; i < length; i++) {
	            if (axis.valueType !== 'DateTimeCategory') {
	                tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel
	                    : (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel;
	            }
	            else {
	                tempInterval = axis.visibleLabels[i] ?
	                    axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleRange.max;
	            }
	            pointX = (valueToCoefficient(tempInterval, axis) * rect.width) + rect.x;
	            if (pointX >= rect.x && (rect.x + rect.width) >= pointX) {
	                if (inside(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointX)) {
	                    majorGrid = 'M ' + pointX + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) +
	                        ' L ' + pointX + ' ' + this.seriesClipRect.y;
	                    this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);
	                }
	                majorTick = 'M ' + (pointX) + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0))
	                    + ' L ' + (pointX) + ' ' + ticks;
	                this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);
	                if (axis.minorTicksPerInterval > 0 && (axis.minorGridLines.width > 0 || axis.minorTickLines.width > 0)) {
	                    if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {
	                        this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);
	                    }
	                    minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);
	                    this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);
	                    this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);
	                    if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {
	                        this.renderMinorGridOnZooming(axis, (tempInterval + axis.visibleRange.interval), rect, i, index, chartThemeStyle, parent);
	                    }
	                }
	            }
	        }
	    };
	    /**
	     * To render missing minor grid lines while zooming
	     *
	     * @param {Axis} axis axis
	     * @param {number} tempInterval tempInterval
	     * @param {Rect} rect rect
	     * @param {number} i i
	     * @param {number} index index
	     * @param {IThemeStyle} chartThemeStyle chartThemeStyle
	     * @param {Element} parent parent
	     * @returns {void}
	     */
	    CartesianAxisLayoutPanel.prototype.renderMinorGridOnZooming = function (axis, tempInterval, rect, i, index, chartThemeStyle, parent) {
	        var minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i, true);
	        this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', -1, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);
	        this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', -1, parent, chartThemeStyle.minorTickLine);
	    };
	    /**
	     * To calcualte the axis minor line
	     *
	     * @param {Axis} axis axis
	     * @param {number} tempInterval tempInterval
	     * @param {Rect} rect rect
	     * @param {number} labelIndex labelIndex
	     * @param {boolean} isFirstLabel isFirstLabel
	     * @returns {string[]} axis minor line path
	     */
	    CartesianAxisLayoutPanel.prototype.drawAxisMinorLine = function (axis, tempInterval, rect, labelIndex, isFirstLabel) {
	        var value = tempInterval;
	        var coor = 0;
	        var position = 0;
	        var range = axis.visibleRange;
	        var isTickInside = axis.tickPosition === 'Inside';
	        var direction = [];
	        var tickSize = axis.isAxisOpposedPosition ? -axis.minorTickLines.height : axis.minorTickLines.height;
	        var logStart;
	        var logEnd;
	        var logInterval = 1;
	        var logPosition = 1;
	        var ticksX = isTickInside ? (rect.y - tickSize) : (rect.y + tickSize);
	        var ticksY = isTickInside ? (rect.x + tickSize) : (rect.x - tickSize);
	        var minorGird = '';
	        var minorTick = '';
	        var isInverse = axis.isAxisInverse;
	        if (axis.valueType === 'Logarithmic') {
	            logStart = Math.pow(axis.logBase, value - range.interval);
	            logEnd = Math.pow(axis.logBase, value);
	            logInterval = (logEnd - logStart) / (axis.minorTicksPerInterval + 1);
	            logPosition = logStart + logInterval;
	        }
	        if (axis.orientation === 'Horizontal') {
	            for (var j = 0; j < axis.minorTicksPerInterval; j++) {
	                value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);
	                logPosition += logInterval;
	                if (inside(value, range)) {
	                    position = ((value - range.min) / (range.max - range.min));
	                    position = Math.ceil((isInverse ? (1 - position) : position) * rect.width);
	                    coor = (Math.floor(position + rect.x));
	                    minorGird = minorGird.concat('M' + ' ' + coor + ' ' + (this.seriesClipRect.y)
	                        + 'L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height));
	                    coor = (Math.floor(position + rect.x));
	                    minorTick = minorTick.concat('M' + ' ' + coor + ' ' + (rect.y)
	                        + 'L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));
	                }
	            }
	        }
	        else {
	            for (var j = 0; j < axis.minorTicksPerInterval; j++) {
	                value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);
	                if (inside(value, range)) {
	                    position = ((value - range.min) / (range.max - range.min));
	                    position = Math.ceil(((isInverse ? (1 - position) : position)) * rect.height) * -1; // For inversed axis
	                    coor = (Math.floor(position + rect.y + rect.height));
	                    minorGird = minorGird.concat('M' + ' ' + (this.seriesClipRect.x) + ' ' + coor
	                        + 'L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor + ' ');
	                    coor = (Math.floor(position + rect.y + rect.height));
	                    minorTick = minorTick.concat('M' + ' ' + rect.x + ' ' + coor + 'L ' + (ticksY - axis.scrollBarHeight) +
	                        ' ' + coor + ' ');
	                }
	                logPosition += logInterval;
	            }
	        }
	        direction.push(minorGird);
	        direction.push(minorTick);
	        return direction;
	    };
	    /**
	     * To find the numeric value of the log
	     *
	     * @param {Axis} axis axis
	     * @param {number} logPosition logPosition
	     * @param {number} value value
	     * @param {number} labelIndex labelIndex
	     * @param {boolean} isFirstLabel isFirstLabel
	     * @returns {number} value
	     */
	    CartesianAxisLayoutPanel.prototype.findLogNumeric = function (axis, logPosition, value, labelIndex, isFirstLabel) {
	        var range = axis.visibleRange;
	        var tempValue;
	        if (axis.valueType === 'Logarithmic') {
	            value = logBase(logPosition, axis.logBase);
	        }
	        else if (axis.valueType === 'DateTime') {
	            tempValue = axis.dateTimeInterval / (axis.minorTicksPerInterval + 1);
	            value = isFirstLabel ? (value - tempValue) : (value + tempValue);
	        }
	        else if (axis.valueType === 'DateTimeCategory') {
	            var padding = axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;
	            value += ((axis.visibleLabels[labelIndex + 1] ?
	                axis.visibleLabels[labelIndex + 1].value - padding : axis.visibleRange.max) -
	                (axis.visibleLabels[labelIndex] ?
	                    axis.visibleLabels[labelIndex].value - padding : axis.visibleRange.min)) /
	                (axis.minorTicksPerInterval + 1);
	        }
	        else {
	            tempValue = range.interval / (axis.minorTicksPerInterval + 1);
	            value = isFirstLabel ? (value - tempValue) : (value + tempValue);
	        }
	        return value;
	    };
	    /**
	     * To render the xAxis Labels
	     *
	     * @param {Axis} axis axis
	     * @param {number} index index
	     * @param {Element} parent parent
	     * @param {Rect} rect rect
	     * @returns {void}
	     * @private
	     */
	    CartesianAxisLayoutPanel.prototype.drawXAxisLabels = function (axis, index, parent, rect) {
	        var chart = this.chart;
	        var pointX = 0;
	        var pointY = 0;
	        var labelSpace = axis.labelPadding;
	        var labelHeight;
	        var elementSize;
	        var labelPadding;
	        var anchor;
	        var pixel = 10;
	        var labelElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisLabels' + index });
	        var islabelInside = axis.labelPosition === 'Inside';
	        var isOpposed = axis.isAxisOpposedPosition;
	        var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;
	        var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;
	        var angle = axis.angle % 360;
	        var isHorizontalAngle = (angle === 0 || angle === -180 || angle === 180);
	        var options;
	        var labelWidth;
	        var isInverse = axis.isAxisInverse;
	        var isLeft;
	        var previousEnd = isInverse ? (rect.x + rect.width) : rect.x;
	        var width = 0;
	        var length = axis.visibleLabels.length;
	        var intervalLength;
	        var label;
	        var isAxisBreakLabel;
	        var scrollBarHeight = axis.scrollbarSettings.enable || (!islabelInside && isNullOrUndefined(axis.crossesAt)
	            && (axis.zoomFactor < 1 || axis.zoomPosition > 0)) ? axis.scrollBarHeight : 0;
	        var newPoints = [];
	        var isRotatedLabelIntersect = false;
	        var textPoints = [];
	        var rotatedLabelSize = new Size(0, 0);
	        padding += (angle === 90 || angle === 270 || angle === -90 || angle === -270) ? (islabelInside ? 5 : -5) : 0;
	        var isLabelUnderAxisLine = ((!isOpposed && !islabelInside) || (isOpposed && islabelInside));
	        var isEndAnchor = isLabelUnderAxisLine ?
	            ((360 >= angle && angle >= 180) || (-1 >= angle && angle >= -180)) :
	            ((1 <= angle && angle <= 180) || (-181 >= angle && angle >= -360));
	        for (var i = 0, len = length; i < len; i++) {
	            label = axis.visibleLabels[i];
	            isAxisBreakLabel = isBreakLabel(label.originalText) || (axis.labelIntersectAction === 'Wrap' && label.text.length > 1);
	            pointX = (valueToCoefficient(label.value, axis) * rect.width) + rect.x;
	            elementSize = label.size;
	            intervalLength = rect.width / length;
	            labelWidth = isAxisBreakLabel ? label.breakLabelSize.width : elementSize.width;
	            width = ((axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle === 0 &&
	                labelWidth > intervalLength) ? intervalLength : labelWidth;
	            labelHeight = elementSize.height / 4;
	            pointX -= (isAxisBreakLabel || angle !== 0) ? 0 : (width / 2);
	            // label X value adjustment for label rotation (Start)
	            if (angle !== 0) {
	                if (isAxisBreakLabel) {
	                    pointX -= axis.lineBreakAlignment === 'Left' ? (label.breakLabelSize.width / 2) : axis.lineBreakAlignment === 'Right' ?
	                        -(label.breakLabelSize.width / 2) : 0;
	                }
	                else {
	                    pointX -= (angle === -90 || angle === 270 ? -labelHeight : (angle === 90 || angle === -270) ? labelHeight : 0);
	                }
	            }
	            // label X value adjustment for label rotation (End)
	            if (axis.labelStyle.textAlignment === 'Far') {
	                pointX = pointX + width - pixel;
	            }
	            else if (axis.labelStyle.textAlignment === 'Near') {
	                pointX = pointX - width + pixel;
	            }
	            else if (axis.labelStyle.textAlignment === 'Center') {
	                // eslint-disable-next-line no-self-assign
	                pointX = pointX;
	            }
	            // For line break label alignment like left, right & center in angle 0
	            if (isAxisBreakLabel && axis.lineBreakAlignment !== 'Center' && angle === 0) {
	                pointX += axis.lineBreakAlignment === 'Left' ? -(width / 2) : (width / 2);
	            }
	            var paddingForBreakLabel = isAxisBreakLabel ?
	                (isHorizontalAngle ? (axis.opposedPosition || islabelInside ? 0 : elementSize.height) : (label.breakLabelSize.width / 2)) : 0;
	            padding = isAxisBreakLabel ? (tickSpace + labelSpace + axis.lineStyle.width * 0.5) : padding;
	            // label Y value adjustment (Start)
	            if (islabelInside && angle) {
	                if (isAxisBreakLabel) {
	                    pointY = isOpposed ? (rect.y + padding + (paddingForBreakLabel)) : (rect.y - padding - (paddingForBreakLabel));
	                }
	                else {
	                    pointY = isOpposed ? (rect.y + padding + labelHeight) : (rect.y - padding - labelHeight);
	                }
	            }
	            else {
	                if (isAxisBreakLabel) {
	                    labelPadding = !isLabelUnderAxisLine ? -(padding + scrollBarHeight + (paddingForBreakLabel)) :
	                        padding + scrollBarHeight + (angle ? paddingForBreakLabel : (3 * labelHeight));
	                }
	                else {
	                    labelPadding = !isLabelUnderAxisLine ?
	                        -(padding + scrollBarHeight + (angle ? labelHeight : (label.index > 1 ? (2 * labelHeight) : 0))) :
	                        padding + scrollBarHeight + ((angle ? 1 : 3) * labelHeight);
	                }
	                pointY = (rect.y + (labelPadding * label.index));
	            }
	            // label Y value adjustment (End)
	            if (isAxisBreakLabel) {
	                anchor = this.getAnchor(axis); // for break label self alignment
	            }
	            else {
	                anchor = (chart.enableRtl) ? ((isEndAnchor) ? '' : 'end') : (chart.isRtlEnabled || isEndAnchor) ? 'end' : '';
	            }
	            options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, anchor);
	            if (angle !== 0 && !chart.stockChart) {
	                rotatedLabelSize = rotateTextSize(label.labelStyle, label.originalText, angle, chart);
	                isLeft = ((angle < 0 && angle > -90) || (angle < -180 && angle > -270) || (angle > 90 && angle < 180) || (angle > 270 && angle < 360));
	            }
	            if (axis.edgeLabelPlacement) {
	                switch (axis.edgeLabelPlacement) {
	                    case 'None':
	                        break;
	                    case 'Hide':
	                        if (((i === 0 || (isInverse && i === len - 1)) && options.x < rect.x) ||
	                            ((i === len - 1 || (isInverse && i === 0)) && (options.x + width > rect.x + rect.width))) {
	                            continue;
	                        }
	                        break;
	                    case 'Shift':
	                        if ((i === 0 || (isInverse && i === len - 1)) && (options.x < rect.x || (angle !== 0 && isLeft && options.x - rotatedLabelSize.width <= rect.x) || (axis.lineBreakAlignment === 'Center' && options.x - (label.size.width / label.text.length) / 2 < rect.x && angle === 0))) {
	                            intervalLength -= (rect.x - options.x);
	                            if (anchor === '' && !isInverse && angle === 0) {
	                                if (options.x <= 0) {
	                                    pointX = options.x = 0;
	                                }
	                                else {
	                                    pointX = options.x;
	                                }
	                                intervalLength = rect.width / length;
	                            }
	                            else if (isLeft && angle !== 0) {
	                                intervalLength = rect.width / length;
	                                if (intervalLength > rect.x + rotatedLabelSize.width) {
	                                    options.x = pointX = rect.x + rotatedLabelSize.width;
	                                }
	                                else {
	                                    options.x = pointX = rect.x + intervalLength - padding;
	                                }
	                            }
	                            else if (isAxisBreakLabel && axis.lineBreakAlignment === 'Center' && axis.labelPlacement === 'OnTicks' && angle === 0) {
	                                var maxWidth = 0;
	                                for (var i_1 = 0; i_1 < label.text.length; i_1++) {
	                                    var breakLabelWidth = measureText(label.text[i_1], axis.labelStyle, chart.themeStyle.axisLabelFont).width;
	                                    if (breakLabelWidth > maxWidth) {
	                                        maxWidth = breakLabelWidth;
	                                    }
	                                }
	                                options.x = pointX = rect.x + maxWidth / 2;
	                            }
	                            else if (!(anchor === 'start' && options.x > 0)) {
	                                options.x = pointX = !isHorizontalAngle ? rect.x + padding : rect.x;
	                            }
	                        }
	                        else if ((i === len - 1 || (isInverse && i === 0)) && (((options.x + width) > rect.x + rect.width && anchor !== 'end' && angle === 0) || (angle !== 0 && !isLeft && (options.x + rotatedLabelSize.width) > rect.x + rect.width) || (anchor === 'end' && options.x > rect.x + rect.width))) {
	                            if (elementSize.width > intervalLength && axis.labelIntersectAction === 'Trim' && angle === 0) {
	                                intervalLength -= (options.x + width - (rect.x + rect.width));
	                            }
	                            else if (angle !== 0) {
	                                if (rotatedLabelSize.width < intervalLength) {
	                                    intervalLength = rotatedLabelSize.width;
	                                }
	                            }
	                            else {
	                                intervalLength = width;
	                            }
	                            if (angle !== 0) {
	                                options.x = pointX = rect.x + rect.width - intervalLength + padding;
	                            }
	                            else {
	                                options.x = pointX = !isHorizontalAngle ? rect.x + rect.width - intervalLength / 2 : rect.x + rect.width - intervalLength;
	                            }
	                        }
	                        if (this.chart.primaryYAxis.opposedPosition && i === 0 && options.x <= rect.x) {
	                            intervalLength -= (rect.x - options.x);
	                            options.x += rect.x + (width / 2);
	                            pointX += rect.x + (width / 2);
	                        }
	                        break;
	                }
	            }
	            options.text = this.getLabelText(label, axis, intervalLength);
	            options.labelRotation = angle;
	            // ------- Hide Calculation (Start) -------------
	            // Currect label actual start value (Start)
	            var xValue = void 0;
	            var xValue2 = void 0;
	            if (isAxisBreakLabel && angle === 0) {
	                if (axis.lineBreakAlignment === 'Right') {
	                    xValue = (options.x - width);
	                    xValue2 = options.x;
	                }
	                else if (axis.lineBreakAlignment === 'Center') {
	                    xValue = (options.x - (width / 2));
	                    xValue2 = options.x + (width / 2);
	                }
	                else {
	                    xValue = options.x;
	                    xValue2 = options.x + width;
	                }
	            }
	            else {
	                xValue = options.x;
	                xValue2 = options.x + width;
	            }
	            // Currect label actual start value (End)
	            if (angle === 0 && axis.labelIntersectAction === 'Hide' && i !== 0 &&
	                (!isInverse ? xValue <= previousEnd : xValue2 >= previousEnd)) {
	                continue;
	            }
	            // Previous label actual end value (Start)
	            if (isAxisBreakLabel) {
	                if (axis.lineBreakAlignment === 'Right') {
	                    previousEnd = isInverse ? (options.x - width) : options.x;
	                }
	                else if (axis.lineBreakAlignment === 'Center') {
	                    previousEnd = isInverse ? (options.x - (width / 2)) : options.x + (width / 2);
	                }
	                else {
	                    previousEnd = isInverse ? options.x : options.x + width;
	                }
	            }
	            else {
	                previousEnd = isInverse ? options.x : options.x + width;
	            }
	            // Previous label actual end value (End)
	            // ------- Hide Calculation (End) -------------
	            // label Rotataion calculation (Start)
	            if (angle !== 0) {
	                var height = void 0;
	                var rect_1 = void 0;
	                if (isAxisBreakLabel) {
	                    var xAdjustment = 0;
	                    var yAdjustment = 0;
	                    height = (label.breakLabelSize.height);
	                    yAdjustment = (label.breakLabelSize.height) - 4; // 4 for label bound correction
	                    // xAdjustment (Start)
	                    if (axis.lineBreakAlignment === 'Center') {
	                        xAdjustment = -(label.breakLabelSize.width / 2);
	                    }
	                    else if (axis.lineBreakAlignment === 'Right') {
	                        xAdjustment = -label.breakLabelSize.width;
	                    }
	                    // xAdjustment (End)
	                    if (isLabelUnderAxisLine) {
	                        yAdjustment = (label.breakLabelSize.height) / (options.text.length + 1);
	                    }
	                    rect_1 = new Rect(options.x + xAdjustment, options.y - (yAdjustment), label.breakLabelSize.width, height);
	                }
	                else {
	                    height = (pointY) - (options.y - ((label.size.height / 2)));
	                    rect_1 = new Rect(options.x, options.y - ((label.size.height / 2) - 5), label.size.width, height);
	                }
	                var rectCoordinates = this.getRectanglePoints(rect_1);
	                var rectCenterX = isAxisBreakLabel ? rect_1.x + (rect_1.width / 2) : pointX;
	                var rectCenterY = isAxisBreakLabel ? rect_1.y + (rect_1.height / 2) : (pointY - (height / 2));
	                if (isAxisBreakLabel) {
	                    options.transform = 'rotate(' + angle + ',' + rectCenterX + ',' + rectCenterY + ')';
	                }
	                else {
	                    options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';
	                }
	                newPoints.push(getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle));
	                isRotatedLabelIntersect = false;
	                if (axis.labelIntersectAction !== 'None') {
	                    for (var index_1 = i; index_1 > 0; index_1--) {
	                        if (newPoints[i] && newPoints[index_1 - 1] && isRotatedRectIntersect(newPoints[i], newPoints[index_1 - 1])) {
	                            isRotatedLabelIntersect = true;
	                            newPoints[i] = null;
	                            break;
	                        }
	                    }
	                }
	                var rotateAngle = ((angle > 0 && angle < 90) || (angle > 180 && angle < 270) || (angle < -90 && angle > -180) || (angle < -270 && angle > -360));
	                var textRect = new Rect(options.x, options.y - (elementSize.height / 2 + padding / 2), label.size.width, height);
	                var textRectCoordinates = this.getRectanglePoints(textRect);
	                var rectPoints = [];
	                rectPoints.push(new ChartLocation(rotateAngle ? this.chart.availableSize.width : this.padding, axis.rect.y));
	                rectPoints.push(new ChartLocation(rotateAngle ? this.chart.availableSize.width : this.padding, axis.rect.y + axis.maxLabelSize.height));
	                textPoints.push(getRotatedRectangleCoordinates(textRectCoordinates, rectCenterX, rectCenterY, angle));
	                var newRect = new Rect(0, axis.rect.y, this.chart.availableSize.width, axis.maxLabelSize.height * 2);
	                for (var k = 0; k < textPoints[i].length; k++) {
	                    if (!axis.opposedPosition && !withInBounds(textPoints[i][k].x, textPoints[i][k].y, newRect) && typeof options.text === 'string') {
	                        var interSectPoint = this.calculateIntersection(textPoints[i][0], textPoints[i][1], rectPoints[0], rectPoints[1]);
	                        var rectPoint1 = rotateAngle ? this.chart.availableSize.width - pointX : pointX;
	                        var rectPoint2 = interSectPoint.y - axis.rect.y;
	                        var trimValue = Math.sqrt((rectPoint1 * rectPoint1) + (rectPoint2 * rectPoint2));
	                        options.text = textTrim(trimValue, label.text, label.labelStyle, chart.themeStyle.axisLabelFont);
	                    }
	                }
	            }
	            // label Rotataion calculation (End)
	            textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, (axis.isAxisOpposedPosition !== (axis.labelPosition === 'Inside')), chart.redraw, true, null, null, null, label.size, isRotatedLabelIntersect, chart.enableCanvas, null, chart.themeStyle.axisLabelFont);
	        }
	        if (!this.chart.enableCanvas) {
	            if (!chart.delayRedraw) {
	                parent.appendChild(labelElement);
	            }
	            else if (axis.visible && axis.internalVisibility) {
	                this.createZoomingLabel(this.chart, labelElement, axis, index, rect);
	            }
	        }
	    };
	    CartesianAxisLayoutPanel.prototype.calculateIntersection = function (p1, p2, p3, p4) {
	        var c2x = p3.x - p4.x;
	        var c3x = p1.x - p2.x;
	        var c2y = p3.y - p4.y;
	        var c3y = p1.y - p2.y;
	        var d = c3x * c2y - c3y * c2x;
	        var u1 = p1.x * p2.y - p1.y * p2.x;
	        var u4 = p3.x * p4.y - p3.y * p4.x;
	        var px = (u1 * c2x - c3x * u4) / d;
	        var py = (u1 * c2y - c3y * u4) / d;
	        var p = { x: px, y: py };
	        return p;
	    };
	    /**
	     * To get text anchor value for line break labels.
	     *
	     * @param {Axis} axis axis model
	     * @returns {string} returns text anchor
	     */
	    CartesianAxisLayoutPanel.prototype.getAnchor = function (axis) {
	        return (axis.lineBreakAlignment === 'Center' ? 'middle' : (this.chart.enableRtl) ? (axis.lineBreakAlignment === 'Left' ? 'end' : 'start') : (axis.lineBreakAlignment === 'Left' ? 'start' : 'end'));
	    };
	    /**
	     * Get rect coordinates
	     *
	     * @param {Rect} rect rect
	     * @returns {ChartLocation[]} rectangle points
	     */
	    CartesianAxisLayoutPanel.prototype.getRectanglePoints = function (rect) {
	        var point1 = new ChartLocation(rect.x, rect.y);
	        var point2 = new ChartLocation(rect.x + rect.width, rect.y);
	        var point3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);
	        var point4 = new ChartLocation(rect.x, rect.y + rect.height);
	        return [point1, point2, point3, point4];
	    };
	    /**
	     * To get axis label text
	     *
	     * @param {VisibleLabels} label label
	     * @param {Axis} axis axis
	     * @param {number} intervalLength intervalLength
	     * @returns {string | string[]} label or label collection
	     */
	    CartesianAxisLayoutPanel.prototype.getLabelText = function (label, axis, intervalLength) {
	        if (isBreakLabel(label.originalText)) {
	            var result = [];
	            var str = void 0;
	            for (var index = 0; index < label.text.length; index++) {
	                str = this.findAxisLabel(axis, label.text[index], intervalLength);
	                result.push(str);
	            }
	            return result;
	        }
	        else {
	            return this.findAxisLabel(axis, label.text, intervalLength);
	        }
	    };
	    /**
	     * To render the x-axis label border.
	     *
	     * @param {Axis} axis axis
	     * @param {number} index index
	     * @param {Element} parent parent
	     * @param {Rect} axisRect axisRect
	     * @returns {void}
	     */
	    CartesianAxisLayoutPanel.prototype.drawXAxisBorder = function (axis, index, parent, axisRect) {
	        if (axis.border.width > 0) {
	            var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;
	            var isOpposed = axis.isAxisOpposedPosition;
	            var startX = void 0;
	            var startY = axisRect.y + ((isOpposed ? -1 : 1) * scrollBarHeight);
	            var padding = 10;
	            var pointX = void 0;
	            var gap = (axisRect.width / axis.visibleRange.delta) * (axis.valueType === 'DateTime' ? axis.dateTimeInterval
	                : axis.visibleRange.interval);
	            var endX = void 0;
	            var length_2 = axis.maxLabelSize.height +
	                ((axis.tickPosition === axis.labelPosition) ? axis.majorTickLines.height : 0);
	            var labelBorder = '';
	            var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? -0.5 : 0;
	            var endY = ((isOpposed && axis.labelPosition === 'Inside') ||
	                (!isOpposed && axis.labelPosition === 'Outside')) ?
	                (axisRect.y + length_2 + padding + scrollBarHeight) : (axisRect.y - length_2 - padding - scrollBarHeight);
	            for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {
	                pointX = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);
	                pointX = (axis.isAxisInverse ? (1 - pointX) : pointX) * axisRect.width;
	                if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {
	                    startX = pointX + axisRect.x;
	                    endX = pointX + (gap) + axisRect.x;
	                }
	                else {
	                    startX = pointX - gap * 0.5 + axisRect.x;
	                    endX = pointX + gap * 0.5 + axisRect.x;
	                }
	                switch (axis.border.type) {
	                    case 'Rectangle':
	                    case 'WithoutTopBorder':
	                        if (startX < axisRect.x && axis.labelPlacement !== 'OnTicks') {
	                            labelBorder += ('M' + ' ' + axisRect.x + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');
	                        }
	                        else if (Math.floor(endX) > axisRect.width + axisRect.x && !(axis.visibleLabels.length === 1) && !(i === axis.visibleLabels.length - 1)) {
	                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +
	                                'L' + ' ' + (axisRect.width + axisRect.x) + ' ' + endY + ' ');
	                        }
	                        else {
	                            startX = (i === 0 && axis.labelPlacement === 'OnTicks') ? axisRect.x : startX;
	                            endX = ((i === axis.visibleLabels.length - 1) && axis.labelPlacement === 'OnTicks') ? endX - gap * 0.5 : endX;
	                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' +
	                                endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');
	                            if (i === 0) {
	                                labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +
	                                    'M ' + startX + ' ' + endY + ' L ' + (axisRect.x) + ' ' + endY);
	                            }
	                            if (i === axis.visibleLabels.length - 1) {
	                                labelBorder += ('M' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ' +
	                                    'M ' + endX + ' ' + endY + ' L ' + (axisRect.width + axisRect.x) + ' ' + endY);
	                            }
	                        }
	                        break;
	                    case 'WithoutTopandBottomBorder':
	                        if (!(startX < axisRect.x) && !(Math.floor(endX) > axisRect.width + axisRect.x)) {
	                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +
	                                'M ' + endX + ' ' + startY + ' L ' + endX + ' ' + endY);
	                        }
	                        break;
	                }
	            }
	            labelBorder += (axis.border.type === 'Rectangle' ? ('M ' + ' ' + axisRect.x + ' ' + startY + 'L' + ' ' +
	                (axisRect.x + axisRect.width) + ' ' + startY) : '');
	            if (labelBorder !== '') {
	                this.createAxisBorderElement(axis, index, labelBorder, parent);
	            }
	        }
	        if (this.chart.multiLevelLabelModule && axis.multiLevelLabels.length > 0) {
	            this.chart.multiLevelLabelModule.renderXAxisMultiLevelLabels(axis, index, parent, axisRect);
	        }
	    };
	    /**
	     * To create border element of the axis
	     *
	     * @param {Axis} axis axis
	     * @param {number} index index
	     * @param {string} labelBorder labelBorder
	     * @param {Element} parent parent
	     * @returns {void}
	     */
	    CartesianAxisLayoutPanel.prototype.createAxisBorderElement = function (axis, index, labelBorder, parent) {
	        var element = getElement(this.chart.element.id + '_BorderLine_' + index);
	        var direction = element ? element.getAttribute('d') : '';
	        var borderElement = this.chart.renderer.drawPath(new PathOption(this.chart.element.id + '_BorderLine_' + index, 'transparent', axis.border.width, axis.border.color || this.chart.themeStyle.axisLine, 1, '', labelBorder));
	        borderElement.style.pointerEvents = 'none';
	        appendChildElement(this.chart.enableCanvas, parent, borderElement, this.chart.redraw, false, 'x', 'y', null, direction, true);
	    };
	    /**
	     * To find the axis label of the intersect action
	     *
	     * @param {Axis} axis axis
	     * @param {string} label label
	     * @param {number} width width
	     * @returns {string} label
	     */
	    CartesianAxisLayoutPanel.prototype.findAxisLabel = function (axis, label, width) {
	        return (axis.labelIntersectAction === 'Trim' ?
	            ((axis.angle % 360 === 0 && !axis.enableTrim) ? textTrim(width, label, axis.labelStyle, this.chart.themeStyle.axisLabelFont) : label) : label);
	    };
	    /**
	     * X-Axis Title function performed
	     *
	     * @param {Axis} axis axis
	     * @param {number} index index
	     * @param {Element} parent parent
	     * @param {Rect} rect rect
	     * @returns {void}
	     */
	    CartesianAxisLayoutPanel.prototype.drawXAxisTitle = function (axis, index, parent, rect) {
	        if (axis.title) {
	            var chart = this.chart;
	            var elementSize = measureText(axis.title, axis.titleStyle, this.chart.themeStyle.axisTitleFont);
	            var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight : 0;
	            var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) +
	                (axis.labelPosition === 'Inside' ? 0 :
	                    axis.maxLabelSize.height + axis.multiLevelLabelHeight + axis.labelPadding);
	            var titleSize = (axis.titleSize.height * (axis.titleCollection.length - 1));
	            padding = axis.isAxisOpposedPosition ? -(padding + elementSize.height / 4 + scrollBarHeight + titleSize) : (padding + (3 *
	                elementSize.height / 4) + scrollBarHeight);
	            var labelRotation = axis.titleRotation ? axis.titleRotation : 0;
	            var x = rect.x + rect.width * 0.5;
	            var y = rect.y + padding;
	            if (labelRotation !== 0) {
	                y += axis.opposedPosition ? -(axis.titleSize.height / 2 + elementSize.height / 4) :
	                    axis.titleSize.height / 2 - elementSize.height / 4;
	            }
	            var options = new TextOption(chart.element.id + '_AxisTitle_' + index, x, y, 'middle', axis.titleCollection, 'rotate(' + labelRotation + ',' + (x) + ',' + (y) + ')', null, labelRotation);
	            var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitleFont.color, parent, null, null, null, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisTitleFont);
	            element.setAttribute('aria-hidden', 'true');
	        }
	    };
	    /**
	     * To render the axis grid and tick lines(Both Major and Minor)
	     *
	     * @param {Axis} axis axis
	     * @param {number} index index
	     * @param {string} gridDirection gridDirection
	     * @param {MajorTickLinesModel | MinorTickLinesModel | MajorGridLinesModel | MinorGridLinesModel} gridModel gridModel
	     * @param {string} gridId gridId
	     * @param {number} gridIndex gridIndex
	     * @param {Element} parent parent
	     * @param {string} themeColor themeColor
	     * @param {string} dashArray dashArray
	     * @returns {void}
	     */
	    CartesianAxisLayoutPanel.prototype.renderGridLine = function (axis, index, gridDirection, gridModel, gridId, gridIndex, parent, themeColor, dashArray) {
	        if (dashArray === void 0) { dashArray = null; }
	        var chart = this.chart;
	        var direction;
	        var element;
	        if (gridModel.width > 0 && axis.visible && axis.internalVisibility && gridDirection) {
	            element = getElement(chart.element.id + gridId + index + '_' + gridIndex);
	            direction = element ? element.getAttribute('d') : null;
	            element = null;
	            this.htmlObject = chart.renderer.drawPath(new PathOption(chart.element.id + gridId + index + '_' + gridIndex, 'transparent', gridModel.width, gridModel.color || themeColor, null, dashArray, gridDirection));
	            appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction, true);
	        }
	    };
	    /**
	     * To Find the parent node of the axis
	     *
	     * @param {string} elementId elementId
	     * @param {Element} label label
	     * @param {number} index index
	     * @returns {Element} parent node of the axis
	     */
	    CartesianAxisLayoutPanel.prototype.findParentNode = function (elementId, label, index) {
	        if (document.getElementById(elementId + 'AxisGroup' + index + 'Inside').contains(document.getElementById(label.id))) {
	            return document.getElementById(elementId + 'AxisGroup' + index + 'Inside');
	        }
	        else {
	            return document.getElementById(elementId + 'AxisGroup' + index + 'Outside');
	        }
	    };
	    /**
	     * Create Zooming Labels Function Called here
	     *
	     * @param {Chart} chart chart
	     * @param {Element} labelElement labelElement
	     * @param {Axis} axis axis
	     * @param {number} index index
	     * @param {Rect} rect rect
	     * @returns {void}
	     */
	    CartesianAxisLayoutPanel.prototype.createZoomingLabel = function (chart, labelElement, axis, index, rect) {
	        var parentNode = this.findParentNode(chart.element.id, labelElement, index);
	        labelElement.setAttribute('opacity', '0.3');
	        var zoomElement = chart.renderer.createGroup({
	            id: chart.element.id + 'AxisLabels_Zoom' + index
	        });
	        zoomElement = createZoomingLabels(chart, axis, zoomElement, index, axis.orientation === 'Vertical', rect);
	        parentNode.replaceChild(labelElement, document.getElementById(labelElement.id));
	        if (getElement(chart.element.id + 'AxisLabels_Zoom' + index)) {
	            parentNode.replaceChild(zoomElement, document.getElementById(zoomElement.id));
	        }
	        else {
	            parentNode.appendChild(zoomElement);
	        }
	    };
	    return CartesianAxisLayoutPanel;
	}());

	/**
	 * To get the data on mouse move.
	 *
	 * @private
	 */
	var ChartData = /** @class */ (function () {
	    /**
	     * Constructor for the data.
	     *
	     * @private
	     */
	    function ChartData(chart) {
	        /** @private */
	        this.currentPoints = [];
	        /** @private */
	        this.previousPoints = [];
	        this.insideRegion = false;
	        this.commonXvalues = [];
	        this.chart = chart;
	        this.lierIndex = 0;
	    }
	    /**
	     * Method to get the Data.
	     *
	     * @private
	     */
	    ChartData.prototype.getData = function () {
	        var chart = this.chart;
	        var point = null;
	        var series = null;
	        var width;
	        var height;
	        var mouseX;
	        var mouseY;
	        for (var len = chart.visibleSeries.length, i = len - 1; i >= 0; i--) {
	            series = chart.visibleSeries[i];
	            width = (series.type === 'Scatter' || series.drawType === 'Scatter' || (series.marker.visible))
	                ? (series.marker.height + 5) / 2 : 0;
	            height = (series.type === 'Scatter' || series.drawType === 'Scatter' || (series.marker.visible))
	                ? (series.marker.width + 5) / 2 : 0;
	            mouseX = chart.mouseX;
	            mouseY = chart.mouseY;
	            if (series.dragSettings.enable && series.isRectSeries) {
	                if (!(series.type === 'Bar' && chart.isTransposed) && (chart.isTransposed || series.type === 'Bar')) {
	                    var markerWidth = series.marker.width / 2;
	                    mouseX = series.yAxis.isAxisInverse ? mouseX + markerWidth : mouseX - markerWidth;
	                }
	                else {
	                    var markerHeight = series.marker.height / 2;
	                    mouseY = series.yAxis.isAxisInverse ? mouseY - markerHeight : mouseY + markerHeight;
	                }
	            }
	            if (series.visible && withInBounds(mouseX, mouseY, series.clipRect, width, height)) {
	                point = this.getRectPoint(series, series.clipRect, mouseX, mouseY);
	            }
	            if (point) {
	                return new PointData(point, series);
	            }
	        }
	        return new PointData(point, series);
	    };
	    ChartData.prototype.isSelected = function (chart) {
	        return ((chart.selectionMode.indexOf('Drag') > -1 || chart.selectionMode.indexOf('Lasso') > -1) && chart.selectionModule &&
	            chart.selectionModule.rectPoints !== null);
	    };
	    ChartData.prototype.getRectPoint = function (series, rect, x, y) {
	        var chart = this.chart;
	        var fromCenterX;
	        var fromCenterY;
	        var clickAngle;
	        var arcAngle = 0;
	        var startAngle;
	        var endAngle;
	        var distanceFromCenter;
	        if (chart.isScrolling) {
	            return null;
	        }
	        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
	            var point = _a[_i];
	            if (!point.regionData) {
	                if (!point.regions || !point.regions.length) {
	                    continue;
	                }
	            }
	            if (point.regionData && this.chart.chartAreaType === 'PolarRadar' && series.drawType.indexOf('Column') > -1) {
	                fromCenterX = x - (series.clipRect.width / 2 + series.clipRect.x);
	                fromCenterY = y - (series.clipRect.height / 2 + series.clipRect.y);
	                arcAngle = 2 * Math.PI * (point.regionData.currentXPosition < 0 ? 1 + point.regionData.currentXPosition
	                    : point.regionData.currentXPosition);
	                clickAngle = (Math.atan2(fromCenterY, fromCenterX) + 0.5 * Math.PI - arcAngle) % (2 * Math.PI);
	                clickAngle = clickAngle < 0 ? 2 * Math.PI + clickAngle : clickAngle;
	                clickAngle = clickAngle + 2 * Math.PI * series.chart.primaryXAxis.startAngle;
	                startAngle = point.regionData.startAngle;
	                startAngle -= arcAngle;
	                startAngle = startAngle < 0 ? 2 * Math.PI + startAngle : startAngle;
	                endAngle = point.regionData.endAngle;
	                endAngle -= arcAngle;
	                endAngle = endAngle < 0 ? 2 * Math.PI + endAngle : endAngle;
	                distanceFromCenter = Math.sqrt(Math.pow(Math.abs(fromCenterX), 2) + Math.pow(Math.abs(fromCenterY), 2));
	                if (clickAngle >= startAngle && clickAngle <= endAngle &&
	                    (((distanceFromCenter >= point.regionData.innerRadius && distanceFromCenter <= point.regionData.radius) ||
	                        (distanceFromCenter <= point.regionData.innerRadius && distanceFromCenter >= point.regionData.radius))
	                        && distanceFromCenter <= series.chart.radius)) {
	                    return point;
	                }
	            }
	            if ((series.dragSettings.enable && series.isRectSeries) || (series.isRectSeries && series.marker.visible)) {
	                if (this.isPointInThresholdRegion(x, y, point, rect, series)) {
	                    this.insideRegion = true;
	                    return point;
	                }
	            }
	            if (!this.insideRegion && this.checkRegionContainsPoint(point.regions, rect, x, y)) {
	                return point;
	            }
	            else if (this.insideRegion && this.checkRegionContainsPoint(point.regions, rect, x, y)) {
	                return point;
	            }
	        }
	        return null;
	    };
	    /**
	     * Checks whether the region contains a point
	     */
	    ChartData.prototype.checkRegionContainsPoint = function (regionRect, rect, x, y) {
	        var _this = this;
	        return regionRect.some(function (region, index) {
	            _this.lierIndex = index;
	            return withInBounds(x, y, new Rect((_this.chart.chartAreaType === 'Cartesian' ? rect.x : 0) + region.x, (_this.chart.chartAreaType === 'Cartesian' ? rect.y : 0) + region.y, region.width, region.height));
	        });
	    };
	    /**
	     * To check the point in threshold region for column and bar series
	     *
	     * @param {number} x X coordinate
	     * @param {number} y Y coodinate
	     * @param {Points} point point
	     * @param {Rect} rect point rect region
	     * @param {Series} series series
	     */
	    ChartData.prototype.isPointInThresholdRegion = function (x, y, point, rect, series) {
	        var _this = this;
	        var isBar = series.type === 'Bar';
	        var isInversed = series.yAxis.isAxisInverse;
	        var isTransposed = series.chart.isTransposed;
	        var heightValue = 10;
	        var yValue = 0;
	        var xValue = 0;
	        var width;
	        var height = width = 2 * heightValue;
	        if (isInversed && isTransposed) {
	            if (isBar) {
	                yValue = point.regions[0].height - heightValue;
	                width = point.regions[0].width;
	            }
	            else {
	                xValue = -heightValue;
	                height = point.regions[0].height;
	            }
	        }
	        else if (isInversed || point.yValue < 0) {
	            if (isBar) {
	                xValue = -heightValue;
	                height = point.regions[0].height;
	            }
	            else {
	                yValue = point.regions[0].height - heightValue;
	                width = point.regions[0].width;
	            }
	        }
	        else if (isTransposed) {
	            if (isBar) {
	                yValue = -heightValue;
	                width = point.regions[0].width;
	            }
	            else {
	                xValue = point.regions[0].width - heightValue;
	                height = point.regions[0].height;
	            }
	        }
	        else {
	            if (isBar) {
	                xValue = point.regions[0].width - heightValue;
	                height = point.regions[0].height;
	            }
	            else {
	                yValue = -heightValue;
	                width = point.regions[0].width;
	            }
	        }
	        return point.regions.some(function (region) {
	            return withInBounds(x, y, new Rect((_this.chart.chartAreaType === 'Cartesian' ? rect.x : 0) + region.x + xValue, (_this.chart.chartAreaType === 'Cartesian' ? rect.y : 0) + region.y + yValue, width, height));
	        });
	    };
	    /**
	     * @private
	     */
	    ChartData.prototype.getClosest = function (series, value, xvalues) {
	        var closest;
	        var data;
	        var xData = xvalues ? xvalues : series.xData;
	        var xLength = xData.length;
	        var leftSideNearest = 0.5;
	        var rightSideNearest = 0.5;
	        if (series.xAxis.valueType === 'DateTime' && series.points.length === 1) {
	            leftSideNearest = series.xAxis.visibleRange.min;
	            rightSideNearest = series.xAxis.visibleRange.max;
	            for (var index = 0; index < series.chart.visibleSeries.length; index++) {
	                var visibleSeries = series.chart.visibleSeries[index];
	                if (visibleSeries.xMin >= leftSideNearest && visibleSeries.xMin < series.xMin) {
	                    leftSideNearest = visibleSeries.xMin + 0.1;
	                }
	                if (visibleSeries.xMax <= rightSideNearest && visibleSeries.xMax > series.xMax) {
	                    rightSideNearest = visibleSeries.xMax - 0.1;
	                }
	                if (visibleSeries.points.length > 1) {
	                    if (visibleSeries.xMax >= leftSideNearest && visibleSeries.xMax < series.xMin) {
	                        leftSideNearest = visibleSeries.xMax + 0.1;
	                    }
	                    if (visibleSeries.xMin <= rightSideNearest && visibleSeries.xMin > series.xMax) {
	                        rightSideNearest = visibleSeries.xMin - 0.1;
	                    }
	                }
	            }
	            if (leftSideNearest !== series.xAxis.visibleRange.min) {
	                leftSideNearest = Math.abs(series.xMin - leftSideNearest) / 2;
	            }
	            if (rightSideNearest !== series.xAxis.visibleRange.max) {
	                rightSideNearest = Math.abs(series.xMax - rightSideNearest) / 2;
	            }
	        }
	        if (value >= series.xMin - leftSideNearest && value <= series.xMax + rightSideNearest) {
	            for (var i = 0; i < xLength; i++) {
	                data = xData[i];
	                if (closest == null || Math.abs(data - value) < Math.abs(closest - value)) {
	                    closest = data;
	                }
	            }
	        }
	        var isDataExist = series.xData.indexOf(closest) !== -1;
	        if (isDataExist) {
	            return closest;
	        }
	        else {
	            return null;
	        }
	    };
	    ChartData.prototype.binarySearch = function (target, list) {
	        var first = 0;
	        var last = list.length;
	        var position = -1;
	        var found = false;
	        var middle;
	        while (found === false && first <= last) {
	            middle = Math.floor((first + last) / 2);
	            if (list[middle].xValue === target) {
	                found = true;
	                position = middle;
	            }
	            else if (list[middle].xValue > target) {
	                last = middle - 1;
	            }
	            else {
	                first = middle + 1;
	            }
	        }
	        return position !== -1 ? list[position] : null;
	    };
	    ChartData.prototype.getClosestX = function (chart, series, xvalues) {
	        var value;
	        var rect = series.clipRect;
	        if (chart.mouseX <= rect.x + rect.width && chart.mouseX >= rect.x) {
	            if (!chart.requireInvertedAxis) {
	                value = getValueXByPoint(chart.mouseX - rect.x, rect.width, series.xAxis);
	            }
	            else {
	                value = getValueYByPoint(chart.mouseY - rect.y, rect.height, series.xAxis);
	            }
	        }
	        var closest = this.getClosest(series, value, xvalues);
	        var point = ((closest || closest === 0) && series.points.length > 0) ? this.binarySearch(closest, sort(series.points, ['xValue'])) : null;
	        if (point && point.visible) {
	            if (!(this.chart.chartAreaType === 'Cartesian' && ((series.category == 'Indicator' && series.name == 'Histogram') ||
	                (point.symbolLocations && point.symbolLocations.length > 0 && point.symbolLocations[0].x >= 0 && point.symbolLocations[0].x <= rect.width)))) {
	                return null;
	            }
	            return new PointData(point, series);
	        }
	        return null;
	    };
	    /**
	     * Merge all visible series X values for shared tooltip (EJ2-47072)
	     *
	     * @param visibleSeries
	     * @private
	     */
	    ChartData.prototype.mergeXvalues = function (visibleSeries) {
	        if (visibleSeries.length && (!this.commonXvalues.length || (this.commonXvalues.length !== visibleSeries[0].xData.length))) {
	            this.commonXvalues = visibleSeries[0].xData;
	            for (var index = 1; index < visibleSeries.length; index++) {
	                this.commonXvalues = this.getDistinctValues(this.commonXvalues, visibleSeries[index].xData);
	            }
	        }
	        return this.commonXvalues;
	    };
	    ChartData.prototype.commonXValue = function (visibleSeries) {
	        var commonXValues = [];
	        for (var j = 0; j < visibleSeries.length; j++) {
	            for (var i = 0; (visibleSeries[j].points && i < visibleSeries[j].points.length); i++) {
	                var point = visibleSeries[j].points[i];
	                if (point && (point.index === 0 || point.index === visibleSeries[j].points.length - 1 ||
	                    (point.symbolLocations && point.symbolLocations.length > 0))) {
	                    commonXValues.push(point.xValue);
	                }
	            }
	        }
	        return commonXValues;
	    };
	    ChartData.prototype.getDistinctValues = function (first, second) {
	        if (first === void 0) { first = []; }
	        if (second === void 0) { second = []; }
	        var intial = {};
	        var result = [];
	        var index;
	        for (index = 0; index < first.length; index++) {
	            var temp = first[index];
	            if (!intial[temp]) {
	                intial[temp] = true;
	                result.push(temp);
	            }
	        }
	        for (index = 0; index < second.length; index++) {
	            var temp = second[index];
	            if (!intial[temp]) {
	                intial[temp] = true;
	                result.push(temp);
	            }
	        }
	        return result;
	    };
	    return ChartData;
	}());

	var __extends$w = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	/**
	 * Configures the data label in the series.
	 */
	var DataLabelSettings = /** @class */ (function (_super) {
	    __extends$w(DataLabelSettings, _super);
	    function DataLabelSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$3([
	        Property(false)
	    ], DataLabelSettings.prototype, "visible", void 0);
	    __decorate$3([
	        Property(true)
	    ], DataLabelSettings.prototype, "showZero", void 0);
	    __decorate$3([
	        Property(null)
	    ], DataLabelSettings.prototype, "name", void 0);
	    __decorate$3([
	        Property('transparent')
	    ], DataLabelSettings.prototype, "fill", void 0);
	    __decorate$3([
	        Property(null)
	    ], DataLabelSettings.prototype, "format", void 0);
	    __decorate$3([
	        Property(1)
	    ], DataLabelSettings.prototype, "opacity", void 0);
	    __decorate$3([
	        Property(0)
	    ], DataLabelSettings.prototype, "angle", void 0);
	    __decorate$3([
	        Property(false)
	    ], DataLabelSettings.prototype, "enableRotation", void 0);
	    __decorate$3([
	        Property('Auto')
	    ], DataLabelSettings.prototype, "position", void 0);
	    __decorate$3([
	        Property(5)
	    ], DataLabelSettings.prototype, "rx", void 0);
	    __decorate$3([
	        Property(5)
	    ], DataLabelSettings.prototype, "ry", void 0);
	    __decorate$3([
	        Property('Center')
	    ], DataLabelSettings.prototype, "alignment", void 0);
	    __decorate$3([
	        Complex({ width: null, color: null }, Border)
	    ], DataLabelSettings.prototype, "border", void 0);
	    __decorate$3([
	        Complex({ left: 5, right: 5, top: 5, bottom: 5 }, Margin)
	    ], DataLabelSettings.prototype, "margin", void 0);
	    __decorate$3([
	        Complex({ size: '12px', color: null, fontStyle: 'Normal', fontWeight: '400', fontFamily: null }, Font)
	    ], DataLabelSettings.prototype, "font", void 0);
	    __decorate$3([
	        Property(null)
	    ], DataLabelSettings.prototype, "template", void 0);
	    __decorate$3([
	        Property('Hide')
	    ], DataLabelSettings.prototype, "labelIntersectAction", void 0);
	    return DataLabelSettings;
	}(ChildProperty));
	/**
	 *  Configures the marker in the series.
	 */
	var MarkerSettings = /** @class */ (function (_super) {
	    __extends$w(MarkerSettings, _super);
	    function MarkerSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$3([
	        Property(false)
	    ], MarkerSettings.prototype, "visible", void 0);
	    __decorate$3([
	        Property(null)
	    ], MarkerSettings.prototype, "shape", void 0);
	    __decorate$3([
	        Property('')
	    ], MarkerSettings.prototype, "imageUrl", void 0);
	    __decorate$3([
	        Property(5)
	    ], MarkerSettings.prototype, "height", void 0);
	    __decorate$3([
	        Property(false)
	    ], MarkerSettings.prototype, "isFilled", void 0);
	    __decorate$3([
	        Property(5)
	    ], MarkerSettings.prototype, "width", void 0);
	    __decorate$3([
	        Complex({ width: 2, color: null }, Border)
	    ], MarkerSettings.prototype, "border", void 0);
	    __decorate$3([
	        Complex({ x: 0, y: 0 }, Offset)
	    ], MarkerSettings.prototype, "offset", void 0);
	    __decorate$3([
	        Property(null)
	    ], MarkerSettings.prototype, "fill", void 0);
	    __decorate$3([
	        Property(true)
	    ], MarkerSettings.prototype, "allowHighlight", void 0);
	    __decorate$3([
	        Property(1)
	    ], MarkerSettings.prototype, "opacity", void 0);
	    __decorate$3([
	        Complex({}, DataLabelSettings)
	    ], MarkerSettings.prototype, "dataLabel", void 0);
	    return MarkerSettings;
	}(ChildProperty));
	/**
	 *  Configures the pareto in the series.
	 */
	var ParetoOptions = /** @class */ (function (_super) {
	    __extends$w(ParetoOptions, _super);
	    function ParetoOptions() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$3([
	        Property(null)
	    ], ParetoOptions.prototype, "fill", void 0);
	    __decorate$3([
	        Property(1)
	    ], ParetoOptions.prototype, "width", void 0);
	    __decorate$3([
	        Property('0')
	    ], ParetoOptions.prototype, "dashArray", void 0);
	    __decorate$3([
	        Complex(null, MarkerSettings)
	    ], ParetoOptions.prototype, "marker", void 0);
	    __decorate$3([
	        Property(true)
	    ], ParetoOptions.prototype, "showAxis", void 0);
	    return ParetoOptions;
	}(ChildProperty));
	/**
	 * Points model for the series.
	 *
	 * @public
	 */
	var Points = /** @class */ (function () {
	    function Points() {
	        /** point symbol location. */
	        this.symbolLocations = null;
	        /** point region. */
	        this.regions = null;
	        /** point percentage value. */
	        this.percentage = null;
	        /** point region data. */
	        this.regionData = null;
	        /** To know the point is selected. */
	        this.isSelect = false;
	        /** point marker. */
	        this.marker = {
	            visible: false
	        };
	        /**
	         * To identify point y value with in the range.
	         *
	         * @private
	         */
	        this.isPointInRange = true;
	        /** vertical error value for the point. */
	        this.verticalError = null;
	        /** vertical negative error value for the point. */
	        this.verticalNegativeError = null;
	        /** horizontal error value for the point. */
	        this.horizontalError = null;
	        /** horizontal negative error value for the point. */
	        this.horizontalNegativeError = null;
	        /** vertical positive error value for the point. */
	        this.verticalPositiveError = null;
	        /** horizontal positive error value for the point. */
	        this.horizontalPositiveError = null;
	    }
	    return Points;
	}());
	/**
	 * Defines the behavior of the Trendlines
	 */
	var Trendline = /** @class */ (function (_super) {
	    __extends$w(Trendline, _super);
	    function Trendline() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /** @private */
	        _this.clipRect = new Rect(0, 0, 0, 0);
	        return _this;
	    }
	    /** @private */
	    Trendline.prototype.setDataSource = function (series, chart) {
	        if (series) {
	            this.points = series.points;
	        }
	        chart.trendLineModule.initDataSource(this);
	        chart.visibleSeriesCount++;
	    };
	    __decorate$3([
	        Property('')
	    ], Trendline.prototype, "name", void 0);
	    __decorate$3([
	        Property('')
	    ], Trendline.prototype, "dashArray", void 0);
	    __decorate$3([
	        Property(true)
	    ], Trendline.prototype, "visible", void 0);
	    __decorate$3([
	        Property('Linear')
	    ], Trendline.prototype, "type", void 0);
	    __decorate$3([
	        Property(2)
	    ], Trendline.prototype, "period", void 0);
	    __decorate$3([
	        Property(2)
	    ], Trendline.prototype, "polynomialOrder", void 0);
	    __decorate$3([
	        Property(0)
	    ], Trendline.prototype, "backwardForecast", void 0);
	    __decorate$3([
	        Property(0)
	    ], Trendline.prototype, "forwardForecast", void 0);
	    __decorate$3([
	        Complex({}, Animation)
	    ], Trendline.prototype, "animation", void 0);
	    __decorate$3([
	        Complex({}, MarkerSettings)
	    ], Trendline.prototype, "marker", void 0);
	    __decorate$3([
	        Property(true)
	    ], Trendline.prototype, "enableTooltip", void 0);
	    __decorate$3([
	        Property(null)
	    ], Trendline.prototype, "intercept", void 0);
	    __decorate$3([
	        Property('')
	    ], Trendline.prototype, "fill", void 0);
	    __decorate$3([
	        Property(1)
	    ], Trendline.prototype, "width", void 0);
	    __decorate$3([
	        Property('SeriesType')
	    ], Trendline.prototype, "legendShape", void 0);
	    return Trendline;
	}(ChildProperty));
	/**
	 * Configures Error bar in series.
	 */
	var ErrorBarCapSettings = /** @class */ (function (_super) {
	    __extends$w(ErrorBarCapSettings, _super);
	    function ErrorBarCapSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$3([
	        Property(1)
	    ], ErrorBarCapSettings.prototype, "width", void 0);
	    __decorate$3([
	        Property(10)
	    ], ErrorBarCapSettings.prototype, "length", void 0);
	    __decorate$3([
	        Property(null)
	    ], ErrorBarCapSettings.prototype, "color", void 0);
	    __decorate$3([
	        Property(1)
	    ], ErrorBarCapSettings.prototype, "opacity", void 0);
	    return ErrorBarCapSettings;
	}(ChildProperty));
	var ChartSegment = /** @class */ (function (_super) {
	    __extends$w(ChartSegment, _super);
	    function ChartSegment() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$3([
	        Property(null)
	    ], ChartSegment.prototype, "value", void 0);
	    __decorate$3([
	        Property(null)
	    ], ChartSegment.prototype, "color", void 0);
	    __decorate$3([
	        Property('0')
	    ], ChartSegment.prototype, "dashArray", void 0);
	    return ChartSegment;
	}(ChildProperty));
	/**
	 * Error bar settings
	 *
	 * @public
	 */
	var ErrorBarSettings = /** @class */ (function (_super) {
	    __extends$w(ErrorBarSettings, _super);
	    function ErrorBarSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$3([
	        Property(false)
	    ], ErrorBarSettings.prototype, "visible", void 0);
	    __decorate$3([
	        Property('Fixed')
	    ], ErrorBarSettings.prototype, "type", void 0);
	    __decorate$3([
	        Property('Both')
	    ], ErrorBarSettings.prototype, "direction", void 0);
	    __decorate$3([
	        Property('Vertical')
	    ], ErrorBarSettings.prototype, "mode", void 0);
	    __decorate$3([
	        Property(null)
	    ], ErrorBarSettings.prototype, "color", void 0);
	    __decorate$3([
	        Property(1)
	    ], ErrorBarSettings.prototype, "verticalError", void 0);
	    __decorate$3([
	        Property(1)
	    ], ErrorBarSettings.prototype, "width", void 0);
	    __decorate$3([
	        Property(1)
	    ], ErrorBarSettings.prototype, "horizontalError", void 0);
	    __decorate$3([
	        Property(3)
	    ], ErrorBarSettings.prototype, "verticalPositiveError", void 0);
	    __decorate$3([
	        Property(3)
	    ], ErrorBarSettings.prototype, "verticalNegativeError", void 0);
	    __decorate$3([
	        Property(1)
	    ], ErrorBarSettings.prototype, "horizontalPositiveError", void 0);
	    __decorate$3([
	        Property(1)
	    ], ErrorBarSettings.prototype, "horizontalNegativeError", void 0);
	    __decorate$3([
	        Complex(null, ErrorBarCapSettings)
	    ], ErrorBarSettings.prototype, "errorBarCap", void 0);
	    __decorate$3([
	        Property('')
	    ], ErrorBarSettings.prototype, "errorBarColorMapping", void 0);
	    return ErrorBarSettings;
	}(ChildProperty));
	/**
	 * Defines the common behavior of Series and Technical Indicators
	 */
	var SeriesBase = /** @class */ (function (_super) {
	    __extends$w(SeriesBase, _super);
	    function SeriesBase() {
	        /**
	         * The DataSource field that contains the x value.
	         * It is applicable for series and technical indicators
	         *
	         * @default ''
	         */
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.rangeColorPoints = [];
	        _this.isAdvancedColor = undefined;
	        /** @private */
	        _this.currentViewData = [];
	        /** @private */
	        _this.clipRect = new Rect(0, 0, 0, 0);
	        /** @private */
	        _this.seriesType = 'XY';
	        _this.isRectTypeSeries = false;
	        return _this;
	    }
	    /**
	     * Process data for the series.
	     *
	     * @hidden
	     */
	    SeriesBase.prototype.processJsonData = function () {
	        var i = 0;
	        var point = new Points();
	        var xName = (this instanceof Series && this.type === 'Histogram') ? 'x' : this.xName;
	        var textMappingName = this instanceof Series && this.marker.dataLabel.name ?
	            this.marker.dataLabel.name : '';
	        if (this instanceof Series) {
	            if ((this.type === 'Waterfall' || this.type === 'Histogram')) {
	                this.currentViewData = this.chart[firstToLowerCase(this.type) + 'SeriesModule'].
	                    processInternalData(extend([], this.currentViewData, null, true), this);
	            }
	            if (this.category === 'Pareto') {
	                this.currentViewData = sort(extend([], this.currentViewData, null, true), [this.yName], true);
	                if (this.type === 'Line') {
	                    this.currentViewData = this.chart.paretoSeriesModule.performCumulativeCalculation(this.currentViewData, this);
	                }
	            }
	            this.isRectTypeSeries = this.type.indexOf('Column') > -1 || this.type.indexOf('Bar') > -1
	                || this.type.indexOf('Histogram') > -1;
	        }
	        var len = (this.currentViewData || []).length;
	        this.points = [];
	        this.xMin = Infinity;
	        this.xMax = -Infinity;
	        this.yMin = Infinity;
	        this.yMax = -Infinity;
	        this.sizeMax = -Infinity;
	        this.getSeriesType();
	        if (this.xAxis.valueType === 'Category') {
	            while (i < len) {
	                point = this.dataPoint(i, textMappingName, xName);
	                this.pushCategoryData(point, i, point.x);
	                this.pushData(point, i);
	                this.setEmptyPoint(point, i);
	                this.rangeColorsInterior(point);
	                i++;
	            }
	        }
	        else if (this.xAxis.valueType.indexOf('DateTime') > -1) {
	            var option = {
	                skeleton: 'full',
	                type: 'dateTime'
	            };
	            var dateParser = this.chart.intl.getDateParser(option);
	            var dateFormatter = this.chart.intl.getDateFormat(option);
	            while (i < len) {
	                point = this.dataPoint(i, textMappingName, xName);
	                if (!isNullOrUndefined(point.x) && point.x !== '') {
	                    point.x = new Date(DataUtil.parse.parseJson({ val: point.x }).val);
	                    if (this.xAxis.valueType === 'DateTime') {
	                        point.xValue = Date.parse(point.x.toString());
	                    }
	                    else {
	                        // eslint-disable-next-line @typescript-eslint/no-unused-expressions
	                        this.chart.isBlazor ? this.pushCategoryData(point, i, Date.parse(point.x.toString()).toString()) :
	                            this.pushCategoryData(point, i, Date.parse(dateParser(dateFormatter(point.x))).toString());
	                    }
	                    this.pushData(point, i);
	                    this.setEmptyPoint(point, i);
	                    //this.rangeColorsInterior(point);
	                }
	                else {
	                    point.visible = false;
	                }
	                i++;
	            }
	        }
	        else {
	            while (i < len) {
	                point = this.dataPoint(i, textMappingName, xName);
	                point.xValue = point.x;
	                this.pushData(point, i);
	                this.setEmptyPoint(point, i);
	                i++;
	            }
	        }
	        if (this instanceof Series && !(this.chart.stockChart && this.xAxis.valueType === 'DateTimeCategory')) {
	            if (this.type.indexOf('Spline') > -1 || (this.drawType.indexOf('Spline') > -1 && this.chart.chartAreaType === 'PolarRadar')) {
	                var isArea = (this.type.indexOf('Area') > -1 || this.drawType.indexOf('Area') > -1);
	                var isRange = this.type.indexOf('Range') > -1;
	                this.chart['spline' + (isArea ? isRange ? 'RangeArea' : 'Area' : '') + 'SeriesModule'].findSplinePoint(this);
	            }
	            else if (this.type.indexOf('Histogram') > -1 && (this.xAxis.maximum || this.xAxis.minimum)) {
	                this.chart['histogramSeriesModule'].calculateBinValues(this);
	            }
	            if (this.type.indexOf('Histogram') > -1 && this.points.length === 1) {
	                this.xMin = this.xMin - this.histogramValues.binWidth;
	                this.xMax = this.xMax + this.histogramValues.binWidth;
	            }
	        }
	    };
	    SeriesBase.prototype.rangeColorsInterior = function (point) {
	        if (this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0 && this.chart.visibleSeries.length === 1 &&
	            (this.chart.series[0].type === 'Column' || this.chart.series[0].type === 'Bar' ||
	                this.chart.series[0].type === 'Scatter' || this.chart.series[0].type === 'Bubble')) {
	            if (!this.rangeColorPoints[point.interior]) {
	                this.rangeColorPoints[point.interior] = [];
	            }
	            else if (this.rangeColorPoints[point.interior] !== undefined) {
	                this.rangeColorPoints[point.interior].push(point);
	            }
	        }
	    };
	    SeriesBase.prototype.pushData = function (point, i) {
	        point.index = i;
	        point.yValue = point.y;
	        point.series = this;
	        // To find the min, max for the axis range.
	        this.xMin = Math.min(this.xMin, point.xValue);
	        this.xMax = Math.max(this.xMax, point.xValue);
	        this.xData.push(point.xValue);
	    };
	    /** @private */
	    SeriesBase.prototype.dataPoint = function (i, textMappingName, xName) {
	        this.points[i] = new Points();
	        var point = this.points[i];
	        var currentViewData = this.currentViewData[i];
	        var getObjectValueByMappingString = this.enableComplexProperty ? getValue : this.getObjectValue;
	        point.x = getObjectValueByMappingString(xName, currentViewData);
	        point.high = getObjectValueByMappingString(this.high, currentViewData);
	        point.low = getObjectValueByMappingString(this.low, currentViewData);
	        point.open = getObjectValueByMappingString(this.open, currentViewData);
	        point.close = getObjectValueByMappingString(this.close, currentViewData);
	        point.volume = getObjectValueByMappingString(this.volume, currentViewData);
	        point.interior = getObjectValueByMappingString(this.pointColorMapping, currentViewData);
	        if (this instanceof Series) {
	            if (this.errorBar.visible) {
	                point.errorBarColor = getObjectValueByMappingString(this.errorBar.errorBarColorMapping, currentViewData);
	                point.verticalError = typeof this.errorBar.verticalError == 'string' ? getObjectValueByMappingString(this.errorBar.verticalError, currentViewData) : this.errorBar.verticalError;
	                point.horizontalError = typeof this.errorBar.horizontalError == 'string' ? getObjectValueByMappingString(this.errorBar.horizontalError, currentViewData) : this.errorBar.horizontalError;
	                point.verticalNegativeError = typeof this.errorBar.verticalNegativeError == 'string' ? getObjectValueByMappingString(this.errorBar.verticalNegativeError, currentViewData) : this.errorBar.verticalNegativeError;
	                point.verticalPositiveError = typeof this.errorBar.verticalPositiveError == 'string' ? getObjectValueByMappingString(this.errorBar.verticalPositiveError, currentViewData) : this.errorBar.verticalPositiveError;
	                point.horizontalNegativeError = typeof this.errorBar.horizontalNegativeError == 'string' ? getObjectValueByMappingString(this.errorBar.horizontalNegativeError, currentViewData) : this.errorBar.horizontalNegativeError;
	                point.horizontalPositiveError = typeof this.errorBar.horizontalPositiveError == 'string' ? getObjectValueByMappingString(this.errorBar.horizontalPositiveError, currentViewData) : this.errorBar.horizontalPositiveError;
	            }
	            point.y = getObjectValueByMappingString(this.yName, currentViewData);
	            point.size = getObjectValueByMappingString(this.size, currentViewData);
	            point.text = getObjectValueByMappingString(textMappingName, currentViewData);
	            point.tooltip = getObjectValueByMappingString(this.tooltipMappingName, currentViewData);
	            if (this.isAdvancedColorSupported()) {
	                this.rangeColorName = this.colorName.length > 0 ? this.colorName : this.yName;
	                point.colorValue = getObjectValueByMappingString(this.rangeColorName, currentViewData);
	                point.interior = this.getPointFillColor(point.interior, point.colorValue);
	            }
	        }
	        return point;
	    };
	    SeriesBase.prototype.isAdvancedColorSupported = function () {
	        if (isNullOrUndefined(this.isAdvancedColor)) {
	            if (this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0 &&
	                (this.chart.series[0].type === 'Column' || this.chart.series[0].type === 'Bar' ||
	                    this.chart.series[0].type === 'Scatter' || this.chart.series[0].type === 'Bubble')) {
	                this.isAdvancedColor = true;
	            }
	            else {
	                this.isAdvancedColor = false;
	            }
	        }
	        return this.isAdvancedColor;
	    };
	    SeriesBase.prototype.getPointFillColor = function (pointFill, value) {
	        var color = pointFill;
	        if (value && this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0) {
	            for (var _i = 0, _a = this.chart.rangeColorSettings; _i < _a.length; _i++) {
	                var rangeMap = _a[_i];
	                if (value >= rangeMap.start && value <= rangeMap.end) {
	                    if (rangeMap.colors.length > 1) {
	                        color = getColorByValue(rangeMap, value);
	                    }
	                    else {
	                        color = rangeMap.colors[0];
	                    }
	                }
	            }
	        }
	        return color;
	    };
	    SeriesBase.prototype.getObjectValue = function (mappingName, data) {
	        return data[mappingName];
	    };
	    /**
	     * To set empty point value based on empty point mode
	     *
	     * @private
	     */
	    SeriesBase.prototype.setEmptyPoint = function (point, i) {
	        if (!this.findVisibility(point)) {
	            point.visible = true;
	            return null;
	        }
	        point.isEmpty = true;
	        var mode = this instanceof Series && point.isPointInRange ? this.emptyPointSettings.mode : 'Drop';
	        switch (mode) {
	            case 'Zero':
	                point.visible = true;
	                if (this instanceof Series && this.seriesType.indexOf('HighLow') > -1) {
	                    point.high = point.low = 0;
	                    if (this.seriesType.indexOf('HighLowOpenClose') > -1) {
	                        point.open = point.close = 0;
	                    }
	                }
	                else {
	                    point.y = point.yValue = this.yData[i] = 0;
	                }
	                break;
	            case 'Average':
	                if (this instanceof Series) {
	                    if (this.seriesType.indexOf('HighLow') > -1) {
	                        point.high = (isNullOrUndefined(point.high) || isNaN(+point.high)) ? this.getAverage(this.high, i) : point.high;
	                        point.low = (isNullOrUndefined(point.low) || isNaN(+point.low)) ? this.getAverage(this.low, i) : point.low;
	                        if (this.seriesType.indexOf('HighLowOpenClose') > -1) {
	                            point.open = (isNullOrUndefined(point.open) || isNaN(+point.open)) ? this.getAverage(this.open, i) : point.open;
	                            point.close = (isNullOrUndefined(point.close) || isNaN(+point.close)) ? this.getAverage(this.close, i) :
	                                point.close;
	                        }
	                    }
	                    else {
	                        point.y = point.yValue = this.yData[i] = this.getAverage(this.yName, i);
	                    }
	                }
	                point.visible = true;
	                break;
	            case 'Drop':
	            case 'Gap':
	                this.yData[i] = null;
	                point.visible = false;
	                break;
	        }
	    };
	    SeriesBase.prototype.findVisibility = function (point) {
	        var type = this instanceof Series ? this.seriesType : 'HighLowOpenClose';
	        var yValues;
	        var yAxisMin = this.yAxis.minimum;
	        var yAxisMax = this.yAxis.maximum;
	        switch (type) {
	            case 'XY':
	                if (this.chart.chartAreaType === 'PolarRadar' && ((!isNullOrUndefined(yAxisMin) && point.yValue < yAxisMin) ||
	                    (!isNullOrUndefined(yAxisMax) && point.yValue > yAxisMax))) {
	                    point.isPointInRange = false;
	                    return true;
	                }
	                this.setXYMinMax(point.yValue);
	                this.yData.push(point.yValue);
	                if (this instanceof Series && this.type === 'Bubble') {
	                    this.sizeMax = Math.max(this.sizeMax, (isNullOrUndefined(point.size) || isNaN(+point.size)) ? this.sizeMax
	                        : point.size);
	                }
	                return isNullOrUndefined(point.x) || (isNullOrUndefined(point.y) || isNaN(+point.y));
	            case 'HighLow':
	                this.setHiloMinMax(point.high, point.low);
	                return isNullOrUndefined(point.x) || (isNullOrUndefined(point.low) || isNaN(+point.low)) ||
	                    (isNullOrUndefined(point.high) || isNaN(+point.high));
	            case 'HighLowOpenClose':
	                this.setHiloMinMax(point.high, point.low);
	                return isNullOrUndefined(point.x) || (isNullOrUndefined(point.low) || isNaN(+point.low)) ||
	                    (isNullOrUndefined(point.open) || isNaN(+point.open)) || (isNullOrUndefined(point.close) || isNaN(+point.close))
	                    || (isNullOrUndefined(point.high) || isNaN(+point.high));
	            case 'BoxPlot':
	                yValues = (point.y || [null]).filter(function (value) {
	                    return !isNullOrUndefined(value) && !isNaN(value);
	                }).sort(function (a, b) {
	                    return a - b;
	                });
	                point.y = yValues;
	                this.yMin = Math.min(this.yMin, Math.min.apply(Math, yValues));
	                this.yMax = Math.max(this.yMax, Math.max.apply(Math, yValues));
	                return !yValues.length;
	        }
	    };
	    /**
	     * To get Y min max for the provided point seriesType XY
	     */
	    SeriesBase.prototype.setXYMinMax = function (yValue) {
	        var isLogAxis = (this.yAxis.valueType === 'Logarithmic' || this.xAxis.valueType === 'Logarithmic');
	        var isNegativeValue = yValue < 0 || this.yAxis.rangePadding === 'None';
	        var seriesMinY;
	        if (this.isRectTypeSeries && !setRange(this.yAxis)) {
	            seriesMinY = ((isLogAxis ? (yValue) : isNegativeValue ? yValue : 0));
	        }
	        else {
	            seriesMinY = yValue;
	        }
	        this.yMin = isLogAxis ?
	            Math.min(this.yMin, (isNullOrUndefined(seriesMinY) || isNaN(seriesMinY) || (seriesMinY === 0) ||
	                (seriesMinY.toString() === '0') || (seriesMinY.toString() === '')) ? this.yMin : seriesMinY) :
	            Math.min(this.yMin, (isNullOrUndefined(seriesMinY) || isNaN(seriesMinY)) ? this.yMin : seriesMinY);
	        this.yMax = Math.max(this.yMax, (isNullOrUndefined(yValue) || isNaN(yValue)) ? this.yMax : yValue);
	    };
	    /**
	     * To get Y min max for the provided point seriesType XY
	     */
	    SeriesBase.prototype.setHiloMinMax = function (high, low) {
	        this.yMin = Math.min(this.yMin, Math.min((isNullOrUndefined(low) || isNaN(low)) ? this.yMin : low, (isNullOrUndefined(high) || isNaN(high)) ? this.yMin : high));
	        this.yMax = Math.max(this.yMax, Math.max((isNullOrUndefined(low) || isNaN(low)) ? this.yMax : low, (isNullOrUndefined(high) || isNaN(high)) ? this.yMax : high));
	    };
	    /**
	     * Finds the type of the series
	     *
	     * @private
	     */
	    SeriesBase.prototype.getSeriesType = function () {
	        var type;
	        if (this instanceof Series) {
	            var seriesType = this.chart.chartAreaType === 'PolarRadar' ? this.drawType : this.type;
	            if (seriesType) {
	                switch (seriesType) {
	                    case 'RangeColumn':
	                    case 'RangeArea':
	                    case 'RangeStepArea':
	                    case 'SplineRangeArea':
	                    case 'Hilo':
	                        type = 'HighLow';
	                        break;
	                    case 'HiloOpenClose':
	                    case 'Candle':
	                        type = 'HighLowOpenClose';
	                        break;
	                    case 'BoxAndWhisker':
	                        type = 'BoxPlot';
	                        break;
	                    default:
	                        type = 'XY';
	                }
	            }
	        }
	        this.seriesType = type;
	    };
	    /** @private */
	    SeriesBase.prototype.pushCategoryData = function (point, index, pointX) {
	        if (!this.chart.tooltip.shared) {
	            if (!this.visible) {
	                return null;
	            }
	        }
	        if (!this.xAxis.isIndexed) {
	            if (this.xAxis.indexLabels[pointX] === undefined) {
	                this.xAxis.indexLabels[pointX] = this.xAxis.labels.length;
	                this.xAxis.labels.push(pointX);
	            }
	            point.xValue = this.xAxis.indexLabels[pointX];
	        }
	        else {
	            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
	            this.xAxis.labels[index] ? this.xAxis.labels[index] += ', ' + pointX :
	                this.xAxis.labels.push(pointX);
	            point.xValue = index;
	        }
	    };
	    /**
	     * To find average of given property
	     */
	    SeriesBase.prototype.getAverage = function (member, i, data) {
	        if (data === void 0) { data = this.currentViewData; }
	        var previous = data[i - 1] ? (data[i - 1][member] || 0) : 0;
	        var next = data[i + 1] ? (data[i + 1][member] || 0) : 0;
	        return (previous + next) / 2;
	    };
	    /**
	     * To find the control points for spline.
	     *
	     * @returns {void}
	     * @private
	     */
	    SeriesBase.prototype.refreshDataManager = function (chart) {
	        var _this = this;
	        this.chart = chart;
	        var dataSource;
	        var isAngular = 'isAngular';
	        if (chart[isAngular]) {
	            dataSource = Object.keys(this.dataSource).length ? this.dataSource : chart.dataSource;
	        }
	        else {
	            dataSource = this.dataSource || chart.dataSource;
	        }
	        if (!(dataSource instanceof DataManager) && isNullOrUndefined(this.query)) {
	            this.dataManagerSuccess({ result: dataSource, count: dataSource.length }, false);
	            return;
	        }
	        var dataManager = this.dataModule.getData(this.dataModule.generateQuery().requiresCount());
	        dataManager.then(function (e) { return _this.dataManagerSuccess(e); });
	    };
	    SeriesBase.prototype.dataManagerSuccess = function (e, isRemoteData) {
	        if (isRemoteData === void 0) { isRemoteData = true; }
	        this.currentViewData = e.count ? e.result : [];
	        this.chart.allowServerDataBinding = false;
	        if (this instanceof Series) {
	            if (this.chart.stockChart) {
	                this.chart.stockChart.series[this.index].localData = this.currentViewData;
	            }
	            var argsData = {
	                name: seriesRender, series: this, data: this.currentViewData, fill: this.interior
	            };
	            this.chart.trigger(seriesRender, argsData);
	            this.interior = argsData.fill;
	            this.currentViewData = argsData.data;
	        }
	        if (this.chart.stockChart && !(this instanceof Series)) {
	            this.currentViewData = this.chart.stockChart.findCurrentData(this.chart.stockChart.series[0].localData, this.chart.stockChart.series[0].xName);
	        }
	        this.processJsonData();
	        this.recordsCount = e.count;
	        this.refreshChart(isRemoteData);
	        this.currentViewData = null;
	    };
	    SeriesBase.prototype.refreshChart = function (isRemoteData) {
	        var chart = this.chart;
	        if (this instanceof Series) {
	            chart.visibleSeriesCount += isRemoteData ? 1 : 0;
	        }
	        chart.refreshTechnicalIndicator(this);
	        if (this instanceof Series && this.category !== 'TrendLine') {
	            for (var _i = 0, _a = this.trendlines; _i < _a.length; _i++) {
	                var trendline = _a[_i];
	                trendline.setDataSource(this, chart);
	            }
	        }
	        //if (chart.visibleSeries.length === (chart.visibleSeriesCount - chart.indicators.length)) {
	        if (chart.visibleSeries.length === (chart.visibleSeriesCount)) {
	            chart.refreshBound();
	            chart.trigger('loaded', { chart: chart.isBlazor ? {} : chart });
	            if (this.chart.stockChart && this.chart.stockChart.initialRender) {
	                this.chart.stockChart.initialRender = false;
	                this.chart.stockChart.stockChartDataManagerSuccess();
	            }
	        }
	        if (this instanceof Series) {
	            chart.visibleSeriesCount += isRemoteData ? 0 : 1;
	        }
	    };
	    __decorate$3([
	        Property('')
	    ], SeriesBase.prototype, "xName", void 0);
	    __decorate$3([
	        Property('')
	    ], SeriesBase.prototype, "colorName", void 0);
	    __decorate$3([
	        Property('')
	    ], SeriesBase.prototype, "high", void 0);
	    __decorate$3([
	        Property('')
	    ], SeriesBase.prototype, "low", void 0);
	    __decorate$3([
	        Property('')
	    ], SeriesBase.prototype, "open", void 0);
	    __decorate$3([
	        Property('')
	    ], SeriesBase.prototype, "close", void 0);
	    __decorate$3([
	        Property('')
	    ], SeriesBase.prototype, "volume", void 0);
	    __decorate$3([
	        Property('')
	    ], SeriesBase.prototype, "pointColorMapping", void 0);
	    __decorate$3([
	        Property(true)
	    ], SeriesBase.prototype, "visible", void 0);
	    __decorate$3([
	        Property(null)
	    ], SeriesBase.prototype, "xAxisName", void 0);
	    __decorate$3([
	        Property(null)
	    ], SeriesBase.prototype, "yAxisName", void 0);
	    __decorate$3([
	        Complex(null, Animation)
	    ], SeriesBase.prototype, "animation", void 0);
	    __decorate$3([
	        Property(null)
	    ], SeriesBase.prototype, "fill", void 0);
	    __decorate$3([
	        Property(1)
	    ], SeriesBase.prototype, "width", void 0);
	    __decorate$3([
	        Property('')
	    ], SeriesBase.prototype, "dashArray", void 0);
	    __decorate$3([
	        Property('')
	    ], SeriesBase.prototype, "dataSource", void 0);
	    __decorate$3([
	        Property()
	    ], SeriesBase.prototype, "query", void 0);
	    __decorate$3([
	        Collection([], ChartSegment)
	    ], SeriesBase.prototype, "segments", void 0);
	    __decorate$3([
	        Property('X')
	    ], SeriesBase.prototype, "segmentAxis", void 0);
	    __decorate$3([
	        Property(false)
	    ], SeriesBase.prototype, "enableComplexProperty", void 0);
	    return SeriesBase;
	}(ChildProperty));
	/**
	 * Configures the series in charts.
	 *
	 * @public
	 */
	var Series = /** @class */ (function (_super) {
	    __extends$w(Series, _super);
	    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
	    function Series(parent, propName, defaultValue, isArray) {
	        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
	        _this.visibleSeriesCount = 0;
	        /** @private */
	        _this.category = 'Series';
	        /** @private */
	        _this.isRectSeries = false;
	        /** @private */
	        _this.drawPoints = [];
	        /** @private */
	        _this.lowDrawPoints = [];
	        /** @private */
	        _this.delayedAnimation = false;
	        /** @private */
	        _this.rangeColorName = _this.colorName.length > 0 ? _this.colorName : _this.yName;
	        return _this;
	    }
	    /**
	     * Refresh the axis label.
	     *
	     * @returns {void}
	     * @private
	     */
	    Series.prototype.refreshAxisLabel = function () {
	        if (this.xAxis.valueType !== 'Category') {
	            return null;
	        }
	        this.xAxis.labels = [];
	        this.xAxis.indexLabels = {};
	        for (var _i = 0, _a = this.xAxis.series; _i < _a.length; _i++) {
	            var item = _a[_i];
	            if (item.visible && item.category !== 'TrendLine') {
	                item.xMin = Infinity;
	                item.xMax = -Infinity;
	                for (var _b = 0, _c = item.points; _b < _c.length; _b++) {
	                    var point = _c[_b];
	                    item.pushCategoryData(point, point.index, point.x);
	                    item.xMin = Math.min(item.xMin, point.xValue);
	                    item.xMax = Math.max(item.xMax, point.xValue);
	                }
	            }
	        }
	    };
	    /**
	     * To get the series collection.
	     *
	     * @returns {void}
	     * @private
	     */
	    Series.prototype.findSeriesCollection = function (column, row, isStack) {
	        var seriesCollection = [];
	        for (var _i = 0, _a = row.axes; _i < _a.length; _i++) {
	            var rowAxis = _a[_i];
	            for (var _b = 0, _c = rowAxis.series; _b < _c.length; _b++) {
	                var rowSeries = _c[_b];
	                for (var _d = 0, _e = column.axes; _d < _e.length; _d++) {
	                    var axis = _e[_d];
	                    for (var _f = 0, _g = axis.series; _f < _g.length; _f++) {
	                        var series = _g[_f];
	                        if (series === rowSeries && series.visible && this.rectSeriesInChart(series, isStack)) {
	                            seriesCollection.push(series);
	                        }
	                    }
	                }
	            }
	        }
	        return seriesCollection;
	    };
	    /**
	     * To get the column type series.
	     *
	     * @returns {void}
	     * @private
	     */
	    Series.prototype.rectSeriesInChart = function (series, isStack) {
	        var type = (series.type).toLowerCase();
	        return (type.indexOf('column') !== -1 || type.indexOf('bar') !== -1 || type.indexOf('histogram') !== -1 ||
	            type.indexOf('hiloopenclose') !== -1 || type.indexOf('candle') !== -1 || type.indexOf('pareto') !== -1 ||
	            type.indexOf('hilo') !== -1 || series.drawType.indexOf('Column') !== -1 ||
	            type.indexOf('waterfall') !== -1 || type.indexOf('boxandwhisker') !== -1 || isStack);
	    };
	    /**
	     * To calculate the stacked values.
	     *
	     * @returns {void}
	     * @private
	     */
	    Series.prototype.calculateStackedValue = function (isStacking100, chart) {
	        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {
	            var columnItem = _a[_i];
	            for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {
	                var item = _c[_b];
	                this.calculateStackingValues(this.findSeriesCollection(columnItem, item, true), isStacking100);
	            }
	        }
	    };
	    Series.prototype.calculateStackingValues = function (seriesCollection, isStacking100) {
	        var startValues;
	        var endValues;
	        var yValues = [];
	        var lastPositive = [];
	        var lastNegative = [];
	        var stackingGroup;
	        var lastValue;
	        var value;
	        var frequencies = [];
	        if (isStacking100) {
	            frequencies = this.findFrequencies(seriesCollection);
	        }
	        var groupingValues = [];
	        var visiblePoints = [];
	        for (var i = 0; i < seriesCollection.length; i++) {
	            var series = seriesCollection[i];
	            if (!groupingValues[series.stackingGroup]) {
	                groupingValues[series.stackingGroup] = [];
	                groupingValues[series.stackingGroup].push(series);
	            }
	            else if (groupingValues[series.stackingGroup] !== undefined) {
	                groupingValues[series.stackingGroup].push(series);
	            }
	        }
	        var keys = Object.keys(groupingValues);
	        for (var k = 0; k < keys.length; k++) {
	            var stackingSeies = [];
	            var stackedValues = [];
	            var seriesCollection_2 = groupingValues[keys[k]];
	            for (var _i = 0, seriesCollection_1 = seriesCollection_2; _i < seriesCollection_1.length; _i++) {
	                var series = seriesCollection_1[_i];
	                if (series.type.indexOf('Stacking') !== -1 || (series.drawType.indexOf('Stacking') !== -1 &&
	                    (series.chart.chartAreaType === 'PolarRadar'))) {
	                    stackingGroup = (series.type.indexOf('StackingArea') !== -1) ? 'StackingArea100' :
	                        (series.type.indexOf('StackingLine') !== -1) ? 'StackingLine100' : series.stackingGroup;
	                    if (!lastPositive[stackingGroup]) {
	                        lastPositive[stackingGroup] = [];
	                        lastNegative[stackingGroup] = [];
	                    }
	                    yValues = series.yData;
	                    startValues = [];
	                    endValues = [];
	                    stackingSeies.push(series);
	                    visiblePoints = getVisiblePoints(series);
	                    for (var j = 0, pointsLength = visiblePoints.length; j < pointsLength; j++) {
	                        lastValue = 0;
	                        value = +yValues[j]; // Fix for chart not rendering while y value is given as string issue
	                        if (lastPositive[stackingGroup][visiblePoints[j].xValue] === undefined) {
	                            lastPositive[stackingGroup][visiblePoints[j].xValue] = 0;
	                        }
	                        if (lastNegative[stackingGroup][visiblePoints[j].xValue] === undefined) {
	                            lastNegative[stackingGroup][visiblePoints[j].xValue] = 0;
	                        }
	                        if (isStacking100) {
	                            value = value / frequencies[stackingGroup][visiblePoints[j].xValue] * 100;
	                            value = !isNaN(value) ? value : 0;
	                            visiblePoints[j].percentage = +(value.toFixed(2));
	                        }
	                        else {
	                            stackedValues[j] = stackedValues[j] ? stackedValues[j] + Math.abs(value) : Math.abs(value);
	                        }
	                        if (value >= 0) {
	                            lastValue = lastPositive[stackingGroup][visiblePoints[j].xValue];
	                            lastPositive[stackingGroup][visiblePoints[j].xValue] += value;
	                        }
	                        else {
	                            lastValue = lastNegative[stackingGroup][visiblePoints[j].xValue];
	                            lastNegative[stackingGroup][visiblePoints[j].xValue] += value;
	                        }
	                        startValues.push(lastValue);
	                        endValues.push(value + lastValue);
	                        if (isStacking100 && (endValues[j] > 100)) {
	                            endValues[j] = 100;
	                        }
	                    }
	                    series.stackedValues = new StackValues(startValues, endValues);
	                    var isLogAxis = series.yAxis.valueType === 'Logarithmic';
	                    var isColumnBarType = (series.type.indexOf('Column') !== -1 || series.type.indexOf('Bar') !== -1);
	                    series.yMin = isLogAxis && isColumnBarType && series.yMin < 1 ? series.yMin : Math.min.apply(0, isStacking100 ? startValues : endValues);
	                    series.yMax = Math.max.apply(0, endValues);
	                    if (series.yMin > Math.min.apply(0, endValues)) {
	                        series.yMin = (isStacking100) ? -100 :
	                            isLogAxis && isColumnBarType && series.yMin < 1 ? series.yMin : Math.min.apply(0, endValues);
	                    }
	                    if (series.yMax < Math.max.apply(0, startValues)) {
	                        series.yMax = 0;
	                    }
	                }
	            }
	            this.findPercentageOfStacking(stackingSeies, stackedValues, isStacking100);
	        }
	    };
	    Series.prototype.findPercentageOfStacking = function (stackingSeies, values, isStacking100) {
	        for (var _i = 0, stackingSeies_1 = stackingSeies; _i < stackingSeies_1.length; _i++) {
	            var item = stackingSeies_1[_i];
	            if (isStacking100) {
	                return null;
	            }
	            for (var _a = 0, _b = getVisiblePoints(item); _a < _b.length; _a++) {
	                var point = _b[_a];
	                point.percentage = Math.abs(+(point.y / values[point.index] * 100).toFixed(2));
	            }
	        }
	    };
	    Series.prototype.findFrequencies = function (seriesCollection) {
	        var frequencies = [];
	        var stackingGroup;
	        var visiblePoints = [];
	        for (var _i = 0, seriesCollection_3 = seriesCollection; _i < seriesCollection_3.length; _i++) {
	            var series = seriesCollection_3[_i];
	            series.yAxis.isStack100 = series.type.indexOf('100') !== -1 ? true : false;
	            visiblePoints = getVisiblePoints(series);
	            if (series.type.indexOf('Stacking') !== -1) {
	                stackingGroup = (series.type.indexOf('StackingArea') !== -1) ? 'StackingArea100' :
	                    (series.type.indexOf('StackingLine') !== -1) ? 'StackingLine100' : series.stackingGroup;
	                if (!frequencies[stackingGroup]) {
	                    frequencies[stackingGroup] = [];
	                }
	                for (var j = 0, pointsLength = visiblePoints.length; j < pointsLength; j++) {
	                    if (frequencies[stackingGroup][visiblePoints[j].xValue] === undefined) {
	                        frequencies[stackingGroup][visiblePoints[j].xValue] = 0;
	                    }
	                    if (series.yData[j] > 0) {
	                        frequencies[stackingGroup][visiblePoints[j].xValue] += series.yData[j];
	                    }
	                    else {
	                        frequencies[stackingGroup][visiblePoints[j].xValue] -= series.yData[j];
	                    }
	                }
	            }
	        }
	        return frequencies;
	    };
	    /* private dataManagerFailure(e: { result: Object[] }): void {
	         this.currentViewData = [];
	         this.refreshChart();
	     }*/
	    /** @private */
	    Series.prototype.renderSeries = function (chart) {
	        if (this.chart.stockChart && this.xAxis.valueType === 'DateTimeCategory') {
	            for (var i = 0; i < this.points.length; i++) {
	                var index = this.xAxis.labels.indexOf(Date.parse(this.points[i].x.toString()).toString());
	                this.points[i].xValue = index;
	                if (chart.series.length > 1) {
	                    this.xData[i] = index;
	                    this.xMin = (this.xMin > index) ? index : this.xMin;
	                    this.xMax = (this.xMax < index) ? index : this.xMax;
	                }
	            }
	            if (this instanceof Series && this.type.indexOf('Spline') > -1) {
	                var isArea = this.type.indexOf('Area') > -1;
	                var isRange = this.type.indexOf('Range') > -1;
	                this.chart['spline' + (isArea ? isRange ? 'RangeArea' : 'Area' : '') + 'SeriesModule'].findSplinePoint(this);
	            }
	        }
	        var seriesType = firstToLowerCase(this.type);
	        seriesType = seriesType.replace('100', '');
	        if (chart[seriesType + 'SeriesModule']) {
	            if (this.category !== 'Indicator' && this.category !== 'TrendLine') {
	                this.createSeriesElements(chart);
	            }
	            this.visiblePoints = getVisiblePoints(this);
	            chart[seriesType + 'SeriesModule'].render(this, this.xAxis, this.yAxis, chart.requireInvertedAxis);
	            if (this.category !== 'Indicator') {
	                if (this.errorBar.visible) {
	                    this.chart.errorBarModule.render(this);
	                }
	                if (this.marker.dataLabel.visible) {
	                    chart.dataLabelModule.render(this, this.chart, this.marker.dataLabel);
	                }
	                this.appendSeriesElement(chart.seriesElements, chart);
	            }
	            if (!this.chart.enableCanvas) {
	                this.performAnimation(chart, seriesType, this.errorBar, this.marker, this.marker.dataLabel);
	            }
	        }
	    };
	    /**
	     * To create seris element.
	     *
	     * @returns {void}
	     * @private
	     */
	    Series.prototype.createSeriesElements = function (chart) {
	        if (this.category !== 'Indicator') {
	            var elementId = chart.element.id;
	            // 8 for extend border value 5 for extend size value
	            var explodeValue = this.marker.border.width + 8 + 5;
	            var render = (this.type === 'Bubble') || (!this.marker.visible && chart.tooltip.shared && chart.enableCanvas) ?
	                chart.svgRenderer : chart.renderer;
	            var index = this.index === undefined ? this.category : this.index;
	            var markerHeight = void 0;
	            var markerWidth = void 0;
	            var options = void 0;
	            if (this.type === 'Scatter' || this.drawType === 'Scatter') {
	                markerHeight = (this.marker.height + explodeValue) / 2;
	                markerWidth = (this.marker.width + explodeValue) / 2;
	            }
	            else {
	                markerHeight = 0;
	                markerWidth = 0;
	            }
	            if (chart.chartAreaType === 'PolarRadar') {
	                var markerMaxValue = (this.drawType === 'Scatter') ? Math.max(this.marker.width, this.marker.height) : 0;
	                options = new CircleOption(elementId + '_ChartSeriesClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, this.clipRect.width / 2 + this.clipRect.x, this.clipRect.height / 2 + this.clipRect.y, chart.radius + markerMaxValue);
	                this.clipRectElement = appendClipElement(chart.redraw, options, render, 'drawCircularClipPath');
	            }
	            else {
	                options = new RectOption(elementId + '_ChartSeriesClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, {
	                    x: (this.xAxis.columnIndex === 0) ? -markerWidth : 0, y: (this.yAxis.rowIndex === chart.rows.length - 1) ? -markerHeight : 0,
	                    width: this.clipRect.width + (this.xAxis.columnIndex === chart.columns.length - 1 ? markerWidth * 2 : markerWidth),
	                    height: this.clipRect.height + (this.yAxis.rowIndex === 0 ? markerHeight * 2 : markerHeight)
	                });
	                this.clipRectElement = appendClipElement(chart.redraw, options, render);
	            }
	            var transform = chart.chartAreaType === 'Cartesian' ? 'translate(' + this.clipRect.x + ',' + (this.clipRect.y) + ')' : '';
	            this.symbolElement = null;
	            this.seriesElement = render.createGroup({
	                'id': elementId + 'SeriesGroup' + index,
	                'transform': transform,
	                'clip-path': 'url(#' + elementId + '_ChartSeriesClipRect_' + index + ')'
	            });
	            if (this.seriesElement) {
	                this.seriesElement.setAttribute('role', 'region');
	                this.seriesElement.setAttribute('aria-label', (this.name + ',' + this.type + ' series with ' + this.points.length + ' data points'));
	                this.seriesElement.setAttribute('aria-hidden', 'false');
	            }
	            if (!this.chart.enableCanvas || this.type === 'Bubble') {
	                this.seriesElement.setAttribute('tabindex', index === 0 ? '0' : !this.checkTabindex(chart.visibleSeries, index) ? '0' : '');
	                this.seriesElement.setAttribute('style', 'outline: none');
	                this.seriesElement.appendChild(this.clipRectElement);
	            }
	        }
	    };
	    Series.prototype.checkTabindex = function (visibleSeries, index) {
	        for (var i = 0; i < index; i++) {
	            if (visibleSeries[i].visible)
	                return true;
	        }
	        return false;
	    };
	    /**
	     * To append the series.
	     *
	     * @returns {void}
	     * @private
	     */
	    Series.prototype.appendSeriesElement = function (element, chart) {
	        var marker = this.marker;
	        var dataLabel = marker.dataLabel;
	        var redraw = chart.redraw;
	        if (this.category !== 'TrendLine') {
	            appendChildElement(chart.enableCanvas, chart.seriesElements, this.seriesElement, redraw);
	            var errorBar = this.errorBar;
	            if (errorBar.visible) {
	                if (chart.chartAreaType === 'PolarRadar') {
	                    appendChildElement(chart.enableCanvas, chart.seriesElements, this.seriesElement, redraw);
	                }
	                else {
	                    appendChildElement(chart.enableCanvas, chart.seriesElements, this.errorBarElement, redraw);
	                }
	            }
	            if (this.type === 'Scatter' || this.type === 'Bubble' || this.drawType === 'Scatter') {
	                appendChildElement(chart.enableCanvas, chart.seriesElements, this.seriesElement, redraw);
	            }
	        }
	        if (marker.visible && (chart.chartAreaType === 'Cartesian' ||
	            ((this.drawType !== 'Scatter') && chart.chartAreaType === 'PolarRadar')) && this.type !== 'Scatter' &&
	            this.type !== 'Bubble' && this.type !== 'Candle' && this.type !== 'Hilo' && this.type !== 'HiloOpenClose' && this.symbolElement) {
	            appendChildElement(chart.enableCanvas, chart.seriesElements, this.symbolElement, redraw);
	        }
	        if (dataLabel.visible && this.textElement) {
	            appendChildElement(chart.enableCanvas, chart.dataLabelElements, this.shapeElement, redraw);
	            appendChildElement(chart.enableCanvas, chart.dataLabelElements, this.textElement, redraw);
	        }
	        if (!chart.enableCanvas && chart.dataLabelElements.hasChildNodes()) {
	            chart.seriesElements.appendChild(chart.dataLabelElements);
	        }
	    };
	    /**
	     * To perform animation for chart series.
	     *
	     * @returns {void}
	     * @private
	     */
	    Series.prototype.performAnimation = function (chart, type, errorBar, marker, dataLabel) {
	        if (((this.animation.enable && animationMode != 'Disable') || animationMode === 'Enable') && chart.animateSeries && (!chart.stockChart || !chart.stockChart.isStockChartRendered)) {
	            chart[type + 'SeriesModule'].doAnimation(this);
	            if (errorBar.visible) {
	                chart.errorBarModule.doErrorBarAnimation(this);
	            }
	            if (marker.visible) {
	                chart.markerRender.doMarkerAnimation(this);
	            }
	            //to datalabel animation disabled for edge and IE
	            if (dataLabel.visible && Browser.info.name !== 'edge' && !Browser.isIE) {
	                chart.dataLabelModule.doDataLabelAnimation(this);
	            }
	        }
	    };
	    /**
	     * To set border color for empty point
	     *
	     * @private
	     */
	    Series.prototype.setPointColor = function (point, color) {
	        color = point.interior || color;
	        return point.isEmpty ? (this.emptyPointSettings.fill || color) : color;
	    };
	    /**
	     * To set border color for empty point
	     *
	     * @private
	     */
	    Series.prototype.setBorderColor = function (point, border) {
	        border.width = point.isEmpty ? (this.emptyPointSettings.border.width || border.width) : border.width;
	        border.color = point.isEmpty ? (this.emptyPointSettings.border.color || border.color) : border.color;
	        return border;
	    };
	    __decorate$3([
	        Property('')
	    ], Series.prototype, "name", void 0);
	    __decorate$3([
	        Property('')
	    ], Series.prototype, "yName", void 0);
	    __decorate$3([
	        Property('Line')
	    ], Series.prototype, "drawType", void 0);
	    __decorate$3([
	        Property(true)
	    ], Series.prototype, "isClosed", void 0);
	    __decorate$3([
	        Property(null)
	    ], Series.prototype, "bearFillColor", void 0);
	    __decorate$3([
	        Property(null)
	    ], Series.prototype, "bullFillColor", void 0);
	    __decorate$3([
	        Property(false)
	    ], Series.prototype, "enableSolidCandles", void 0);
	    __decorate$3([
	        Property('')
	    ], Series.prototype, "size", void 0);
	    __decorate$3([
	        Property(null)
	    ], Series.prototype, "binInterval", void 0);
	    __decorate$3([
	        Property(false)
	    ], Series.prototype, "showNormalDistribution", void 0);
	    __decorate$3([
	        Property('')
	    ], Series.prototype, "stackingGroup", void 0);
	    __decorate$3([
	        Complex({ color: null, width: 0 }, Border)
	    ], Series.prototype, "border", void 0);
	    __decorate$3([
	        Property(1)
	    ], Series.prototype, "opacity", void 0);
	    __decorate$3([
	        Property(0)
	    ], Series.prototype, "zOrder", void 0);
	    __decorate$3([
	        Property('')
	    ], Series.prototype, "groupName", void 0);
	    __decorate$3([
	        Property('Line')
	    ], Series.prototype, "type", void 0);
	    __decorate$3([
	        Complex(null, ErrorBarSettings)
	    ], Series.prototype, "errorBar", void 0);
	    __decorate$3([
	        Complex(null, MarkerSettings)
	    ], Series.prototype, "marker", void 0);
	    __decorate$3([
	        Complex(null, ParetoOptions)
	    ], Series.prototype, "paretoOptions", void 0);
	    __decorate$3([
	        Complex({}, DragSettings)
	    ], Series.prototype, "dragSettings", void 0);
	    __decorate$3([
	        Collection([], Trendline)
	    ], Series.prototype, "trendlines", void 0);
	    __decorate$3([
	        Property(true)
	    ], Series.prototype, "enableTooltip", void 0);
	    __decorate$3([
	        Property('')
	    ], Series.prototype, "tooltipFormat", void 0);
	    __decorate$3([
	        Property('')
	    ], Series.prototype, "tooltipMappingName", void 0);
	    __decorate$3([
	        Property('SeriesType')
	    ], Series.prototype, "legendShape", void 0);
	    __decorate$3([
	        Property('')
	    ], Series.prototype, "legendImageUrl", void 0);
	    __decorate$3([
	        Property(null)
	    ], Series.prototype, "selectionStyle", void 0);
	    __decorate$3([
	        Property(null)
	    ], Series.prototype, "unSelectedStyle", void 0);
	    __decorate$3([
	        Property(null)
	    ], Series.prototype, "nonHighlightStyle", void 0);
	    __decorate$3([
	        Property(1)
	    ], Series.prototype, "minRadius", void 0);
	    __decorate$3([
	        Property(3)
	    ], Series.prototype, "maxRadius", void 0);
	    __decorate$3([
	        Property('Natural')
	    ], Series.prototype, "splineType", void 0);
	    __decorate$3([
	        Property(0.5)
	    ], Series.prototype, "cardinalSplineTension", void 0);
	    __decorate$3([
	        Complex(null, EmptyPointSettings)
	    ], Series.prototype, "emptyPointSettings", void 0);
	    __decorate$3([
	        Property(true)
	    ], Series.prototype, "showMean", void 0);
	    __decorate$3([
	        Property('Normal')
	    ], Series.prototype, "boxPlotMode", void 0);
	    __decorate$3([
	        Property(null)
	    ], Series.prototype, "columnWidth", void 0);
	    __decorate$3([
	        Property(null)
	    ], Series.prototype, "columnWidthInPixel", void 0);
	    __decorate$3([
	        Property('Rectangle')
	    ], Series.prototype, "columnFacet", void 0);
	    __decorate$3([
	        Property(0)
	    ], Series.prototype, "columnSpacing", void 0);
	    __decorate$3([
	        Property('#C64E4A')
	    ], Series.prototype, "negativeFillColor", void 0);
	    __decorate$3([
	        Property('#4E81BC')
	    ], Series.prototype, "summaryFillColor", void 0);
	    __decorate$3([
	        Property()
	    ], Series.prototype, "intermediateSumIndexes", void 0);
	    __decorate$3([
	        Property()
	    ], Series.prototype, "sumIndexes", void 0);
	    __decorate$3([
	        Complex({ color: 'black', width: 2 }, Connector)
	    ], Series.prototype, "connector", void 0);
	    __decorate$3([
	        Complex(null, CornerRadius)
	    ], Series.prototype, "cornerRadius", void 0);
	    return Series;
	}(SeriesBase));

	/**
	 * data module is used to generate query and dataSource
	 */
	var Data = /** @class */ (function () {
	    /**
	     * Constructor for data module
	     *
	     * @param dataSource
	     * @param query
	     * @param dataSource
	     * @param query
	     * @private
	     */
	    function Data(dataSource, query) {
	        this.initDataManager(dataSource, query);
	    }
	    /**
	     * The function used to initialize dataManager and query
	     *
	     * @param dataSource
	     * @param query
	     * @param dataSource
	     * @param query
	     * @returns {void}
	     * @private
	     */
	    Data.prototype.initDataManager = function (dataSource, query) {
	        this.dataManager = dataSource instanceof DataManager ? dataSource : new DataManager(dataSource);
	        this.query = query instanceof Query ? query : new Query();
	    };
	    /**
	     * The function used to generate updated Query from chart model
	     *
	     * @returns {void}
	     * @private
	     */
	    Data.prototype.generateQuery = function () {
	        var query = this.query.clone();
	        return query;
	    };
	    /**
	     * The function used to get dataSource by executing given Query
	     *
	     * @param  {Query} query - A Query that specifies to generate dataSource
	     * @returns {void}
	     * @private
	     */
	    Data.prototype.getData = function (dataQuery) {
	        var _this = this;
	        if (this.dataManager.ready) {
	            var dataManagerDeferred_1 = new Deferred();
	            var ready = this.dataManager.ready;
	            ready.then(function () {
	                _this.dataManager.executeQuery(dataQuery).then(function (result) {
	                    dataManagerDeferred_1.resolve(result);
	                });
	            }).catch(function (e) { dataManagerDeferred_1.reject(e); });
	            return dataManagerDeferred_1.promise;
	        }
	        else {
	            return this.dataManager.executeQuery(dataQuery);
	        }
	    };
	    return Data;
	}());

	var __extends$v = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Marker Module used to render the marker for line type series.
	 */
	var MarkerExplode = /** @class */ (function (_super) {
	    __extends$v(MarkerExplode, _super);
	    /**
	     * Constructor for the marker module.
	     *
	     * @private
	     */
	    function MarkerExplode(chart) {
	        var _this = _super.call(this, chart) || this;
	        _this.elementId = chart.element.id;
	        _this.commonXvalues = [];
	        return _this;
	    }
	    /**
	     * @hidden
	     */
	    MarkerExplode.prototype.addEventListener = function () {
	        if (this.chart.isDestroyed) {
	            return;
	        }
	        this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
	        this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);
	    };
	    /**
	     * @hidden
	     */
	    MarkerExplode.prototype.removeEventListener = function () {
	        if (this.chart.isDestroyed) {
	            return;
	        }
	        this.chart.off(Browser.touchMoveEvent, this.mouseMoveHandler);
	        this.chart.off(Browser.touchEndEvent, this.mouseUpHandler);
	    };
	    /**
	     * @hidden
	     */
	    MarkerExplode.prototype.mouseUpHandler = function () {
	        var chart = this.chart;
	        if (chart.isTouch && !chart.crosshair.enable && !this.isSelected(chart)) {
	            this.markerMove(true);
	        }
	    };
	    /**
	     * @hidden
	     */
	    MarkerExplode.prototype.mouseMoveHandler = function () {
	        var chart = this.chart;
	        if ((chart.highlightMode !== 'None' || (chart.tooltip.enable)) && (!chart.isTouch || chart.startMove) && !this.isSelected(chart)) {
	            this.markerMove(false);
	        }
	    };
	    MarkerExplode.prototype.markerMove = function (remove) {
	        var _this = this;
	        var chart = this.chart;
	        this.currentPoints = [];
	        var data;
	        var previous;
	        var explodeSeries;
	        var series;
	        if (!chart.tooltip.shared || !chart.tooltip.enable) {
	            data = this.getData();
	            series = data.series;
	            previous = this.previousPoints[0];
	            explodeSeries = series && ((series.type === 'Bubble' || series.drawType === 'Scatter' || series.type === 'Scatter') ||
	                (((series.type !== 'Candle') && (series.type !== 'Hilo') && (series.type !== 'HiloOpenClose')) &&
	                    (series.marker.visible && series.marker.width !== 0 && series.marker.height !== 0)));
	            data.lierIndex = this.lierIndex;
	            if (data.point && explodeSeries && ((!previous || (previous.point !== data.point)) ||
	                (previous && previous.lierIndex > 3 && previous.lierIndex !== this.lierIndex))) {
	                this.currentPoints.push(data);
	            }
	            if (data.point && explodeSeries && chart.isPointMouseDown) {
	                this.currentPoints.push(data);
	            }
	        }
	        else {
	            if (!withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
	                return null;
	            }
	            if (chart.tooltip.enable) {
	                var pointData = chart.chartAreaType === 'PolarRadar' ? this.getData() : null;
	                if (!this.chart.tooltip.showNearestPoint) {
	                    this.currentPoints = this.chart.tooltipModule.currentPoints;
	                }
	                else {
	                    for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
	                        var chartSeries = _a[_i];
	                        if (!chartSeries.enableTooltip || chartSeries.category === 'Indicator') {
	                            continue;
	                        }
	                        if (chart.chartAreaType === 'Cartesian' && chartSeries.visible) {
	                            data = this.getClosestX(chart, chartSeries, this.commonXValue(this.chart.visibleSeries));
	                        }
	                        else if (chart.chartAreaType === 'PolarRadar' && chartSeries.visible && pointData.point !== null) {
	                            data = new PointData(chartSeries.points[pointData.point.index], chartSeries);
	                        }
	                        if (data) {
	                            this.currentPoints.push(data);
	                            data = null;
	                        }
	                    }
	                }
	            }
	        }
	        var length = this.previousPoints.length;
	        if (this.currentPoints.length > 0 || (length > 0 && chart.tooltip.shared)) {
	            if (length === 0 || chart.isPointMouseDown || (length > 0 && (this.currentPoints.length == 0 || (this.previousPoints[0].point !== this.currentPoints[0].point)))) {
	                if (length > 0) {
	                    for (var _b = 0, _c = this.previousPoints; _b < _c.length; _b++) {
	                        var previousPoint = _c[_b];
	                        if (!isNullOrUndefined(previousPoint)) {
	                            this.removeHighlightedMarker(previousPoint.series, previousPoint.point);
	                        }
	                    }
	                }
	                var _loop_1 = function (data_1) {
	                    if ((data_1 && data_1.point) || ((series.type !== 'Candle') &&
	                        (series.type !== 'Hilo') && (series.type !== 'HiloOpenClose'))) {
	                        stopTimer(this_1.markerExplode);
	                        this_1.isRemove = true;
	                        data_1.point.symbolLocations.map(function (location, index) {
	                            if (data_1.series.marker.allowHighlight && (!data_1.series.isRectSeries || data_1.point.marker.visible)) {
	                                _this.drawTrackBall(data_1.series, data_1.point, location, index);
	                            }
	                        });
	                    }
	                };
	                var this_1 = this;
	                for (var _d = 0, _e = this.currentPoints; _d < _e.length; _d++) {
	                    var data_1 = _e[_d];
	                    _loop_1(data_1);
	                }
	                this.previousPoints = extend([], this.currentPoints, null, true);
	            }
	        }
	        if (!chart.tooltip.enable && ((this.currentPoints.length === 0 && this.isRemove) || (remove && this.isRemove) ||
	            !withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect))) {
	            this.isRemove = false;
	            if (!isNullOrUndefined(this.previousPoints[0])) {
	                this.markerExplode = +setTimeout(function () {
	                    if (_this.previousPoints[0]) {
	                        _this.removeHighlightedMarker(_this.previousPoints[0].series, _this.previousPoints[0].point);
	                    }
	                }, 2000);
	            }
	        }
	        this.currentPoints = [];
	    };
	    MarkerExplode.prototype.animationDuration = function () {
	        var duration = 200;
	        if (this.chart.maxPointCount > 100) {
	            duration = 10;
	        }
	        else if (this.chart.maxPointCount > 50) {
	            duration = 100;
	        }
	        return duration;
	    };
	    MarkerExplode.prototype.drawTrackBall = function (series, point, location, index) {
	        var marker = point.marker;
	        var seriesMarker = series.marker;
	        var shape = marker.shape || seriesMarker.shape || 'Circle';
	        var svg;
	        if (shape === 'None' || shape === 'Image') {
	            return null;
	        }
	        var element = series.symbolElement || series.seriesElement;
	        var className;
	        if (this.chart.highlightModule && this.chart.highlightMode !== 'None') {
	            className = this.chart.highlightModule.generateStyle(series);
	        }
	        if (this.chart.selectionModule && this.chart.selectionMode !== 'None') {
	            className = this.chart.selectionModule.generateStyle(series);
	        }
	        var symbolId = this.elementId + '_Series_' + series.index + '_Point_' + point.index + '_Trackball' +
	            (index ? index : '');
	        var size = new Size((marker.width || seriesMarker.width) + 3, (marker.height || seriesMarker.height) + 3);
	        var border = (marker.border || series.border);
	        var explodeSeries = (series.type === 'BoxAndWhisker' || series.type === 'Bubble' || series.type === 'Scatter');
	        var borderColor = (border.color && border.color !== 'transparent') ? border.color :
	            marker.fill || point.interior || (explodeSeries ? point.color : series.interior);
	        var colorValue = convertHexToColor(colorNameToHex(borderColor));
	        var borderWidth = marker.border ? marker.border.width : seriesMarker.border.width;
	        var markerShadow = series.chart.themeStyle.markerShadow ||
	            'rgba(' + colorValue.r + ',' + colorValue.g + ',' + colorValue.b + ',0.2)';
	        var markerElement = document.getElementById(this.elementId + '_Series_' + series.index + '_Point_' +
	            point.index + '_Symbol');
	        if (!isNullOrUndefined(markerElement)) {
	            markerElement.setAttribute('visibility', 'hidden');
	        }
	        if (this.chart.enableCanvas) {
	            var trackElement = document.getElementById(this.chart.element.id + '_Secondary_Element');
	            svg = this.chart.svgRenderer.createSvg({
	                id: this.chart.element.id + '_trackball_svg',
	                width: this.chart.availableSize.width,
	                height: this.chart.availableSize.height
	            });
	            svg.style.cssText = 'position: absolute; pointer-events: none';
	            trackElement.appendChild(svg);
	        }
	        for (var i = 0; i < 2; i++) {
	            var options = new PathOption(symbolId + '_' + i, i ? (marker.fill || point.color || (explodeSeries ? series.interior : '#ffffff')) : 'transparent', borderWidth + (i ? 0 : 8), i ? borderColor : markerShadow, (marker.opacity || seriesMarker.opacity), null, null);
	            var symbol = drawSymbol(location, shape, size, marker.imageUrl, options, '', this.chart.svgRenderer, series.clipRect);
	            // incident: 252450 point click selection not working while maker explode
	            //symbol.setAttribute('style', 'pointer-events:none');
	            symbol.setAttribute('class', this.elementId + '_EJ2-Trackball_Series_' + series.index + '_Point_' + point.index);
	            var selectionId = element.id.indexOf('Symbol') !== -1 ? '_Symbol' : '';
	            var seletionElem = document.getElementById(this.elementId + '_Series_' + series.index + '_Point_' +
	                point.index + selectionId);
	            if (className !== '' && !isNullOrUndefined(className) && !isNullOrUndefined(seletionElem) &&
	                seletionElem.hasAttribute('class') && (className === seletionElem.getAttribute('class'))) {
	                symbol.classList.add(className);
	            }
	            symbol.setAttribute('role', 'img');
	            symbol.setAttribute('clip-path', element.getAttribute('clip-path'));
	            symbol.setAttribute('transform', element.getAttribute('transform'));
	            if (this.chart.enableCanvas) {
	                svg.appendChild(symbol);
	            }
	            else {
	                this.chart.svgObject.appendChild(symbol);
	            }
	        }
	        this.doAnimation(series, point, false);
	    };
	    /**
	     * Animates the series.
	     *
	     * @param  {Series} series - Defines the series to animate.
	     * @returns {void}
	     */
	    MarkerExplode.prototype.doAnimation = function (series, point, endAnimate) {
	        if (endAnimate === void 0) { endAnimate = false; }
	        var duration = this.animationDuration();
	        var delay = series.animation.delay;
	        var rectElements = document.getElementsByClassName(this.elementId + '_EJ2-Trackball_Series_' + series.index + '_Point_' + point.index);
	        for (var i = 0, len = rectElements.length; i < len; i++) {
	            this.trackballAnimate(rectElements[i], delay, duration, series, point.index, point.symbolLocations[0], false, endAnimate);
	        }
	    };
	    /**
	     * Animation Effect Calculation End
	     *
	     * @private
	     */
	    MarkerExplode.prototype.trackballAnimate = function (elements, delays, durations, series, pointIndex, point, isLabel, endAnimate) {
	        var centerX = point.x;
	        var centerY = point.y;
	        var clipX = (series.type !== 'Polar' && series.type !== 'Radar') ? series.clipRect.x : 0;
	        var clipY = (series.type !== 'Polar' && series.type !== 'Radar') ? series.clipRect.y : 0;
	        var transform = elements.getAttribute('transform');
	        new Animation$1({}).animate(elements, {
	            duration: durations,
	            delay: delays,
	            progress: function (args) {
	                if (args.timeStamp > args.delay) {
	                    args.element.style.visibility = 'visible';
	                    ((args.timeStamp - args.delay) / args.duration);
	                    elements.setAttribute('transform', 'translate(' + (centerX + clipX)
	                        + ' ' + (centerY + clipY) + ') scale(1) translate(' + (-centerX) + ' ' + (-centerY) + ')');
	                }
	            },
	            end: function () {
	                elements.style.visibility = '';
	                elements.setAttribute('transform', transform);
	                if (!isLabel && (pointIndex === series.points.length - 1)) {
	                    series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });
	                }
	                if (endAnimate) {
	                    remove(elements);
	                }
	            }
	        });
	    };
	    /**
	     * @param series
	     * @param point
	     * @param fadeOut
	     * @param series
	     * @param point
	     * @param fadeOut
	     * @param series
	     * @param point
	     * @param fadeOut
	     * @hidden
	     */
	    MarkerExplode.prototype.removeHighlightedMarker = function (series, point, fadeOut) {
	        if (series === void 0) { series = null; }
	        if (point === void 0) { point = null; }
	        if (fadeOut === void 0) { fadeOut = false; }
	        if (!isNullOrUndefined(series) && !isNullOrUndefined(point)) {
	            var markerElement = document.getElementById(this.elementId + '_Series_' + series.index + '_Point_' +
	                point.index + '_Symbol');
	            var trackballElements = document.getElementsByClassName(this.elementId + '_EJ2-Trackball_Series_' + series.index + '_Point_' + point.index);
	            for (var i = 0, len = trackballElements.length; i < len; i++) {
	                remove(trackballElements[0]);
	            }
	            if (!isNullOrUndefined(markerElement)) {
	                markerElement.setAttribute('visibility', 'visible');
	            }
	        }
	        else {
	            for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
	                var point_1 = _a[_i];
	                var elements = document.getElementsByClassName(this.elementId + '_EJ2-Trackball_Series_' + series.index + '_Point_' + point_1.index);
	                var markerElement = document.getElementById(this.elementId + '_Series_' + series.index + '_Point_' +
	                    point_1.index + '_Symbol');
	                for (var i = 0, len = elements.length; i < len; i++) {
	                    if (!isNullOrUndefined(markerElement)) {
	                        markerElement.setAttribute('visibility', 'visible');
	                    }
	                    remove(elements[0]);
	                }
	            }
	        }
	        if (fadeOut) {
	            this.previousPoints = [];
	        }
	    };
	    return MarkerExplode;
	}(ChartData));

	var __extends$u = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var markerShapes = ["Circle", "Triangle", "Diamond", "Rectangle", "Pentagon", "InvertedTriangle", "VerticalLine", "Cross", "Plus", "HorizontalLine"];
	/**
	 * Marker module used to render the marker for line type series.
	 */
	var Marker = /** @class */ (function (_super) {
	    __extends$u(Marker, _super);
	    /**
	     * Constructor for the marker module.
	     *
	     * @private
	     */
	    function Marker(chart) {
	        var _this = _super.call(this, chart) || this;
	        _this.addEventListener();
	        return _this;
	    }
	    /**
	     * Render the marker for series.
	     *
	     * @returns {void}
	     * @private
	     */
	    Marker.prototype.render = function (series) {
	        var _this = this;
	        var redraw = series.chart.redraw;
	        this.createElement(series, redraw);
	        var _loop_1 = function (point) {
	            if (point.visible && point.symbolLocations && point.symbolLocations.length) {
	                point.symbolLocations.map(function (location, index) {
	                    if (series.marker.shape !== 'None') {
	                        _this.renderMarker(series, point, location, index, redraw);
	                    }
	                });
	            }
	        };
	        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
	            var point = _a[_i];
	            _loop_1(point);
	        }
	    };
	    Marker.prototype.renderMarker = function (series, point, location, index, redraw) {
	        var seriesIndex = series.index === undefined ? series.category : series.index;
	        var marker = series.marker;
	        series.marker.shape = series.marker.shape ? series.marker.shape : markerShapes[seriesIndex % 10];
	        var border = {
	            color: marker.border.color,
	            width: marker.border.width
	        };
	        var borderColor = marker.border.color;
	        var previousLocation;
	        var previousPath;
	        var circlePath;
	        var shapeOption;
	        location.x = location.x + marker.offset.x;
	        location.y = location.y - marker.offset.y;
	        var isBoxPlot = series.type === 'BoxAndWhisker';
	        var fill = marker.fill || ((isBoxPlot || series.marker.isFilled) ? point.interior || series.interior : '#ffffff');
	        var markerElement;
	        var parentElement = isBoxPlot ?
	            findlElement(series.seriesElement.childNodes, 'Series_' + series.index + '_Point_' + point.index)
	            : series.symbolElement;
	        border.color = borderColor || series.setPointColor(point, series.interior);
	        var symbolId = this.elementId + '_Series_' + seriesIndex + '_Point_' + point.index + '_Symbol' +
	            (index ? index : '');
	        var argsData = {
	            cancel: false, name: pointRender, series: series, point: point,
	            fill: point.isEmpty ? (series.emptyPointSettings.fill || fill) : fill,
	            border: {
	                color: series.type === 'BoxAndWhisker' ?
	                    (!isNullOrUndefined(borderColor) && borderColor !== 'transparent') ? borderColor :
	                        getSaturationColor(fill, -0.6)
	                    : border.color,
	                width: border.width
	            },
	            height: marker.height, width: marker.width, shape: marker.shape
	        };
	        argsData.border = series.setBorderColor(point, { width: argsData.border.width, color: argsData.border.color });
	        if (!series.isRectSeries || series.type === 'BoxAndWhisker') {
	            this.chart.trigger(pointRender, argsData);
	            point.color = argsData.fill;
	        }
	        point.color = argsData.fill;
	        if (!argsData.cancel) {
	            var y = void 0;
	            if (series.type === 'RangeArea' || series.type === 'RangeColumn' || series.drawType === 'RangeColumn'
	                || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea') {
	                y = index ? point.low : point.high;
	            }
	            else if (isBoxPlot) {
	                y = point.outliers[index];
	            }
	            else {
	                y = point.y;
	            }
	            var markerFill = argsData.point.marker.fill || argsData.fill;
	            var markerBorder = void 0;
	            if (!isNullOrUndefined(argsData.point.marker.border)) {
	                markerBorder = {
	                    color: argsData.point.marker.border.color || argsData.border.color,
	                    width: argsData.point.marker.border.width || argsData.border.width
	                };
	            }
	            else {
	                markerBorder = { color: argsData.border.color, width: argsData.border.width };
	            }
	            var markerWidth = argsData.point.marker.width || argsData.width;
	            var markerHeight = argsData.point.marker.height || argsData.height;
	            var markerOpacity = argsData.point.marker.opacity || marker.opacity;
	            var markerShape = argsData.point.marker.shape || argsData.shape;
	            var imageURL = argsData.point.marker.imageUrl || marker.imageUrl;
	            shapeOption = new PathOption(symbolId, markerFill, markerBorder.width, markerBorder.color, markerOpacity, null);
	            if ((parentElement !== undefined && parentElement !== null) || this.chart.enableCanvas) {
	                if (redraw && getElement(shapeOption.id)) {
	                    markerElement = getElement(shapeOption.id);
	                    circlePath = markerShape === 'Circle' ? 'c' : '';
	                    previousLocation = {
	                        x: +markerElement.getAttribute(circlePath + 'x'), y: +markerElement.getAttribute(circlePath + 'y')
	                    };
	                    previousPath = markerElement.getAttribute('d');
	                }
	                markerElement = drawSymbol(location, markerShape, new Size(markerWidth, markerHeight), imageURL, shapeOption, point.x.toString() + ':' + y.toString(), this.chart.renderer, series.clipRect);
	                if (markerElement) {
	                    markerElement.setAttribute('role', 'img');
	                    markerElement.setAttribute('aria-label', (point.x + ': ' + point.y + ', ' + series.name));
	                }
	                appendChildElement(this.chart.enableCanvas, parentElement, markerElement, redraw, true, circlePath + 'x', circlePath + 'y', previousLocation, previousPath, false, false, null, series.chart.duration);
	            }
	            point.marker = {
	                border: markerBorder, fill: markerFill, height: markerHeight,
	                visible: true, shape: markerShape, width: markerWidth, imageUrl: imageURL
	            };
	        }
	        else {
	            location = null;
	            point.marker = {
	                visible: false
	            };
	        }
	    };
	    Marker.prototype.createElement = function (series, redraw) {
	        var markerClipRect;
	        var marker = series.marker;
	        // 8 for extend border value 5 for extend size value
	        var explodeValue = marker.border.width + 8 + 5;
	        var render = series.chart.svgRenderer;
	        var index = series.index === undefined ? series.category : series.index;
	        var options;
	        var transform = series.chart.chartAreaType === 'Cartesian' ? 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')' : '';
	        if (marker.visible) {
	            var markerHeight = (marker.height + explodeValue) / 2;
	            var markerWidth = (marker.width + explodeValue) / 2;
	            if (series.chart.chartAreaType === 'Cartesian') {
	                var isZoomed = series.xAxis.zoomFactor < 1 || series.xAxis.zoomPosition > 0;
	                options = new RectOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, {
	                    x: isZoomed ? 0 : -markerWidth, y: -markerHeight,
	                    width: series.clipRect.width + (isZoomed ? 0 : markerWidth * 2),
	                    height: series.clipRect.height + markerHeight * 2
	                });
	                markerClipRect = appendClipElement(redraw, options, render);
	            }
	            else {
	                options = new CircleOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, series.clipRect.width / 2 + series.clipRect.x, series.clipRect.height / 2 + series.clipRect.y, series.chart.radius + Math.max(markerHeight, markerWidth));
	                markerClipRect = appendClipElement(redraw, options, render, 'drawCircularClipPath');
	            }
	            options = {
	                'id': this.elementId + 'SymbolGroup' + index,
	                'transform': transform,
	                'clip-path': 'url(#' + this.elementId + '_ChartMarkerClipRect_' + index + ')'
	            };
	            series.symbolElement = render.createGroup(options);
	            series.symbolElement.appendChild(markerClipRect);
	            if (this.chart.enableCanvas) {
	                var element = document.getElementById(this.chart.element.id + '_tooltip_svg');
	                element.appendChild(series.symbolElement);
	            }
	        }
	    };
	    Marker.prototype.getRangeLowPoint = function (region, series) {
	        var x = region.x;
	        var y = region.y;
	        if (series.chart.requireInvertedAxis) {
	            y += region.height / 2;
	            x += series.yAxis.isAxisInverse ? region.width : 0;
	        }
	        else {
	            y += series.yAxis.isAxisInverse ? 0 : region.height;
	            x += region.width / 2;
	        }
	        return { x: x, y: y };
	    };
	    /**
	     * Animates the marker.
	     *
	     * @returns {void}
	     * @private
	     */
	    Marker.prototype.doMarkerAnimation = function (series) {
	        if (!(series.type === 'Scatter' || series.type === 'Bubble' || series.type === 'Candle' || series.type === 'Hilo' ||
	            series.type === 'HiloOpenClose' || (series.chart.chartAreaType === 'PolarRadar' && (series.drawType === 'Scatter')))) {
	            var markerElements = series.symbolElement.childNodes;
	            var delay = series.animation.delay + (series.animation.duration === 0 && animationMode === 'Enable' ? 1000 : series.animation.duration);
	            var duration = series.chart.animated ? series.chart.duration : 200;
	            var j = 1;
	            var incFactor = (series.type === 'RangeArea' || series.type === 'RangeColumn' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea') ? 2 : 1;
	            for (var i = 0; i < series.points.length; i++) {
	                if (series.points[i].symbolLocations) {
	                    if (!series.points[i].symbolLocations.length || !markerElements[j]) {
	                        continue;
	                    }
	                    markerAnimate(markerElements[j], delay, duration, series, i, series.points[i].symbolLocations[0], false);
	                    if (incFactor === 2) {
	                        var lowPoint = this.getRangeLowPoint(series.points[i].regions[0], series);
	                        markerAnimate(markerElements[j + 1], delay, duration, series, i, lowPoint, false);
	                    }
	                    j += incFactor;
	                }
	            }
	        }
	    };
	    return Marker;
	}(MarkerExplode));

	var __extends$t = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	/**
	 * Configures the location for the legend.
	 */
	var Location = /** @class */ (function (_super) {
	    __extends$t(Location, _super);
	    function Location() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$2([
	        Property(0)
	    ], Location.prototype, "x", void 0);
	    __decorate$2([
	        Property(0)
	    ], Location.prototype, "y", void 0);
	    return Location;
	}(ChildProperty));
	/**
	 * Configures the legends in charts.
	 */
	var LegendSettings = /** @class */ (function (_super) {
	    __extends$t(LegendSettings, _super);
	    function LegendSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate$2([
	        Property(true)
	    ], LegendSettings.prototype, "visible", void 0);
	    __decorate$2([
	        Property(null)
	    ], LegendSettings.prototype, "height", void 0);
	    __decorate$2([
	        Property(null)
	    ], LegendSettings.prototype, "width", void 0);
	    __decorate$2([
	        Complex({ x: 0, y: 0 }, Location)
	    ], LegendSettings.prototype, "location", void 0);
	    __decorate$2([
	        Property('Auto')
	    ], LegendSettings.prototype, "position", void 0);
	    __decorate$2([
	        Property('Series')
	    ], LegendSettings.prototype, "mode", void 0);
	    __decorate$2([
	        Property(8)
	    ], LegendSettings.prototype, "padding", void 0);
	    __decorate$2([
	        Property(null)
	    ], LegendSettings.prototype, "itemPadding", void 0);
	    __decorate$2([
	        Property('Center')
	    ], LegendSettings.prototype, "alignment", void 0);
	    __decorate$2([
	        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '400', color: null }, Font)
	    ], LegendSettings.prototype, "textStyle", void 0);
	    __decorate$2([
	        Property(10)
	    ], LegendSettings.prototype, "shapeHeight", void 0);
	    __decorate$2([
	        Property(10)
	    ], LegendSettings.prototype, "shapeWidth", void 0);
	    __decorate$2([
	        Complex({}, Border)
	    ], LegendSettings.prototype, "border", void 0);
	    __decorate$2([
	        Complex({ left: 0, right: 0, top: 0, bottom: 0 }, Margin)
	    ], LegendSettings.prototype, "margin", void 0);
	    __decorate$2([
	        Complex({ left: 0, right: 0, top: 0, bottom: 0 }, ContainerPadding)
	    ], LegendSettings.prototype, "containerPadding", void 0);
	    __decorate$2([
	        Property(8)
	    ], LegendSettings.prototype, "shapePadding", void 0);
	    __decorate$2([
	        Property('transparent')
	    ], LegendSettings.prototype, "background", void 0);
	    __decorate$2([
	        Property(1)
	    ], LegendSettings.prototype, "opacity", void 0);
	    __decorate$2([
	        Property(true)
	    ], LegendSettings.prototype, "toggleVisibility", void 0);
	    __decorate$2([
	        Property(false)
	    ], LegendSettings.prototype, "enableHighlight", void 0);
	    __decorate$2([
	        Property(null)
	    ], LegendSettings.prototype, "description", void 0);
	    __decorate$2([
	        Property(3)
	    ], LegendSettings.prototype, "tabIndex", void 0);
	    __decorate$2([
	        Property(null)
	    ], LegendSettings.prototype, "title", void 0);
	    __decorate$2([
	        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '600', color: null }, Font)
	    ], LegendSettings.prototype, "titleStyle", void 0);
	    __decorate$2([
	        Property('Top')
	    ], LegendSettings.prototype, "titlePosition", void 0);
	    __decorate$2([
	        Property('Normal')
	    ], LegendSettings.prototype, "textWrap", void 0);
	    __decorate$2([
	        Property('Ellipsis')
	    ], LegendSettings.prototype, "textOverflow", void 0);
	    __decorate$2([
	        Property(100)
	    ], LegendSettings.prototype, "maximumTitleWidth", void 0);
	    __decorate$2([
	        Property(null)
	    ], LegendSettings.prototype, "maximumLabelWidth", void 0);
	    __decorate$2([
	        Property(true)
	    ], LegendSettings.prototype, "enablePages", void 0);
	    __decorate$2([
	        Property(false)
	    ], LegendSettings.prototype, "isInversed", void 0);
	    __decorate$2([
	        Property(false)
	    ], LegendSettings.prototype, "reverse", void 0);
	    return LegendSettings;
	}(ChildProperty));
	/**
	 * Legend base class for Chart and Accumulation chart.
	 *
	 * @private
	 */
	var BaseLegend = /** @class */ (function () {
	    /**
	     * Constructor for the dateTime module.
	     *
	     * @private
	     */
	    function BaseLegend(chart) {
	        this.maxItemHeight = 0;
	        this.rowHeights = [];
	        this.pageHeights = [];
	        this.columnHeights = [];
	        this.pageXCollections = []; // pages of x locations
	        this.chartRowCount = 1;
	        this.legendTitleCollections = [];
	        this.legendRegions = [];
	        this.pagingRegions = [];
	        this.chart = chart;
	        this.legend = chart.legendSettings;
	        this.legendID = chart.element.id + '_chart_legend';
	        this.isChartControl = (chart.getModuleName() === 'chart');
	        this.isAccChartControl = (chart.getModuleName() === 'accumulationchart');
	        this.isBulletChartControl = (chart.getModuleName() === 'bulletChart');
	        this.isStockChartControl = (chart.getModuleName() === 'stockChart');
	        this.bulletChart = this.chart;
	        this.fivePixel = 5;
	        this.rowCount = 0;
	        this.pageButtonSize = 8;
	        this.maxColumns = 0;
	        this.maxWidth = 0;
	        this.currentPage = 1;
	        this.backwardArrowOpacity = 0;
	        this.forwardArrowOpacity = 1;
	        this.arrowWidth = (2 * (this.fivePixel + this.pageButtonSize + this.fivePixel));
	        this.arrowHeight = this.arrowWidth;
	        this.isTop = false;
	        this.isTitle = false;
	        this.currentPageNumber = 1;
	    }
	    /**
	     * Calculate the bounds for the legends.
	     *
	     * @returns {void}
	     * @private
	     */
	    BaseLegend.prototype.calculateLegendBounds = function (rect, availableSize, maxLabelSize) {
	        var legend = this.legend;
	        var defaultValue = (this.isBulletChartControl) ? '40%' : '20%';
	        this.getPosition(legend.position, availableSize);
	        this.legendBounds = new Rect(rect.x, rect.y, 0, 0);
	        this.isVertical = (this.position === 'Left' || this.position === 'Right');
	        this.itemPadding = this.legend.itemPadding ? this.legend.itemPadding : this.isVertical ? this.legend.padding : 20;
	        if (this.isVertical) {
	            this.legendBounds.height = stringToNumber(legend.height, availableSize.height - (rect.y - this.chart.margin.top)) || rect.height;
	            this.legendBounds.width = stringToNumber(legend.width || defaultValue, availableSize.width);
	        }
	        else {
	            this.legendBounds.width = stringToNumber(legend.width, availableSize.width) || rect.width;
	            this.legendBounds.height = stringToNumber(legend.height || defaultValue, availableSize.height);
	        }
	        this.library.getLegendBounds(availableSize, this.legendBounds, legend);
	        if (!this.isBulletChartControl) {
	            this.legendBounds.width += (this.legend.containerPadding.left + this.legend.containerPadding.right);
	            this.legendBounds.height += (this.legend.containerPadding.top + this.legend.containerPadding.bottom);
	        }
	        this.getLocation(this.position, legend.alignment, this.legendBounds, rect, availableSize, maxLabelSize);
	    };
	    /**
	     * To find legend position based on available size for chart and accumulation chart
	     *
	     * @param position
	     * @param availableSize
	     * @param position
	     * @param availableSize
	     * @returns {void}
	     */
	    BaseLegend.prototype.getPosition = function (position, availableSize) {
	        var chart = this.chart;
	        var accumulation = this.chart;
	        if (this.isChartControl || this.isBulletChartControl || this.isStockChartControl) {
	            this.position = (position !== 'Auto') ? position : 'Bottom';
	        }
	        else {
	            if (position === 'Auto' && ((chart || accumulation).visibleSeries && (chart || accumulation).visibleSeries[0].type === 'Funnel' || (chart || accumulation).visibleSeries[0].type === 'Pyramid')) {
	                position = 'Top';
	            }
	            this.position = (position !== 'Auto') ? position :
	                (availableSize.width > availableSize.height ? 'Right' : 'Bottom');
	        }
	    };
	    /**
	     * To set bounds for chart and accumulation chart
	     *
	     * @param computedWidth
	     * @param computedHeight
	     * @param legend
	     * @param legendBounds
	     * @param computedWidth
	     * @param computedHeight
	     * @param legend
	     * @param legendBounds
	     * @param computedWidth
	     * @param computedHeight
	     * @param legend
	     * @param legendBounds
	     * @param computedWidth
	     * @param computedHeight
	     * @param legend
	     * @param legendBounds
	     * @returns {void}
	     */
	    BaseLegend.prototype.setBounds = function (computedWidth, computedHeight, legend, legendBounds) {
	        var titleHeight = legend.title && legend.titlePosition === 'Top' ? this.legendTitleSize.height + this.fivePixel : 0;
	        if (this.isVertical && this.isPaging && !legend.enablePages && !this.isBulletChartControl) {
	            titleHeight = legend.title && legend.titlePosition === 'Top' ? this.legendTitleSize.height + this.fivePixel : 0;
	            titleHeight += (this.pageButtonSize + this.fivePixel);
	        }
	        computedWidth = Math.min(computedWidth, legendBounds.width);
	        computedHeight = Math.min(computedHeight, legendBounds.height);
	        if (legend.mode === 'Gradient') {
	            legendBounds.width = legend.width ? legendBounds.width : this.isVertical ? computedWidth : 0.75 * legendBounds.width;
	            legendBounds.height = legend.height ? legendBounds.height : this.isVertical ? 0.75 * legendBounds.height : computedHeight;
	        }
	        else {
	            legendBounds.width = !legend.width ? computedWidth : legendBounds.width;
	            legendBounds.height = !legend.height ? computedHeight : legendBounds.height;
	        }
	        if (!this.isBulletChartControl) {
	            if (this.isTop && legend.titleStyle.textOverflow !== 'None') {
	                this.calculateLegendTitle(legend, legendBounds);
	                legendBounds.height += legend.titleStyle.textOverflow === 'Wrap' && this.legendTitleCollections.length > 1 ?
	                    (this.legendTitleSize.height - (this.legendTitleSize.height / this.legendTitleCollections.length)) : 0;
	            }
	        }
	        this.rowCount = Math.max(1, Math.ceil((legendBounds.height - legend.padding - titleHeight) /
	            (this.maxItemHeight + legend.padding)));
	    };
	    /**
	     * To find legend location based on position, alignment for chart and accumulation chart
	     *
	     * @param position
	     * @param alignment
	     * @param legendBounds
	     * @param rect
	     * @param availableSize
	     * @param maxLabelSize
	     * @param position
	     * @param alignment
	     * @param legendBounds
	     * @param rect
	     * @param availableSize
	     * @param maxLabelSize
	     * @param position
	     * @param alignment
	     * @param legendBounds
	     * @param rect
	     * @param availableSize
	     * @param maxLabelSize
	     * @param position
	     * @param alignment
	     * @param legendBounds
	     * @param rect
	     * @param availableSize
	     * @param maxLabelSize
	     * @param position
	     * @param alignment
	     * @param legendBounds
	     * @param rect
	     * @param availableSize
	     * @param maxLabelSize
	     * @param position
	     * @param alignment
	     * @param legendBounds
	     * @param rect
	     * @param availableSize
	     * @param maxLabelSize
	     */
	    BaseLegend.prototype.getLocation = function (position, alignment, legendBounds, rect, availableSize, maxLabelSize) {
	        var padding = this.legend.border.width;
	        var isBulletChart = this.isBulletChartControl;
	        var bulletChart = this.bulletChart;
	        var labelIns = bulletChart.labelPosition === 'Inside';
	        var ticklIns = bulletChart.tickPosition === 'Inside';
	        var isVertical = bulletChart.orientation === 'Vertical';
	        var categoryFieldValue = (isBulletChart && bulletChart.categoryField !== '') ?
	            maxLabelSize.width + this.chart.border.width + padding * 3 : 0;
	        var marginBottom = this.chart.margin.bottom;
	        var legendHeight = legendBounds.height + padding + this.legend.margin.top + this.legend.margin.bottom;
	        var legendWidth = legendBounds.width + padding + this.legend.margin.left + this.legend.margin.right;
	        if (position === 'Bottom') {
	            legendBounds.x = this.alignLegend(legendBounds.x, availableSize.width, legendBounds.width, alignment);
	            legendBounds.y = rect.y + (rect.height - legendHeight) + padding + this.legend.margin.top;
	            legendBounds.y += (isBulletChart && !bulletChart.opposedPosition && !labelIns && !ticklIns
	                && !isVertical) ? bulletChart.majorTickLines.height + marginBottom + this.legend.border.width + padding * 2 :
	                (isVertical && bulletChart.categoryField !== '') ? maxLabelSize.height + padding * 2 : 0;
	            subtractThickness(rect, new Thickness(0, 0, 0, legendHeight));
	        }
	        else if (position === 'Top') {
	            var axisTextSize = void 0;
	            if (this.isChartControl) {
	                axisTextSize = measureText('100', this.chart.verticalAxes[0].labelStyle, this.chart.themeStyle.legendLabelFont);
	            }
	            legendBounds.x = this.alignLegend(legendBounds.x, availableSize.width, legendBounds.width, alignment);
	            legendBounds.y = rect.y + padding + this.legend.margin.top;
	            legendBounds.y -= (isBulletChart && bulletChart.opposedPosition && !labelIns && !ticklIns &&
	                !isVertical) ? bulletChart.majorTickLines.height + this.chart.margin.top : 0;
	            legendHeight -= (isBulletChart) ? -padding * 2 : (this.isChartControl ? -padding * 2 - axisTextSize.height / 2 : 0);
	            subtractThickness(rect, new Thickness(0, 0, legendHeight, 0));
	        }
	        else if (position === 'Right') {
	            legendBounds.x = rect.x + (rect.width - legendBounds.width) - this.legend.margin.right;
	            legendBounds.y = rect.y + this.alignLegend(0, availableSize.height - (rect.y + marginBottom), legendBounds.height, alignment);
	            legendWidth += (isBulletChart && bulletChart.opposedPosition && !labelIns && !ticklIns &&
	                isVertical) ? (this.chart.margin.left + this.chart.margin.right + bulletChart.majorTickLines.height) : 0;
	            subtractThickness(rect, new Thickness(0, legendWidth, 0, 0));
	        }
	        else if (position === 'Left') {
	            legendBounds.x = legendBounds.x + this.legend.margin.left;
	            legendBounds.y = rect.y + this.alignLegend(0, availableSize.height - (rect.y + marginBottom), legendBounds.height, alignment);
	            legendWidth += (isBulletChart && !bulletChart.opposedPosition && !labelIns && !ticklIns &&
	                isVertical) ? (legendBounds.x - this.chart.margin.left + padding + bulletChart.majorTickLines.height) :
	                (bulletChart.orientation !== 'Vertical' && bulletChart.categoryField !== '') ? categoryFieldValue : 0;
	            subtractThickness(rect, new Thickness(legendWidth, 0, 0, 0));
	        }
	        else {
	            legendBounds.x = this.legend.location.x;
	            legendBounds.y = this.legend.location.y;
	            subtractThickness(rect, new Thickness(0, 0, 0, 0));
	        }
	    };
	    /**
	     * To find legend alignment for chart and accumulation chart
	     *
	     * @param start
	     * @param size
	     * @param legendSize
	     * @param alignment
	     * @param start
	     * @param size
	     * @param legendSize
	     * @param alignment
	     * @param start
	     * @param size
	     * @param legendSize
	     * @param alignment
	     * @param start
	     * @param size
	     * @param legendSize
	     * @param alignment
	     */
	    BaseLegend.prototype.alignLegend = function (start, size, legendSize, alignment) {
	        switch (alignment) {
	            case 'Far':
	                start = (size - legendSize) - start;
	                break;
	            case 'Center':
	                start = ((size - legendSize) / 2);
	                break;
	        }
	        return start;
	    };
	    /**
	     * Renders the legend.
	     *
	     * @param chart
	     * @param legend
	     * @param legendBounds
	     * @param redraw
	     * @param chart
	     * @param legend
	     * @param legendBounds
	     * @param redraw
	     * @param chart
	     * @param legend
	     * @param legendBounds
	     * @param redraw
	     * @param chart
	     * @param legend
	     * @param legendBounds
	     * @param redraw
	     * @returns {void}
	     * @private
	     */
	    BaseLegend.prototype.renderLegend = function (chart, legend, legendBounds, redraw) {
	        var titleHeight = 0;
	        var titlePlusArrowWidth = 0;
	        var pagingLegendBounds = new Rect(0, 0, 0, 0);
	        var requireLegendBounds = new Rect(0, 0, 0, 0);
	        var firstLegend = this.findFirstLegendPosition(this.legendCollections);
	        var padding = legend.padding;
	        this.itemPadding = this.isBulletChartControl ? legend.padding : this.itemPadding;
	        var isPaging = legend.enablePages;
	        var titlePosition = legend.titlePosition;
	        var upArrowHeight = this.isPaging && !legend.enablePages && this.isVertical ? this.pageButtonSize : 0;
	        var legendGroup = chart.renderer.createGroup({ id: this.legendID + '_g' });
	        var legendTranslateGroup = this.createLegendElements(chart, legendBounds, legendGroup, legend, this.legendID, redraw);
	        this.legendRegions = [];
	        this.chartRowCount = 1;
	        var maxHeight = 0;
	        titleHeight = !this.isTitle ? 0 : (this.isTop || this.isVertical ? this.legendTitleSize.height : 0);
	        if (this.isChartControl || (this.isAccChartControl && !this.isVertical)) {
	            var pageCount = 1;
	            var rowHeights = this.rowHeights[0] + padding;
	            for (var i = 1; i < this.rowHeights.length; i++) {
	                if ((rowHeights + this.rowHeights[i] + padding) > (this.legendBounds.height - this.pageButtonSize - this.maxItemHeight / 2)) {
	                    this.pageHeights[pageCount - 1] = rowHeights + titleHeight;
	                    pageCount++;
	                    rowHeights = 0;
	                }
	                rowHeights += (this.rowHeights[i] + (this.isVertical ? this.itemPadding : padding));
	            }
	            this.pageHeights[pageCount - 1] = rowHeights + titleHeight;
	            this.totalPages = pageCount;
	        }
	        for (var i = 0; i < this.legendCollections.length; i++) {
	            if (this.legendCollections[i].text !== '') {
	                maxHeight = Math.max(this.legendCollections[i].textSize.height, maxHeight);
	                break;
	            }
	            else {
	                continue;
	            }
	        }
	        if (!this.isChartControl && !this.isAccChartControl) {
	            this.maxItemHeight = Math.max(maxHeight, legend.shapeHeight);
	        }
	        // For new legend navigation
	        if (!isPaging && this.isPaging && !this.isVertical) {
	            titlePlusArrowWidth = !this.isTitle ? 0 : titlePosition === 'Left' ? this.legendTitleSize.width : 0;
	            titlePlusArrowWidth += (this.pageButtonSize + (2 * this.fivePixel));
	        }
	        else if (this.isTitle && !this.isPaging && !this.isVertical) {
	            titlePlusArrowWidth = titlePosition === ((!this.isRtlEnable) ? 'Left' : 'Right') ? (this.fivePixel + this.legendTitleSize.width) : 0;
	        }
	        if (chart.legendSettings.mode === 'Gradient' && this.legendCollections.length > 1) {
	            this.getLinearLegend(legendBounds, chart, legend, legendTranslateGroup);
	            this.totalPages = 1;
	        }
	        else if (firstLegend !== this.legendCollections.length) {
	            var legendSeriesGroup = void 0; // legendItem group for each series group element
	            var count = 0;
	            var previousLegend = this.legendCollections[firstLegend];
	            // starting shape center x,y position && to resolve lint error used new line for declaration
	            var startPadding = this.isBulletChartControl ? 0 : titlePlusArrowWidth + padding + (legend.shapeWidth / 2) + legend.containerPadding.left;
	            var xLocation = this.isBulletChartControl ? legendBounds.x + titlePlusArrowWidth + padding + (legend.shapeWidth / 2) :
	                (!this.isRtlEnable) ? legendBounds.x + startPadding : legendBounds.x + ((this.chart.getModuleName() === 'accumulationchart' && this.isVertical) ? this.maxWidth : legendBounds.width) - startPadding;
	            var start = new ChartLocation(xLocation, this.isBulletChartControl ? legendBounds.y + titleHeight + upArrowHeight + padding + (this.maxItemHeight / 2) :
	                legendBounds.y + titleHeight + upArrowHeight + padding + (this.maxItemHeight / 2) + legend.containerPadding.top);
	            var anchor = chart.isRtlEnabled || chart.enableRtl ? 'end' : 'start';
	            var textOptions = new TextOption('', start.x, start.y, anchor);
	            var textPadding = legend.shapePadding + this.itemPadding + legend.shapeWidth;
	            //  initialization for totalPages legend click totalpage again calculate
	            this.totalPages = this.totalPages = (this.isAccChartControl || this.isChartControl || this.isBulletChartControl || this.isStockChartControl) ? this.totalPages : 0;
	            this.pageXCollections = [];
	            this.legendCollections[firstLegend].location = start;
	            var legendIndex = void 0;
	            if (!legend.enablePages && this.isPaging) {
	                var x = start.x - this.fivePixel;
	                var y = start.y - this.fivePixel;
	                var leftSpace = this.isTitle && !this.isVertical && titlePosition === 'Left' ?
	                    this.legendTitleSize.width + this.fivePixel : 0;
	                var bottomSapce = this.isVertical ? (this.pageButtonSize) + Math.abs(y - legendBounds.y) : 0;
	                var rightSpace = this.isTitle && !this.isVertical && titlePosition === 'Right' ?
	                    this.legendTitleSize.width + this.fivePixel : 0;
	                rightSpace += this.isVertical ? 0 : (this.fivePixel + this.pageButtonSize + this.fivePixel);
	                pagingLegendBounds = new Rect(x, y, legendBounds.width - rightSpace - leftSpace, legendBounds.height - bottomSapce);
	                requireLegendBounds = pagingLegendBounds;
	            }
	            else {
	                requireLegendBounds = legendBounds;
	            }
	            var legendOption = void 0;
	            for (var i = 0; i < this.legendCollections.length; i++) {
	                legendOption = this.legendCollections[i];
	                legendIndex = !this.isReverse ? count : (this.legendCollections.length - 1) - count;
	                if (this.chart.getModuleName() === 'accumulationchart') {
	                    legendOption.fill = (this.chart || this.chart || this.chart).visibleSeries[0].points[legendOption.pointIndex].color;
	                }
	                if (this.chart.getModuleName() === 'stockChart') {
	                    legendOption.type = this.chart.visibleSeries[count].type;
	                }
	                this.accessbilityText = (this.isBulletChartControl) ? 'Legend of bullet chart' + '' + legendOption.text
	                    : 'Click to show or hide the ' + legendOption.text + ' series';
	                if (legendOption.render && legendOption.text && legendOption.text !== '') {
	                    legendSeriesGroup = chart.renderer.createGroup({
	                        id: this.legendID + this.generateId(legendOption, '_g_', legendIndex)
	                    });
	                    if (legendSeriesGroup) {
	                        legendSeriesGroup.setAttribute('tabindex', i === 0 ? '0' : '');
	                        legendSeriesGroup.setAttribute('aria-label', legend.description || (legendOption.text + ' series is ' + (legendOption.visible ? 'showing, press enter to hide the ' : 'hidden, press enter to show the ') + legendOption.text + ' series'));
	                        legendSeriesGroup.setAttribute('aria-pressed', legendOption.visible ? 'true' : 'false');
	                    }
	                    this.library.getRenderPoint(legendOption, start, textPadding, previousLegend, requireLegendBounds, count, firstLegend);
	                    this.renderSymbol(legendOption, legendSeriesGroup, legendIndex);
	                    this.renderText(chart, legendOption, legendSeriesGroup, textOptions, count, legendIndex);
	                    if (legendSeriesGroup) {
	                        legendSeriesGroup.style.cssText =
	                            'pointer-events: bounding-box; cursor: ' + ((!legend.toggleVisibility && (chart.selectionMode === 'None' ||
	                                chart.highlightMode === 'None' ||
	                                chart.selectionMode === 'None') || this.isBulletChartControl) ? 'auto' : 'pointer');
	                    }
	                    if (legendTranslateGroup) {
	                        legendTranslateGroup.appendChild(legendSeriesGroup);
	                    }
	                    previousLegend = legendOption;
	                }
	                count++;
	            }
	            this.totalPages = (this.isPaging && !this.isBulletChartControl && !this.legend.enablePages && !this.isVertical &&
	                this.totalPages > this.chartRowCount) ? this.chartRowCount : this.totalPages;
	            if (this.isPaging && this.totalPages > 1) {
	                this.renderPagingElements(chart, legendBounds, textOptions, legendGroup);
	            }
	            else {
	                this.totalPages = 1;
	            }
	        }
	        appendChildElement(chart.enableCanvas, chart.svgObject, legendGroup, redraw);
	    };
	    /** @private */
	    BaseLegend.prototype.getLinearLegend = function (legendBounds, chart, legend, legendTranslateGroup) {
	        var xmlns = 'http://www.w3.org/2000/svg';
	        var previousLegend = this.legendCollections[0];
	        var nextLegend = this.legendCollections[1];
	        var defElement = this.chart.renderer.createDefs();
	        var gradientLegendCount = 0;
	        var linerGradientEle = document.createElementNS(xmlns, 'linearGradient');
	        var opacity = 1;
	        var fillColors = [];
	        var numberItems = [];
	        if (legend.title) {
	            if (!this.isVertical) {
	                if (legend.titlePosition === 'Left') {
	                    legendBounds.x += this.legendTitleSize.width;
	                    legendBounds.width -= this.legendTitleSize.width;
	                }
	                else if (legend.titlePosition === 'Right') {
	                    legendBounds.width -= this.legendTitleSize.width;
	                }
	                else if (legend.titlePosition === 'Top') {
	                    legendBounds.y += this.legendTitleSize.height;
	                    legendBounds.height -= this.legendTitleSize.height;
	                }
	            }
	            else {
	                legendBounds.y += this.legendTitleSize.height;
	                legendBounds.height -= this.legendTitleSize.height;
	            }
	        }
	        for (var _i = 0, _a = this.chart.rangeColorSettings; _i < _a.length; _i++) {
	            var colorMap = _a[_i];
	            if (numberItems.indexOf(colorMap.start) < 0) {
	                numberItems.push(colorMap.start);
	            }
	            if (colorMap.colors.length > 2) {
	                var diffValue = (colorMap.end - colorMap.start);
	                var colorsLength = colorMap.colors.length - 1;
	                if (diffValue > 0) {
	                    diffValue = diffValue / colorsLength;
	                    for (var index = 1; index < colorsLength; index++) {
	                        var calculatedValue = colorMap.start + (diffValue * index);
	                        numberItems.push(calculatedValue);
	                    }
	                }
	                else {
	                    for (var index = 1; index < colorsLength; index++) {
	                        numberItems.push(colorMap.start);
	                    }
	                }
	            }
	            if (numberItems.indexOf(colorMap.end) < 0) {
	                numberItems.push(colorMap.end);
	            }
	            for (var _b = 0, _c = colorMap.colors; _b < _c.length; _b++) {
	                var fillColor = _c[_b];
	                if (fillColors.indexOf(fillColor) < 0) {
	                    fillColors.push(fillColor);
	                }
	            }
	            if (colorMap.colors.length > 0 && colorMap.colors.length < 2) {
	                fillColors.push(colorMap.colors[0]);
	            }
	        }
	        var x1 = this.isRtlEnable && !this.isVertical ? '100%' : '0%';
	        var x2 = this.isVertical || this.isRtlEnable ? '0%' : '100%';
	        var y2 = this.isVertical ? '100%' : '0%';
	        linerGradientEle.setAttribute('id', this.generateId(previousLegend, 'linearGradient', gradientLegendCount));
	        linerGradientEle.setAttribute('x1', x1);
	        linerGradientEle.setAttribute('y1', '0%');
	        linerGradientEle.setAttribute('x2', x2);
	        linerGradientEle.setAttribute('y2', y2);
	        var full = numberItems[numberItems.length - 1] - numberItems[0];
	        for (var b = 0; b < fillColors.length; b++) {
	            var offsetValue = numberItems[b] - numberItems[0];
	            offsetValue = offsetValue / full;
	            var stopEle = document.createElementNS(xmlns, 'stop');
	            stopEle.setAttribute('offset', offsetValue.toString());
	            stopEle.setAttribute('stop-color', fillColors[b]);
	            stopEle.setAttribute('stop-opacity', opacity.toString());
	            linerGradientEle.appendChild(stopEle);
	        }
	        var startLabel = previousLegend.text.toString();
	        var endLabel = nextLegend.text.toString();
	        var startTextSize = measureText(startLabel, legend.textStyle, this.chart.themeStyle.legendLabelFont);
	        var endTextSize = measureText(endLabel, legend.textStyle, this.chart.themeStyle.legendLabelFont);
	        var textWidth = startTextSize.width > endTextSize.width ? startTextSize.width : endTextSize.width;
	        var textHeight = startTextSize.height > endTextSize.height ? startTextSize.height : endTextSize.height;
	        var otherSpaces = (2 * textWidth) + (4 * legend.padding);
	        var linearBarWidth = legendBounds.width;
	        var linearBarHeight = legendBounds.height;
	        var xValue = legendBounds.x + textWidth + (2 * legend.padding);
	        var yValue = legendBounds.y + legend.padding;
	        var startLabelY;
	        var endLabelY;
	        var startLabelX;
	        var endLabelX;
	        if (this.isVertical) {
	            otherSpaces = (2 * textHeight) + (4 * legend.padding);
	            linearBarWidth = legendBounds.width - (2 * legend.padding);
	            linearBarHeight = legendBounds.height - otherSpaces;
	            xValue = legendBounds.x + legend.padding;
	            yValue = legendBounds.y + textHeight + (2 * legend.padding);
	            startLabelY = legendBounds.y + legend.padding + textHeight;
	            endLabelY = yValue + linearBarHeight + textHeight;
	            startLabelX = (legendBounds.x + (legendBounds.width * 0.5)) - (textWidth * 0.5);
	            endLabelX = startLabelX;
	            if (linearBarWidth > 30) {
	                var diffWidth = linearBarWidth - 30;
	                linearBarWidth = 30;
	                xValue = xValue + (diffWidth / 2);
	            }
	        }
	        else {
	            linearBarWidth = legendBounds.width - otherSpaces;
	            linearBarHeight = legendBounds.height - (2 * legend.padding);
	            startLabelX = legendBounds.x + ((!this.isRtlEnable) ? legend.padding + (textWidth - startTextSize.width) :
	                linearBarWidth + (3 * legend.padding) + textWidth);
	            endLabelX = legendBounds.x + ((!this.isRtlEnable) ? linearBarWidth + (3 * legend.padding) + textWidth :
	                legend.padding + (textWidth - endTextSize.width));
	            startLabelY = legendBounds.y + (legendBounds.height * 0.5) + (textHeight * 0.25);
	            endLabelY = startLabelY;
	            if (linearBarHeight > 30) {
	                var diffHeight = linearBarHeight - 30;
	                linearBarHeight = 30;
	                yValue = yValue + (diffHeight / 2);
	            }
	        }
	        var anchor = chart.enableRtl ? 'end' : '';
	        var textOptions = new TextOption('', startLabelX, startLabelY, anchor, startLabel);
	        var hiddenColor = '#D3D3D3';
	        textOptions.id = this.legendID + this.generateId(previousLegend, '_text_', 1);
	        var fontcolor = previousLegend.visible ? legend.textStyle.color || chart.themeStyle.legendLabelFont.color : hiddenColor;
	        var isCanvas = this.isStockChartControl ? false : this.chart.enableCanvas;
	        textElement(chart.renderer, textOptions, legend.textStyle, fontcolor, legendTranslateGroup, false, false, false, false, 
	        // tslint:disable-next-line:align
	        null, this.currentPageNumber && isCanvas ?
	            new Rect(0, -this.translatePage(isCanvas, null, this.currentPageNumber - 1, this.currentPageNumber), 0, 0) : null, null, null, null, null, this.chart.themeStyle.legendLabelFont);
	        textOptions = new TextOption('', endLabelX, endLabelY, anchor, endLabel);
	        textOptions.id = this.legendID + this.generateId(previousLegend, '_text_', 2);
	        textElement(chart.renderer, textOptions, legend.textStyle, fontcolor, legendTranslateGroup, false, false, false, false, 
	        // tslint:disable-next-line:align
	        null, this.currentPageNumber && isCanvas ?
	            new Rect(0, -this.translatePage(isCanvas, null, this.currentPageNumber - 1, this.currentPageNumber), 0, 0) : null, null, null, null, null, this.chart.themeStyle.legendLabelFont);
	        var gradientLegend = chart.renderer.drawRectangle({
	            width: linearBarWidth,
	            height: linearBarHeight,
	            x: xValue,
	            y: yValue,
	            fill: 'url(#' + this.generateId(previousLegend, 'linearGradient', gradientLegendCount) + ')'
	        });
	        defElement.appendChild(linerGradientEle);
	        legendTranslateGroup.appendChild(defElement);
	        legendTranslateGroup.appendChild(gradientLegend);
	    };
	    /**
	     * To find first valid legend text index for chart and accumulation chart
	     *
	     * @param legendCollection
	     * @returns {number}
	     * @private
	     */
	    BaseLegend.prototype.findFirstLegendPosition = function (legendCollection) {
	        var count = 0;
	        for (var _i = 0, legendCollection_1 = legendCollection; _i < legendCollection_1.length; _i++) {
	            var legend = legendCollection_1[_i];
	            if (legend.render && legend.text && legend.text !== '') {
	                break;
	            }
	            count++;
	        }
	        return count;
	    };
	    /**
	     * To get the legend title text width and height.
	     *
	     * @param legend
	     * @param legendBounds
	     */
	    BaseLegend.prototype.calculateLegendTitle = function (legend, legendBounds) {
	        if (legend.title) {
	            this.isTop = legend.titlePosition === 'Top';
	            var padding = legend.titleStyle.textOverflow === 'Trim' ? 2 * legend.padding : 0;
	            if (this.isTop || this.isVertical) {
	                this.legendTitleCollections = getTitle(legend.title, legend.titleStyle, (legendBounds.width - padding), this.chart.themeStyle.legendTitleFont);
	            }
	            else {
	                this.legendTitleCollections[0] = textTrim(legend.maximumTitleWidth, legend.title, legend.titleStyle, this.chart.themeStyle.legendTitleFont);
	            }
	            var text = this.isTop ? legend.title : this.legendTitleCollections[0];
	            this.legendTitleSize = measureText(text, legend.titleStyle, this.chart.themeStyle.legendTitleFont);
	            this.legendTitleSize.height *= this.legendTitleCollections.length;
	        }
	        else {
	            this.legendTitleSize = new Size(0, 0);
	        }
	    };
	    /**
	     * Render the legend title
	     *
	     * @param chart
	     * @param legend
	     * @param legendBounds
	     * @param legendGroup
	     */
	    BaseLegend.prototype.renderLegendTitle = function (chart, legend, legendBounds, legendGroup) {
	        var padding = legend.padding;
	        var alignment = legend.titleStyle.textAlignment;
	        this.isTop = legend.titlePosition === 'Top';
	        var anchor = getTextAnchor(legend.titleStyle.textAlignment, chart.enableRtl);
	        var x = titlePositionX(legendBounds, legend.titleStyle);
	        anchor = this.isTop || this.isVertical ? anchor : (chart.enableRtl) ? 'end' : '';
	        x = alignment === 'Near' ? (x + padding) : alignment === 'Far' ? (x - padding) : x;
	        x = (this.isTop || this.isVertical) ? x : ((legendBounds.x) + (legend.titlePosition === 'Left' ? 5 :
	            (legendBounds.width - this.legendTitleSize.width - 5)));
	        var topPadding = (legendBounds.height / 2) + (this.legendTitleSize.height / 4);
	        var y = legendBounds.y + (!this.isTop && !this.isVertical ? topPadding :
	            (this.legendTitleSize.height / this.legendTitleCollections.length));
	        var legendTitleTextOptions = new TextOption(this.legendID + '_title', x, y, anchor, this.legendTitleCollections);
	        textElement(chart.renderer, legendTitleTextOptions, legend.titleStyle, legend.titleStyle.color || this.chart.themeStyle.legendTitleFont.color, legendGroup, null, null, null, null, null, null, null, null, null, null, this.chart.themeStyle.legendTitleFont);
	    };
	    /**
	     * To create legend rendering elements for chart and accumulation chart
	     *
	     * @param chart
	     * @param legendBounds
	     * @param legendGroup
	     * @param legend
	     * @param id
	     * @param redraw
	     */
	    BaseLegend.prototype.createLegendElements = function (chart, legendBounds, legendGroup, legend, id, redraw) {
	        var padding = legend.padding;
	        var options = new RectOption(id + '_element', legend.background, legend.border, legend.opacity, legendBounds);
	        var legendItemsGroup = chart.renderer.createGroup({ id: id + '_collections' });
	        var isCanvas = this.isStockChartControl ? false : chart.enableCanvas;
	        var clippath = chart.renderer.createClipPath({ id: id + '_clipPath' });
	        options.width = (this.isRtlEnable && this.chart.getModuleName() === 'accumulationchart' && this.isVertical) ? this.maxWidth : legendBounds.width;
	        if (legendGroup) {
	            legendGroup.appendChild(chart.renderer.drawRectangle(options));
	        }
	        else {
	            chart.renderer.drawRectangle(options);
	        }
	        if (legend.title) {
	            this.renderLegendTitle(chart, legend, legendBounds, legendGroup);
	        }
	        if (!isCanvas) {
	            legendGroup.appendChild(legendItemsGroup);
	        }
	        this.legendTranslateGroup = chart.renderer.createGroup({ id: id + '_translate_g' });
	        if (!isCanvas) {
	            legendItemsGroup.appendChild(this.legendTranslateGroup);
	        }
	        options.y += (this.isTop ? this.legendTitleSize.height : 0);
	        options.id += '_clipPath_rect';
	        options.width = ((!this.isChartControl && chart.getModuleName() !== 'bulletChart' && !this.isStockChartControl) && this.isVertical) ? this.maxWidth - padding + legend.containerPadding.left + legend.containerPadding.right
	            : legendBounds.width;
	        if (!isCanvas) {
	            this.clipRect = chart.renderer.drawRectangle(options);
	            clippath.appendChild(this.clipRect);
	        }
	        else {
	            this.pagingClipRect = options;
	        }
	        appendChildElement(isCanvas, chart.svgObject, clippath, redraw);
	        if (!isCanvas) {
	            legendItemsGroup.style.cssText = 'clip-path:url(#' + clippath.id + ')';
	        }
	        return this.legendTranslateGroup;
	    };
	    /**
	     * To render legend symbols for chart and accumulation chart
	     *
	     * @param legendOption
	     * @param group
	     * @param i
	     * @param legendOption
	     * @param group
	     * @param i
	     * @param legendOption
	     * @param group
	     * @param i
	     */
	    BaseLegend.prototype.renderSymbol = function (legendOption, group, legendIndex) {
	        var control = this.isBulletChartControl ? this.chart : null;
	        var symbolColor = legendOption.visible ? legendOption.fill : '#D3D3D3';
	        var isStrokeWidth = (this.chart.getModuleName() === 'chart' || this.chart.getModuleName() === 'stockChart') && (((legendOption.shape === 'SeriesType') &&
	            (legendOption.type.toLowerCase().indexOf('line') > -1) && (legendOption.type.toLowerCase().indexOf('area') === -1)) ||
	            ((legendOption.shape === 'HorizontalLine') || (legendOption.shape === 'VerticalLine') || (legendOption.shape === 'Cross')));
	        var isCustomBorder = (this.chart.getModuleName() === 'chart' || this.chart.getModuleName() === 'stockChart') &&
	            (legendOption.type === 'Scatter' || legendOption.type === 'Bubble');
	        var isCanvas = this.isStockChartControl ? false : this.chart.enableCanvas;
	        var borderColor;
	        var shape = (legendOption.shape === 'SeriesType') ? legendOption.type : legendOption.shape;
	        var strokewidth = isStrokeWidth ? (this.legend.mode === 'Series' ?
	            this.chart.visibleSeries[legendIndex].width : this.chart.visibleSeries[0].width) :
	            (this.isBulletChartControl && legendOption.shape === 'Multiply') ? 4 : 1;
	        var regionPadding;
	        shape = shape === 'Scatter' ? legendOption.markerShape : shape;
	        if (isCustomBorder && legendIndex < this.chart.visibleSeries.length) {
	            var series = this.chart.visibleSeries[legendIndex];
	            var seriesBorder = series.border;
	            var isLineShapemarker = shape === 'HorizontalLine' || shape === 'VerticalLine';
	            borderColor = isLineShapemarker ? symbolColor : seriesBorder.color ? seriesBorder.color : symbolColor;
	            strokewidth = isLineShapemarker ? series.width : seriesBorder.width ? seriesBorder.width : 1;
	        }
	        var symbolOption = new PathOption(this.legendID + this.generateId(legendOption, '_shape_', legendIndex), symbolColor, strokewidth, (isCustomBorder ? borderColor : symbolColor), this.legend.opacity, legendOption.dashArray, '');
	        var textSize = measureText(legendOption.text, this.legend.textStyle, this.chart.themeStyle.legendLabelFont);
	        var x = this.legend.isInversed && !this.isRtlEnable ? legendOption.location.x + textSize.width + this.legend.shapePadding
	            : legendOption.location.x;
	        var y = legendOption.location.y;
	        if (!isCanvas) {
	            group.appendChild(drawSymbol({ x: x, y: y }, shape, new Size(this.legend.shapeWidth, this.legend.shapeHeight), legendOption.url, symbolOption, this.accessbilityText, this.chart.renderer, null, this.isBulletChartControl, control));
	        }
	        else {
	            regionPadding = -this.translatePage(isCanvas, null, this.currentPageNumber - 1, this.currentPageNumber);
	            drawSymbol({ x: x, y: y }, shape, new Size(this.legend.shapeWidth, this.legend.shapeHeight), '', symbolOption, this.accessbilityText, this.chart.renderer, this.currentPageNumber ? new Rect(0, regionPadding, 0, 0) : null, this.isBulletChartControl, control);
	            this.legendRegions.push({
	                rect: new Rect(legendOption.location.x, legendOption.location.y, this.legend.shapeWidth, this.legend.shapeHeight + regionPadding), index: legendIndex
	            });
	        }
	        if (shape === 'Line' && legendOption.markerVisibility && legendOption.markerShape !== 'Image' ||
	            (legendOption.type === 'Doughnut' && shape === 'Doughnut')) {
	            symbolOption.id = this.legendID + this.generateId(legendOption, '_shape_marker_', legendIndex);
	            shape = legendOption.type === 'Doughnut' ? 'Circle' : legendOption.markerShape;
	            symbolOption.fill = legendOption.type === 'Doughnut' ? '#FFFFFF' : symbolOption.fill;
	            if (!isCanvas) {
	                group.appendChild(drawSymbol({ x: x, y: y }, shape, new Size(this.legend.shapeWidth / 2, this.legend.shapeHeight / 2), '', symbolOption, this.accessbilityText, null, null, this.isBulletChartControl, control));
	            }
	            else {
	                drawSymbol({ x: x, y: y }, shape, new Size(this.legend.shapeWidth / 2, this.legend.shapeHeight / 2), '', symbolOption, this.accessbilityText, this.chart.renderer, this.currentPageNumber ?
	                    new Rect(0, -this.translatePage(isCanvas, null, this.currentPageNumber - 1, this.currentPageNumber), 0, 0) : null, this.isBulletChartControl, control);
	            }
	        }
	    };
	    /**
	     * To render legend text for chart and accumulation chart
	     *
	     * @param chart
	     * @param legendOption
	     * @param group
	     * @param textOptions
	     * @param i
	     * @param chart
	     * @param legendOption
	     * @param group
	     * @param textOptions
	     * @param i
	     * @param chart
	     * @param legendOption
	     * @param group
	     * @param textOptions
	     * @param i
	     * @param chart
	     * @param legendOption
	     * @param group
	     * @param textOptions
	     * @param i
	     * @param chart
	     * @param legendOption
	     * @param group
	     * @param textOptions
	     * @param i
	     */
	    BaseLegend.prototype.renderText = function (chart, legendOption, group, textOptions, i, legendIndex) {
	        var legend = chart.legendSettings;
	        var hiddenColor = '#D3D3D3';
	        var fontcolor = legendOption.visible ? legend.textStyle.color || chart.themeStyle.legendLabelFont.color : hiddenColor;
	        var isCanvas = this.isStockChartControl ? false : this.chart.enableCanvas;
	        textOptions.id = this.legendID + this.generateId(legendOption, '_text_', legendIndex);
	        textOptions.text = legendOption.textCollection.length > 0 ? legendOption.textCollection : legendOption.text;
	        if (legend.isInversed && !this.isRtlEnable) {
	            textOptions.x = legendOption.location.x - (legend.shapeWidth / 2);
	        }
	        else if (this.isRtlEnable) {
	            textOptions.x = legendOption.location.x - (measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont).width + legend.shapeWidth / 2 + legend.shapePadding);
	        }
	        else {
	            textOptions.x = legendOption.location.x + (legend.shapeWidth / 2) + legend.shapePadding;
	        }
	        textOptions.y = legendOption.location.y + this.maxItemHeight / 4;
	        textElement(chart.renderer, textOptions, legend.textStyle, fontcolor, group, false, false, false, false, null, this.currentPageNumber && isCanvas ?
	            new Rect(0, -this.translatePage(isCanvas, null, this.currentPageNumber - 1, this.currentPageNumber), 0, 0) : null, null, null, null, null, this.chart.themeStyle.legendLabelFont);
	        if (isCanvas) {
	            var textSize = measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);
	            this.legendRegions[i].rect.y = textOptions.y < this.legendRegions[i].rect.y ? textOptions.y : this.legendRegions[i].rect.y;
	            this.legendRegions[i].rect.width += textSize.width;
	            this.legendRegions[i].rect.height = textSize.height;
	            this.legendRegions[i].rect.y -= textSize.height * 0.5;
	            this.legendRegions[i].rect.x -= (this.isRtlEnable) ? this.legendRegions[i].rect.width : 0;
	        }
	    };
	    /**
	     * To render legend paging elements for chart and accumulation chart
	     *
	     * @param chart
	     * @param bounds
	     * @param textOption
	     * @param legendGroup
	     * @param chart
	     * @param bounds
	     * @param textOption
	     * @param legendGroup
	     * @param chart
	     * @param bounds
	     * @param textOption
	     * @param legendGroup
	     * @param chart
	     * @param bounds
	     * @param textOption
	     * @param legendGroup
	     */
	    // tslint:disable-next-line:max-func-body-length
	    BaseLegend.prototype.renderPagingElements = function (chart, bounds, textOption, legendGroup) {
	        var paginggroup = chart.renderer.createGroup({ id: this.legendID + '_navigation' });
	        var isCanvas = this.isStockChartControl ? false : chart.enableCanvas;
	        var titleHeight = this.isBulletChartControl ? 0 : this.legendTitleSize.height;
	        var grayColor = (this.chart.theme.indexOf('Dark') > -1 || this.chart.theme.indexOf('Contrast') > -1) ? '#FFFFFF' : '#545454';
	        var legend = chart.legendSettings; // to solve parameter lint error, legend declaration is here
	        var padding = 8; // const padding for paging elements
	        var pageUp = this.legendID + (!this.isRtlEnable ? '_pageup' : '_pagedown');
	        var pageDown = this.legendID + (!this.isRtlEnable ? '_pagedown' : '_pageup');
	        var symbolOption = new PathOption(pageUp, 'transparent', 5, grayColor, 1, '', '');
	        var iconSize = this.pageButtonSize;
	        // Page left arrow drawing calculation started here
	        var rowCount = !legend.enablePages && this.isPaging && !this.isVertical && !this.isBulletChartControl ? 1 :
	            (this.rowCount - 1);
	        var titleWidth = this.isTitle && legend.titlePosition === 'Left' ? this.legendTitleSize.width : 0;
	        this.pagingRegions = [];
	        this.backwardArrowOpacity = this.currentPage !== 1 ? 1 : 0;
	        this.forwardArrowOpacity = this.currentPage === this.totalPages ? 0 : 1;
	        if (!isCanvas) {
	            legendGroup.appendChild(paginggroup);
	        }
	        if (!this.isChartControl && !this.isAccChartControl) {
	            if (this.isBulletChartControl || this.isStockChartControl || !this.isVertical) {
	                this.totalPages = Math.ceil(this.totalPages / Math.max(1, this.rowCount - 1));
	            }
	            else {
	                this.totalPages = Math.ceil(this.totalPages / this.maxColumns);
	            }
	        }
	        if (paginggroup) {
	            paginggroup.style.cursor = 'pointer';
	        }
	        if ((this.isChartControl || this.isAccChartControl) && !(!legend.enablePages && this.isPaging)) {
	            this.clipPathHeight = this.pageHeights[0];
	        }
	        else {
	            this.clipPathHeight = (rowCount * (this.maxItemHeight + legend.padding));
	        }
	        //this.clipPathHeight = !(this.isChartControl) ? (rowCount * (this.maxItemHeight + legend.padding)) : this.columnHeights[0];
	        if (!isCanvas) {
	            this.clipRect.setAttribute('height', this.clipPathHeight.toString());
	        }
	        else {
	            //paging clipRect only for canvas mode
	            this.pagingClipRect.height = this.legendBounds.height - this.clipPathHeight -
	                (this.pagingClipRect.y - this.legendBounds.y) - legend.border.width;
	            this.pagingClipRect.y = this.pagingClipRect.y + this.clipPathHeight;
	            this.pagingClipRect.x += legend.border.width;
	            this.pagingClipRect.width -= (legend.border.width + legend.border.width / 2);
	            this.chart.renderer.clearRect(new Rect(this.pagingClipRect.x, this.pagingClipRect.y, this.pagingClipRect.width, this.pagingClipRect.height));
	        }
	        var pageTextElement;
	        var x = (bounds.x + iconSize / 2);
	        var y = bounds.y + this.clipPathHeight + ((titleHeight + bounds.height - this.clipPathHeight) / 2);
	        if (this.isPaging && !legend.enablePages && !this.isVertical && !this.isBulletChartControl) {
	            x = (bounds.x + this.pageButtonSize + titleWidth);
	            y = legend.title && this.isTop ? (bounds.y + padding + titleHeight + (iconSize / 1) + 0.5) :
	                (bounds.y + padding + iconSize + 0.5);
	        }
	        var size = measureText(this.totalPages + '/' + this.totalPages, legend.textStyle, this.chart.themeStyle.legendLabelFont);
	        var translateX = (this.isRtlEnable) ? legend.border.width + (iconSize / 2) : bounds.width - (2 * (iconSize + padding) + padding + size.width);
	        if (!isCanvas) {
	            if (this.isVertical && !legend.enablePages && !this.isBulletChartControl) {
	                x = bounds.x + (bounds.width / 2);
	                y = bounds.y + (iconSize / 2) + (padding / 2) + titleHeight;
	                symbolOption.opacity = this.backwardArrowOpacity;
	                paginggroup.appendChild(drawSymbol({ x: x, y: y }, 'UpArrow', new Size(iconSize, iconSize), '', symbolOption));
	            }
	            else {
	                symbolOption.opacity = this.isBulletChartControl ? symbolOption.opacity :
	                    (legend.enablePages ? 1 : !this.isRtlEnable ? this.backwardArrowOpacity : this.forwardArrowOpacity);
	                paginggroup.appendChild(drawSymbol({ x: x, y: y }, 'LeftArrow', new Size(iconSize, iconSize), '', symbolOption));
	            }
	        }
	        else {
	            drawSymbol({ x: x, y: y }, 'LeftArrow', new Size(iconSize, iconSize), '', symbolOption, 'LeftArrow', this.chart.renderer, new Rect(translateX, 0, 0, 0));
	        }
	        this.pagingRegions.push(new Rect(!this.isRtlEnable ? x + bounds.width - (2 * (iconSize + padding) + padding + size.width) - iconSize * 0.5 : x, y - iconSize * 0.5, iconSize, iconSize));
	        // Page numbering rendering calculation started here
	        textOption.x = x + (iconSize / 2) + padding;
	        textOption.y = y + (size.height / 4);
	        textOption.id = this.legendID + '_pagenumber';
	        textOption.text = !this.isRtlEnable ? '1/' + this.totalPages : this.totalPages + '/1';
	        var color = (this.chart.theme.indexOf('Dark') > -1 || this.chart.theme.indexOf('Contrast') > -1) ? '#FFFFFF' : legend.textStyle.color || this.chart.themeStyle.legendLabelFont.color;
	        if (isCanvas && this.totalNoOfPages) {
	            textOption.text = !this.isRtlEnable ? this.currentPageNumber + '/' + this.totalNoOfPages : this.totalNoOfPages + '/' + this.currentPageNumber;
	        }
	        if (legend.enablePages || this.isBulletChartControl) {
	            pageTextElement = textElement(chart.renderer, textOption, legend.textStyle, color, paginggroup, false, false, false, false, null, new Rect(translateX, 0, 0, 0), null, null, null, null, this.chart.themeStyle.legendLabelFont);
	        }
	        // Page right arrow rendering calculation started here
	        x = textOption.x + padding + (iconSize / 2) + size.width;
	        if (this.isPaging && !legend.enablePages && !this.isVertical) {
	            x = (bounds.x + bounds.width - (this.isBulletChartControl ? this.fivePixel : 0) - this.pageButtonSize - (legend.title && legend.titlePosition === 'Right' ?
	                this.legendTitleSize.width + this.fivePixel : 0));
	        }
	        symbolOption.id = pageDown;
	        symbolOption.opacity = !legend.enablePages ? !this.isRtlEnable ? this.forwardArrowOpacity : this.backwardArrowOpacity : 1;
	        if (!isCanvas) {
	            if (this.isVertical && !legend.enablePages && !this.isBulletChartControl) {
	                x = bounds.x + (bounds.width / 2);
	                y = bounds.y + bounds.height - (iconSize / 2);
	                paginggroup.appendChild(drawSymbol({ x: x, y: y }, 'DownArrow', new Size(iconSize, iconSize), '', symbolOption));
	            }
	            else {
	                paginggroup.appendChild(drawSymbol({ x: x, y: y }, 'RightArrow', new Size(iconSize, iconSize), '', symbolOption));
	            }
	        }
	        else {
	            drawSymbol({ x: x, y: y }, 'RightArrow', new Size(iconSize, iconSize), '', symbolOption, 'RightArrow', this.chart.renderer, new Rect(translateX, 0, 0, 0));
	        }
	        this.pagingRegions.push(new Rect(!this.isRtlEnable ? x + (bounds.width - (2 * (iconSize + padding) + padding + size.width) - iconSize * 0.5) : x, y - iconSize * 0.5, iconSize, iconSize));
	        if (!isCanvas && (legend.enablePages || this.isBulletChartControl)) {
	            //placing the navigation buttons and page numbering in legend right corner
	            paginggroup.setAttribute('transform', 'translate(' + translateX + ', ' + 0 + ')');
	        }
	        else {
	            if (this.currentPageNumber === 1 && this.calTotalPage && (legend.enablePages || this.isBulletChartControl)) {
	                this.totalNoOfPages = this.totalPages;
	                this.calTotalPage = false;
	            }
	            if (!legend.enablePages && !this.isBulletChartControl) { // For new legend page navigation
	                this.translatePage(isCanvas, null, this.currentPage - 1, this.currentPage, legend);
	            }
	        }
	        if (legend.enablePages || this.isBulletChartControl) {
	            this.translatePage(isCanvas, pageTextElement, this.currentPage - 1, this.currentPage, legend);
	        }
	    };
	    BaseLegend.prototype.getPageHeight = function (pageHeights, pageCount) {
	        var sum = 0;
	        for (var i = 0; i < pageCount; i++) {
	            sum += pageHeights[i];
	        }
	        return sum;
	    };
	    /**
	     * To translate legend pages for chart and accumulation chart
	     *
	     * @param pagingText
	     * @param page
	     * @param pageNumber
	     * @param legend
	     * @param pagingText
	     * @param page
	     * @param pageNumber
	     * @param legend
	     * @param pagingText
	     * @param page
	     * @param pageNumber
	     * @param legend
	     * @param pagingText
	     * @param page
	     * @param pageNumber
	     * @param legend
	     */
	    BaseLegend.prototype.translatePage = function (isCanvas, pagingText, page, pageNumber, legend) {
	        var size = (this.isChartControl || this.isAccChartControl) ? (page ? this.getPageHeight(this.pageHeights, page) : 0) : ((this.clipPathHeight) * page);
	        if (!isCanvas && (this.isChartControl || this.isAccChartControl)) {
	            this.clipRect.setAttribute('height', this.pageHeights[page].toString());
	            if (this.isAccChartControl && this.isPaging && !legend.enablePages && this.isVertical) {
	                this.clipRect.setAttribute('height', this.legendBounds.height.toString());
	            }
	        }
	        var translate = 'translate(0,-' + size + ')';
	        if (!this.isChartControl && !this.isBulletChartControl && !this.isStockChartControl && this.isVertical) {
	            var pageX = this.pageXCollections[page * this.maxColumns];
	            size = (!this.isRtlEnable) ? pageX - this.legendBounds.x : (this.legendBounds.x + this.maxWidth) - pageX;
	            size = size < 0 ? 0 : size; // to avoid small pixel variation
	            translate = ((!this.isRtlEnable) ? 'translate(-' : 'translate(') + size + ',0)';
	        }
	        if (!this.chart.enableCanvas) {
	            this.legendTranslateGroup.setAttribute('transform', translate);
	        }
	        if (!this.chart.enableCanvas && (legend.enablePages || this.isBulletChartControl)) {
	            pagingText.textContent = !this.isRtlEnable ? (pageNumber) + '/' + this.totalPages : this.totalPages + '/' + pageNumber;
	        }
	        this.currentPage = pageNumber;
	        return size;
	    };
	    /**
	     * To change legend pages for chart and accumulation chart
	     *
	     * @param event
	     * @param pageUp
	     * @param event
	     * @param pageUp
	     */
	    BaseLegend.prototype.changePage = function (event, pageUp) {
	        var legend = this.chart.legendSettings;
	        var backwardArrow = document.getElementById(this.legendID + '_pageup');
	        var forwardArrow = document.getElementById(this.legendID + '_pagedown');
	        var isCanvas = this.isStockChartControl ? false : this.chart.enableCanvas;
	        var pageText = (legend.enablePages || this.isBulletChartControl) ?
	            document.getElementById(this.legendID + '_pagenumber') : null;
	        var page = (legend.enablePages || this.isBulletChartControl) ? parseInt(pageText.textContent.split('/')[!this.isRtlEnable ? 0 : 1], 10) :
	            this.currentPage;
	        if (pageUp && page > 1) {
	            this.translatePage(isCanvas, pageText, (page - 2), (page - 1), legend);
	        }
	        else if (!pageUp && page < this.totalPages) {
	            this.translatePage(isCanvas, pageText, page, (page + 1), legend);
	        }
	        if (this.isPaging && !legend.enablePages && !this.isBulletChartControl) {
	            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
	            this.currentPage === this.totalPages ? this.hideArrow(forwardArrow) : this.showArrow(forwardArrow);
	            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
	            this.currentPage === 1 ? this.hideArrow(backwardArrow) : this.showArrow(backwardArrow);
	        }
	    };
	    /**
	     * To hide the backward and forward arrow
	     *
	     * @param arrowElement
	     */
	    BaseLegend.prototype.hideArrow = function (arrowElement) {
	        arrowElement.setAttribute('opacity', '0');
	    };
	    /**
	     * To show the  backward and forward arrow
	     *
	     * @param arrowElement
	     */
	    BaseLegend.prototype.showArrow = function (arrowElement) {
	        arrowElement.setAttribute('opacity', '1');
	    };
	    /**
	     * To find legend elements id based on chart or accumulation chart
	     *
	     * @param option
	     * @param prefix
	     * @param count
	     * @param option
	     * @param prefix
	     * @param count
	     * @param option
	     * @param prefix
	     * @param count
	     * @private
	     */
	    BaseLegend.prototype.generateId = function (option, prefix, count) {
	        if (this.isChartControl || this.isStockChartControl) {
	            return prefix + count;
	        }
	        else {
	            return prefix + option.pointIndex;
	        }
	    };
	    /**
	     * To show or hide trimmed text tooltip for legend.
	     *
	     * @param event
	     * @returns {void}
	     * @private
	     */
	    BaseLegend.prototype.move = function (event) {
	        var _this = this;
	        var x = this.chart.mouseX;
	        var y = this.chart.mouseY;
	        if (event.target.textContent.indexOf('...') > -1) {
	            var targetId = event.target.id.split(this.legendID + '_text_');
	            if (targetId.length === 2) {
	                var index = parseInt(targetId[1], 10);
	                var element = this.chart.element;
	                if (!isNaN(index)) {
	                    if (this.chart.isTouch) {
	                        removeElement(this.chart.element.id + '_EJ2_Legend_Tooltip');
	                    }
	                    if (this.isChartControl) {
	                        showTooltip(this.chart.series[index].name, x, y, element.offsetWidth, element.id + '_EJ2_Legend_Tooltip', getElement(this.chart.element.id + '_Secondary_Element'));
	                    }
	                    else {
	                        showTooltip(this.chart.visibleSeries[0].points[index].x.toString(), x + 10, y + 10, element.offsetWidth, element.id + '_EJ2_Legend_Tooltip', getElement(this.chart.element.id + '_Secondary_Element'));
	                    }
	                }
	            }
	        }
	        else {
	            removeElement(this.chart.element.id + '_EJ2_Legend_Tooltip');
	        }
	        if (this.chart.isTouch) {
	            clearTimeout(this.clearTooltip);
	            this.clearTooltip = +setTimeout(function () { removeElement(_this.chart.element.id + '_EJ2_Legend_Tooltip'); }, 1000);
	        }
	    };
	    return BaseLegend;
	}());
	/**
	 * Class for legend options
	 *
	 * @private
	 */
	var LegendOptions = /** @class */ (function () {
	    function LegendOptions(text, fill, shape, visible, type, url, markerShape, markerVisibility, pointIndex, seriesIndex, dashArray) {
	        this.location = { x: 0, y: 0 };
	        this.textCollection = [];
	        this.text = text;
	        this.fill = fill;
	        this.shape = shape;
	        this.url = url;
	        this.visible = visible;
	        this.type = type;
	        this.markerVisibility = markerVisibility;
	        this.markerShape = markerShape;
	        this.pointIndex = pointIndex;
	        this.seriesIndex = seriesIndex;
	        this.dashArray = dashArray;
	    }
	    return LegendOptions;
	}());

	var __extends$s = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	/**
	 * Defines how to represent the market trend using technical indicators
	 */
	var TechnicalIndicator = /** @class */ (function (_super) {
	    __extends$s(TechnicalIndicator, _super);
	    function TechnicalIndicator() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /** @private */
	        _this.clipRect = new Rect(0, 0, 0, 0);
	        return _this;
	    }
	    /** @private */
	    TechnicalIndicator.prototype.setDataSource = function (series, chart) {
	        if (series) {
	            this.xData = series.xData;
	            this.yData = series.yData;
	            this.points = series.points;
	        }
	        var type = firstToLowerCase(this.type);
	        if (this.visible) {
	            chart[type + 'IndicatorModule'].initDataSource(this, chart);
	        }
	        chart.visibleSeriesCount += this.targetSeries.length;
	    };
	    __decorate$1([
	        Property('Sma')
	    ], TechnicalIndicator.prototype, "type", void 0);
	    __decorate$1([
	        Property(14)
	    ], TechnicalIndicator.prototype, "period", void 0);
	    __decorate$1([
	        Property(14)
	    ], TechnicalIndicator.prototype, "kPeriod", void 0);
	    __decorate$1([
	        Property(3)
	    ], TechnicalIndicator.prototype, "dPeriod", void 0);
	    __decorate$1([
	        Property(80)
	    ], TechnicalIndicator.prototype, "overBought", void 0);
	    __decorate$1([
	        Property(20)
	    ], TechnicalIndicator.prototype, "overSold", void 0);
	    __decorate$1([
	        Property(2)
	    ], TechnicalIndicator.prototype, "standardDeviation", void 0);
	    __decorate$1([
	        Property('Close')
	    ], TechnicalIndicator.prototype, "field", void 0);
	    __decorate$1([
	        Property(12)
	    ], TechnicalIndicator.prototype, "slowPeriod", void 0);
	    __decorate$1([
	        Property(26)
	    ], TechnicalIndicator.prototype, "fastPeriod", void 0);
	    __decorate$1([
	        Property(true)
	    ], TechnicalIndicator.prototype, "showZones", void 0);
	    __decorate$1([
	        Complex({ color: '#ff9933', width: 2 }, Connector)
	    ], TechnicalIndicator.prototype, "macdLine", void 0);
	    __decorate$1([
	        Property('Both')
	    ], TechnicalIndicator.prototype, "macdType", void 0);
	    __decorate$1([
	        Property('#2ecd71')
	    ], TechnicalIndicator.prototype, "macdPositiveColor", void 0);
	    __decorate$1([
	        Property('#e74c3d')
	    ], TechnicalIndicator.prototype, "macdNegativeColor", void 0);
	    __decorate$1([
	        Property('rgba(211,211,211,0.25)')
	    ], TechnicalIndicator.prototype, "bandColor", void 0);
	    __decorate$1([
	        Complex({ color: '#ffb735', width: 1 }, Connector)
	    ], TechnicalIndicator.prototype, "upperLine", void 0);
	    __decorate$1([
	        Complex({ color: '#f2ec2f', width: 1 }, Connector)
	    ], TechnicalIndicator.prototype, "lowerLine", void 0);
	    __decorate$1([
	        Complex({ color: '#f2ec2f', width: 1 }, Connector)
	    ], TechnicalIndicator.prototype, "periodLine", void 0);
	    __decorate$1([
	        Property('')
	    ], TechnicalIndicator.prototype, "seriesName", void 0);
	    return TechnicalIndicator;
	}(SeriesBase));

	/**
	 * @private
	 * @hidden
	 */
	function defaultToString(item) {
	    // if (item === null) {
	    //     return 'COLLECTION_NULL';
	    // } else if (typeof item === 'undefined') {
	    //     return 'COLLECTION_UNDEFINED';
	    // } else if (Object.prototype.toString.call(item) === '[object String]') {
	    if (Object.prototype.toString.call(item) === '[object String]') {
	        return '$s' + item;
	    }
	    else {
	        return '$o' + item.toString();
	    }
	}

	/**
	 * Dictionary.ts class for EJ2-PDF
	 * @private
	 * @hidden
	 */
	/**
	 * @private
	 * @hidden
	 */
	var Dictionary = /** @class */ (function () {
	    /**
	     * @private
	     * @hidden
	     */
	    function Dictionary(toStringFunction) {
	        this.table = {};
	        this.nElements = 0;
	        this.toStr = toStringFunction || defaultToString;
	    }
	    /**
	     * @private
	     * @hidden
	     */
	    Dictionary.prototype.getValue = function (key) {
	        var pair = this.table['$' + this.toStr(key)];
	        if (typeof pair === 'undefined') {
	            return undefined;
	        }
	        return pair.value;
	    };
	    /**
	     * @private
	     * @hidden
	     */
	    Dictionary.prototype.setValue = function (key, value) {
	        // if (typeof key === 'undefined' || typeof value === 'undefined') {
	        //     return undefined;
	        // }
	        var ret;
	        var k = '$' + this.toStr(key);
	        this.table[k];
	        // if (typeof previousElement === 'undefined') {
	        this.nElements++;
	        ret = undefined;
	        // }
	        this.table[k] = {
	            key: key,
	            value: value
	        };
	        return ret;
	    };
	    /**
	     * @private
	     * @hidden
	     */
	    Dictionary.prototype.remove = function (key) {
	        var k = '$' + this.toStr(key);
	        var previousElement = this.table[k];
	        // if (typeof previousElement !== 'undefined') {
	        delete this.table[k];
	        this.nElements--;
	        return previousElement.value;
	        // }
	        // return undefined;
	    };
	    /**
	     * @private
	     * @hidden
	     */
	    Dictionary.prototype.keys = function () {
	        var keysArray = [];
	        var namesOfKeys = Object.keys(this.table);
	        for (var index1 = 0; index1 < namesOfKeys.length; index1++) {
	            // if (Object.prototype.hasOwnProperty.call(this.table, namesOfKeys[index1])) {
	            var pair1 = this.table[namesOfKeys[index1]];
	            keysArray.push(pair1.key);
	            // }
	        }
	        return keysArray;
	    };
	    /**
	     * @private
	     * @hidden
	     */
	    Dictionary.prototype.values = function () {
	        var valuesArray = [];
	        var namesOfValues = Object.keys(this.table);
	        for (var index2 = 0; index2 < namesOfValues.length; index2++) {
	            // if (Object.prototype.hasOwnProperty.call(this.table, namesOfValues[index2])) {
	            var pair2 = this.table[namesOfValues[index2]];
	            valuesArray.push(pair2.value);
	            // }
	        }
	        return valuesArray;
	    };
	    /**
	     * @private
	     * @hidden
	     */
	    Dictionary.prototype.containsKey = function (key) {
	        var retutnValue = true;
	        if (typeof this.getValue(key) === 'undefined') {
	            retutnValue = true;
	        }
	        else {
	            retutnValue = false;
	        }
	        return !retutnValue;
	    };
	    /**
	     * @private
	     * @hidden
	     */
	    Dictionary.prototype.clear = function () {
	        this.table = {};
	        this.nElements = 0;
	    };
	    /**
	     * @private
	     * @hidden
	     */
	    Dictionary.prototype.size = function () {
	        return this.nElements;
	    };
	    return Dictionary;
	}()); // End of dictionary

	/**
	 * `PdfName` class is used to perform name (element names) related primitive operations.
	 * @private
	 */
	var PdfName = /** @class */ (function () {
	    function PdfName(value) {
	        /**
	         * `Start symbol` of the name object.
	         * @default /
	         * @private
	         */
	        this.stringStartMark = '/';
	        /**
	         * `Value` of the element.
	         * @private
	         */
	        this.internalValue = '';
	        /**
	         * Indicates if the object is currently in `saving state or not`.
	         * @default false
	         * @private
	         */
	        this.isSaving6 = false;
	        /**
	         * Internal variable to store the `position`.
	         * @default -1
	         * @private
	         */
	        this.position6 = -1;
	        this.internalValue = this.normalizeValue(value);
	    }
	    Object.defineProperty(PdfName.prototype, "status", {
	        //property
	        /**
	         * Gets or sets the `Status` of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.status6;
	        },
	        set: function (value) {
	            this.status6 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfName.prototype, "isSaving", {
	        /**
	         * Gets or sets a value indicating whether this document `is saving` or not.
	         * @private
	         */
	        get: function () {
	            return this.isSaving6;
	        },
	        set: function (value) {
	            this.isSaving6 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfName.prototype, "objectCollectionIndex", {
	        /**
	         * Gets or sets the `index` value of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.index6;
	        },
	        set: function (value) {
	            this.index6 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfName.prototype, "position", {
	        /**
	         * Gets or sets the `position` of the object.
	         * @private
	         */
	        get: function () {
	            return this.position6;
	        },
	        set: function (value) {
	            this.position6 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfName.prototype, "clonedObject", {
	        /**
	         * Returns `cloned object`.
	         * @private
	         */
	        get: function () {
	            return null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfName.prototype, "value", {
	        /**
	         * Gets or sets the `value` of the object.
	         * @private
	         */
	        get: function () {
	            return this.internalValue;
	        },
	        set: function (value) {
	            // if (value !== this.value) {
	            var val = value;
	            if (value !== null && value.length > 0) {
	                // val = (value.substring(0, 1) === this.stringStartMark) ? value.substring(1) : value;
	                val = value;
	                this.internalValue = this.normalizeValue(val);
	            }
	            else {
	                this.internalValue = val;
	            }
	            // }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //public methods
	    /**
	     * `Saves` the name using the specified writer.
	     * @private
	     */
	    PdfName.prototype.save = function (writer) {
	        // if (writer === null) {
	        //     throw new Error('ArgumentNullException : writer');
	        // }
	        writer.write(this.toString());
	    };
	    /**
	     * Gets `string` representation of the primitive.
	     * @private
	     */
	    PdfName.prototype.toString = function () {
	        return (this.stringStartMark + this.escapeString(this.value));
	    };
	    /**
	     * Creates a `copy of PdfName`.
	     * @private
	     */
	    PdfName.prototype.clone = function (crossTable) {
	        var newName = new PdfName();
	        newName.value = this.internalValue;
	        return newName;
	    };
	    /**
	     * Replace some characters with its `escape sequences`.
	     * @private
	     */
	    PdfName.prototype.escapeString = function (stringValue) {
	        // if (str === null) {
	        //     throw new Error('ArgumentNullException : str');
	        // }
	        // if (str === '') {
	        //     return str;
	        // }
	        var result = '';
	        for (var i = 0, len_1 = stringValue.length; i < len_1; i++) {
	            var ch = stringValue[i];
	            PdfName.delimiters.indexOf(ch);
	            // switch (ch) {
	            //     case '\r' :
	            //         result = result + '\\r';
	            //         break;
	            //     case '\n' :
	            //         result = result + '\n';
	            //         break;
	            //     case '(' :
	            //     case ')' :
	            //     case '\\' :
	            //         //result.Append( '\\' ).Append( ch );
	            //         result = result + ch;
	            //         break;
	            //     default :
	            //         result = result + ch;
	            //         break;
	            // }
	            result = result + ch;
	        }
	        return result;
	    };
	    //methiods
	    /**
	     * Replace a symbol with its code with the precedence of the `sharp sign`.
	     * @private
	     */
	    PdfName.prototype.normalizeValue = function (value, c) {
	        //return value.replace(c.toString(),String.format(strFormat,c));
	        return value;
	        // }
	    };
	    /**
	     * PDF `special characters`.
	     * @private
	     */
	    PdfName.delimiters = '()<>[]{}/%}';
	    /**
	     * The symbols that are not allowed in PDF names and `should be replaced`.
	     * @private
	     */
	    PdfName.replacements = [' ', '\t', '\n', '\r'];
	    return PdfName;
	}());

	/**
	 * PdfOperators.ts class for EJ2-PDF
	 * Class of string PDF common operators.
	 * @private
	 */
	var Operators = /** @class */ (function () {
	    /**
	     * Create an instance of `PdfOperator` class.
	     * @private
	     */
	    function Operators() {
	        /**
	         * Specifies the value of `test`.
	         * @private
	         */
	        this.forTest = 'test';
	        this.forTest = Operators.obj;
	    }
	    /**
	     * Specifies the value of `obj`.
	     * @private
	     */
	    Operators.obj = 'obj';
	    /**
	     * Specifies the value of `endObj`.
	     * @private
	     */
	    Operators.endObj = 'endobj';
	    /**
	     * Specifies the value of `R`.
	     * @private
	     */
	    Operators.r = 'R';
	    /**
	     * Specifies the value of ` `.
	     * @private
	     */
	    Operators.whiteSpace = ' ';
	    /**
	     * Specifies the value of `/`.
	     * @private
	     */
	    Operators.slash = '/';
	    /**
	     * Specifies the value of `\r\n`.
	     * @private
	     */
	    Operators.newLine = '\r\n';
	    /**
	     * Specifies the value of `stream`.
	     * @private
	     */
	    Operators.stream = 'stream';
	    /**
	     * Specifies the value of `endStream`.
	     * @private
	     */
	    Operators.endStream = 'endstream';
	    /**
	     * Specifies the value of `xref`.
	     * @private
	     */
	    Operators.xref = 'xref';
	    /**
	     * Specifies the value of `f`.
	     * @private
	     */
	    Operators.f = 'f';
	    /**
	     * Specifies the value of `n`.
	     * @private
	     */
	    Operators.n = 'n';
	    /**
	     * Specifies the value of `trailer`.
	     * @private
	     */
	    Operators.trailer = 'trailer';
	    /**
	     * Specifies the value of `startxref`.
	     * @private
	     */
	    Operators.startxref = 'startxref';
	    /**
	     * Specifies the value of `eof`.
	     * @private
	     */
	    Operators.eof = '%%EOF';
	    /**
	     * Specifies the value of `header`.
	     * @private
	     */
	    Operators.header = '%PDF-1.5';
	    /**
	     * Specifies the value of `beginText`.
	     * @private
	     */
	    Operators.beginText = 'BT';
	    /**
	     * Specifies the value of `endText`.
	     * @private
	     */
	    Operators.endText = 'ET';
	    /**
	     * Specifies the value of `m`.
	     * @private
	     */
	    Operators.beginPath = 'm';
	    /**
	     * Specifies the value of `l`.
	     * @private
	     */
	    Operators.appendLineSegment = 'l';
	    /**
	     * Specifies the value of `S`.
	     * @private
	     */
	    Operators.stroke = 'S';
	    /**
	     * Specifies the value of `f`.
	     * @private
	     */
	    Operators.fill = 'f';
	    /**
	     * Specifies the value of `f*`.
	     * @private
	     */
	    Operators.fillEvenOdd = 'f*';
	    /**
	     * Specifies the value of `B`.
	     * @private
	     */
	    Operators.fillStroke = 'B';
	    /**
	     * Specifies the value of `B*`.
	     * @private
	     */
	    Operators.fillStrokeEvenOdd = 'B*';
	    /**
	     * Specifies the value of `c`.
	     * @private
	     */
	    Operators.appendbeziercurve = 'c';
	    /**
	     * Specifies the value of `re`.
	     * @private
	     */
	    Operators.appendRectangle = 're';
	    /**
	     * Specifies the value of `q`.
	     * @private
	     */
	    Operators.saveState = 'q';
	    /**
	     * Specifies the value of `Q`.
	     * @private
	     */
	    Operators.restoreState = 'Q';
	    /**
	     * Specifies the value of `Do`.
	     * @private
	     */
	    Operators.paintXObject = 'Do';
	    /**
	     * Specifies the value of `cm`.
	     * @private
	     */
	    Operators.modifyCtm = 'cm';
	    /**
	     * Specifies the value of `Tm`.
	     * @private
	     */
	    Operators.modifyTM = 'Tm';
	    /**
	     * Specifies the value of `w`.
	     * @private
	     */
	    Operators.setLineWidth = 'w';
	    /**
	     * Specifies the value of `J`.
	     * @private
	     */
	    Operators.setLineCapStyle = 'J';
	    /**
	     * Specifies the value of `j`.
	     * @private
	     */
	    Operators.setLineJoinStyle = 'j';
	    /**
	     * Specifies the value of `d`.
	     * @private
	     */
	    Operators.setDashPattern = 'd';
	    /**
	     * Specifies the value of `i`.
	     * @private
	     */
	    Operators.setFlatnessTolerance = 'i';
	    /**
	     * Specifies the value of `h`.
	     * @private
	     */
	    Operators.closePath = 'h';
	    /**
	     * Specifies the value of `s`.
	     * @private
	     */
	    Operators.closeStrokePath = 's';
	    /**
	     * Specifies the value of `b`.
	     * @private
	     */
	    Operators.closeFillStrokePath = 'b';
	    /**
	     * Specifies the value of `setCharacterSpace`.
	     * @private
	     */
	    Operators.setCharacterSpace = 'Tc';
	    /**
	     * Specifies the value of `setWordSpace`.
	     * @private
	     */
	    Operators.setWordSpace = 'Tw';
	    /**
	     * Specifies the value of `setHorizontalScaling`.
	     * @private
	     */
	    Operators.setHorizontalScaling = 'Tz';
	    /**
	     * Specifies the value of `setTextLeading`.
	     * @private
	     */
	    Operators.setTextLeading = 'TL';
	    /**
	     * Specifies the value of `setFont`.
	     * @private
	     */
	    Operators.setFont = 'Tf';
	    /**
	     * Specifies the value of `setRenderingMode`.
	     * @private
	     */
	    Operators.setRenderingMode = 'Tr';
	    /**
	     * Specifies the value of `setTextRise`.
	     * @private
	     */
	    Operators.setTextRise = 'Ts';
	    /**
	     * Specifies the value of `setTextScaling`.
	     * @private
	     */
	    Operators.setTextScaling = 'Tz';
	    /**
	     * Specifies the value of `setCoords`.
	     * @private
	     */
	    Operators.setCoords = 'Td';
	    /**
	     * Specifies the value of `goToNextLine`.
	     * @private
	     */
	    Operators.goToNextLine = 'T*';
	    /**
	     * Specifies the value of `setText`.
	     * @private
	     */
	    Operators.setText = 'Tj';
	    /**
	     * Specifies the value of `setTextWithFormatting`.
	     * @private
	     */
	    Operators.setTextWithFormatting = 'TJ';
	    /**
	     * Specifies the value of `setTextOnNewLine`.
	     * @private
	     */
	    Operators.setTextOnNewLine = '\'';
	    /**
	     * Specifies the value of `selectcolorspaceforstroking`.
	     * @private
	     */
	    Operators.selectcolorspaceforstroking = 'CS';
	    /**
	     * Specifies the value of `selectcolorspacefornonstroking`.
	     * @private
	     */
	    Operators.selectcolorspacefornonstroking = 'cs';
	    /**
	     * Specifies the value of `setrbgcolorforstroking`.
	     * @private
	     */
	    Operators.setrbgcolorforstroking = 'RG';
	    /**
	     * Specifies the value of `setrbgcolorfornonstroking`.
	     * @private
	     */
	    Operators.setrbgcolorfornonstroking = 'rg';
	    /**
	     * Specifies the value of `K`.
	     * @private
	     */
	    Operators.setcmykcolorforstroking = 'K';
	    /**
	     * Specifies the value of `k`.
	     * @private
	     */
	    Operators.setcmykcolorfornonstroking = 'k';
	    /**
	     * Specifies the value of `G`.
	     * @private
	     */
	    Operators.setgraycolorforstroking = 'G';
	    /**
	     * Specifies the value of `g`.
	     * @private
	     */
	    Operators.setgraycolorfornonstroking = 'g';
	    /**
	     * Specifies the value of `W`.
	     * @private
	     */
	    Operators.clipPath = 'W';
	    /**
	     * Specifies the value of `clipPathEvenOdd`.
	     * @private
	     */
	    Operators.clipPathEvenOdd = 'W*';
	    /**
	     * Specifies the value of `n`.
	     * @private
	     */
	    Operators.endPath = 'n';
	    /**
	     * Specifies the value of `setGraphicsState`.
	     * @private
	     */
	    Operators.setGraphicsState = 'gs';
	    /**
	     * Specifies the value of `%`.
	     * @private
	     */
	    Operators.comment = '%';
	    /**
	     * Specifies the value of `*`.
	     * @private
	     */
	    Operators.evenOdd = '*';
	    /**
	     * Specifies the value of `M`.
	     * @private
	     */
	    Operators.setMiterLimit = 'M';
	    /**
	     * Same as SC, but also supports Pattern, Separation, DeviceN, and ICCBased color spaces. For non-stroking operations.
	     * @public
	     */
	    Operators.setColorAndPattern = 'scn';
	    /**
	     * Same as SC, but also supports Pattern, Separation, DeviceN, and ICCBased color spaces. For stroking.
	     */
	    Operators.setColorAndPatternStroking = 'SCN';
	    return Operators;
	}());

	/**
	 * dictionaryProperties.ts class for EJ2-PDF
	 * PDF dictionary properties.
	 * @private
	 */
	var DictionaryProperties = /** @class */ (function () {
	    /**
	     * Initialize an instance for `PdfDictionaryProperties` class.
	     * @private
	     */
	    function DictionaryProperties() {
	        /**
	         * Specifies the value of `Pages`.
	         * @private
	         */
	        this.pages = 'Pages';
	        /**
	         * Specifies the value of `Kids`.
	         * @private
	         */
	        this.kids = 'Kids';
	        /**
	         * Specifies the value of `Count`.
	         * @private
	         */
	        this.count = 'Count';
	        /**
	         * Specifies the value of `Resources`.
	         * @private
	         */
	        this.resources = 'Resources';
	        /**
	         * Specifies the value of `Type`.
	         * @private
	         */
	        this.type = 'Type';
	        /**
	         * Specifies the value of `Size`.
	         * @private
	         */
	        this.size = 'Size';
	        /**
	         * Specifies the value of `MediaBox`.
	         * @private
	         */
	        this.mediaBox = 'MediaBox';
	        /**
	         * Specifies the value of `Parent`.
	         * @private
	         */
	        this.parent = 'Parent';
	        /**
	         * Specifies the value of `Root`.
	         * @private
	         */
	        this.root = 'Root';
	        /**
	         * Specifies the value of `DecodeParms`.
	         * @private
	         */
	        this.decodeParms = 'DecodeParms';
	        /**
	         * Specifies the value of `Filter`.
	         * @private
	         */
	        this.filter = 'Filter';
	        /**
	         * Specifies the value of `Font`.
	         * @private
	         */
	        this.font = 'Font';
	        /**
	         * Specifies the value of `Type1`.
	         * @private
	         */
	        this.type1 = 'Type1';
	        /**
	         * Specifies the value of `BaseFont`.
	         * @private
	         */
	        this.baseFont = 'BaseFont';
	        /**
	         * Specifies the value of `Encoding`.
	         * @private
	         */
	        this.encoding = 'Encoding';
	        /**
	         * Specifies the value of `Subtype`.
	         * @private
	         */
	        this.subtype = 'Subtype';
	        /**
	         * Specifies the value of `Contents`.
	         * @private
	         */
	        this.contents = 'Contents';
	        /**
	         * Specifies the value of `ProcSet`.
	         * @private
	         */
	        this.procset = 'ProcSet';
	        /**
	         * Specifies the value of `ColorSpace`.
	         * @private
	         */
	        this.colorSpace = 'ColorSpace';
	        /**
	         * Specifies the value of `ExtGState`.
	         * @private
	         */
	        this.extGState = 'ExtGState';
	        /**
	         * Specifies the value of `Pattern`.
	         * @private
	         */
	        this.pattern = 'Pattern';
	        /**
	         * Specifies the value of `XObject`.
	         * @private
	         */
	        this.xObject = 'XObject';
	        /**
	         * Specifies the value of `Length`.
	         * @private
	         */
	        this.length = 'Length';
	        /**
	         * Specifies the value of `Width`.
	         * @private
	         */
	        this.width = 'Width';
	        /**
	         * Specifies the value of `Height`.
	         * @private
	         */
	        this.height = 'Height';
	        /**
	         * Specifies the value of `BitsPerComponent`.
	         * @private
	         */
	        this.bitsPerComponent = 'BitsPerComponent';
	        /**
	         * Specifies the value of `Image`.
	         * @private
	         */
	        this.image = 'Image';
	        /**
	         * Specifies the value of `dctdecode`.
	         * @private
	         */
	        this.dctdecode = 'DCTDecode';
	        /**
	         * Specifies the value of `Columns`.
	         * @private
	         */
	        this.columns = 'Columns';
	        /**
	         * Specifies the value of `BlackIs1`.
	         * @private
	         */
	        this.blackIs1 = 'BlackIs1';
	        /**
	         * Specifies the value of `K`.
	         * @private
	         */
	        this.k = 'K';
	        /**
	         * Specifies the value of `S`.
	         * @private
	         */
	        this.s = 'S';
	        /**
	         * Specifies the value of `Predictor`.
	         * @private
	         */
	        this.predictor = 'Predictor';
	        /**
	         * Specifies the value of `DeviceRGB`.
	         * @private
	         */
	        this.deviceRgb = 'DeviceRGB';
	        /**
	         * Specifies the value of `Next`.
	         * @private
	         */
	        this.next = 'Next';
	        /**
	         * Specifies the value of `Action`.
	         * @private
	         */
	        this.action = 'Action';
	        /**
	         * Specifies the value of `Link`.
	         * @private
	         */
	        this.link = 'Link';
	        /**
	         *
	         * Specifies the value of `A`.
	         * @private
	         */
	        this.a = 'A';
	        /**
	         * Specifies the value of `Annot`.
	         * @private
	         */
	        this.annot = 'Annot';
	        /**
	         * Specifies the value of `P`.
	         * @private
	         */
	        this.p = 'P';
	        /**
	         * Specifies the value of `C`.
	         * @private
	         */
	        this.c = 'C';
	        /**
	         * Specifies the value of `Rect`.
	         * @private
	         */
	        this.rect = 'Rect';
	        /**
	         * Specifies the value of `URI`.
	         * @private
	         */
	        this.uri = 'URI';
	        /**
	         * Specifies the value of `Annots`.
	         * @private
	         */
	        this.annots = 'Annots';
	        /**
	         * Specifies the value of `ca`.
	         * @private
	         */
	        this.ca = 'ca';
	        /**
	         * Specifies the value of `CA`.
	         * @private
	         */
	        this.CA = 'CA';
	        /**
	         * Specifies the value of `XYZ`.
	         * @private
	         */
	        this.xyz = 'XYZ';
	        /**
	         * Specifies the value of `Fit`.
	         * @private
	         */
	        this.fit = 'Fit';
	        /**
	         * Specifies the value of `Dest`.
	         * @private
	         */
	        this.dest = 'Dest';
	        /**
	         * Specifies the value of `BM`.
	         * @private
	         */
	        this.BM = 'BM';
	        /**
	         * Specifies the value of `flatedecode`.
	         * @private
	         */
	        this.flatedecode = 'FlateDecode';
	        /**
	         * Specifies the value of `Rotate`.
	         * @private
	         */
	        this.rotate = 'Rotate';
	        /**
	         * Specifies the value of 'bBox'.
	         * @private
	         */
	        this.bBox = 'BBox';
	        /**
	         * Specifies the value of 'form'.
	         * @private
	         */
	        this.form = 'Form';
	        /**
	         * Specifies the value of 'w'.
	         * @private
	         */
	        this.w = 'W';
	        /**
	         * Specifies the value of 'cIDFontType2'.
	         * @private
	         */
	        this.cIDFontType2 = 'CIDFontType2';
	        /**
	         * Specifies the value of 'cIDToGIDMap'.
	         * @private
	         */
	        this.cIDToGIDMap = 'CIDToGIDMap';
	        /**
	         * Specifies the value of 'identity'.
	         * @private
	         */
	        this.identity = 'Identity';
	        /**
	         * Specifies the value of 'dw'.
	         * @private
	         */
	        this.dw = 'DW';
	        /**
	         * Specifies the value of 'fontDescriptor'.
	         * @private
	         */
	        this.fontDescriptor = 'FontDescriptor';
	        /**
	         * Specifies the value of 'cIDSystemInfo'.
	         * @private
	         */
	        this.cIDSystemInfo = 'CIDSystemInfo';
	        /**
	         * Specifies the value of 'fontName'.
	         * @private
	         */
	        this.fontName = 'FontName';
	        /**
	         * Specifies the value of 'flags'.
	         * @private
	         */
	        this.flags = 'Flags';
	        /**
	         * Specifies the value of 'fontBBox'.
	         * @private
	         */
	        this.fontBBox = 'FontBBox';
	        /**
	         * Specifies the value of 'missingWidth'.
	         * @private
	         */
	        this.missingWidth = 'MissingWidth';
	        /**
	         * Specifies the value of 'stemV'.
	         * @private
	         */
	        this.stemV = 'StemV';
	        /**
	         * Specifies the value of 'italicAngle'.
	         * @private
	         */
	        this.italicAngle = 'ItalicAngle';
	        /**
	         * Specifies the value of 'capHeight'.
	         * @private
	         */
	        this.capHeight = 'CapHeight';
	        /**
	         * Specifies the value of 'ascent'.
	         * @private
	         */
	        this.ascent = 'Ascent';
	        /**
	         * Specifies the value of 'descent'.
	         * @private
	         */
	        this.descent = 'Descent';
	        /**
	         * Specifies the value of 'leading'.
	         * @private
	         */
	        this.leading = 'Leading';
	        /**
	         * Specifies the value of 'avgWidth'.
	         * @private
	         */
	        this.avgWidth = 'AvgWidth';
	        /**
	         * Specifies the value of 'fontFile2'.
	         * @private
	         */
	        this.fontFile2 = 'FontFile2';
	        /**
	         * Specifies the value of 'maxWidth'.
	         * @private
	         */
	        this.maxWidth = 'MaxWidth';
	        /**
	         * Specifies the value of 'xHeight'.
	         * @private
	         */
	        this.xHeight = 'XHeight';
	        /**
	         * Specifies the value of 'stemH'.
	         * @private
	         */
	        this.stemH = 'StemH';
	        /**
	         * Specifies the value of 'registry'.
	         * @private
	         */
	        this.registry = 'Registry';
	        /**
	         * Specifies the value of 'ordering'.
	         * @private
	         */
	        this.ordering = 'Ordering';
	        /**
	         * Specifies the value of 'supplement'.
	         * @private
	         */
	        this.supplement = 'Supplement';
	        /**
	         * Specifies the value of 'type0'.
	         * @private
	         */
	        this.type0 = 'Type0';
	        /**
	         * Specifies the value of 'identityH'.
	         * @private
	         */
	        this.identityH = 'Identity-H';
	        /**
	         * Specifies the value of 'toUnicode'.
	         * @private
	         */
	        this.toUnicode = 'ToUnicode';
	        /**
	         * Specifies the value of 'descendantFonts'.
	         * @private
	         */
	        this.descendantFonts = 'DescendantFonts';
	        /**
	         * Specifies the value of 'background'.
	         * @private
	         */
	        this.background = 'Background';
	        /**
	         * Specifies the value of 'shading'.
	         * @private
	         */
	        this.shading = 'Shading';
	        /**
	         * Specifies the value of 'matrix'.
	         * @private
	         */
	        this.matrix = 'Matrix';
	        /**
	         * Specifies the value of 'antiAlias'.
	         * @private
	         */
	        this.antiAlias = 'AntiAlias';
	        /**
	         * Specifies the value of 'function'.
	         * @private
	         */
	        this.function = 'Function';
	        /**
	         * Specifies the value of 'extend'.
	         * @private
	         */
	        this.extend = 'Extend';
	        /**
	         * Specifies the value of 'shadingType'.
	         * @private
	         */
	        this.shadingType = 'ShadingType';
	        /**
	         * Specifies the value of 'coords'.
	         * @private
	         */
	        this.coords = 'Coords';
	        /**
	         * Specifies the value of 'domain'.
	         * @private
	         */
	        this.domain = 'Domain';
	        /**
	         * Specifies the value of 'range'.
	         * @private
	         */
	        this.range = 'Range';
	        /**
	         * Specifies the value of 'functionType'.
	         * @private
	         */
	        this.functionType = 'FunctionType';
	        /**
	         * Specifies the value of 'bitsPerSample'.
	         * @private
	         */
	        this.bitsPerSample = 'BitsPerSample';
	        /**
	         * Specifies the value of 'patternType'.
	         * @private
	         */
	        this.patternType = 'PatternType';
	        /**
	         * Specifies the value of 'paintType'.
	         * @private
	         */
	        this.paintType = 'PaintType';
	        /**
	         * Specifies the value of 'tilingType'.
	         * @private
	         */
	        this.tilingType = 'TilingType';
	        /**
	         * Specifies the value of 'xStep'.
	         * @private
	         */
	        this.xStep = 'XStep';
	        /**
	         * Specifies the value of 'yStep'.
	         * @private
	         */
	        this.yStep = 'YStep';
	        /**
	         * Specifies the value of viewer preferences.
	         * @private
	         */
	        this.viewerPreferences = 'ViewerPreferences';
	        /**
	         * Specifies the value of center window.
	         * @private
	         */
	        this.centerWindow = 'CenterWindow';
	        /**
	         * Specifies the value of display title.
	         * @private
	         */
	        this.displayTitle = 'DisplayTitle';
	        /**
	         * Specifies the value of fit window.
	         * @private
	         */
	        this.fitWindow = 'FitWindow';
	        /**
	         * Specifies the value of hide menu bar.
	         * @private
	         */
	        this.hideMenuBar = 'HideMenubar';
	        /**
	         * Specifies the value of hide tool bar.
	         * @private
	         */
	        this.hideToolBar = 'HideToolbar';
	        /**
	         * Specifies the value of hide window UI.
	         * @private
	         */
	        this.hideWindowUI = 'HideWindowUI';
	        /**
	         * Specifies the value of page mode.
	         * @private
	         */
	        this.pageMode = 'PageMode';
	        /**
	         * Specifies the value of page layout.
	         * @private
	         */
	        this.pageLayout = 'PageLayout';
	        /**
	         * Specifies the value of duplex.
	         * @private
	         */
	        this.duplex = 'Duplex';
	        /**
	         * Specifies the value of print scaling.
	         * @private
	         */
	        this.printScaling = 'PrintScaling';
	        //
	    }
	    return DictionaryProperties;
	}());

	/**
	 * `PdfDictionary` class is used to perform primitive operations.
	 * @private
	 */
	var PdfDictionary = /** @class */ (function () {
	    function PdfDictionary(dictionary) {
	        /**
	         * Internal variable to store the `position`.
	         * @default -1
	         * @private
	         */
	        this.position7 = -1;
	        /**
	         * The `IPdfSavable` with the specified key.
	         * @private
	         */
	        this.primitiveItems = new Dictionary();
	        /**
	         * `Start marker` for dictionary.
	         * @private
	         */
	        this.prefix = '<<';
	        /**
	         * `End marker` for dictionary.
	         * @private
	         */
	        this.suffix = '>>';
	        /**
	         * @hidden
	         * @private
	         */
	        this.resources = [];
	        /**
	         * Internal variable to hold `cloned object`.
	         * @default null
	         * @private
	         */
	        this.object = null;
	        /**
	         * Flag for PDF file formar 1.5 is dictionary `archiving` needed.
	         * @default true
	         * @private
	         */
	        this.archive = true;
	        /**
	         * Represents the Font dictionary.
	         * @hidden
	         * @private
	         */
	        this.isResource = false;
	        if (typeof dictionary === 'undefined') {
	            this.primitiveItems = new Dictionary();
	            this.encrypt = true;
	            this.dictionaryProperties = new DictionaryProperties();
	        }
	        else {
	            this.primitiveItems = new Dictionary();
	            var keys = dictionary.items.keys();
	            var values = dictionary.items.values();
	            for (var index = 0; index < dictionary.items.size(); index++) {
	                this.primitiveItems.setValue(keys[index], values[index]);
	            }
	            this.status = dictionary.status;
	            this.freezeChanges(this);
	            this.encrypt = true;
	            this.dictionaryProperties = new DictionaryProperties();
	        }
	    }
	    Object.defineProperty(PdfDictionary.prototype, "items", {
	        //Properties
	        /**
	         * Gets or sets the `IPdfSavable` with the specified key.
	         * @private
	         */
	        get: function () {
	            return this.primitiveItems;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDictionary.prototype, "status", {
	        /**
	         * Gets or sets the `Status` of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.status7;
	        },
	        set: function (value) {
	            this.status7 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDictionary.prototype, "isSaving", {
	        /**
	         * Gets or sets a value indicating whether this document `is saving` or not.
	         * @private
	         */
	        get: function () {
	            return this.isSaving7;
	        },
	        set: function (value) {
	            this.isSaving7 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDictionary.prototype, "objectCollectionIndex", {
	        /**
	         * Gets or sets the `index` value of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.index7;
	        },
	        set: function (value) {
	            this.index7 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDictionary.prototype, "clonedObject", {
	        /**
	         * Returns `cloned object`.
	         * @private
	         */
	        get: function () {
	            return this.object;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDictionary.prototype, "position", {
	        /**
	         * Gets or sets the `position` of the object.
	         * @private
	         */
	        get: function () {
	            return this.position7;
	        },
	        set: function (value) {
	            this.position7 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDictionary.prototype, "Count", {
	        /**
	         * Gets the `count`.
	         * @private
	         */
	        get: function () {
	            return this.primitiveItems.size();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDictionary.prototype, "Dictionary", {
	        /**
	         * Collection of `items` in the object.
	         * @private
	         */
	        get: function () {
	            return this;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Get flag if need to `archive` dictionary.
	     * @private
	     */
	    PdfDictionary.prototype.getArchive = function () {
	        return this.archive;
	    };
	    /**
	     * Set flag if need to `archive` dictionary.
	     * @private
	     */
	    PdfDictionary.prototype.setArchive = function (value) {
	        this.archive = value;
	    };
	    /**
	     * Sets flag if `encryption` is needed.
	     * @private
	     */
	    PdfDictionary.prototype.setEncrypt = function (value) {
	        this.encrypt = value;
	        this.modify();
	    };
	    /**
	     * Gets flag if `encryption` is needed.
	     * @private
	     */
	    PdfDictionary.prototype.getEncrypt = function () {
	        return this.encrypt;
	    };
	    /**
	     * `Freezes` the changes.
	     * @private
	     */
	    PdfDictionary.prototype.freezeChanges = function (freezer) {
	        this.bChanged = false;
	    };
	    /**
	     * Creates a `copy of PdfDictionary`.
	     * @private
	     */
	    PdfDictionary.prototype.clone = function (crossTable) {
	        //Need to add more codings
	        var newDict = new PdfDictionary();
	        return newDict;
	    };
	    /**
	     * `Mark` this instance modified.
	     * @private
	     */
	    PdfDictionary.prototype.modify = function () {
	        this.bChanged = true;
	    };
	    /**
	     * `Removes` the specified key.
	     * @private
	     */
	    PdfDictionary.prototype.remove = function (key) {
	        if (typeof key !== 'string') {
	            this.primitiveItems.remove(key.value);
	            this.modify();
	        }
	        else {
	            this.remove(new PdfName(key));
	        }
	    };
	    /**
	     * `Determines` whether the dictionary contains the key.
	     * @private
	     */
	    PdfDictionary.prototype.containsKey = function (key) {
	        var returnValue = false;
	        returnValue = this.primitiveItems.containsKey(key.toString());
	        return returnValue;
	    };
	    /**
	     * Raises event `BeginSave`.
	     * @private
	     */
	    PdfDictionary.prototype.onBeginSave = function () {
	        this.beginSave.sender.beginSave();
	    };
	    /**
	     * Raises event `Font Dictionary BeginSave`.
	     * @private
	     */
	    PdfDictionary.prototype.onFontDictionaryBeginSave = function () {
	        this.fontDictionaryBeginSave.sender.fontDictionaryBeginSave();
	    };
	    /**
	     * Raises event `Descendant Font BeginSave`.
	     * @private
	     */
	    PdfDictionary.prototype.onDescendantFontBeginSave = function () {
	        this.descendantFontBeginSave.sender.descendantFontBeginSave();
	    };
	    /**
	     * Raises event 'BeginSave'.
	     * @private
	     */
	    PdfDictionary.prototype.onTemplateBeginSave = function () {
	        this.pageBeginDrawTemplate.sender.pageBeginSave();
	    };
	    /**
	     * Raises event `BeginSave`.
	     * @private
	     */
	    PdfDictionary.prototype.onBeginAnnotationSave = function () {
	        this.annotationBeginSave.sender.beginSave();
	    };
	    /**
	     * Raises event `BeginSave`.
	     * @private
	     */
	    PdfDictionary.prototype.onSectionBeginSave = function (writer) {
	        var saveEvent = this.sectionBeginSave;
	        saveEvent.sender.beginSave(saveEvent.state, writer);
	    };
	    PdfDictionary.prototype.save = function (writer, bRaiseEvent) {
	        if (typeof bRaiseEvent === 'undefined') {
	            this.save(writer, true);
	        }
	        else {
	            writer.write(this.prefix);
	            if (typeof this.beginSave !== 'undefined') {
	                this.onBeginSave();
	            }
	            if (typeof this.descendantFontBeginSave !== 'undefined') {
	                this.onDescendantFontBeginSave();
	            }
	            if (typeof this.fontDictionaryBeginSave !== 'undefined') {
	                this.onFontDictionaryBeginSave();
	            }
	            if (typeof this.annotationBeginSave !== 'undefined') {
	                this.onBeginAnnotationSave();
	            }
	            if (typeof this.sectionBeginSave !== 'undefined') {
	                this.onSectionBeginSave(writer);
	            }
	            if (typeof this.pageBeginDrawTemplate !== 'undefined') {
	                this.onTemplateBeginSave();
	            }
	            // }
	            if (this.Count > 0) {
	                this.saveItems(writer);
	            }
	            writer.write(this.suffix);
	            writer.write(Operators.newLine);
	        }
	    };
	    /**
	     * `Save dictionary items`.
	     * @private
	     */
	    PdfDictionary.prototype.saveItems = function (writer) {
	        writer.write(Operators.newLine);
	        var keys = this.primitiveItems.keys();
	        var values = this.primitiveItems.values();
	        for (var index = 0; index < keys.length; index++) {
	            var key = keys[index];
	            var name_1 = new PdfName(key);
	            name_1.save(writer);
	            writer.write(Operators.whiteSpace);
	            var resources = values[index];
	            resources.save(writer);
	            writer.write(Operators.newLine);
	        }
	    };
	    return PdfDictionary;
	}());
	var SaveSectionCollectionEventHandler = /** @class */ (function () {
	    /**
	     * New instance for `save section collection event handler` class.
	     * @private
	     */
	    function SaveSectionCollectionEventHandler(sender) {
	        this.sender = sender;
	    }
	    return SaveSectionCollectionEventHandler;
	}());
	var SaveDescendantFontEventHandler = /** @class */ (function () {
	    /**
	     * New instance for `save section collection event handler` class.
	     * @private
	     */
	    function SaveDescendantFontEventHandler(sender) {
	        this.sender = sender;
	    }
	    return SaveDescendantFontEventHandler;
	}());
	var SaveFontDictionaryEventHandler = /** @class */ (function () {
	    /**
	     * New instance for `save section collection event handler` class.
	     * @private
	     */
	    function SaveFontDictionaryEventHandler(sender) {
	        this.sender = sender;
	    }
	    return SaveFontDictionaryEventHandler;
	}());
	var SaveSectionEventHandler = /** @class */ (function () {
	    // constructors
	    /**
	     * New instance for `save section event handler` class.
	     * @private
	     */
	    function SaveSectionEventHandler(sender, state) {
	        this.sender = sender;
	        this.state = state;
	    }
	    return SaveSectionEventHandler;
	}());
	/**
	 * SaveTemplateEventHandler class used to store information about template elements.
	 * @private
	 * @hidden
	 */
	var SaveTemplateEventHandler = /** @class */ (function () {
	    /**
	     * New instance for save section collection event handler class.
	     * @public
	     */
	    function SaveTemplateEventHandler(sender) {
	        this.sender = sender;
	    }
	    return SaveTemplateEventHandler;
	}());

	/**
	 * `PdfNumber` class is used to perform number related primitive operations.
	 * @private
	 */
	var PdfNumber = /** @class */ (function () {
	    /**
	     * Initializes a new instance of the `PdfNumber` class.
	     * @private
	     */
	    function PdfNumber(value) {
	        /**
	         * Sotres the `position`.
	         * @default -1
	         * @private
	         */
	        this.position5 = -1;
	        this.value = value;
	    }
	    Object.defineProperty(PdfNumber.prototype, "intValue", {
	        /**
	         * Gets or sets the `integer` value.
	         * @private
	         */
	        get: function () {
	            return this.value;
	        },
	        set: function (value) {
	            this.value = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfNumber.prototype, "isInteger", {
	        /**
	         * Gets or sets a value indicating whether this instance `is integer`.
	         * @private
	         */
	        get: function () {
	            return this.integer;
	        },
	        set: function (value) {
	            this.integer = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfNumber.prototype, "status", {
	        /**
	         * Gets or sets the `Status` of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.status5;
	        },
	        set: function (value) {
	            this.status5 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfNumber.prototype, "isSaving", {
	        /**
	         * Gets or sets a value indicating whether this document `is saving` or not.
	         * @private
	         */
	        get: function () {
	            return this.isSaving5;
	        },
	        set: function (value) {
	            this.isSaving5 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfNumber.prototype, "objectCollectionIndex", {
	        /**
	         * Gets or sets the `index` value of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.index5;
	        },
	        set: function (value) {
	            this.index5 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfNumber.prototype, "position", {
	        /**
	         * Gets or sets the `position` of the object.
	         * @private
	         */
	        get: function () {
	            return this.position5;
	        },
	        set: function (value) {
	            this.position5 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfNumber.prototype, "clonedObject", {
	        /**
	         * Returns `cloned object`.
	         * @private
	         */
	        get: function () {
	            var rValue = null;
	            return rValue;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * `Saves the object`.
	     * @private
	     */
	    PdfNumber.prototype.save = function (writer) {
	        writer.write(this.intValue.toString()); //tostring(CultureInfo.InletiantCulture)
	    };
	    /**
	     * Creates a `copy of PdfNumber`.
	     * @private
	     */
	    PdfNumber.prototype.clone = function (crossTable) {
	        var newNumber = new PdfNumber(this.value);
	        return newNumber;
	    };
	    /**
	     * Converts a `float value to a string` using Adobe PDF rules.
	     * @private
	     */
	    PdfNumber.floatToString = function (number) {
	        // let tempString1 : string = number.toString();
	        // let tempString2 : string = tempString1.indexOf('.') != -1 ? tempString1.substring(0, tempString1.indexOf('.')) : tempString1;
	        var returnString = number.toFixed(2);
	        if (returnString === '0.00') {
	            returnString = '.00';
	        }
	        // let prefixLength : number = (22 - tempString2.length) >= 0 ? (22 - tempString2.length) : 0;
	        // for (let index : number = 0; index < prefixLength; index++) {
	        //     returnString += '0';
	        // }
	        // returnString += tempString2 + '.00';
	        // returnString += (tempString3.length > 6) ? tempString3.substring(0,6) : tempString3;
	        // let suffixLength : number = (6 - tempString3.length) >= 0 ? (6 - tempString3.length) : 0;
	        // for (let index : number = 0; index < suffixLength; index++) {
	        //     returnString += '0';
	        // }
	        return returnString;
	    };
	    /**
	     * Determines the `minimum of the three values`.
	     * @private
	     */
	    PdfNumber.min = function (x, y, z) {
	        var r = Math.min(x, y);
	        return Math.min(z, r);
	    };
	    return PdfNumber;
	}());

	/**
	 * `PdfArray` class is used to perform array related primitive operations.
	 * @private
	 */
	var PdfArray = /** @class */ (function () {
	    function PdfArray(array) {
	        //Fields
	        /**
	         * `startMark` - '['
	         * @private
	         */
	        this.startMark = '[';
	        /**
	         * `endMark` - ']'.
	         * @private
	         */
	        this.endMark = ']';
	        /**
	         * Internal variable to store the `position`.
	         * @default -1
	         * @private
	         */
	        this.position9 = -1;
	        /**
	         * Internal variable to hold `cloned object`.
	         * @default null
	         * @private
	         */
	        this.clonedObject9 = null;
	        /**
	         * Represents the Font dictionary.
	         * @hidden
	         * @private
	         */
	        this.isFont = false;
	        if (typeof array === 'undefined') {
	            this.internalElements = [];
	        }
	        else {
	            if (typeof array !== 'undefined' && !(array instanceof PdfArray)) {
	                var tempNumberArray = array;
	                for (var index = 0; index < tempNumberArray.length; index++) {
	                    var pdfNumber = new PdfNumber(tempNumberArray[index]);
	                    this.add(pdfNumber);
	                }
	                // } else if (typeof array !== 'undefined' && (array instanceof PdfArray)) {
	            }
	            else {
	                var tempArray = array;
	                // if (tempArray.Elements.length > 0) {
	                this.internalElements = [];
	                for (var index = 0; index < tempArray.elements.length; index++) {
	                    this.internalElements.push(tempArray.elements[index]);
	                }
	                // }
	            }
	        }
	    }
	    //property
	    /**
	     * Gets the `IPdfSavable` at the specified index.
	     * @private
	     */
	    PdfArray.prototype.items = function (index) {
	        // if (index < 0 || index >= this.Count) {
	        //     throw new Error('ArgumentOutOfRangeException : index, The index can"t be less then zero or greater then Count.');
	        // }
	        return this.internalElements[index];
	    };
	    Object.defineProperty(PdfArray.prototype, "count", {
	        /**
	         * Gets the `count`.
	         * @private
	         */
	        get: function () {
	            return this.internalElements.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfArray.prototype, "status", {
	        /**
	         * Gets or sets the `Status` of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.status9;
	        },
	        set: function (value) {
	            this.status9 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfArray.prototype, "isSaving", {
	        /**
	         * Gets or sets a value indicating whether this document `is saving` or not.
	         * @private
	         */
	        get: function () {
	            return this.isSaving9;
	        },
	        set: function (value) {
	            this.isSaving9 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfArray.prototype, "clonedObject", {
	        /**
	         * Returns `cloned object`.
	         * @private
	         */
	        get: function () {
	            return this.clonedObject9;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfArray.prototype, "position", {
	        /**
	         * Gets or sets the `position` of the object.
	         * @private
	         */
	        get: function () {
	            return this.position9;
	        },
	        set: function (value) {
	            this.position9 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfArray.prototype, "objectCollectionIndex", {
	        /**
	         * Gets or sets the `index` value of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.index9;
	        },
	        set: function (value) {
	            this.index9 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfArray.prototype, "CrossTable", {
	        /**
	         * Returns `PdfCrossTable` associated with the object.
	         * @private
	         */
	        get: function () {
	            return this.pdfCrossTable;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfArray.prototype, "elements", {
	        /**
	         * Gets the `elements` of the Pdf Array.
	         * @private
	         */
	        get: function () {
	            return this.internalElements;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * `Adds` the specified element to the PDF array.
	     * @private
	     */
	    PdfArray.prototype.add = function (element) {
	        // if (element === null) {
	        //     throw new Error('ArgumentNullException : obj');
	        // }
	        if (typeof this.internalElements === 'undefined') {
	            this.internalElements = [];
	        }
	        this.internalElements.push(element);
	        this.markedChange();
	    };
	    /**
	     * `Marks` the object changed.
	     * @private
	     */
	    PdfArray.prototype.markedChange = function () {
	        this.bChanged = true;
	    };
	    /**
	     * `Determines` whether the specified element is within the array.
	     * @private
	     */
	    PdfArray.prototype.contains = function (element) {
	        var returnValue = false;
	        for (var index = 0; index < this.internalElements.length; index++) {
	            var tempElement = this.internalElements[index];
	            var inputElement = element;
	            if (tempElement != null && typeof tempElement !== 'undefined' && inputElement != null && typeof inputElement !== 'undefined') {
	                if (tempElement.value === inputElement.value) {
	                    return true;
	                }
	            }
	            // if (this.internalElements[index] === element) {
	            //     returnValue = true;
	            // }
	        }
	        return returnValue;
	    };
	    /**
	     * Returns the `primitive object` of input index.
	     * @private
	     */
	    PdfArray.prototype.getItems = function (index) {
	        // if (index < 0 || index >= this.Count) {
	        //     throw new Error('ArgumentOutOfRangeException : index , The index can"t be less then zero or greater then Count.');
	        // }
	        return this.internalElements[index];
	    };
	    /**
	     * `Saves` the object using the specified writer.
	     * @private
	     */
	    PdfArray.prototype.save = function (writer) {
	        // if (writer === null) {
	        //     throw new Error('ArgumentNullException : writer');
	        // }
	        writer.write(this.startMark);
	        for (var i = 0, len = this.count; i < len; i++) {
	            this.getItems(i).save(writer);
	            if (i + 1 !== len) {
	                writer.write(Operators.whiteSpace);
	            }
	        }
	        writer.write(this.endMark);
	    };
	    /**
	     * Creates a `copy of PdfArray`.
	     * @private
	     */
	    PdfArray.prototype.clone = function (crossTable) {
	        // if (this.clonedObject9 !== null && this.clonedObject9.CrossTable === crossTable) {
	        //     return this.clonedObject9;
	        // } else {
	        this.clonedObject9 = null;
	        // Else clone the object.
	        var newArray = new PdfArray();
	        for (var index = 0; index < this.internalElements.length; index++) {
	            var obj = this.internalElements[index];
	            newArray.add(obj.clone(crossTable));
	        }
	        newArray.pdfCrossTable = crossTable;
	        this.clonedObject9 = newArray;
	        return newArray;
	    };
	    /**
	     * Creates filled PDF array `from the rectangle`.
	     * @private
	     */
	    PdfArray.fromRectangle = function (bounds) {
	        var values = [bounds.x, bounds.y, bounds.width, bounds.height];
	        var array = new PdfArray(values);
	        return array;
	    };
	    // /**
	    //  * Creates the rectangle from filled PDF array.
	    //  * @private
	    //  */
	    // public ToRectangle() : RectangleF {
	    //     if (this.Count < 4) {
	    //         throw Error('InvalidOperationException-Can not convert to rectangle.');
	    //     }
	    //     let x1 : number;
	    //     let x2 : number;
	    //     let y1 : number;
	    //     let y2 : number;
	    //     let num : PdfNumber = this.getItems(0) as PdfNumber;
	    //     x1 = num.IntValue;
	    //     num = this.getItems(1) as PdfNumber;
	    //     y1 = num.IntValue;
	    //     num = this.getItems(2) as PdfNumber;
	    //     x2 = num.IntValue;
	    //     num = this.getItems(3) as PdfNumber;
	    //     y2 = num.IntValue;
	    //     let x : number = Math.min(x1, x2);
	    //     let y : number = Math.min(y1, y2);
	    //     let width : number = Math.abs(x1 - x2);
	    //     let height : number = Math.abs(y1 - y2);
	    //     let rect : RectangleF = new RectangleF(new PointF(x, y), new SizeF(width, height));
	    //     return rect;
	    // }
	    /**
	     * `Inserts` the element into the array.
	     * @private
	     */
	    PdfArray.prototype.insert = function (index, element) {
	        if (index < this.internalElements.length && index > 0) {
	            var tempElements = [];
	            for (var i = 0; i < index; i++) {
	                tempElements.push(this.internalElements[i]);
	            }
	            tempElements.push(element);
	            for (var i = index; i < this.internalElements.length; i++) {
	                tempElements.push(this.internalElements[i]);
	            }
	            this.internalElements = tempElements;
	        }
	        else {
	            this.internalElements.push(element);
	        }
	        this.markChanged();
	    };
	    /**
	     * `Checks whether array contains the element`.
	     * @private
	     */
	    PdfArray.prototype.indexOf = function (element) {
	        return this.internalElements.indexOf(element);
	    };
	    /**
	     * `Removes` element from the array.
	     * @private
	     */
	    PdfArray.prototype.remove = function (element) {
	        // if (element === null) {
	        //     throw new Error('ArgumentNullException : element');
	        // }
	        var index = this.internalElements.indexOf(element);
	        // if (index >= 0 && index < this.internalElements.length) {
	        this.internalElements[index] = null;
	        // }
	        this.markChanged();
	    };
	    /**
	     * `Remove` the element from the array by its index.
	     * @private
	     */
	    PdfArray.prototype.removeAt = function (index) {
	        // this.internalElements.RemoveAt(index);
	        if (this.internalElements.length > index) {
	            var tempArray = [];
	            for (var i = 0; i < index; i++) {
	                tempArray.push(this.internalElements[i]);
	            }
	            for (var i = index + 1; i < this.internalElements.length; i++) {
	                tempArray.push(this.internalElements[i]);
	            }
	            this.internalElements = tempArray;
	        }
	        this.markChanged();
	    };
	    /**
	     * `Clear` the array.
	     * @private
	     */
	    PdfArray.prototype.clear = function () {
	        this.internalElements = [];
	        this.markChanged();
	    };
	    /**
	     * `Marks` the object changed.
	     * @private
	     */
	    PdfArray.prototype.markChanged = function () {
	        this.bChanged = true;
	    };
	    return PdfArray;
	}());

	/**
	 * Save class provide method to save file
	 * ```typescript
	 * let blob : Blob = new Blob([''], { type: 'text/plain' });
	 * Save.save('fileName.txt',blob);
	 */
	var Save = /** @class */ (function () {
	    /**
	     * Initialize new instance of {save}
	     */
	    function Save() {
	        // tslint:disable
	    }
	    /**
	     * Saves the file with specified name and sends the file to client browser
	     * @param  {string} fileName- file name to save.
	     * @param  {Blob} buffer- the content to write in file
	     * @param  {boolean} isMicrosoftBrowser- specify whether microsoft browser or not
	     * @returns {void}
	     */
	    Save.save = function (fileName, buffer) {
	        if (fileName === null || fileName === undefined || fileName === '') {
	            throw new Error('ArgumentException: fileName cannot be undefined, null or empty');
	        }
	        var extension = fileName.substring(fileName.lastIndexOf('.') + 1, fileName.length);
	        var mimeType = this.getMimeType(extension);
	        if (mimeType !== '') {
	            buffer = new Blob([buffer], { type: mimeType });
	        }
	        if (this.isMicrosoftBrowser) {
	            navigator.msSaveBlob(buffer, fileName);
	        }
	        else {
	            var downloadLink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');
	            this.saveInternal(fileName, extension, buffer, downloadLink, 'download' in downloadLink);
	        }
	    };
	    Save.saveInternal = function (fileName, extension, buffer, downloadLink, hasDownloadAttribute) {
	        if (hasDownloadAttribute) {
	            downloadLink.download = fileName;
	            var dataUrl_1 = window.URL.createObjectURL(buffer);
	            downloadLink.href = dataUrl_1;
	            var event_1 = document.createEvent('MouseEvent');
	            event_1.initEvent('click', true, true);
	            downloadLink.dispatchEvent(event_1);
	            setTimeout(function () {
	                window.URL.revokeObjectURL(dataUrl_1);
	                dataUrl_1 = undefined;
	            });
	        }
	        else {
	            if (extension !== 'docx' && extension !== 'xlsx') {
	                var url = window.URL.createObjectURL(buffer);
	                var isPopupBlocked = window.open(url, '_blank');
	                if (!isPopupBlocked) {
	                    window.location.href = url;
	                }
	            }
	            else {
	                var reader_1 = new FileReader();
	                reader_1.onloadend = function () {
	                    var isPopupBlocked = window.open(reader_1.result, '_blank');
	                    if (!isPopupBlocked) {
	                        window.location.href = reader_1.result;
	                    }
	                };
	                reader_1.readAsDataURL(buffer);
	            }
	        }
	    };
	    /**
	     *
	     * @param {string} extension - get mime type of the specified extension
	     * @private
	     */
	    Save.getMimeType = function (extension) {
	        var mimeType = '';
	        switch (extension) {
	            case 'html':
	                mimeType = 'text/html';
	                break;
	            case 'pdf':
	                mimeType = 'application/pdf';
	                break;
	            case 'docx':
	                mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
	                break;
	            case 'xlsx':
	                mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
	                break;
	            case 'txt':
	                mimeType = 'text/plain';
	                break;
	        }
	        return mimeType;
	    };
	    return Save;
	}());

	/**
	 * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).
	 * ```typescript
	 * let encoding : Encoding = new Encoding();
	 * encoding.type = 'Utf8';
	 * encoding.getBytes('Encoding', 0, 5);
	 * ```
	 */
	var Encoding = /** @class */ (function () {
	    /**
	     * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark
	     * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.
	     */
	    function Encoding(includeBom) {
	        this.emitBOM = true;
	        this.encodingType = 'Ansi';
	        this.initBOM(includeBom);
	    }
	    Object.defineProperty(Encoding.prototype, "includeBom", {
	        /**
	         * Gets a value indicating whether to write a Unicode byte order mark
	         * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false
	         */
	        get: function () {
	            return this.emitBOM;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Encoding.prototype, "type", {
	        /**
	         * Gets the encoding type.
	         * @returns EncodingType
	         */
	        get: function () {
	            return this.encodingType;
	        },
	        /**
	         * Sets the encoding type.
	         * @param  {EncodingType} value
	         */
	        set: function (value) {
	            this.encodingType = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Initialize the includeBom to emit BOM or Not
	     * @param  {boolean} includeBom
	     */
	    Encoding.prototype.initBOM = function (includeBom) {
	        if (includeBom === undefined || includeBom === null) {
	            this.emitBOM = true;
	        }
	        else {
	            this.emitBOM = includeBom;
	        }
	    };
	    /**
	     * Calculates the number of bytes produced by encoding the characters in the specified string
	     * @param  {string} chars - The string containing the set of characters to encode
	     * @returns {number} - The number of bytes produced by encoding the specified characters
	     */
	    Encoding.prototype.getByteCount = function (chars) {
	        validateNullOrUndefined(chars, 'string');
	        if (chars === '') {
	            var byte = this.utf8Len(chars.charCodeAt(0));
	            return byte;
	        }
	        if (this.type === null || this.type === undefined) {
	            this.type = 'Ansi';
	        }
	        return this.getByteCountInternal(chars, 0, chars.length);
	    };
	    /**
	     * Return the Byte of character
	     * @param  {number} codePoint
	     * @returns {number}
	     */
	    Encoding.prototype.utf8Len = function (codePoint) {
	        var bytes = codePoint <= 0x7F ? 1 :
	            codePoint <= 0x7FF ? 2 :
	                codePoint <= 0xFFFF ? 3 :
	                    codePoint <= 0x1FFFFF ? 4 : 0;
	        return bytes;
	    };
	    /**
	     * for 4 byte character return surrogate pair true, otherwise false
	     * @param  {number} codeUnit
	     * @returns {boolean}
	     */
	    Encoding.prototype.isHighSurrogate = function (codeUnit) {
	        return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;
	    };
	    /**
	     * for 4byte character generate the surrogate pair
	     * @param  {number} highCodeUnit
	     * @param  {number} lowCodeUnit
	     */
	    Encoding.prototype.toCodepoint = function (highCodeUnit, lowCodeUnit) {
	        highCodeUnit = (0x3FF & highCodeUnit) << 10;
	        var u = highCodeUnit | (0x3FF & lowCodeUnit);
	        return u + 0x10000;
	    };
	    /**
	     * private method to get the byte count for specific charindex and count
	     * @param  {string} chars
	     * @param  {number} charIndex
	     * @param  {number} charCount
	     */
	    Encoding.prototype.getByteCountInternal = function (chars, charIndex, charCount) {
	        var byteCount = 0;
	        if (this.encodingType === 'Utf8' || this.encodingType === 'Unicode') {
	            var isUtf8 = this.encodingType === 'Utf8';
	            for (var i = 0; i < charCount; i++) {
	                var charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);
	                if (this.isHighSurrogate(charCode)) {
	                    if (isUtf8) {
	                        var high = charCode;
	                        var low = chars.charCodeAt(++charIndex);
	                        byteCount += this.utf8Len(this.toCodepoint(high, low));
	                    }
	                    else {
	                        byteCount += 4;
	                        ++i;
	                    }
	                }
	                else {
	                    if (isUtf8) {
	                        byteCount += this.utf8Len(charCode);
	                    }
	                    else {
	                        byteCount += 2;
	                    }
	                }
	                if (isUtf8) {
	                    charIndex++;
	                }
	            }
	            return byteCount;
	        }
	        else {
	            byteCount = charCount;
	            return byteCount;
	        }
	    };
	    /**
	     * Encodes a set of characters from the specified string into the ArrayBuffer.
	     * @param  {string} s- The string containing the set of characters to encode
	     * @param  {number} charIndex-The index of the first character to encode.
	     * @param  {number} charCount- The number of characters to encode.
	     * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.
	     */
	    Encoding.prototype.getBytes = function (s, charIndex, charCount) {
	        validateNullOrUndefined(s, 'string');
	        validateNullOrUndefined(charIndex, 'charIndex');
	        validateNullOrUndefined(charCount, 'charCount');
	        if (charIndex < 0 || charCount < 0) {
	            throw new RangeError('Argument Out Of Range Exception: charIndex or charCount is less than zero');
	        }
	        if (s.length - charIndex < charCount) {
	            throw new RangeError('Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string');
	        }
	        var bytes;
	        if (s === '') {
	            bytes = new ArrayBuffer(0);
	            return bytes;
	        }
	        if (this.type === null || this.type === undefined) {
	            this.type = 'Ansi';
	        }
	        var byteCount = this.getByteCountInternal(s, charIndex, charCount);
	        switch (this.type) {
	            case 'Utf8':
	                bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);
	                return bytes;
	            case 'Unicode':
	                bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);
	                return bytes;
	            default:
	                bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);
	                return bytes;
	        }
	    };
	    /**
	     * Decodes a sequence of bytes from the specified ArrayBuffer into the string.
	     * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.
	     * @param  {number} index- The index of the first byte to decode.
	     * @param  {number} count- The number of bytes to decode.
	     * @returns {string} - The string that contains the resulting set of characters.
	     */
	    Encoding.prototype.getString = function (bytes, index, count) {
	        validateNullOrUndefined(bytes, 'bytes');
	        validateNullOrUndefined(index, 'index');
	        validateNullOrUndefined(count, 'count');
	        if (index < 0 || count < 0) {
	            throw new RangeError('Argument Out Of Range Exception: index or count is less than zero');
	        }
	        if (bytes.byteLength - index < count) {
	            throw new RangeError('Argument Out Of Range Exception: index and count do not denote a valid range in bytes');
	        }
	        if (bytes.byteLength === 0 || count === 0) {
	            return '';
	        }
	        if (this.type === null || this.type === undefined) {
	            this.type = 'Ansi';
	        }
	        var out = '';
	        var byteCal = new Uint8Array(bytes);
	        switch (this.type) {
	            case 'Utf8':
	                var s = this.getStringOfUtf8Encoding(byteCal, index, count);
	                return s;
	            case 'Unicode':
	                var byteUnicode = new Uint16Array(bytes);
	                out = this.getStringofUnicodeEncoding(byteUnicode, index, count);
	                return out;
	            default:
	                var j = index;
	                for (var i = 0; i < count; i++) {
	                    var c = byteCal[j];
	                    out += String.fromCharCode(c); // 1 byte(ASCII) character                  
	                    j++;
	                }
	                return out;
	        }
	    };
	    Encoding.prototype.getBytesOfAnsiEncoding = function (byteCount, s, charIndex, charCount) {
	        var bytes = new ArrayBuffer(byteCount);
	        var bufview = new Uint8Array(bytes);
	        var k = 0;
	        for (var i = 0; i < charCount; i++) {
	            var charcode = s.charCodeAt(charIndex++);
	            if (charcode < 0x800) {
	                bufview[k] = charcode;
	            }
	            else {
	                bufview[k] = 63; //replacement character '?'
	            }
	            k++;
	        }
	        return bytes;
	    };
	    Encoding.prototype.getBytesOfUtf8Encoding = function (byteCount, s, charIndex, charCount) {
	        var bytes = new ArrayBuffer(byteCount);
	        var uint = new Uint8Array(bytes);
	        var index = charIndex;
	        var j = 0;
	        for (var i = 0; i < charCount; i++) {
	            var charcode = s.charCodeAt(index);
	            if (charcode <= 0x7F) { // 1 byte character 2^7
	                uint[j] = charcode;
	            }
	            else if (charcode < 0x800) { // 2 byte character 2^11
	                uint[j] = 0xc0 | (charcode >> 6);
	                uint[++j] = 0x80 | (charcode & 0x3f);
	            }
	            else if ((charcode < 0xd800 || charcode >= 0xe000)) { // 3 byte character 2^16        
	                uint[j] = 0xe0 | (charcode >> 12);
	                uint[++j] = 0x80 | ((charcode >> 6) & 0x3f);
	                uint[++j] = 0x80 | (charcode & 0x3f);
	            }
	            else {
	                uint[j] = 0xef;
	                uint[++j] = 0xbf;
	                uint[++j] = 0xbd; // U+FFFE "replacement character"
	            }
	            ++j;
	            ++index;
	        }
	        return bytes;
	    };
	    Encoding.prototype.getBytesOfUnicodeEncoding = function (byteCount, s, charIndex, charCount) {
	        var bytes = new ArrayBuffer(byteCount);
	        var uint16 = new Uint16Array(bytes);
	        for (var i = 0; i < charCount; i++) {
	            var charcode = s.charCodeAt(i);
	            uint16[i] = charcode;
	        }
	        return bytes;
	    };
	    Encoding.prototype.getStringOfUtf8Encoding = function (byteCal, index, count) {
	        var j = 0;
	        var i = index;
	        var s = '';
	        for (j; j < count; j++) {
	            var c = byteCal[i++];
	            while (i > byteCal.length) {
	                return s;
	            }
	            if (c > 127) {
	                if (c > 191 && c < 224 && i < count) {
	                    c = (c & 31) << 6 | byteCal[i] & 63;
	                }
	                else if (c > 223 && c < 240 && i < byteCal.byteLength) {
	                    c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;
	                }
	                else if (c > 239 && c < 248 && i < byteCal.byteLength) {
	                    c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;
	                }
	                ++i;
	            }
	            s += String.fromCharCode(c); // 1 byte(ASCII) character                          
	        }
	        return s;
	    };
	    Encoding.prototype.getStringofUnicodeEncoding = function (byteUni, index, count) {
	        if (count > byteUni.length) {
	            throw new RangeError('ArgumentOutOfRange_Count');
	        }
	        var byte16 = new Uint16Array(count);
	        var out = '';
	        for (var i = 0; i < count && i < byteUni.length; i++) {
	            byte16[i] = byteUni[index++];
	        }
	        out = String.fromCharCode.apply(null, byte16);
	        return out;
	    };
	    /**
	     * To clear the encoding instance
	     * @return {void}
	     */
	    Encoding.prototype.destroy = function () {
	        this.emitBOM = undefined;
	        this.encodingType = undefined;
	    };
	    return Encoding;
	}());
	/**
	 * To check the object is null or undefined and throw error if it is null or undefined
	 * @param {Object} value - object to check is null or undefined
	 * @return {boolean}
	 * @throws {ArgumentException} - if the value is null or undefined
	 * @private
	 */
	function validateNullOrUndefined(value, message) {
	    if (value === null || value === undefined) {
	        throw new Error('ArgumentException: ' + message + ' cannot be null or undefined');
	    }
	}

	/**
	 * StreamWriter class contains the implementation for writing characters to a file in a particular encoding
	 * ```typescript
	 * let writer = new StreamWriter();
	 * writer.write('Hello World');
	 * writer.save('Sample.txt');
	 * writer.dispose();
	 * ```
	 */
	var StreamWriter = /** @class */ (function () {
	    /**
	     * Initializes a new instance of the StreamWriter class by using the specified encoding.
	     * @param  {Encoding} encoding?- The character encoding to use.
	     */
	    function StreamWriter(encoding) {
	        this.bufferBlob = new Blob(['']);
	        this.bufferText = '';
	        this.init(encoding);
	        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);
	    }
	    Object.defineProperty(StreamWriter.prototype, "buffer", {
	        /**
	         * Gets the content written to the StreamWriter as Blob.
	         * @returns Blob
	         */
	        get: function () {
	            this.flush();
	            return this.bufferBlob;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(StreamWriter.prototype, "encoding", {
	        /**
	         * Gets the encoding.
	         * @returns Encoding
	         */
	        get: function () {
	            return this.enc;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    StreamWriter.prototype.init = function (encoding) {
	        if (encoding === null || encoding === undefined) {
	            this.enc = new Encoding(false);
	            this.enc.type = 'Utf8';
	        }
	        else {
	            this.enc = encoding;
	            this.setBomByte();
	        }
	    };
	    /**
	     * Private method to set Byte Order Mark(BOM) value based on EncodingType
	     */
	    StreamWriter.prototype.setBomByte = function () {
	        if (this.encoding.includeBom) {
	            switch (this.encoding.type) {
	                case 'Unicode':
	                    var arrayUnicode = new ArrayBuffer(2);
	                    var uint8 = new Uint8Array(arrayUnicode);
	                    uint8[0] = 255;
	                    uint8[1] = 254;
	                    this.bufferBlob = new Blob([arrayUnicode]);
	                    break;
	                case 'Utf8':
	                    var arrayUtf8 = new ArrayBuffer(3);
	                    var utf8 = new Uint8Array(arrayUtf8);
	                    utf8[0] = 239;
	                    utf8[1] = 187;
	                    utf8[2] = 191;
	                    this.bufferBlob = new Blob([arrayUtf8]);
	                    break;
	                default:
	                    this.bufferBlob = new Blob(['']);
	                    break;
	            }
	        }
	    };
	    /**
	     * Saves the file with specified name and sends the file to client browser
	     * @param  {string} fileName - The file name to save
	     * @returns {void}
	     */
	    StreamWriter.prototype.save = function (fileName) {
	        if (this.bufferText !== '') {
	            this.flush();
	        }
	        Save.save(fileName, this.buffer);
	    };
	    /**
	     * Writes the specified string.
	     * @param  {string} value - The string to write. If value is null or undefined, nothing is written.
	     * @returns {void}
	     */
	    StreamWriter.prototype.write = function (value) {
	        if (this.encoding === undefined) {
	            throw new Error('Object Disposed Exception: current writer is disposed');
	        }
	        validateNullOrUndefined(value, 'string');
	        this.bufferText += value;
	        if (this.bufferText.length >= 10240) {
	            this.flush();
	        }
	    };
	    StreamWriter.prototype.flush = function () {
	        if (this.bufferText === undefined || this.bufferText === null || this.bufferText.length === 0) {
	            return;
	        }
	        var bufferArray = this.encoding.getBytes(this.bufferText, 0, this.bufferText.length);
	        this.bufferText = '';
	        this.bufferBlob = new Blob([this.bufferBlob, bufferArray]);
	    };
	    /**
	     * Writes the specified string followed by a line terminator
	     * @param  {string} value - The string to write. If value is null or undefined, nothing is written
	     * @returns {void}
	     */
	    StreamWriter.prototype.writeLine = function (value) {
	        if (this.encoding === undefined) {
	            throw new Error('Object Disposed Exception: current writer is disposed');
	        }
	        validateNullOrUndefined(value, 'string');
	        this.bufferText = this.bufferText + value + '\r\n';
	        if (this.bufferText.length >= 10240) {
	            this.flush();
	        }
	    };
	    /**
	     * Releases the resources used by the StreamWriter
	     * @returns {void}
	     */
	    StreamWriter.prototype.destroy = function () {
	        this.bufferBlob = undefined;
	        this.bufferText = undefined;
	        if (this.enc instanceof Encoding) {
	            this.enc.destroy();
	        }
	        this.enc = undefined;
	    };
	    return StreamWriter;
	}());

	/* eslint-disable */
	/**
	 * array literal codes
	 */
	var ARR_LITERAL_CODES = new Int16Array(286);
	var ARR_LITERAL_LENGTHS = new Uint8Array(286);
	var ARR_DISTANCE_CODES = new Int16Array(30);
	var ARR_DISTANCE_LENGTHS = new Uint8Array(30);
	/**
	 * represent compression stream writer
	 * ```typescript
	 * let compressedWriter = new CompressedStreamWriter();
	 * let text: string = 'Hello world!!!';
	 * compressedWriter.write(text, 0, text.length);
	 * compressedWriter.close();
	 * ```
	 */
	var CompressedStreamWriter = /** @class */ (function () {
	    /**
	     * Initializes compressor and writes ZLib header if needed.
	     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.
	     */
	    function CompressedStreamWriter(noWrap) {
	        this.pendingBuffer = new Uint8Array(1 << 16);
	        this.pendingBufLength = 0;
	        this.pendingBufCache = 0;
	        this.pendingBufBitsInCache = 0;
	        this.bufferPosition = 0;
	        this.extraBits = 0;
	        this.currentHash = 0;
	        this.matchStart = 0;
	        this.matchLength = 0;
	        this.matchPrevAvail = false;
	        this.blockStart = 0;
	        this.stringStart = 0;
	        this.lookAhead = 0;
	        this.totalBytesIn = 0;
	        this.inputOffset = 0;
	        this.inputEnd = 0;
	        this.windowSize = 1 << 15;
	        this.windowMask = this.windowSize - 1;
	        this.hashSize = 1 << 15;
	        this.hashMask = this.hashSize - 1;
	        this.hashShift = Math.floor((15 + 3 - 1) / 3);
	        this.maxDist = this.windowSize - 262;
	        this.checkSum = 1;
	        this.noWrap = false;
	        if (!CompressedStreamWriter.isHuffmanTreeInitiated) {
	            CompressedStreamWriter.initHuffmanTree();
	            CompressedStreamWriter.isHuffmanTreeInitiated = true;
	        }
	        this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);
	        this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);
	        this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);
	        this.arrDistances = new Uint16Array((1 << 14));
	        this.arrLiterals = new Uint8Array((1 << 14));
	        this.stream = [];
	        this.dataWindow = new Uint8Array(2 * this.windowSize);
	        this.hashHead = new Int16Array(this.hashSize);
	        this.hashPrevious = new Int16Array(this.windowSize);
	        this.blockStart = this.stringStart = 1;
	        this.noWrap = noWrap;
	        if (!noWrap) {
	            this.writeZLibHeader();
	        }
	    }
	    Object.defineProperty(CompressedStreamWriter.prototype, "compressedData", {
	        /**
	         * get compressed data
	         */
	        get: function () {
	            return this.stream;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CompressedStreamWriter.prototype, "getCompressedString", {
	        get: function () {
	            var compressedString = '';
	            if (this.stream !== undefined) {
	                for (var i = 0; i < this.stream.length; i++) {
	                    compressedString += String.fromCharCode.apply(null, this.stream[i]);
	                }
	            }
	            return compressedString;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Compresses data and writes it to the stream.
	     * @param {Uint8Array} data - data to compress
	     * @param {number} offset - offset in data
	     * @param {number} length - length of the data
	     * @returns {void}
	     */
	    CompressedStreamWriter.prototype.write = function (data, offset, length) {
	        if (data === undefined || data === null) {
	            throw new Error('ArgumentException: data cannot null or undefined');
	        }
	        var end = offset + length;
	        if (0 > offset || offset > end || end > data.length) {
	            throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');
	        }
	        if (typeof data === 'string') {
	            var encode = new Encoding(false);
	            encode.type = 'Utf8';
	            data = new Uint8Array(encode.getBytes(data, 0, data.length));
	            end = offset + data.length;
	        }
	        this.inputBuffer = data;
	        this.inputOffset = offset;
	        this.inputEnd = end;
	        if (!this.noWrap) {
	            this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);
	        }
	        while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {
	            this.pendingBufferFlush();
	            this.compressData(false);
	        }
	    };
	    /**
	     * write ZLib header to the compressed data
	     * @return {void}
	     */
	    CompressedStreamWriter.prototype.writeZLibHeader = function () {
	        /* Initialize header.*/
	        var headerDate = (8 + (7 << 4)) << 8;
	        /* Save compression level.*/
	        headerDate |= ((5 >> 2) & 3) << 6;
	        /* Align header.*/
	        headerDate += 31 - (headerDate % 31);
	        /* Write header to stream.*/
	        this.pendingBufferWriteShortBytes(headerDate);
	    };
	    /**
	     *  Write Most Significant Bytes in to stream
	     * @param {number} s - check sum value
	     */
	    CompressedStreamWriter.prototype.pendingBufferWriteShortBytes = function (s) {
	        this.pendingBuffer[this.pendingBufLength++] = s >> 8;
	        this.pendingBuffer[this.pendingBufLength++] = s;
	    };
	    CompressedStreamWriter.prototype.compressData = function (finish) {
	        var success;
	        do {
	            this.fillWindow();
	            var canFlush = (finish && this.inputEnd === this.inputOffset);
	            success = this.compressSlow(canFlush, finish);
	        } while (this.pendingBufLength === 0 && success);
	        return success;
	    };
	    CompressedStreamWriter.prototype.compressSlow = function (flush, finish) {
	        if (this.lookAhead < 262 && !flush) {
	            return false;
	        }
	        while (this.lookAhead >= 262 || flush) {
	            if (this.lookAhead === 0) {
	                return this.lookAheadCompleted(finish);
	            }
	            if (this.stringStart >= 2 * this.windowSize - 262) {
	                this.slideWindow();
	            }
	            var prevMatch = this.matchStart;
	            var prevLen = this.matchLength;
	            if (this.lookAhead >= 3) {
	                this.discardMatch();
	            }
	            if (prevLen >= 3 && this.matchLength <= prevLen) {
	                prevLen = this.matchPreviousBest(prevMatch, prevLen);
	            }
	            else {
	                this.matchPreviousAvailable();
	            }
	            if (this.bufferPosition >= (1 << 14)) {
	                return this.huffmanIsFull(finish);
	            }
	        }
	        return true;
	    };
	    CompressedStreamWriter.prototype.discardMatch = function () {
	        var hashHead = this.insertString();
	        if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {
	            if (this.matchLength <= 5 && (this.matchLength === 3 && this.stringStart - this.matchStart > 4096)) {
	                this.matchLength = 3 - 1;
	            }
	        }
	    };
	    CompressedStreamWriter.prototype.matchPreviousAvailable = function () {
	        if (this.matchPrevAvail) {
	            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);
	        }
	        this.matchPrevAvail = true;
	        this.stringStart++;
	        this.lookAhead--;
	    };
	    CompressedStreamWriter.prototype.matchPreviousBest = function (prevMatch, prevLen) {
	        this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);
	        prevLen -= 2;
	        do {
	            this.stringStart++;
	            this.lookAhead--;
	            if (this.lookAhead >= 3) {
	                this.insertString();
	            }
	        } while (--prevLen > 0);
	        this.stringStart++;
	        this.lookAhead--;
	        this.matchPrevAvail = false;
	        this.matchLength = 3 - 1;
	        return prevLen;
	    };
	    CompressedStreamWriter.prototype.lookAheadCompleted = function (finish) {
	        if (this.matchPrevAvail) {
	            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);
	        }
	        this.matchPrevAvail = false;
	        this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);
	        this.blockStart = this.stringStart;
	        return false;
	    };
	    CompressedStreamWriter.prototype.huffmanIsFull = function (finish) {
	        var len = this.stringStart - this.blockStart;
	        if (this.matchPrevAvail) {
	            len--;
	        }
	        var lastBlock = (finish && this.lookAhead === 0 && !this.matchPrevAvail);
	        this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);
	        this.blockStart += len;
	        return !lastBlock;
	    };
	    CompressedStreamWriter.prototype.fillWindow = function () {
	        if (this.stringStart >= this.windowSize + this.maxDist) {
	            this.slideWindow();
	        }
	        while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {
	            var more = 2 * this.windowSize - this.lookAhead - this.stringStart;
	            if (more > this.inputEnd - this.inputOffset) {
	                more = this.inputEnd - this.inputOffset;
	            }
	            this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);
	            this.inputOffset += more;
	            this.totalBytesIn += more;
	            this.lookAhead += more;
	        }
	        if (this.lookAhead >= 3) {
	            this.updateHash();
	        }
	    };
	    CompressedStreamWriter.prototype.slideWindow = function () {
	        this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);
	        this.matchStart -= this.windowSize;
	        this.stringStart -= this.windowSize;
	        this.blockStart -= this.windowSize;
	        for (var i = 0; i < this.hashSize; ++i) {
	            var m = this.hashHead[i] & 0xffff;
	            this.hashHead[i] = (((m >= this.windowSize) ? (m - this.windowSize) : 0));
	        }
	        for (var i = 0; i < this.windowSize; i++) {
	            var m = this.hashPrevious[i] & 0xffff;
	            this.hashPrevious[i] = ((m >= this.windowSize) ? (m - this.windowSize) : 0);
	        }
	    };
	    CompressedStreamWriter.prototype.insertString = function () {
	        var match;
	        var hash = ((this.currentHash << this.hashShift) ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;
	        this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];
	        this.hashHead[hash] = this.stringStart;
	        this.currentHash = hash;
	        return match & 0xffff;
	    };
	    CompressedStreamWriter.prototype.findLongestMatch = function (curMatch) {
	        var chainLen = 4096;
	        var niceLen = 258;
	        var scan = this.stringStart;
	        var match;
	        var bestEnd = this.stringStart + this.matchLength;
	        var bestLength = Math.max(this.matchLength, 3 - 1);
	        var limit = Math.max(this.stringStart - this.maxDist, 0);
	        var stringEnd = this.stringStart + 258 - 1;
	        var scanEnd1 = this.dataWindow[bestEnd - 1];
	        var scanEnd = this.dataWindow[bestEnd];
	        var data = this.dataWindow;
	        if (bestLength >= 32) {
	            chainLen >>= 2;
	        }
	        if (niceLen > this.lookAhead) {
	            niceLen = this.lookAhead;
	        }
	        do {
	            if (data[curMatch + bestLength] !== scanEnd ||
	                data[curMatch + bestLength - 1] !== scanEnd1 ||
	                data[curMatch] !== data[scan] ||
	                data[curMatch + 1] !== data[scan + 1]) {
	                continue;
	            }
	            match = curMatch + 2;
	            scan += 2;
	            /* tslint:disable */
	            while (data[++scan] === data[++match] && data[++scan] === data[++match] &&
	                data[++scan] === data[++match] && data[++scan] === data[++match] &&
	                data[++scan] === data[++match] && data[++scan] === data[++match] &&
	                data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {
	                /* tslint:disable */
	            }
	            if (scan > bestEnd) {
	                this.matchStart = curMatch;
	                bestEnd = scan;
	                bestLength = scan - this.stringStart;
	                if (bestLength >= niceLen) {
	                    break;
	                }
	                scanEnd1 = data[bestEnd - 1];
	                scanEnd = data[bestEnd];
	            }
	            scan = this.stringStart;
	        } while ((curMatch = (this.hashPrevious[curMatch & this.windowMask] & 0xffff)) > limit && --chainLen !== 0);
	        this.matchLength = Math.min(bestLength, this.lookAhead);
	        return this.matchLength >= 3;
	    };
	    CompressedStreamWriter.prototype.updateHash = function () {
	        this.currentHash = (this.dataWindow[this.stringStart] << this.hashShift) ^ this.dataWindow[this.stringStart + 1];
	    };
	    CompressedStreamWriter.prototype.huffmanTallyLit = function (literal) {
	        this.arrDistances[this.bufferPosition] = 0;
	        this.arrLiterals[this.bufferPosition++] = literal;
	        this.treeLiteral.codeFrequencies[literal]++;
	        return this.bufferPosition >= (1 << 14);
	    };
	    CompressedStreamWriter.prototype.huffmanTallyDist = function (dist, len) {
	        this.arrDistances[this.bufferPosition] = dist;
	        this.arrLiterals[this.bufferPosition++] = (len - 3);
	        var lc = this.huffmanLengthCode(len - 3);
	        this.treeLiteral.codeFrequencies[lc]++;
	        if (lc >= 265 && lc < 285) {
	            this.extraBits += Math.floor((lc - 261) / 4);
	        }
	        var dc = this.huffmanDistanceCode(dist - 1);
	        this.treeDistances.codeFrequencies[dc]++;
	        if (dc >= 4) {
	            this.extraBits += Math.floor((dc / 2 - 1));
	        }
	        return this.bufferPosition >= (1 << 14);
	    };
	    CompressedStreamWriter.prototype.huffmanFlushBlock = function (stored, storedOffset, storedLength, lastBlock) {
	        this.treeLiteral.codeFrequencies[256]++;
	        this.treeLiteral.buildTree();
	        this.treeDistances.buildTree();
	        this.treeLiteral.calculateBLFreq(this.treeCodeLengths);
	        this.treeDistances.calculateBLFreq(this.treeCodeLengths);
	        this.treeCodeLengths.buildTree();
	        var blTreeCodes = 4;
	        for (var i = 18; i > blTreeCodes; i--) {
	            if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {
	                blTreeCodes = i + 1;
	            }
	        }
	        var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() +
	            this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;
	        var static_len = this.extraBits;
	        for (var i = 0; i < 286; i++) {
	            static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];
	        }
	        for (var i = 0; i < 30; i++) {
	            static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];
	        }
	        if (opt_len >= static_len) {
	            // Force static trees.
	            opt_len = static_len;
	        }
	        if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {
	            this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);
	        }
	        else if (opt_len == static_len) {
	            // Encode with static tree.
	            this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);
	            this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);
	            this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);
	            this.huffmanCompressBlock();
	            this.huffmanReset();
	        }
	        else {
	            this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);
	            this.huffmanSendAllTrees(blTreeCodes);
	            this.huffmanCompressBlock();
	            this.huffmanReset();
	        }
	    };
	    CompressedStreamWriter.prototype.huffmanFlushStoredBlock = function (stored, storedOffset, storedLength, lastBlock) {
	        this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);
	        this.pendingBufferAlignToByte();
	        this.pendingBufferWriteShort(storedLength);
	        this.pendingBufferWriteShort(~storedLength);
	        this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);
	        this.huffmanReset();
	    };
	    CompressedStreamWriter.prototype.huffmanLengthCode = function (len) {
	        if (len === 255) {
	            return 285;
	        }
	        var code = 257;
	        while (len >= 8) {
	            code += 4;
	            len >>= 1;
	        }
	        return code + len;
	    };
	    CompressedStreamWriter.prototype.huffmanDistanceCode = function (distance) {
	        var code = 0;
	        while (distance >= 4) {
	            code += 2;
	            distance >>= 1;
	        }
	        return code + distance;
	    };
	    CompressedStreamWriter.prototype.huffmanSendAllTrees = function (blTreeCodes) {
	        this.treeCodeLengths.buildCodes();
	        this.treeLiteral.buildCodes();
	        this.treeDistances.buildCodes();
	        this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);
	        this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);
	        this.pendingBufferWriteBits(blTreeCodes - 4, 4);
	        for (var rank = 0; rank < blTreeCodes; rank++) {
	            this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);
	        }
	        this.treeLiteral.writeTree(this.treeCodeLengths);
	        this.treeDistances.writeTree(this.treeCodeLengths);
	    };
	    CompressedStreamWriter.prototype.huffmanReset = function () {
	        this.bufferPosition = 0;
	        this.extraBits = 0;
	        this.treeLiteral.reset();
	        this.treeDistances.reset();
	        this.treeCodeLengths.reset();
	    };
	    CompressedStreamWriter.prototype.huffmanCompressBlock = function () {
	        for (var i = 0; i < this.bufferPosition; i++) {
	            var literalLen = this.arrLiterals[i] & 255;
	            var dist = this.arrDistances[i];
	            if (dist-- !== 0) {
	                var lc = this.huffmanLengthCode(literalLen);
	                this.treeLiteral.writeCodeToStream(lc);
	                var bits = Math.floor((lc - 261) / 4);
	                if (bits > 0 && bits <= 5) {
	                    this.pendingBufferWriteBits(literalLen & ((1 << bits) - 1), bits);
	                }
	                var dc = this.huffmanDistanceCode(dist);
	                this.treeDistances.writeCodeToStream(dc);
	                bits = Math.floor(dc / 2 - 1);
	                if (bits > 0) {
	                    this.pendingBufferWriteBits(dist & ((1 << bits) - 1), bits);
	                }
	            }
	            else {
	                this.treeLiteral.writeCodeToStream(literalLen);
	            }
	        }
	        this.treeLiteral.writeCodeToStream(256);
	    };
	    /**
	     * write bits in to internal buffer
	     * @param {number} b - source of bits
	     * @param {number} count - count of bits to write
	     */
	    CompressedStreamWriter.prototype.pendingBufferWriteBits = function (b, count) {
	        var uint = new Uint32Array(1);
	        uint[0] = this.pendingBufCache | (b << this.pendingBufBitsInCache);
	        this.pendingBufCache = uint[0];
	        this.pendingBufBitsInCache += count;
	        this.pendingBufferFlushBits();
	    };
	    CompressedStreamWriter.prototype.pendingBufferFlush = function (isClose) {
	        this.pendingBufferFlushBits();
	        if (this.pendingBufLength > 0) {
	            var array = new Uint8Array(this.pendingBufLength);
	            array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);
	            this.stream.push(array);
	        }
	        this.pendingBufLength = 0;
	    };
	    CompressedStreamWriter.prototype.pendingBufferFlushBits = function () {
	        var result = 0;
	        while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < (1 << 16)) {
	            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;
	            this.pendingBufCache >>= 8;
	            this.pendingBufBitsInCache -= 8;
	            result++;
	        }
	        return result;
	    };
	    CompressedStreamWriter.prototype.pendingBufferWriteByteBlock = function (data, offset, length) {
	        var array = data.subarray(offset, offset + length);
	        this.pendingBuffer.set(array, this.pendingBufLength);
	        this.pendingBufLength += length;
	    };
	    CompressedStreamWriter.prototype.pendingBufferWriteShort = function (s) {
	        this.pendingBuffer[this.pendingBufLength++] = s;
	        this.pendingBuffer[this.pendingBufLength++] = (s >> 8);
	    };
	    CompressedStreamWriter.prototype.pendingBufferAlignToByte = function () {
	        if (this.pendingBufBitsInCache > 0) {
	            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;
	        }
	        this.pendingBufCache = 0;
	        this.pendingBufBitsInCache = 0;
	    };
	    /**
	     * Huffman Tree literal calculation
	     * @private
	     */
	    CompressedStreamWriter.initHuffmanTree = function () {
	        var i = 0;
	        while (i < 144) {
	            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x030 + i) << 8);
	            ARR_LITERAL_LENGTHS[i++] = 8;
	        }
	        while (i < 256) {
	            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x190 - 144 + i) << 7);
	            ARR_LITERAL_LENGTHS[i++] = 9;
	        }
	        while (i < 280) {
	            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x000 - 256 + i) << 9);
	            ARR_LITERAL_LENGTHS[i++] = 7;
	        }
	        while (i < 286) {
	            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x0c0 - 280 + i) << 8);
	            ARR_LITERAL_LENGTHS[i++] = 8;
	        }
	        for (i = 0; i < 30; i++) {
	            ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);
	            ARR_DISTANCE_LENGTHS[i] = 5;
	        }
	    };
	    /**
	     * close the stream and write all pending buffer in to stream
	     * @returns {void}
	     */
	    CompressedStreamWriter.prototype.close = function () {
	        do {
	            this.pendingBufferFlush(true);
	            if (!this.compressData(true)) {
	                this.pendingBufferFlush(true);
	                this.pendingBufferAlignToByte();
	                if (!this.noWrap) {
	                    this.pendingBufferWriteShortBytes(this.checkSum >> 16);
	                    this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);
	                }
	                this.pendingBufferFlush(true);
	            }
	        } while (!(this.inputEnd === this.inputOffset) ||
	            !(this.pendingBufLength === 0));
	    };
	    /**
	     * release allocated un-managed resource
	     * @returns {void}
	     */
	    CompressedStreamWriter.prototype.destroy = function () {
	        this.stream = [];
	        this.stream = undefined;
	        this.pendingBuffer = undefined;
	        this.treeLiteral = undefined;
	        this.treeDistances = undefined;
	        this.treeCodeLengths = undefined;
	        this.arrLiterals = undefined;
	        this.arrDistances = undefined;
	        this.hashHead = undefined;
	        this.hashPrevious = undefined;
	        this.dataWindow = undefined;
	        this.inputBuffer = undefined;
	        this.pendingBufLength = undefined;
	        this.pendingBufCache = undefined;
	        this.pendingBufBitsInCache = undefined;
	        this.bufferPosition = undefined;
	        this.extraBits = undefined;
	        this.currentHash = undefined;
	        this.matchStart = undefined;
	        this.matchLength = undefined;
	        this.matchPrevAvail = undefined;
	        this.blockStart = undefined;
	        this.stringStart = undefined;
	        this.lookAhead = undefined;
	        this.totalBytesIn = undefined;
	        this.inputOffset = undefined;
	        this.inputEnd = undefined;
	        this.windowSize = undefined;
	        this.windowMask = undefined;
	        this.hashSize = undefined;
	        this.hashMask = undefined;
	        this.hashShift = undefined;
	        this.maxDist = undefined;
	        this.checkSum = undefined;
	        this.noWrap = undefined;
	    };
	    CompressedStreamWriter.isHuffmanTreeInitiated = false;
	    return CompressedStreamWriter;
	}());
	/**
	 * represent the Huffman Tree
	 */
	var CompressorHuffmanTree = /** @class */ (function () {
	    /**
	     * Create new Huffman Tree
	     * @param {CompressedStreamWriter} writer instance
	     * @param {number} elementCount - element count
	     * @param {number} minCodes - minimum count
	     * @param {number} maxLength - maximum count
	     */
	    function CompressorHuffmanTree(writer, elementCount, minCodes, maxLength) {
	        this.writer = writer;
	        this.codeMinCount = minCodes;
	        this.maxLength = maxLength;
	        this.codeFrequency = new Uint16Array(elementCount);
	        this.lengthCount = new Int32Array(maxLength);
	    }
	    Object.defineProperty(CompressorHuffmanTree.prototype, "treeLength", {
	        get: function () {
	            return this.codeCount;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CompressorHuffmanTree.prototype, "codeLengths", {
	        get: function () {
	            return this.codeLength;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CompressorHuffmanTree.prototype, "codeFrequencies", {
	        get: function () {
	            return this.codeFrequency;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    CompressorHuffmanTree.prototype.setStaticCodes = function (codes, lengths) {
	        var temp = new Int16Array(codes.length);
	        temp.set(codes, 0);
	        this.codes = temp;
	        var lengthTemp = new Uint8Array(lengths.length);
	        lengthTemp.set(lengths, 0);
	        this.codeLength = lengthTemp;
	    };
	    /**
	     * reset all code data in tree
	     * @returns {void}
	     */
	    CompressorHuffmanTree.prototype.reset = function () {
	        for (var i = 0; i < this.codeFrequency.length; i++) {
	            this.codeFrequency[i] = 0;
	        }
	        this.codes = undefined;
	        this.codeLength = undefined;
	    };
	    /**
	     * write code to the compressor output stream
	     * @param {number} code - code to be written
	     * @returns {void}
	     */
	    CompressorHuffmanTree.prototype.writeCodeToStream = function (code) {
	        this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);
	    };
	    /**
	     * calculate code from their frequencies
	     * @returns {void}
	     */
	    CompressorHuffmanTree.prototype.buildCodes = function () {
	        var nextCode = new Int32Array(this.maxLength);
	        this.codes = new Int16Array(this.codeCount);
	        var code = 0;
	        for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {
	            nextCode[bitsCount] = code;
	            code += this.lengthCount[bitsCount] << (15 - bitsCount);
	        }
	        for (var i = 0; i < this.codeCount; i++) {
	            var bits = this.codeLength[i];
	            if (bits > 0) {
	                this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);
	                nextCode[bits - 1] += 1 << (16 - bits);
	            }
	        }
	    };
	    CompressorHuffmanTree.bitReverse = function (value) {
	        return (CompressorHuffmanTree.reverseBits[value & 15] << 12
	            | CompressorHuffmanTree.reverseBits[(value >> 4) & 15] << 8
	            | CompressorHuffmanTree.reverseBits[(value >> 8) & 15] << 4
	            | CompressorHuffmanTree.reverseBits[value >> 12]);
	    };
	    /**
	     * calculate length of compressed data
	     * @returns {number}
	     */
	    CompressorHuffmanTree.prototype.getEncodedLength = function () {
	        var len = 0;
	        for (var i = 0; i < this.codeFrequency.length; i++) {
	            len += this.codeFrequency[i] * this.codeLength[i];
	        }
	        return len;
	    };
	    /**
	     * calculate code frequencies
	     * @param {CompressorHuffmanTree} blTree
	     * @returns {void}
	     */
	    CompressorHuffmanTree.prototype.calculateBLFreq = function (blTree) {
	        var maxCount;
	        var minCount;
	        var count;
	        var curLen = -1;
	        var i = 0;
	        while (i < this.codeCount) {
	            count = 1;
	            var nextLen = this.codeLength[i];
	            if (nextLen === 0) {
	                maxCount = 138;
	                minCount = 3;
	            }
	            else {
	                maxCount = 6;
	                minCount = 3;
	                if (curLen !== nextLen) {
	                    blTree.codeFrequency[nextLen]++;
	                    count = 0;
	                }
	            }
	            curLen = nextLen;
	            i++;
	            while (i < this.codeCount && curLen === this.codeLength[i]) {
	                i++;
	                if (++count >= maxCount) {
	                    break;
	                }
	            }
	            if (count < minCount) {
	                blTree.codeFrequency[curLen] += count;
	            }
	            else if (curLen !== 0) {
	                blTree.codeFrequency[16]++;
	            }
	            else if (count <= 10) {
	                blTree.codeFrequency[17]++;
	            }
	            else {
	                blTree.codeFrequency[18]++;
	            }
	        }
	    };
	    /**
	     * @param {CompressorHuffmanTree} blTree - write tree to output stream
	     * @returns {void}
	     */
	    CompressorHuffmanTree.prototype.writeTree = function (blTree) {
	        var maxRepeatCount;
	        var minRepeatCount;
	        var currentRepeatCount;
	        var currentCodeLength = -1;
	        var i = 0;
	        while (i < this.codeCount) {
	            currentRepeatCount = 1;
	            var nextLen = this.codeLength[i];
	            if (nextLen === 0) {
	                maxRepeatCount = 138;
	                minRepeatCount = 3;
	            }
	            else {
	                maxRepeatCount = 6;
	                minRepeatCount = 3;
	                if (currentCodeLength !== nextLen) {
	                    blTree.writeCodeToStream(nextLen);
	                    currentRepeatCount = 0;
	                }
	            }
	            currentCodeLength = nextLen;
	            i++;
	            while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {
	                i++;
	                if (++currentRepeatCount >= maxRepeatCount) {
	                    break;
	                }
	            }
	            if (currentRepeatCount < minRepeatCount) {
	                while (currentRepeatCount-- > 0) {
	                    blTree.writeCodeToStream(currentCodeLength);
	                }
	            }
	            else if (currentCodeLength !== 0) {
	                blTree.writeCodeToStream(16);
	                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);
	            }
	            else if (currentRepeatCount <= 10) {
	                blTree.writeCodeToStream(17);
	                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);
	            }
	            else {
	                blTree.writeCodeToStream(18);
	                this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);
	            }
	        }
	    };
	    /**
	     * Build huffman tree
	     * @returns {void}
	     */
	    CompressorHuffmanTree.prototype.buildTree = function () {
	        var codesCount = this.codeFrequency.length;
	        var arrTree = new Int32Array(codesCount);
	        var treeLength = 0;
	        var maxCount = 0;
	        for (var n = 0; n < codesCount; n++) {
	            var freq = this.codeFrequency[n];
	            if (freq !== 0) {
	                var pos = treeLength++;
	                var pPos = 0;
	                while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {
	                    arrTree[pos] = arrTree[pPos];
	                    pos = pPos;
	                }
	                arrTree[pos] = n;
	                maxCount = n;
	            }
	        }
	        while (treeLength < 2) {
	            arrTree[treeLength++] =
	                (maxCount < 2) ? ++maxCount : 0;
	        }
	        this.codeCount = Math.max(maxCount + 1, this.codeMinCount);
	        var leafsCount = treeLength;
	        var nodesCount = leafsCount;
	        var child = new Int32Array(4 * treeLength - 2);
	        var values = new Int32Array(2 * treeLength - 1);
	        for (var i = 0; i < treeLength; i++) {
	            var node = arrTree[i];
	            var iIndex = 2 * i;
	            child[iIndex] = node;
	            child[iIndex + 1] = -1;
	            values[i] = (this.codeFrequency[node] << 8);
	            arrTree[i] = i;
	        }
	        this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);
	        this.buildLength(child);
	    };
	    CompressorHuffmanTree.prototype.constructHuffmanTree = function (arrTree, treeLength, values, nodesCount, child) {
	        do {
	            var first = arrTree[0];
	            var last = arrTree[--treeLength];
	            var lastVal = values[last];
	            var pPos = 0;
	            var path = 1;
	            while (path < treeLength) {
	                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {
	                    path++;
	                }
	                arrTree[pPos] = arrTree[path];
	                pPos = path;
	                path = pPos * 2 + 1;
	            }
	            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {
	                arrTree[path] = arrTree[pPos];
	            }
	            arrTree[path] = last;
	            var second = arrTree[0];
	            last = nodesCount++;
	            child[2 * last] = first;
	            child[2 * last + 1] = second;
	            var minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);
	            values[last] = lastVal = values[first] + values[second] - minDepth + 1;
	            pPos = 0;
	            path = 1;
	            /* tslint:disable */
	            while (path < treeLength) {
	                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {
	                    path++;
	                }
	                arrTree[pPos] = arrTree[path];
	                pPos = path;
	                path = pPos * 2 + 1;
	            } /* tslint:disable */
	            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {
	                arrTree[path] = arrTree[pPos];
	            }
	            arrTree[path] = last;
	        } while (treeLength > 1);
	    };
	    CompressorHuffmanTree.prototype.buildLength = function (child) {
	        this.codeLength = new Uint8Array(this.codeFrequency.length);
	        var numNodes = Math.floor(child.length / 2);
	        var numLeafs = Math.floor((numNodes + 1) / 2);
	        var overflow = 0;
	        for (var i = 0; i < this.maxLength; i++) {
	            this.lengthCount[i] = 0;
	        }
	        overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);
	        if (overflow === 0) {
	            return;
	        }
	        var iIncreasableLength = this.maxLength - 1;
	        do {
	            while (this.lengthCount[--iIncreasableLength] === 0) {
	                /* tslint:disable */
	            }
	            do {
	                this.lengthCount[iIncreasableLength]--;
	                this.lengthCount[++iIncreasableLength]++;
	                overflow -= (1 << (this.maxLength - 1 - iIncreasableLength));
	            } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);
	        } while (overflow > 0);
	        this.recreateTree(child, overflow, numLeafs);
	    };
	    CompressorHuffmanTree.prototype.recreateTree = function (child, overflow, numLeafs) {
	        this.lengthCount[this.maxLength - 1] += overflow;
	        this.lengthCount[this.maxLength - 2] -= overflow;
	        var nodePtr = 2 * numLeafs;
	        for (var bits = this.maxLength; bits !== 0; bits--) {
	            var n = this.lengthCount[bits - 1];
	            while (n > 0) {
	                var childPtr = 2 * child[nodePtr++];
	                if (child[childPtr + 1] === -1) {
	                    this.codeLength[child[childPtr]] = bits;
	                    n--;
	                }
	            }
	        }
	    };
	    CompressorHuffmanTree.prototype.calculateOptimalCodeLength = function (child, overflow, numNodes) {
	        var lengths = new Int32Array(numNodes);
	        lengths[numNodes - 1] = 0;
	        for (var i = numNodes - 1; i >= 0; i--) {
	            var childIndex = 2 * i + 1;
	            if (child[childIndex] !== -1) {
	                var bitLength = lengths[i] + 1;
	                if (bitLength > this.maxLength) {
	                    bitLength = this.maxLength;
	                    overflow++;
	                }
	                lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;
	            }
	            else {
	                var bitLength = lengths[i];
	                this.lengthCount[bitLength - 1]++;
	                this.codeLength[child[childIndex - 1]] = lengths[i];
	            }
	        }
	        return overflow;
	    };
	    CompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];
	    CompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
	    return CompressorHuffmanTree;
	}());
	/**
	 * Checksum calculator, based on Adler32 algorithm.
	 */
	var ChecksumCalculator = /** @class */ (function () {
	    function ChecksumCalculator() {
	    }
	    /**
	     * Updates checksum by calculating checksum of the
	     * given buffer and adding it to current value.
	     * @param {number} checksum - current checksum.
	     * @param {Uint8Array} buffer - data byte array.
	     * @param {number} offset - offset in the buffer.
	     * @param {number} length - length of data to be used from the stream.
	     * @returns {number}
	     */
	    ChecksumCalculator.checksumUpdate = function (checksum, buffer, offset, length) {
	        var uint = new Uint32Array(1);
	        uint[0] = checksum;
	        var checksum_uint = uint[0];
	        var s1 = uint[0] = checksum_uint & 65535;
	        var s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;
	        while (length > 0) {
	            var steps = Math.min(length, ChecksumCalculator.checksumIterationCount);
	            length -= steps;
	            while (--steps >= 0) {
	                s1 = s1 + (uint[0] = (buffer[offset++] & 255));
	                s2 = s2 + s1;
	            }
	            s1 %= ChecksumCalculator.checksumBase;
	            s2 %= ChecksumCalculator.checksumBase;
	        }
	        checksum_uint = (s2 << ChecksumCalculator.checkSumBitOffset) | s1;
	        return checksum_uint;
	    };
	    ChecksumCalculator.checkSumBitOffset = 16;
	    ChecksumCalculator.checksumBase = 65521;
	    ChecksumCalculator.checksumIterationCount = 3800;
	    return ChecksumCalculator;
	}());
	/* eslint-enable */

	var __extends$r = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `PdfStream` class is used to perform stream related primitive operations.
	 * @private
	 */
	var PdfStream = /** @class */ (function (_super) {
	    __extends$r(PdfStream, _super);
	    function PdfStream(dictionary, data) {
	        var _this = _super.call(this, dictionary) || this;
	        //Constants
	        /**
	         * @hidden
	         * @private
	         */
	        _this.dicPrefix = 'stream';
	        /**
	         * @hidden
	         * @private
	         */
	        _this.dicSuffix = 'endstream';
	        /**
	         * Internal variable to hold `cloned object`.
	         * @private
	         */
	        _this.clonedObject2 = null;
	        /**
	         * @hidden
	         * @private
	         */
	        _this.bCompress = true;
	        if (typeof dictionary !== 'undefined' || typeof data !== 'undefined') {
	            _this.dataStream2 = [];
	            _this.dataStream2 = data;
	            _this.bCompress2 = false;
	        }
	        else {
	            _this.dataStream2 = [];
	            _this.bCompress2 = true;
	            //Pending
	        }
	        return _this;
	    }
	    Object.defineProperty(PdfStream.prototype, "internalStream", {
	        /**
	         * Gets the `internal` stream.
	         * @private
	         */
	        get: function () {
	            return this.dataStream2;
	        },
	        set: function (value) {
	            this.dataStream2 = [];
	            this.dataStream2 = value;
	            this.modify();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStream.prototype, "compress", {
	        /**
	         * Gets or sets `compression` flag.
	         * @private
	         */
	        get: function () {
	            return this.bCompress;
	        },
	        set: function (value) {
	            this.bCompress = value;
	            this.modify();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStream.prototype, "data", {
	        /**
	         * Gets or sets the `data`.
	         * @private
	         */
	        get: function () {
	            return this.dataStream2;
	        },
	        set: function (value) {
	            this.dataStream2 = [];
	            this.dataStream2 = value;
	            this.modify();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * `Clear` the internal stream.
	     * @private
	     */
	    PdfStream.prototype.clearStream = function () {
	        this.internalStream = [];
	        if (this.items.containsKey(this.dictionaryProperties.filter)) {
	            this.remove(this.dictionaryProperties.filter);
	        }
	        this.bCompress = true;
	        this.modify();
	    };
	    /**
	     * `Writes` the specified string.
	     * @private
	     */
	    PdfStream.prototype.write = function (text) {
	        if (text == null) {
	            throw new Error('ArgumentNullException:text');
	        }
	        if (text.length <= 0) {
	            throw new Error('ArgumentException: Can not write an empty string, text');
	        }
	        this.dataStream2.push(text);
	        this.modify();
	    };
	    /**
	     * `Writes` the specified bytes.
	     * @private
	     */
	    PdfStream.prototype.writeBytes = function (data) {
	        if (data === null) {
	            throw new Error('ArgumentNullException:data');
	        }
	        if (data.length <= 0) {
	            throw new Error('ArgumentException: Can not write an empty bytes, data');
	        }
	        var text = '';
	        for (var i = 0; i < data.length; i++) {
	            text += String.fromCharCode(data[i]);
	        }
	        this.dataStream2.push(text);
	        this.modify();
	    };
	    /**
	     * Raises event `Cmap BeginSave`.
	     * @private
	     */
	    PdfStream.prototype.onCmapBeginSave = function () {
	        this.cmapBeginSave.sender.cmapBeginSave();
	    };
	    /**
	     * Raises event `Font Program BeginSave`.
	     * @private
	     */
	    PdfStream.prototype.onFontProgramBeginSave = function () {
	        this.fontProgramBeginSave.sender.fontProgramBeginSave();
	    };
	    /**
	     * `Compresses the content` if it's required.
	     * @private
	     */
	    PdfStream.prototype.compressContent = function (data, writer) {
	        if (this.bCompress) {
	            var byteArray = [];
	            for (var i = 0; i < data.length; i++) {
	                byteArray.push(data.charCodeAt(i));
	            }
	            var dataArray = new Uint8Array(byteArray);
	            var sw = new CompressedStreamWriter();
	            // data = 'Hello World!!!';
	            sw.write(dataArray, 0, dataArray.length);
	            sw.close();
	            data = sw.getCompressedString;
	            this.addFilter(this.dictionaryProperties.flatedecode);
	        }
	        return data;
	    };
	    /**
	     * `Adds a filter` to the filter array.
	     * @private
	     */
	    PdfStream.prototype.addFilter = function (filterName) {
	        var obj = this.items.getValue(this.dictionaryProperties.filter);
	        if (obj instanceof PdfReferenceHolder) {
	            var rh = obj;
	            obj = rh.object;
	        }
	        var array = obj;
	        var name = obj;
	        if (name != null) {
	            array = new PdfArray();
	            array.insert(0, name);
	            this.items.setValue(this.dictionaryProperties.filter, array);
	        }
	        name = new PdfName(filterName);
	        if (array == null) {
	            this.items.setValue(this.dictionaryProperties.filter, name);
	        }
	        else {
	            array.insert(0, name);
	        }
	    };
	    /**
	     * `Saves` the object using the specified writer.
	     * @private
	     */
	    PdfStream.prototype.save = function (writer) {
	        if (typeof this.cmapBeginSave !== 'undefined') {
	            this.onCmapBeginSave();
	        }
	        if (typeof this.fontProgramBeginSave !== 'undefined') {
	            this.onFontProgramBeginSave();
	        }
	        var data = '';
	        for (var i = 0; i < this.data.length; i++) {
	            data = data + this.data[i];
	        }
	        if (data.length > 1 && !this.isResource) {
	            data = 'q\r\n' + data + 'Q\r\n';
	        }
	        data = this.compressContent(data, writer);
	        var length = data.length;
	        this.items.setValue(this.dictionaryProperties.length, new PdfNumber(length));
	        _super.prototype.save.call(this, writer, false);
	        writer.write(this.dicPrefix);
	        writer.write(Operators.newLine);
	        if (data.length > 0) {
	            writer.write(data);
	        }
	        writer.write(Operators.newLine);
	        writer.write(this.dicSuffix);
	        writer.write(Operators.newLine);
	    };
	    /**
	     * Converts `bytes to string`.
	     * @private
	     */
	    PdfStream.bytesToString = function (byteArray) {
	        var output = '';
	        for (var i = 0; i < byteArray.length; i++) {
	            output = output + String.fromCharCode(byteArray[i]);
	        }
	        return output;
	    };
	    return PdfStream;
	}(PdfDictionary));
	var SaveCmapEventHandler = /** @class */ (function () {
	    /**
	     * New instance for `save section collection event handler` class.
	     * @private
	     */
	    function SaveCmapEventHandler(sender) {
	        this.sender = sender;
	    }
	    return SaveCmapEventHandler;
	}());
	var SaveFontProgramEventHandler = /** @class */ (function () {
	    /**
	     * New instance for `save section collection event handler` class.
	     * @private
	     */
	    function SaveFontProgramEventHandler(sender) {
	        this.sender = sender;
	    }
	    return SaveFontProgramEventHandler;
	}());

	/**
	 * `PdfString` class is used to perform string related primitive operations.
	 * @private
	 */
	var InternalEnum;
	(function (InternalEnum) {
	    (function (ForceEncoding) {
	        /**
	         * Specifies the type of `None`.
	         * @private
	         */
	        ForceEncoding[ForceEncoding["None"] = 0] = "None";
	        /**
	         * Specifies the type of `Ascii`.
	         * @private
	         */
	        ForceEncoding[ForceEncoding["Ascii"] = 1] = "Ascii";
	        /**
	         * Specifies the type of `Unicode`.
	         * @private
	         */
	        ForceEncoding[ForceEncoding["Unicode"] = 2] = "Unicode";
	    })(InternalEnum.ForceEncoding || (InternalEnum.ForceEncoding = {}));
	    /**
	     * public Enum for `SourceType`.
	     * @private
	     */
	    var SourceType;
	    (function (SourceType) {
	        /**
	         * Specifies the type of `StringValue`.
	         * @private
	         */
	        SourceType[SourceType["StringValue"] = 0] = "StringValue";
	        /**
	         * Specifies the type of `ByteBuffer`.
	         * @private
	         */
	        SourceType[SourceType["ByteBuffer"] = 1] = "ByteBuffer";
	    })(SourceType || (SourceType = {}));
	})(InternalEnum || (InternalEnum = {}));
	var PdfString = /** @class */ (function () {
	    function PdfString(value) {
	        /**
	         * Value indicating whether the string was converted to hex.
	         * @default false
	         * @private
	         */
	        this.bHex = false;
	        /**
	         * Internal variable to store the `position`.
	         * @default -1
	         * @private
	         */
	        this.position1 = -1;
	        /**
	         * Internal variable to hold `cloned object`.
	         * @default null
	         * @private
	         */
	        this.clonedObject1 = null;
	        /**
	         * `Shows` if the data of the stream was decrypted.
	         * @default false
	         * @private
	         */
	        this.bDecrypted = false;
	        /**
	         * Shows if the data of the stream `was decrypted`.
	         * @default false
	         * @private
	         */
	        this.isParentDecrypted = false;
	        /**
	         * Gets a value indicating whether the object is `packed or not`.
	         * @default false
	         * @private
	         */
	        this.isPacked = false;
	        /**
	         * @hidden
	         * @private
	         */
	        this.isFormField = false;
	        /**
	         * @hidden
	         * @private
	         */
	        this.isColorSpace = false;
	        /**
	         * @hidden
	         * @private
	         */
	        this.isHexString = true;
	        if (typeof value === 'undefined') {
	            this.bHex = false;
	        }
	        else {
	            if (!(value.length > 0 && value[0] === '0xfeff')) {
	                this.stringValue = value;
	                this.data = [];
	                for (var i = 0; i < value.length; ++i) {
	                    this.data.push(value.charCodeAt(i));
	                }
	            }
	        }
	    }
	    Object.defineProperty(PdfString.prototype, "hex", {
	        //Property
	        /**
	         * Gets a value indicating whether string is in `hex`.
	         * @private
	         */
	        get: function () {
	            return this.bHex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfString.prototype, "value", {
	        /**
	         * Gets or sets string `value` of the object.
	         * @private
	         */
	        get: function () {
	            return this.stringValue;
	        },
	        set: function (value) {
	            this.stringValue = value;
	            this.data = null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfString.prototype, "status", {
	        /**
	         * Gets or sets the `Status` of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.status1;
	        },
	        set: function (value) {
	            this.status1 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfString.prototype, "isSaving", {
	        /**
	         * Gets or sets a value indicating whether this document `is saving` or not.
	         * @private
	         */
	        get: function () {
	            return this.isSaving1;
	        },
	        set: function (value) {
	            this.isSaving1 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfString.prototype, "objectCollectionIndex", {
	        /**
	         * Gets or sets the `index` value of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.index1;
	        },
	        set: function (value) {
	            this.index1 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfString.prototype, "clonedObject", {
	        /**
	         * Returns `cloned object`.
	         * @private
	         */
	        get: function () {
	            return this.clonedObject1;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfString.prototype, "position", {
	        /**
	         * Gets or sets the `position` of the object.
	         * @private
	         */
	        get: function () {
	            return this.position1;
	        },
	        set: function (value) {
	            this.position1 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfString.prototype, "CrossTable", {
	        /**
	         * Returns `PdfCrossTable` associated with the object.
	         * @private
	         */
	        get: function () {
	            return this.crossTable;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfString.prototype, "converted", {
	        /**
	         * Gets a value indicating whether to check if the value has unicode characters.
	         * @private
	         */
	        get: function () {
	            return this.bConverted;
	        },
	        /**
	         * sets a value indicating whether to check if the value has unicode characters.
	         * @private
	         */
	        set: function (value) {
	            this.bConverted = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfString.prototype, "encode", {
	        /**
	         * Gets value indicating whether we should convert data to Unicode.
	         */
	        get: function () {
	            return this.bForceEncoding;
	        },
	        set: function (value) {
	            this.bForceEncoding = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //Methods
	    /**
	     * Converts `bytes to string using hex format` for representing string.
	     * @private
	     */
	    PdfString.bytesToHex = function (bytes) {
	        if (bytes == null) {
	            return '';
	        }
	        var builder = '';
	        return builder;
	    };
	    /**
	     * `Saves` the object using the specified writer.
	     * @private
	     */
	    PdfString.prototype.save = function (writer) {
	        if (writer === null) {
	            throw new Error('ArgumentNullException : writer');
	        }
	        if (this.encode !== undefined && this.encode === InternalEnum.ForceEncoding.Ascii) {
	            writer.write(this.pdfEncode());
	        }
	        else {
	            writer.write(PdfString.stringMark[0] + this.value + PdfString.stringMark[1]);
	        }
	    };
	    PdfString.prototype.pdfEncode = function () {
	        var result = '';
	        if (this.encode !== undefined && this.encode === InternalEnum.ForceEncoding.Ascii) {
	            var data = this.escapeSymbols(this.value);
	            for (var i = 0; i < data.length; i++) {
	                result += String.fromCharCode(data[i]);
	            }
	            result = PdfString.stringMark[0] + result + PdfString.stringMark[1];
	        }
	        else {
	            result = this.value;
	        }
	        return result;
	    };
	    PdfString.prototype.escapeSymbols = function (value) {
	        var data = [];
	        for (var i = 0; i < value.length; i++) {
	            var currentData = value.charCodeAt(i);
	            switch (currentData) {
	                case 40:
	                case 41:
	                    data.push(92);
	                    data.push(currentData);
	                    break;
	                case 13:
	                    data.push(92);
	                    data.push(114);
	                    break;
	                case 92:
	                    data.push(92);
	                    data.push(currentData);
	                    break;
	                default:
	                    data.push(currentData);
	                    break;
	            }
	        }
	        return data;
	    };
	    /**
	     * Creates a `copy of PdfString`.
	     * @private
	     */
	    PdfString.prototype.clone = function (crossTable) {
	        if (this.clonedObject1 !== null && this.clonedObject1.CrossTable === crossTable) {
	            return this.clonedObject1;
	        }
	        else {
	            this.clonedObject1 = null;
	        }
	        var newString = new PdfString(this.stringValue);
	        newString.bHex = this.bHex;
	        newString.crossTable = crossTable;
	        newString.isColorSpace = this.isColorSpace;
	        this.clonedObject1 = newString;
	        return newString;
	    };
	    /**
	     * Converts string to array of unicode symbols.
	     */
	    PdfString.toUnicodeArray = function (value, bAddPrefix) {
	        if (value == null) {
	            throw new Error('Argument Null Exception : value');
	        }
	        var output = [];
	        for (var i = 0; i < value.length; i++) {
	            var code = value.charCodeAt(i);
	            output.push(code / 256 >>> 0);
	            output.push(code & 0xff);
	        }
	        return output;
	    };
	    /**
	     * Converts byte data to string.
	     */
	    PdfString.byteToString = function (data) {
	        if (data == null) {
	            throw new Error('Argument Null Exception : stream');
	        }
	        var result = '';
	        for (var i = 0; i < data.length; ++i) {
	            result += String.fromCharCode(data[i]);
	        }
	        return result;
	    };
	    //constants = ;
	    /**
	     * `General markers` for string.
	     * @private
	     */
	    PdfString.stringMark = '()';
	    /**
	     * `Hex markers` for string.
	     * @private
	     */
	    PdfString.hexStringMark = '<>';
	    /**
	     * Format of password data.
	     * @private
	     */
	    PdfString.hexFormatPattern = '{0:X2}';
	    return PdfString;
	}());

	/**
	 * `PdfReference` class is used to perform reference related primitive operations.
	 * @private
	 */
	var PdfReference = /** @class */ (function () {
	    function PdfReference(objNumber, genNumber) {
	        /**
	         * Holds the `index` number of the object.
	         * @default -1
	         * @private
	         */
	        this.index3 = -1;
	        /**
	         * Internal variable to store the `position`.
	         * @default -1
	         * @private
	         */
	        this.position3 = -1;
	        /**
	         * Holds the `object number`.
	         * @default 0
	         * @private
	         */
	        this.objNumber = 0;
	        /**
	         * Holds the `generation number` of the object.
	         * @default 0
	         * @private
	         */
	        this.genNumber = 0;
	        if (typeof objNumber === 'number' && typeof genNumber === 'number') {
	            this.objNumber = objNumber;
	            this.genNumber = genNumber;
	            // } else if (typeof objNum === 'string' && typeof genNum === 'string') {
	        }
	        else {
	            this.objNumber = Number(objNumber);
	            this.genNumber = Number(genNumber);
	        }
	    }
	    Object.defineProperty(PdfReference.prototype, "status", {
	        //Property
	        /**
	         * Gets or sets the `Status` of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.status3;
	        },
	        set: function (value) {
	            this.status3 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfReference.prototype, "isSaving", {
	        /**
	         * Gets or sets a value indicating whether this document `is saving` or not.
	         * @private
	         */
	        get: function () {
	            return this.isSaving3;
	        },
	        set: function (value) {
	            this.isSaving3 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfReference.prototype, "objectCollectionIndex", {
	        /**
	         * Gets or sets the `index` value of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.index3;
	        },
	        set: function (value) {
	            this.index3 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfReference.prototype, "position", {
	        /**
	         * Gets or sets the `position` of the object.
	         * @private
	         */
	        get: function () {
	            return this.position3;
	        },
	        set: function (value) {
	            this.position3 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfReference.prototype, "clonedObject", {
	        /**
	         * Returns `cloned object`.
	         * @private
	         */
	        get: function () {
	            var returnObject3 = null;
	            return returnObject3;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //IPdfPrimitives methods
	    /**
	     * `Saves` the object.
	     * @private
	     */
	    PdfReference.prototype.save = function (writer) {
	        writer.write(this.toString());
	    };
	    /**
	     * Returns a `string` representing the object.
	     * @private
	     */
	    PdfReference.prototype.toString = function () {
	        return this.objNumber.toString() + ' ' + this.genNumber.toString() + ' R';
	    };
	    /**
	     * Creates a `deep copy` of the IPdfPrimitive object.
	     * @private
	     */
	    PdfReference.prototype.clone = function (crossTable) {
	        return null;
	    };
	    return PdfReference;
	}());
	/**
	 * `PdfReferenceHolder` class is used to perform reference holder related primitive operations.
	 * @private
	 */
	var PdfReferenceHolder = /** @class */ (function () {
	    function PdfReferenceHolder(obj1, obj2) {
	        /**
	         * Holds the `index` number of the object.
	         * @default -1
	         * @private
	         */
	        this.index4 = -1;
	        /**
	         * Internal variable to store the `position`.
	         * @default -1
	         * @private
	         */
	        this.position4 = -1;
	        /**
	         * The `index` of the object within the object collection.
	         * @default -1
	         * @private
	         */
	        this.objectIndex = -1;
	        /**
	         * @hidden
	         * @private
	         */
	        this.dictionaryProperties = new DictionaryProperties();
	        // if (typeof obj2 === 'undefined') {
	        this.initialize(obj1);
	        // }
	        // else {
	        //     if (obj2 === null) {
	        //         throw new Error('ArgumentNullException : crossTable');
	        //     }
	        //     if (obj1 === null) {
	        //         throw new Error('ArgumentNullException : reference');
	        //     }
	        //     this.crossTable = obj2;
	        //     let tempObj1 : PdfReference = <PdfReference>obj1;
	        //     this.reference = tempObj1;
	        // }
	    }
	    Object.defineProperty(PdfReferenceHolder.prototype, "status", {
	        //Properties
	        /**
	         * Gets or sets the `Status` of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.status4;
	        },
	        set: function (value) {
	            this.status4 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfReferenceHolder.prototype, "isSaving", {
	        /**
	         * Gets or sets a value indicating whether this document `is saving` or not.
	         * @private
	         */
	        get: function () {
	            return this.isSaving4;
	        },
	        set: function (value) {
	            this.isSaving4 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfReferenceHolder.prototype, "objectCollectionIndex", {
	        /**
	         * Gets or sets the `index` value of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.index4;
	        },
	        set: function (value) {
	            this.index4 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfReferenceHolder.prototype, "position", {
	        /**
	         * Gets or sets the `position` of the object.
	         * @private
	         */
	        get: function () {
	            return this.position4;
	        },
	        set: function (value) {
	            this.position4 = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfReferenceHolder.prototype, "clonedObject", {
	        /**
	         * Returns `cloned object`.
	         * @private
	         */
	        get: function () {
	            return null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfReferenceHolder.prototype, "object", {
	        /**
	         * Gets the `object` the reference is of.
	         * @private
	         */
	        get: function () {
	            // if ((this.reference != null) || (this.object == null)) {
	            //     this.object = this.GetterObject();
	            // }
	            return this.primitiveObject;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfReferenceHolder.prototype, "reference", {
	        /**
	         * Gets the `reference`.
	         * @private
	         */
	        get: function () {
	            return this.pdfReference;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfReferenceHolder.prototype, "index", {
	        /**
	         * Gets the `index` of the object.
	         * @private
	         */
	        get: function () {
	            // let items : PdfMainObjectCollection = this.crossTable.PdfObjects;
	            // this.objectIndex = items.GetObjectIndex(this.reference);
	            // if (this.objectIndex < 0) {
	            //     let obj : IPdfPrimitive = this.crossTable.GetObject(this.reference);
	            //     this.objectIndex = items.Count - 1;
	            // }
	            return this.objectIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfReferenceHolder.prototype, "element", {
	        /**
	         * Gets the `element`.
	         * @private
	         */
	        get: function () {
	            return this.primitiveObject;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PdfReferenceHolder.prototype.initialize = function (obj1) {
	        if (obj1 instanceof PdfArray
	            || obj1 instanceof PdfDictionary
	            || obj1 instanceof PdfName
	            || obj1 instanceof PdfNumber
	            || obj1 instanceof PdfStream
	            || obj1 instanceof PdfReference
	            || obj1 instanceof PdfString) {
	            this.primitiveObject = obj1;
	        }
	        else {
	            var tempObj = obj1;
	            this.initialize(tempObj.element);
	        }
	    };
	    /**
	     * `Writes` a reference into a PDF document.
	     * @private
	     */
	    PdfReferenceHolder.prototype.save = function (writer) {
	        // if (writer == null) {
	        //     throw new Error('ArgumentNullException : writer');
	        // }
	        writer.position;
	        var cTable = writer.document.crossTable;
	        // if (cTable.Document instanceof PdfDocument) {
	        this.object.isSaving = true;
	        // }
	        var reference = null;
	        // if (writer.Document.FileStructure.IncrementalUpdate === true && writer.Document.isStreamCopied === true) {
	        //     if (this.reference === null) {
	        //         reference = cTable.GetReference(this.Object);
	        //     } else {
	        //         reference = this.reference;
	        //     }
	        // } else {
	        //     reference = cTable.GetReference(this.Object);
	        // }
	        // if (!(writer.Document.FileStructure.IncrementalUpdate === true && writer.Document.isStreamCopied === true)) {
	        reference = cTable.getReference(this.object);
	        // }
	        // if (writer.Position !== position) {
	        //     writer.Position = position;
	        // }
	        reference.save(writer);
	    };
	    /**
	     * Creates a `copy of PdfReferenceHolder`.
	     * @private
	     */
	    PdfReferenceHolder.prototype.clone = function (crossTable) {
	        // Restricts addition of same object multiple time.
	        /* if (this.Reference != null && this.crossTable != null && this.crossTable.PageCorrespondance.containsKey(this.Reference)) {
	            refHolder = new PdfReferenceHolder(this.crossTable.PageCorrespondance.getValue(this.Reference) as PdfReference, crossTable);
	            return refHolder;
	        }
	        if (Object instanceof PdfNumber) {
	            return new PdfNumber((Object as PdfNumber).IntValue);
	        }
	        */
	        // if (Object instanceof PdfDictionary) {
	        //     // Meaning the referenced page is not available for import.
	        //     let type : PdfName = new PdfName(this.dictionaryProperties.type);
	        //     let dict : PdfDictionary = Object as PdfDictionary;
	        //     if (dict.ContainsKey(type)) {
	        //         let pageName : PdfName = dict.Items.getValue(type.Value) as PdfName;
	        //         if (pageName !== null) {
	        //             if (pageName.Value === 'Page') {
	        //                 return new PdfNull();
	        //             }
	        //         }
	        //     }
	        // }
	        /* if (Object instanceof PdfName) {
	            return new PdfName ((Object as PdfName ).Value);
	        }
	        */
	        // Resolves circular references.
	        // if (crossTable.PrevReference !== null && (crossTable.PrevReference.indexOf(this.Reference) !== -1)) {
	        //     let obj : IPdfPrimitive = this.crossTable.GetObject(this.Reference).ClonedObject;
	        //     if (obj !== null) {
	        //         reference = crossTable.GetReference(obj);
	        //         return new PdfReferenceHolder(reference, crossTable);
	        //     } else {
	        //         return new PdfNull();
	        //     }
	        // }
	        /*if (this.Reference !== null) {
	            crossTable.PrevReference.push(this.Reference);
	        }
	        reference = crossTable.GetReference(temp);
	        refHolder = new PdfReferenceHolder(reference, crossTable);
	        return refHolder;
	        */
	        return null;
	    };
	    return PdfReferenceHolder;
	}());

	/**
	 * public Enum for `PdfHorizontalAlignment`.
	 * @private
	 */
	var PdfHorizontalAlignment;
	(function (PdfHorizontalAlignment) {
	    /**
	     * Specifies the type of `Left`.
	     * @private
	     */
	    PdfHorizontalAlignment[PdfHorizontalAlignment["Left"] = 0] = "Left";
	    /**
	     * Specifies the type of `Center`.
	     * @private
	     */
	    PdfHorizontalAlignment[PdfHorizontalAlignment["Center"] = 1] = "Center";
	    /**
	     * Specifies the type of `Right`.
	     * @private
	     */
	    PdfHorizontalAlignment[PdfHorizontalAlignment["Right"] = 2] = "Right";
	})(PdfHorizontalAlignment || (PdfHorizontalAlignment = {}));
	/**
	 * public Enum for `PdfVerticalAlignment`.
	 * @private
	 */
	var PdfVerticalAlignment;
	(function (PdfVerticalAlignment) {
	    /**
	     * Specifies the type of `Top`.
	     * @private
	     */
	    PdfVerticalAlignment[PdfVerticalAlignment["Top"] = 0] = "Top";
	    /**
	     * Specifies the type of `Middle`.
	     * @private
	     */
	    PdfVerticalAlignment[PdfVerticalAlignment["Middle"] = 1] = "Middle";
	    /**
	     * Specifies the type of `Bottom`.
	     * @private
	     */
	    PdfVerticalAlignment[PdfVerticalAlignment["Bottom"] = 2] = "Bottom";
	})(PdfVerticalAlignment || (PdfVerticalAlignment = {}));
	/**
	 * public Enum for `public`.
	 * @private
	 */
	var PdfTextAlignment;
	(function (PdfTextAlignment) {
	    /**
	     * Specifies the type of `Left`.
	     * @private
	     */
	    PdfTextAlignment[PdfTextAlignment["Left"] = 0] = "Left";
	    /**
	     * Specifies the type of `Center`.
	     * @private
	     */
	    PdfTextAlignment[PdfTextAlignment["Center"] = 1] = "Center";
	    /**
	     * Specifies the type of `Right`.
	     * @private
	     */
	    PdfTextAlignment[PdfTextAlignment["Right"] = 2] = "Right";
	    /**
	     * Specifies the type of `Justify`.
	     * @private
	     */
	    PdfTextAlignment[PdfTextAlignment["Justify"] = 3] = "Justify";
	})(PdfTextAlignment || (PdfTextAlignment = {}));
	/**
	 * public Enum for `TextRenderingMode`.
	 * @private
	 */
	var TextRenderingMode;
	(function (TextRenderingMode) {
	    /**
	     * Specifies the type of `Fill`.
	     * @private
	     */
	    TextRenderingMode[TextRenderingMode["Fill"] = 0] = "Fill";
	    /**
	     * Specifies the type of `Stroke`.
	     * @private
	     */
	    TextRenderingMode[TextRenderingMode["Stroke"] = 1] = "Stroke";
	    /**
	     * Specifies the type of `FillStroke`.
	     * @private
	     */
	    TextRenderingMode[TextRenderingMode["FillStroke"] = 2] = "FillStroke";
	    /**
	     * Specifies the type of `None`.
	     * @private
	     */
	    TextRenderingMode[TextRenderingMode["None"] = 3] = "None";
	    /**
	     * Specifies the type of `ClipFlag`.
	     * @private
	     */
	    TextRenderingMode[TextRenderingMode["ClipFlag"] = 4] = "ClipFlag";
	    /**
	     * Specifies the type of `ClipFill`.
	     * @private
	     */
	    TextRenderingMode[TextRenderingMode["ClipFill"] = 4] = "ClipFill";
	    /**
	     * Specifies the type of `ClipStroke`.
	     * @private
	     */
	    TextRenderingMode[TextRenderingMode["ClipStroke"] = 5] = "ClipStroke";
	    /**
	     * Specifies the type of `ClipFillStroke`.
	     * @private
	     */
	    TextRenderingMode[TextRenderingMode["ClipFillStroke"] = 6] = "ClipFillStroke";
	    /**
	     * Specifies the type of `Clip`.
	     * @private
	     */
	    TextRenderingMode[TextRenderingMode["Clip"] = 7] = "Clip";
	})(TextRenderingMode || (TextRenderingMode = {}));
	/**
	 * public Enum for `PdfLineJoin`.
	 * @private
	 */
	var PdfLineJoin;
	(function (PdfLineJoin) {
	    /**
	     * Specifies the type of `Miter`.
	     * @private
	     */
	    PdfLineJoin[PdfLineJoin["Miter"] = 0] = "Miter";
	    /**
	     * Specifies the type of `Round`.
	     * @private
	     */
	    PdfLineJoin[PdfLineJoin["Round"] = 1] = "Round";
	    /**
	     * Specifies the type of `Bevel`.
	     * @private
	     */
	    PdfLineJoin[PdfLineJoin["Bevel"] = 2] = "Bevel";
	})(PdfLineJoin || (PdfLineJoin = {}));
	/**
	 * public Enum for `PdfLineCap`.
	 * @private
	 */
	var PdfLineCap;
	(function (PdfLineCap) {
	    /**
	     * Specifies the type of `Flat`.
	     * @private
	     */
	    PdfLineCap[PdfLineCap["Flat"] = 0] = "Flat";
	    /**
	     * Specifies the type of `Round`.
	     * @private
	     */
	    PdfLineCap[PdfLineCap["Round"] = 1] = "Round";
	    /**
	     * Specifies the type of `Square`.
	     * @private
	     */
	    PdfLineCap[PdfLineCap["Square"] = 2] = "Square";
	})(PdfLineCap || (PdfLineCap = {}));
	/**
	 * public Enum for `PdfDashStyle`.
	 * @private
	 */
	var PdfDashStyle;
	(function (PdfDashStyle) {
	    /**
	     * Specifies the type of `Solid`.
	     * @private
	     */
	    PdfDashStyle[PdfDashStyle["Solid"] = 0] = "Solid";
	    /**
	     * Specifies the type of `Dash`.
	     * @private
	     */
	    PdfDashStyle[PdfDashStyle["Dash"] = 1] = "Dash";
	    /**
	     * Specifies the type of `Dot`.
	     * @private
	     */
	    PdfDashStyle[PdfDashStyle["Dot"] = 2] = "Dot";
	    /**
	     * Specifies the type of `DashDot`.
	     * @private
	     */
	    PdfDashStyle[PdfDashStyle["DashDot"] = 3] = "DashDot";
	    /**
	     * Specifies the type of `DashDotDot`.
	     * @private
	     */
	    PdfDashStyle[PdfDashStyle["DashDotDot"] = 4] = "DashDotDot";
	    /**
	     * Specifies the type of `Custom`.
	     * @private
	     */
	    PdfDashStyle[PdfDashStyle["Custom"] = 5] = "Custom";
	})(PdfDashStyle || (PdfDashStyle = {}));
	/**
	 * public Enum for `PdfFillMode`.
	 * @private
	 */
	var PdfFillMode;
	(function (PdfFillMode) {
	    /**
	     * Specifies the type of `Winding`.
	     * @private
	     */
	    PdfFillMode[PdfFillMode["Winding"] = 0] = "Winding";
	    /**
	     * Specifies the type of `Alternate`.
	     * @private
	     */
	    PdfFillMode[PdfFillMode["Alternate"] = 1] = "Alternate";
	})(PdfFillMode || (PdfFillMode = {}));
	/**
	 * public Enum for `PdfColorSpace`.
	 * @private
	 */
	var PdfColorSpace;
	(function (PdfColorSpace) {
	    /**
	     * Specifies the type of `Rgb`.
	     * @private
	     */
	    PdfColorSpace[PdfColorSpace["Rgb"] = 0] = "Rgb";
	    /**
	     * Specifies the type of `Cmyk`.
	     * @private
	     */
	    PdfColorSpace[PdfColorSpace["Cmyk"] = 1] = "Cmyk";
	    /**
	     * Specifies the type of `GrayScale`.
	     * @private
	     */
	    PdfColorSpace[PdfColorSpace["GrayScale"] = 2] = "GrayScale";
	    /**
	     * Specifies the type of `Indexed`.
	     * @private
	     */
	    PdfColorSpace[PdfColorSpace["Indexed"] = 3] = "Indexed";
	})(PdfColorSpace || (PdfColorSpace = {}));
	/**
	 * public Enum for `PdfBlendMode`.
	 * @private
	 */
	var PdfBlendMode;
	(function (PdfBlendMode) {
	    /**
	     * Specifies the type of `Normal`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["Normal"] = 0] = "Normal";
	    /**
	     * Specifies the type of `Multiply`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["Multiply"] = 1] = "Multiply";
	    /**
	     * Specifies the type of `Screen`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["Screen"] = 2] = "Screen";
	    /**
	     * Specifies the type of `Overlay`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["Overlay"] = 3] = "Overlay";
	    /**
	     * Specifies the type of `Darken`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["Darken"] = 4] = "Darken";
	    /**
	     * Specifies the type of `Lighten`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["Lighten"] = 5] = "Lighten";
	    /**
	     * Specifies the type of `ColorDodge`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["ColorDodge"] = 6] = "ColorDodge";
	    /**
	     * Specifies the type of `ColorBurn`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["ColorBurn"] = 7] = "ColorBurn";
	    /**
	     * Specifies the type of `HardLight`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["HardLight"] = 8] = "HardLight";
	    /**
	     * Specifies the type of `SoftLight`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["SoftLight"] = 9] = "SoftLight";
	    /**
	     * Specifies the type of `Difference`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["Difference"] = 10] = "Difference";
	    /**
	     * Specifies the type of `Exclusion`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["Exclusion"] = 11] = "Exclusion";
	    /**
	     * Specifies the type of `Hue`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["Hue"] = 12] = "Hue";
	    /**
	     * Specifies the type of `Saturation`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["Saturation"] = 13] = "Saturation";
	    /**
	     * Specifies the type of `Color`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["Color"] = 14] = "Color";
	    /**
	     * Specifies the type of `Luminosity`.
	     * @private
	     */
	    PdfBlendMode[PdfBlendMode["Luminosity"] = 15] = "Luminosity";
	})(PdfBlendMode || (PdfBlendMode = {}));
	/**
	 * public Enum for `PdfGraphicsUnit`.
	 * @private
	 */
	var PdfGraphicsUnit;
	(function (PdfGraphicsUnit) {
	    /**
	     * Specifies the type of `Centimeter`.
	     * @private
	     */
	    PdfGraphicsUnit[PdfGraphicsUnit["Centimeter"] = 0] = "Centimeter";
	    /**
	     * Specifies the type of `Pica`.
	     * @private
	     */
	    PdfGraphicsUnit[PdfGraphicsUnit["Pica"] = 1] = "Pica";
	    /**
	     * Specifies the type of `Pixel`.
	     * @private
	     */
	    PdfGraphicsUnit[PdfGraphicsUnit["Pixel"] = 2] = "Pixel";
	    /**
	     * Specifies the type of `Point`.
	     * @private
	     */
	    PdfGraphicsUnit[PdfGraphicsUnit["Point"] = 3] = "Point";
	    /**
	     * Specifies the type of `Inch`.
	     * @private
	     */
	    PdfGraphicsUnit[PdfGraphicsUnit["Inch"] = 4] = "Inch";
	    /**
	     * Specifies the type of `Document`.
	     * @private
	     */
	    PdfGraphicsUnit[PdfGraphicsUnit["Document"] = 5] = "Document";
	    /**
	     * Specifies the type of `Millimeter`.
	     * @private
	     */
	    PdfGraphicsUnit[PdfGraphicsUnit["Millimeter"] = 6] = "Millimeter";
	})(PdfGraphicsUnit || (PdfGraphicsUnit = {}));
	/**
	 * public Enum for `PdfGridImagePosition`.
	 * @private
	 */
	var PdfGridImagePosition;
	(function (PdfGridImagePosition) {
	    /**
	     * Specifies the type of `Fit`.
	     * @private
	     */
	    PdfGridImagePosition[PdfGridImagePosition["Fit"] = 0] = "Fit";
	    /**
	     * Specifies the type of `Center`.
	     * @private
	     */
	    PdfGridImagePosition[PdfGridImagePosition["Center"] = 1] = "Center";
	    /**
	     * Specifies the type of `Stretch`.
	     * @private
	     */
	    PdfGridImagePosition[PdfGridImagePosition["Stretch"] = 2] = "Stretch";
	    /**
	     * Specifies the type of `Tile`.
	     * @private
	     */
	    PdfGridImagePosition[PdfGridImagePosition["Tile"] = 3] = "Tile";
	})(PdfGridImagePosition || (PdfGridImagePosition = {}));
	/**
	 * public Enum for `the text rendering direction`.
	 * @private
	 */
	var PdfTextDirection;
	(function (PdfTextDirection) {
	    /**
	     * Specifies the type of `None`.
	     * @private
	     */
	    PdfTextDirection[PdfTextDirection["None"] = 0] = "None";
	    /**
	     * Specifies the type of `LeftToRight`.
	     * @private
	     */
	    PdfTextDirection[PdfTextDirection["LeftToRight"] = 1] = "LeftToRight";
	    /**
	     * Specifies the type of `RightToLeft`.
	     * @private
	     */
	    PdfTextDirection[PdfTextDirection["RightToLeft"] = 2] = "RightToLeft";
	})(PdfTextDirection || (PdfTextDirection = {}));

	/**
	 * Implements structures and routines working with `color`.
	 * ```typescript
	 * // create a new PDF document
	 * let document : PdfDocument = new PdfDocument();
	 * // add a new page to the document
	 * let page1 : PdfPage = document.pages.add();
	 * // set the font
	 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	 * //
	 * // set color
	 * let brushColor : PdfColor = new PdfColor(0, 0, 0);
	 * //
	 * // create black brush
	 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(brushColor);
	 * // draw the text
	 * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
	 * // save the document
	 * document.save('output.pdf');
	 * // destroy the document
	 * document.destroy();
	 * ```
	 * @default black color
	 */
	var PdfColor = /** @class */ (function () {
	    function PdfColor(color1, color2, color3, color4) {
	        if (typeof color1 === 'undefined') {
	            if (typeof color2 !== 'undefined' && typeof color3 !== 'undefined' && typeof color4 !== 'undefined') {
	                this.assignRGB(color2, color3, color4);
	            }
	            else {
	                this.filled = false;
	            }
	        }
	        else if (color1 instanceof PdfColor) {
	            this.redColor = color1.r;
	            this.greenColor = color1.g;
	            this.blueColor = color1.b;
	            this.grayColor = color1.gray;
	            this.alpha = color1.alpha;
	            this.filled = (this.alpha !== 0);
	            /* tslint:disable-next-line:max-line-length */
	        }
	        else if (typeof color1 === 'number' && typeof color2 === 'undefined' && typeof color3 === 'undefined' && typeof color4 === 'undefined') {
	            if (color1 < 0) {
	                color1 = 0;
	            }
	            if (color1 > 1) {
	                color1 = 1;
	            }
	            this.redColor = color1 * PdfColor.maxColourChannelValue;
	            this.greenColor = color1 * PdfColor.maxColourChannelValue;
	            this.blueColor = color1 * PdfColor.maxColourChannelValue;
	            this.cyanColor = color1;
	            this.magentaColor = color1;
	            this.yellowColor = color1;
	            this.blackColor = color1;
	            this.grayColor = color1;
	            this.alpha = PdfColor.maxColourChannelValue;
	            this.filled = true;
	        }
	        else if (typeof color4 === 'undefined') {
	            this.assignRGB(color1, color2, color3);
	        }
	        else {
	            this.assignRGB(color2, color3, color4, color1);
	        }
	    }
	    /**
	     * `Assign` red, green, blue colors with alpha value..
	     * @private
	     */
	    PdfColor.prototype.assignRGB = function (r, g, b, a) {
	        if (typeof r === 'undefined' || typeof g === 'undefined' || typeof b === 'undefined') {
	            this.filled = false;
	        }
	        else {
	            this.cyanColor = 0;
	            this.magentaColor = 0;
	            this.yellowColor = 0;
	            this.blackColor = 0;
	            this.grayColor = 0;
	            this.redColor = r;
	            this.greenColor = g;
	            this.blueColor = b;
	            if (typeof a === 'undefined') {
	                this.alpha = PdfColor.maxColourChannelValue;
	            }
	            else {
	                this.alpha = a;
	            }
	            this.filled = true;
	            this.assignCMYK(r, g, b);
	        }
	    };
	    /**
	     * `Calculate and assign` cyan, megenta, yellow colors from rgb values..
	     * @private
	     */
	    PdfColor.prototype.assignCMYK = function (r, g, b) {
	        var red = r / PdfColor.maxColourChannelValue;
	        var green = g / PdfColor.maxColourChannelValue;
	        var blue = b / PdfColor.maxColourChannelValue;
	        var black = PdfNumber.min(1 - red, 1 - green, 1 - blue);
	        var cyan = (black === 1.0) ? 0 : (1 - red - black) / (1 - black);
	        var magenta = (black === 1.0) ? 0 : (1 - green - black) / (1 - black);
	        var yellow = (black === 1.0) ? 0 : (1 - blue - black) / (1 - black);
	        this.blackColor = black;
	        this.cyanColor = cyan;
	        this.magentaColor = magenta;
	        this.yellowColor = yellow;
	    };
	    Object.defineProperty(PdfColor.prototype, "r", {
	        //Properties
	        // public static get Empty():PdfColor
	        // {
	        //     return this.s_emptyColor
	        // }
	        /**
	         * Gets or sets `Red` channel value.
	         * @private
	         */
	        get: function () {
	            return this.redColor;
	        },
	        set: function (value) {
	            this.redColor = value;
	            this.assignCMYK(this.redColor, this.greenColor, this.blueColor);
	            this.filled = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfColor.prototype, "red", {
	        /**
	         * Gets the `Red` color
	         * @private
	         */
	        get: function () {
	            return (this.r / PdfColor.maxColourChannelValue);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfColor.prototype, "b", {
	        /**
	         * Gets or sets `Blue` channel value.
	         * @private
	         */
	        get: function () {
	            return this.blueColor;
	        },
	        set: function (value) {
	            this.blueColor = value;
	            this.assignCMYK(this.redColor, this.greenColor, this.blueColor);
	            this.filled = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfColor.prototype, "blue", {
	        /**
	         * Gets the `blue` color.
	         * @private
	         */
	        get: function () {
	            return (this.b / PdfColor.maxColourChannelValue);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfColor.prototype, "c", {
	        /**
	         * Gets or sets `Cyan` channel value.
	         * @private
	         */
	        get: function () {
	            return this.cyanColor;
	        },
	        set: function (value) {
	            if (value < 0) {
	                this.cyanColor = 0;
	            }
	            else if (value > 1) {
	                this.cyanColor = 1;
	            }
	            else {
	                this.cyanColor = value;
	            }
	            this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);
	            this.filled = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfColor.prototype, "k", {
	        /**
	         * Gets or sets `Black` channel value.
	         * @private
	         */
	        get: function () {
	            return this.blackColor;
	        },
	        set: function (value) {
	            if ((value < 0)) {
	                this.blackColor = 0;
	            }
	            else if ((value > 1)) {
	                this.blackColor = 1;
	            }
	            else {
	                this.blackColor = value;
	            }
	            this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);
	            this.filled = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfColor.prototype, "m", {
	        /**
	         * Gets or sets `Magenta` channel value.
	         * @private
	         */
	        get: function () {
	            return this.magentaColor;
	        },
	        set: function (value) {
	            if ((value < 0)) {
	                this.magentaColor = 0;
	            }
	            else if ((value > 1)) {
	                this.magentaColor = 1;
	            }
	            else {
	                this.magentaColor = value;
	            }
	            this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);
	            this.filled = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfColor.prototype, "y", {
	        /**
	         * Gets or sets `Yellow` channel value.
	         * @private
	         */
	        get: function () {
	            return this.yellowColor;
	        },
	        set: function (value) {
	            if ((value < 0)) {
	                this.yellowColor = 0;
	            }
	            else if ((value > 1)) {
	                this.yellowColor = 1;
	            }
	            else {
	                this.yellowColor = value;
	            }
	            this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);
	            this.filled = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfColor.prototype, "g", {
	        /**
	         *  Gets or sets `Green` channel value.
	         * @private
	         */
	        get: function () {
	            return this.greenColor;
	        },
	        set: function (value) {
	            this.greenColor = value;
	            this.assignCMYK(this.redColor, this.greenColor, this.blueColor);
	            this.filled = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfColor.prototype, "green", {
	        /**
	         * Gets the `Green` color.
	         * @private
	         */
	        get: function () {
	            return (this.g / PdfColor.maxColourChannelValue);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfColor.prototype, "gray", {
	        /**
	         * Gets or sets `Gray` channel value.
	         * @private
	         */
	        get: function () {
	            return ((((this.redColor + this.greenColor) + this.blueColor)) / (PdfColor.maxColourChannelValue * 3));
	        },
	        set: function (value) {
	            if (value < 0) {
	                this.grayColor = 0;
	            }
	            else if (value > 1) {
	                this.grayColor = 1;
	            }
	            else {
	                this.grayColor = value;
	            }
	            this.r = (this.grayColor * PdfColor.maxColourChannelValue);
	            this.g = (this.grayColor * PdfColor.maxColourChannelValue);
	            this.b = (this.grayColor * PdfColor.maxColourChannelValue);
	            this.assignCMYK(this.redColor, this.greenColor, this.blueColor);
	            this.filled = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfColor.prototype, "isEmpty", {
	        /**
	         * Gets whether the PDFColor `is Empty` or not.
	         * @private
	         */
	        get: function () {
	            return !this.filled;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfColor.prototype, "a", {
	        /**
	         * Gets or sets `Alpha` channel value.
	         * @private
	         */
	        get: function () {
	            return this.alpha;
	        },
	        set: function (value) {
	            if (value < 0) {
	                this.alpha = 0;
	            }
	            else {
	                // if (this.alpha !== value) {
	                this.alpha = value;
	                // }
	            }
	            this.filled = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //Public methods
	    /**
	     * Converts `PDFColor to PDF string` representation.
	     * @private
	     */
	    PdfColor.prototype.toString = function (colorSpace, stroke) {
	        if (this.isEmpty) {
	            return '';
	        }
	        var str = '';
	        switch (colorSpace) {
	            case PdfColorSpace.Rgb:
	                str = this.rgbToString(stroke);
	                break;
	            case PdfColorSpace.GrayScale:
	                str = this.grayScaleToString(stroke);
	                break;
	            case PdfColorSpace.Cmyk:
	                str = this.cmykToString(stroke);
	                break;
	        }
	        return str;
	    };
	    /**
	     * Sets `GrayScale` color.
	     * @private
	     */
	    PdfColor.prototype.grayScaleToString = function (ifStroking) {
	        var gray = this.gray;
	        var colour = '';
	        var obj = null;
	        /* tslint:disable-next-line:max-line-length */
	        obj = (ifStroking) ? PdfColor.grayStringsSroke.containsKey(gray) ? PdfColor.grayStringsSroke.getValue(gray) : null : PdfColor.grayStringsFill.containsKey(gray) ? PdfColor.grayStringsFill.getValue(gray) : null;
	        if (obj == null) {
	            if (ifStroking) {
	                colour = gray.toString() + ' G';
	                PdfColor.grayStringsSroke.setValue(gray, colour);
	            }
	        }
	        else {
	            colour = obj.toString();
	        }
	        return colour + Operators.newLine;
	    };
	    /**
	     * Sets `RGB` color.
	     * @private
	     */
	    PdfColor.prototype.rgbToString = function (ifStroking) {
	        var r = this.r;
	        var g = this.g;
	        var b = this.b;
	        var key = (r << 16) + (g << 8) + b;
	        if (ifStroking) {
	            key += 1 << 24;
	        }
	        var colour = '';
	        var obj = null;
	        if (PdfColor.rgbStrings.containsKey(key)) {
	            obj = PdfColor.rgbStrings.getValue(key);
	        }
	        if (obj == null) {
	            var red = r / PdfColor.maxColourChannelValue;
	            var green = g / PdfColor.maxColourChannelValue;
	            var blue = b / PdfColor.maxColourChannelValue;
	            if (ifStroking) {
	                colour = red.toString() + ' ' + green.toString() + ' ' + blue.toString() + ' RG';
	            }
	            else {
	                colour = red.toString() + ' ' + green.toString() + ' ' + blue.toString() + ' rg';
	            }
	            PdfColor.rgbStrings.setValue(key, colour);
	        }
	        else {
	            colour = obj.toString();
	        }
	        return colour + Operators.newLine;
	    };
	    /***
	     * Sets `CMYK` color.
	     * @private
	     */
	    PdfColor.prototype.cmykToString = function (ifStroking) {
	        var cyan = this.c;
	        var magenta = this.m;
	        var yellow = this.y;
	        var black = this.b;
	        var colour = '';
	        colour = cyan.toString() + ' ' + magenta.toString() + ' ' + yellow.toString() + ' ' + black.toString() + ' K';
	        return colour + Operators.newLine;
	    };
	    /**
	     * Converts `colour to a PDF array`.
	     * @private
	     */
	    PdfColor.prototype.toArray = function (colorSpace) {
	        var array = new PdfArray();
	        switch (colorSpace) {
	            case PdfColorSpace.Rgb:
	                array.add(new PdfNumber(this.red));
	                array.add(new PdfNumber(this.green));
	                array.add(new PdfNumber(this.blue));
	                break;
	        }
	        return array;
	    };
	    //Fields
	    /**
	     * Holds `RGB colors` converted into strings.
	     * @private
	     */
	    PdfColor.rgbStrings = new Dictionary();
	    /**
	     * Holds Gray scale colors converted into strings for `stroking`.
	     * @private
	     */
	    PdfColor.grayStringsSroke = new Dictionary();
	    /**
	     * Holds Gray scale colors converted into strings for `filling`.
	     * @private
	     */
	    PdfColor.grayStringsFill = new Dictionary();
	    /**
	     * `Max value` of color channel.
	     * @private
	     */
	    PdfColor.maxColourChannelValue = 255.0;
	    return PdfColor;
	}());

	/**
	 * Coordinates of Position for `PointF`.
	 * @private
	 */
	var PointF = /** @class */ (function () {
	    function PointF(x, y) {
	        if (typeof x === 'undefined') {
	            this.x = 0;
	            this.y = 0;
	        }
	        else {
	            if (x !== null) {
	                this.x = x;
	            }
	            else {
	                this.x = 0;
	            }
	            if (y !== null) {
	                this.y = y;
	            }
	            else {
	                this.y = 0;
	            }
	        }
	    }
	    return PointF;
	}());
	/**
	 * Width and Height as `Size`.
	 * @private
	 */
	var SizeF = /** @class */ (function () {
	    function SizeF(width, height) {
	        if (typeof height === 'undefined') {
	            this.height = 0;
	            this.width = 0;
	        }
	        else {
	            if (height !== null) {
	                this.height = height;
	            }
	            else {
	                this.height = 0;
	            }
	            if (width !== null) {
	                this.width = width;
	            }
	            else {
	                this.width = 0;
	            }
	        }
	    }
	    return SizeF;
	}());
	/**
	 * `RectangleF` with Position and size.
	 * @private
	 */
	var RectangleF = /** @class */ (function () {
	    function RectangleF(arg1, arg2, arg3, arg4) {
	        if (typeof arg1 === typeof arg1 && typeof arg1 === 'undefined') {
	            this.x = 0;
	            this.y = 0;
	            this.height = 0;
	            this.width = 0;
	        }
	        else {
	            if (arg1 instanceof PointF && arg2 instanceof SizeF && typeof arg3 === 'undefined') {
	                var pointf = arg1;
	                this.x = pointf.x;
	                this.y = pointf.y;
	                var sizef = arg2;
	                this.height = sizef.height;
	                this.width = sizef.width;
	            }
	            else {
	                var x = arg1;
	                var y = arg2;
	                var width = arg3;
	                var height = arg4;
	                this.x = x;
	                this.y = y;
	                this.height = height;
	                this.width = width;
	            }
	        }
	    }
	    return RectangleF;
	}());
	/**
	 * `Rectangle` with left, right, top and bottom.
	 * @private
	 */
	var Rectangle = /** @class */ (function () {
	    /**
	     * Instance of `RectangleF` class with X, Y, Width and Height.
	     * @private
	     */
	    function Rectangle(left, top, right, bottom) {
	        this.left = left;
	        this.top = top;
	        this.right = right;
	        this.bottom = bottom;
	    }
	    Object.defineProperty(Rectangle.prototype, "width", {
	        /**
	         * Gets a value of width
	         */
	        get: function () {
	            return this.right - this.left;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "height", {
	        /**
	         * Gets a value of height
	         */
	        get: function () {
	            return this.bottom - this.top;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "topLeft", {
	        /**
	         * Gets a value of Top and Left
	         */
	        get: function () {
	            return new PointF(this.left, this.top);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "size", {
	        /**
	         * Gets a value of size
	         */
	        get: function () {
	            return new SizeF(this.width, this.height);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Rectangle.prototype.toString = function () {
	        return this.topLeft + 'x' + this.size;
	    };
	    return Rectangle;
	}());

	/**
	 * `PdfBrush` class provides objects used to fill the interiors of graphical shapes such as rectangles,
	 * ellipses, pies, polygons, and paths.
	 * @private
	 */
	var PdfBrush = /** @class */ (function () {
	    /**
	     * Creates instanceof `PdfBrush` class.
	     * @hidden
	     * @private
	     */
	    function PdfBrush() {
	        //
	    }
	    //IClonable implementation
	    PdfBrush.prototype.clone = function () {
	        return this;
	    };
	    return PdfBrush;
	}());

	var __extends$q = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Represents a brush that fills any object with a solid color.
	 * ```typescript
	 * // create a new PDF document
	 * let document : PdfDocument = new PdfDocument();
	 * // add a pages to the document
	 * let page1 : PdfPage = document.pages.add();
	 * // set font
	 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	 * // set brush
	 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	 * // draw the text
	 * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10));
	 * // save the document
	 * document.save('output.pdf');
	 * // destroy the document
	 * document.destroy();
	 * ```
	 */
	var PdfSolidBrush = /** @class */ (function (_super) {
	    __extends$q(PdfSolidBrush, _super);
	    //Constructors
	    /**
	     * Initializes a new instance of the `PdfSolidBrush` class.
	     * ```typescript
	     * // create a new PDF document
	     * let document : PdfDocument = new PdfDocument();
	     * // add a pages to the document
	     * let page1 : PdfPage = document.pages.add();
	     * // set font
	     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	     * // set brush
	     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	     * // draw the text
	     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10));
	     * // save the document
	     * document.save('output.pdf');
	     * // destroy the document
	     * document.destroy();
	     * ```
	     * @param color color of the brush
	     */
	    function PdfSolidBrush(color) {
	        var _this = _super.call(this) || this;
	        _this.pdfColor = color;
	        return _this;
	    }
	    Object.defineProperty(PdfSolidBrush.prototype, "color", {
	        //Properties
	        /**
	         * Gets or sets the `color` of the brush.
	         * @private
	         */
	        get: function () {
	            return this.pdfColor;
	        },
	        set: function (value) {
	            this.pdfColor = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //Implementation
	    /**
	     * `Monitors` the changes of the brush and modify PDF state respectively.
	     * @private
	     */
	    PdfSolidBrush.prototype.monitorChanges = function (brush, streamWriter, getResources, saveChanges, currentColorSpace) {
	        if (streamWriter == null) {
	            throw new Error('ArgumentNullException:streamWriter');
	        }
	        var diff = false;
	        if (brush == null) {
	            diff = true;
	            streamWriter.setColorAndSpace(this.pdfColor, currentColorSpace, false);
	            return diff;
	        }
	        else {
	            diff = true;
	            streamWriter.setColorAndSpace(this.pdfColor, currentColorSpace, false);
	            return diff;
	        }
	    };
	    /**
	     * `Resets` the changes, which were made by the brush.
	     * @private
	     */
	    PdfSolidBrush.prototype.resetChanges = function (streamWriter) {
	        streamWriter.setColorAndSpace(new PdfColor(0, 0, 0), PdfColorSpace.Rgb, false);
	    };
	    return PdfSolidBrush;
	}(PdfBrush));

	/**
	 * public Enum for `PdfFontStyle`.
	 * @private
	 */
	var PdfFontStyle;
	(function (PdfFontStyle) {
	    /**
	     * Specifies the type of `Regular`.
	     * @private
	     */
	    PdfFontStyle[PdfFontStyle["Regular"] = 0] = "Regular";
	    /**
	     * Specifies the type of `Bold`.
	     * @private
	     */
	    PdfFontStyle[PdfFontStyle["Bold"] = 1] = "Bold";
	    /**
	     * Specifies the type of `Italic`.
	     * @private
	     */
	    PdfFontStyle[PdfFontStyle["Italic"] = 2] = "Italic";
	    /**
	     * Specifies the type of `Underline`.
	     * @private
	     */
	    PdfFontStyle[PdfFontStyle["Underline"] = 4] = "Underline";
	    /**
	     * Specifies the type of `Strikeout`.
	     * @private
	     */
	    PdfFontStyle[PdfFontStyle["Strikeout"] = 8] = "Strikeout";
	})(PdfFontStyle || (PdfFontStyle = {}));
	/**
	 * Specifies the font family from the standard font.
	 * ```typescript
	 * // create a new PDF document
	 * let document : PdfDocument = new PdfDocument();
	 * // add a new page to the document
	 * let page1 : PdfPage = document.pages.add();
	 * // create new standard font
	 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	 * // create black brush
	 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	 * // draw the text
	 * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
	 * // save the document
	 * document.save('output.pdf');
	 * ```
	 */
	var PdfFontFamily;
	(function (PdfFontFamily) {
	    /**
	     * Specifies the `Helvetica` font.
	     */
	    PdfFontFamily[PdfFontFamily["Helvetica"] = 0] = "Helvetica";
	    /**
	     * Specifies the `Courier` font.
	     */
	    PdfFontFamily[PdfFontFamily["Courier"] = 1] = "Courier";
	    /**
	     * Specifies the `TimesRoman` font.
	     */
	    PdfFontFamily[PdfFontFamily["TimesRoman"] = 2] = "TimesRoman";
	    /**
	     * Specifies the `Symbol` font.
	     */
	    PdfFontFamily[PdfFontFamily["Symbol"] = 3] = "Symbol";
	    /**
	     * Specifies the `ZapfDingbats` font.
	     */
	    PdfFontFamily[PdfFontFamily["ZapfDingbats"] = 4] = "ZapfDingbats";
	})(PdfFontFamily || (PdfFontFamily = {}));
	/**
	 * public Enum for `PdfFontType`.
	 * @private
	 */
	var PdfFontType;
	(function (PdfFontType) {
	    /**
	     * Specifies the type of `Standard`.
	     * @private
	     */
	    PdfFontType[PdfFontType["Standard"] = 0] = "Standard";
	    /**
	     * Specifies the type of `TrueType`.
	     * @private
	     */
	    PdfFontType[PdfFontType["TrueType"] = 1] = "TrueType";
	    /**
	     * Specifies the type of `TrueTypeEmbedded`.
	     * @private
	     */
	    PdfFontType[PdfFontType["TrueTypeEmbedded"] = 2] = "TrueTypeEmbedded";
	})(PdfFontType || (PdfFontType = {}));
	/**
	 * public Enum for `PdfWordWrapType`.
	 * @private
	 */
	var PdfWordWrapType;
	(function (PdfWordWrapType) {
	    /**
	     * Specifies the type of `None`.
	     * @private
	     */
	    PdfWordWrapType[PdfWordWrapType["None"] = 0] = "None";
	    /**
	     * Specifies the type of `Word`.
	     * @private
	     */
	    PdfWordWrapType[PdfWordWrapType["Word"] = 1] = "Word";
	    /**
	     * Specifies the type of `WordOnly`.
	     * @private
	     */
	    PdfWordWrapType[PdfWordWrapType["WordOnly"] = 2] = "WordOnly";
	    /**
	     * Specifies the type of `Character`.
	     * @private
	     */
	    PdfWordWrapType[PdfWordWrapType["Character"] = 3] = "Character";
	})(PdfWordWrapType || (PdfWordWrapType = {}));
	/**
	 * public Enum for `PdfSubSuperScript`.
	 * @private
	 */
	var PdfSubSuperScript;
	(function (PdfSubSuperScript) {
	    /**
	     * Specifies the type of `None`.
	     * @private
	     */
	    PdfSubSuperScript[PdfSubSuperScript["None"] = 0] = "None";
	    /**
	     * Specifies the type of `SuperScript`.
	     * @private
	     */
	    PdfSubSuperScript[PdfSubSuperScript["SuperScript"] = 1] = "SuperScript";
	    /**
	     * Specifies the type of `SubScript`.
	     * @private
	     */
	    PdfSubSuperScript[PdfSubSuperScript["SubScript"] = 2] = "SubScript";
	})(PdfSubSuperScript || (PdfSubSuperScript = {}));
	/**
	 * public Enum for `FontEncoding`.
	 * @private
	 */
	var FontEncoding;
	(function (FontEncoding) {
	    /**
	     * Specifies the type of `Unknown`.
	     * @private
	     */
	    FontEncoding[FontEncoding["Unknown"] = 0] = "Unknown";
	    /**
	     * Specifies the type of `StandardEncoding`.
	     * @private
	     */
	    FontEncoding[FontEncoding["StandardEncoding"] = 1] = "StandardEncoding";
	    /**
	     * Specifies the type of `MacRomanEncoding`.
	     * @private
	     */
	    FontEncoding[FontEncoding["MacRomanEncoding"] = 2] = "MacRomanEncoding";
	    /**
	     * Specifies the type of `MacExpertEncoding`.
	     * @private
	     */
	    FontEncoding[FontEncoding["MacExpertEncoding"] = 3] = "MacExpertEncoding";
	    /**
	     * Specifies the type of `WinAnsiEncoding`.
	     * @private
	     */
	    FontEncoding[FontEncoding["WinAnsiEncoding"] = 4] = "WinAnsiEncoding";
	    /**
	     * Specifies the type of `PdfDocEncoding`.
	     * @private
	     */
	    FontEncoding[FontEncoding["PdfDocEncoding"] = 5] = "PdfDocEncoding";
	    /**
	     * Specifies the type of `IdentityH`.
	     * @private
	     */
	    FontEncoding[FontEncoding["IdentityH"] = 6] = "IdentityH";
	})(FontEncoding || (FontEncoding = {}));
	/**
	 * public Enum for `TtfCmapFormat`.
	 * @private
	 */
	var TtfCmapFormat;
	(function (TtfCmapFormat) {
	    /**
	     * This is the Apple standard character to glyph index mapping table.
	     * @private
	     */
	    TtfCmapFormat[TtfCmapFormat["Apple"] = 0] = "Apple";
	    /**
	     * This is the Microsoft standard character to glyph index mapping table.
	     * @private
	     */
	    TtfCmapFormat[TtfCmapFormat["Microsoft"] = 4] = "Microsoft";
	    /**
	     * Format 6: Trimmed table mapping.
	     * @private
	     */
	    TtfCmapFormat[TtfCmapFormat["Trimmed"] = 6] = "Trimmed";
	})(TtfCmapFormat || (TtfCmapFormat = {}));
	/**
	 * Enumerator that implements CMAP encodings.
	 * @private
	 */
	var TtfCmapEncoding;
	(function (TtfCmapEncoding) {
	    /**
	     * Unknown encoding.
	     * @private
	     */
	    TtfCmapEncoding[TtfCmapEncoding["Unknown"] = 0] = "Unknown";
	    /**
	     * When building a symbol font for Windows.
	     * @private
	     */
	    TtfCmapEncoding[TtfCmapEncoding["Symbol"] = 1] = "Symbol";
	    /**
	     * When building a Unicode font for Windows.
	     * @private
	     */
	    TtfCmapEncoding[TtfCmapEncoding["Unicode"] = 2] = "Unicode";
	    /**
	     * For font that will be used on a Macintosh.
	     * @private
	     */
	    TtfCmapEncoding[TtfCmapEncoding["Macintosh"] = 3] = "Macintosh";
	})(TtfCmapEncoding || (TtfCmapEncoding = {}));
	/**
	 * Ttf platform ID.
	 * @private
	 */
	var TtfPlatformID;
	(function (TtfPlatformID) {
	    /**
	     * Apple platform.
	     * @private
	     */
	    TtfPlatformID[TtfPlatformID["AppleUnicode"] = 0] = "AppleUnicode";
	    /**
	     * Macintosh platform.
	     * @private
	     */
	    TtfPlatformID[TtfPlatformID["Macintosh"] = 1] = "Macintosh";
	    /**
	     * Iso platform.
	     * @private
	     */
	    TtfPlatformID[TtfPlatformID["Iso"] = 2] = "Iso";
	    /**
	     * Microsoft platform.
	     * @private
	     */
	    TtfPlatformID[TtfPlatformID["Microsoft"] = 3] = "Microsoft";
	})(TtfPlatformID || (TtfPlatformID = {}));
	/**
	 * Microsoft encoding ID.
	 * @private
	 */
	var TtfMicrosoftEncodingID;
	(function (TtfMicrosoftEncodingID) {
	    /**
	     * Undefined encoding.
	     * @private
	     */
	    TtfMicrosoftEncodingID[TtfMicrosoftEncodingID["Undefined"] = 0] = "Undefined";
	    /**
	     * Unicode encoding.
	     * @private
	     */
	    TtfMicrosoftEncodingID[TtfMicrosoftEncodingID["Unicode"] = 1] = "Unicode";
	})(TtfMicrosoftEncodingID || (TtfMicrosoftEncodingID = {}));
	/**
	 * Macintosh encoding ID.
	 * @private
	 */
	var TtfMacintoshEncodingID;
	(function (TtfMacintoshEncodingID) {
	    /**
	     * Roman encoding.
	     * @private
	     */
	    TtfMacintoshEncodingID[TtfMacintoshEncodingID["Roman"] = 0] = "Roman";
	    /**
	     * Japanese encoding.
	     * @private
	     */
	    TtfMacintoshEncodingID[TtfMacintoshEncodingID["Japanese"] = 1] = "Japanese";
	    /**
	     * Chinese encoding.
	     * @private
	     */
	    TtfMacintoshEncodingID[TtfMacintoshEncodingID["Chinese"] = 2] = "Chinese";
	})(TtfMacintoshEncodingID || (TtfMacintoshEncodingID = {}));
	/**
	 * Enumerator that implements font descriptor flags.
	 * @private
	 */
	var FontDescriptorFlags;
	(function (FontDescriptorFlags) {
	    /**
	     * All glyphs have the same width (as opposed to proportional or variable-pitch fonts, which have different widths).
	     * @private
	     */
	    FontDescriptorFlags[FontDescriptorFlags["FixedPitch"] = 1] = "FixedPitch";
	    /**
	     * Glyphs have serifs, which are short strokes drawn at an angle on the top and
	     * bottom of glyph stems (as opposed to sans serif fonts, which do not).
	     * @private
	     */
	    FontDescriptorFlags[FontDescriptorFlags["Serif"] = 2] = "Serif";
	    /**
	     * Font contains glyphs outside the Adobe standard Latin character set. The
	     * flag and the nonsymbolic flag cannot both be set or both be clear.
	     * @private
	     */
	    FontDescriptorFlags[FontDescriptorFlags["Symbolic"] = 4] = "Symbolic";
	    /**
	     * Glyphs resemble cursive handwriting.
	     * @private
	     */
	    FontDescriptorFlags[FontDescriptorFlags["Script"] = 8] = "Script";
	    /**
	     * Font uses the Adobe standard Latin character set or a subset of it.
	     * @private
	     */
	    FontDescriptorFlags[FontDescriptorFlags["Nonsymbolic"] = 32] = "Nonsymbolic";
	    /**
	     * Glyphs have dominant vertical strokes that are slanted.
	     * @private
	     */
	    FontDescriptorFlags[FontDescriptorFlags["Italic"] = 64] = "Italic";
	    /**
	     * Bold font.
	     * @private
	     */
	    FontDescriptorFlags[FontDescriptorFlags["ForceBold"] = 262144] = "ForceBold";
	})(FontDescriptorFlags || (FontDescriptorFlags = {}));
	/**
	 * true type font composite glyph flags.
	 * @private
	 */
	var TtfCompositeGlyphFlags;
	(function (TtfCompositeGlyphFlags) {
	    /**
	     * The Arg1And2AreWords.
	     * @private
	     */
	    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags["Arg1And2AreWords"] = 1] = "Arg1And2AreWords";
	    /**
	     * The ArgsAreXyValues.
	     * @private
	     */
	    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags["ArgsAreXyValues"] = 2] = "ArgsAreXyValues";
	    /**
	     * The RoundXyToGrid.
	     * @private
	     */
	    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags["RoundXyToGrid"] = 4] = "RoundXyToGrid";
	    /**
	     * The WeHaveScale.
	     * @private
	     */
	    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags["WeHaveScale"] = 8] = "WeHaveScale";
	    /**
	     * The Reserved.
	     * @private
	     */
	    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags["Reserved"] = 16] = "Reserved";
	    /**
	     * The MoreComponents.
	     * @private
	     */
	    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags["MoreComponents"] = 32] = "MoreComponents";
	    /**
	     * The WeHaveAnXyScale.
	     * @private
	     */
	    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags["WeHaveAnXyScale"] = 64] = "WeHaveAnXyScale";
	    /**
	     * The WeHaveTwoByTwo
	     */
	    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags["WeHaveTwoByTwo"] = 128] = "WeHaveTwoByTwo";
	    /**
	     * The WeHaveInstructions.
	     */
	    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags["WeHaveInstructions"] = 256] = "WeHaveInstructions";
	    /**
	     * The UseMyMetrics.
	     */
	    TtfCompositeGlyphFlags[TtfCompositeGlyphFlags["UseMyMetrics"] = 512] = "UseMyMetrics";
	})(TtfCompositeGlyphFlags || (TtfCompositeGlyphFlags = {}));

	/**
	 * PdfStringFormat.ts class for EJ2-PDF
	 */
	/**
	 * `PdfStringFormat` class represents the text layout information on PDF.
	 * ```typescript
	 * // create a new PDF document
	 * let document : PdfDocument = new PdfDocument();
	 * // add a pages to the document
	 * let page1 : PdfPage = document.pages.add();
	 * // set font
	 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	 * // set brush
	 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	 * //
	 * // set the format for string
	 * let stringFormat : PdfStringFormat = new PdfStringFormat();
	 * // set the text alignment
	 * stringFormat.alignment = PdfTextAlignment.Center;
	 * // set the vertical alignment
	 * stringFormat.lineAlignment = PdfVerticalAlignment.Middle;
	 * //
	 * // draw the text
	 * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
	 * // save the document
	 * document.save('output.pdf');
	 * // destroy the document
	 * document.destroy();
	 * ```
	 */
	var PdfStringFormat = /** @class */ (function () {
	    function PdfStringFormat(arg1, arg2) {
	        /**
	         * The `scaling factor` of the text being drawn.
	         * @private
	         */
	        this.scalingFactor = 100.0;
	        /**
	         * Indicates text `wrapping` type.
	         * @private
	         */
	        this.wordWrapType = PdfWordWrapType.Word;
	        this.internalLineLimit = true;
	        this.wordWrapType = PdfWordWrapType.Word;
	        if ((typeof arg1 !== 'undefined') && (typeof arg1 !== 'string')) {
	            this.textAlignment = arg1;
	        }
	        if (typeof arg2 !== 'undefined') {
	            this.verticalAlignment = arg2;
	        }
	    }
	    Object.defineProperty(PdfStringFormat.prototype, "alignment", {
	        //Properties
	        /**
	         * Gets or sets the `horizontal` text alignment
	         * ```typescript
	         * // create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // add a pages to the document
	         * let page1 : PdfPage = document.pages.add();
	         * // set font
	         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	         * // set brush
	         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	         * //
	         * // set the format for string
	         * let stringFormat : PdfStringFormat = new PdfStringFormat();
	         * // set the text alignment
	         * stringFormat.alignment = PdfTextAlignment.Center;
	         * //
	         * // draw the text
	         * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
	         * // save the document
	         * document.save('output.pdf');
	         * // destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            return this.textAlignment;
	        },
	        set: function (value) {
	            this.textAlignment = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringFormat.prototype, "textDirection", {
	        get: function () {
	            return this.direction;
	        },
	        set: function (value) {
	            this.direction = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringFormat.prototype, "lineAlignment", {
	        /**
	         * Gets or sets the `vertical` text alignment.
	         * ```typescript
	         * // create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // add a pages to the document
	         * let page1 : PdfPage = document.pages.add();
	         * // set font
	         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	         * // set brush
	         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	         * //
	         * // set the format for string
	         * let stringFormat : PdfStringFormat = new PdfStringFormat();
	         * // set the vertical alignment
	         * stringFormat.lineAlignment = PdfVerticalAlignment.Middle;
	         * //
	         * // draw the text
	         * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
	         * // save the document
	         * document.save('output.pdf');
	         * // destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            if (typeof this.verticalAlignment === 'undefined' || this.verticalAlignment == null) {
	                return PdfVerticalAlignment.Top;
	            }
	            else {
	                return this.verticalAlignment;
	            }
	        },
	        set: function (value) {
	            this.verticalAlignment = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringFormat.prototype, "rightToLeft", {
	        /**
	         * Gets or sets the value that indicates text `direction` mode.
	         * @private
	         */
	        get: function () {
	            if (typeof this.isRightToLeft === 'undefined' || this.isRightToLeft == null) {
	                return false;
	            }
	            else {
	                return this.isRightToLeft;
	            }
	        },
	        set: function (value) {
	            this.isRightToLeft = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringFormat.prototype, "characterSpacing", {
	        /**
	         * Gets or sets value that indicates a `size` among the characters in the text.
	         * ```typescript
	         * // create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // add a pages to the document
	         * let page1 : PdfPage = document.pages.add();
	         * // set font
	         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	         * // set brush
	         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	         * //
	         * // set the format for string
	         * let stringFormat : PdfStringFormat = new PdfStringFormat();
	         * // set character spacing
	         * stringFormat.characterSpacing = 10;
	         * //
	         * // draw the text
	         * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
	         * // save the document
	         * document.save('output.pdf');
	         * // destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            if (typeof this.internalCharacterSpacing === 'undefined' || this.internalCharacterSpacing == null) {
	                return 0;
	            }
	            else {
	                return this.internalCharacterSpacing;
	            }
	        },
	        set: function (value) {
	            this.internalCharacterSpacing = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringFormat.prototype, "wordSpacing", {
	        /**
	         * Gets or sets value that indicates a `size` among the words in the text.
	         * ```typescript
	         * // create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // add a pages to the document
	         * let page1 : PdfPage = document.pages.add();
	         * // set font
	         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	         * // set brush
	         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	         * //
	         * // set the format for string
	         * let stringFormat : PdfStringFormat = new PdfStringFormat();
	         * // set word spacing
	         * stringFormat.wordSpacing = 10;
	         * //
	         * // draw the text
	         * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
	         * // save the document
	         * document.save('output.pdf');
	         * // destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            if (typeof this.internalWordSpacing === 'undefined' || this.internalWordSpacing == null) {
	                return 0;
	            }
	            else {
	                return this.internalWordSpacing;
	            }
	        },
	        set: function (value) {
	            this.internalWordSpacing = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringFormat.prototype, "lineSpacing", {
	        /**
	         * Gets or sets value that indicates the `vertical distance` between the baselines of adjacent lines of text.
	         * ```typescript
	         * // create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // add a pages to the document
	         * let page1 : PdfPage = document.pages.add();
	         * // set font
	         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	         * // set brush
	         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	         * // set string
	         * let text : string = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
	         * incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitati';
	         * // set rectangle bounds
	         * let rectangle : RectangleF = new RectangleF({x : 0, y : 0}, {width : 300, height : 100})
	         * //
	         * // set the format for string
	         * let stringFormat : PdfStringFormat = new PdfStringFormat();
	         * // set line spacing
	         * stringFormat.lineSpacing = 10;
	         * //
	         * // draw the text
	         * page1.graphics.drawString(text, font, blackBrush, rectangle, stringFormat);
	         * // save the document
	         * document.save('output.pdf');
	         * // destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            if (typeof this.leading === 'undefined' || this.leading == null) {
	                return 0;
	            }
	            else {
	                return this.leading;
	            }
	        },
	        set: function (value) {
	            this.leading = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringFormat.prototype, "clipPath", {
	        /**
	         * Gets or sets a value indicating whether the text is `clipped` or not.
	         * @private
	         */
	        get: function () {
	            if (typeof this.clip === 'undefined' || this.clip == null) {
	                return false;
	            }
	            else {
	                return this.clip;
	            }
	        },
	        set: function (value) {
	            this.clip = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringFormat.prototype, "subSuperScript", {
	        /**
	         * Gets or sets value indicating whether the text is in `subscript or superscript` mode.
	         * @private
	         */
	        get: function () {
	            if (typeof this.pdfSubSuperScript === 'undefined' || this.pdfSubSuperScript == null) {
	                return PdfSubSuperScript.None;
	            }
	            else {
	                return this.pdfSubSuperScript;
	            }
	        },
	        set: function (value) {
	            this.pdfSubSuperScript = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringFormat.prototype, "paragraphIndent", {
	        /**
	         * Gets or sets the `indent` of the first line in the paragraph.
	         * @private
	         */
	        get: function () {
	            if (typeof this.internalParagraphIndent === 'undefined' || this.internalParagraphIndent == null) {
	                return 0;
	            }
	            else {
	                return this.internalParagraphIndent;
	            }
	        },
	        set: function (value) {
	            this.internalParagraphIndent = value;
	            this.firstLineIndent = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringFormat.prototype, "lineLimit", {
	        /**
	         * Gets or sets a value indicating whether [`line limit`].
	         * @private
	         */
	        get: function () {
	            return this.internalLineLimit;
	        },
	        set: function (value) {
	            this.internalLineLimit = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringFormat.prototype, "measureTrailingSpaces", {
	        /**
	         * Gets or sets a value indicating whether [`measure trailing spaces`].
	         * @private
	         */
	        get: function () {
	            if (typeof this.trailingSpaces === 'undefined' || this.trailingSpaces == null) {
	                return false;
	            }
	            else {
	                return this.trailingSpaces;
	            }
	        },
	        set: function (value) {
	            this.trailingSpaces = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringFormat.prototype, "noClip", {
	        /**
	         * Gets or sets a value indicating whether [`no clip`].
	         * @private
	         */
	        get: function () {
	            if (typeof this.isNoClip === 'undefined' || this.isNoClip == null) {
	                return false;
	            }
	            else {
	                return this.isNoClip;
	            }
	        },
	        set: function (value) {
	            this.isNoClip = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringFormat.prototype, "wordWrap", {
	        /**
	         * Gets or sets value indicating type of the text `wrapping`.
	         * @private
	         */
	        get: function () {
	            // if (typeof this.wrapType === 'undefined' || this.wrapType == null) {
	            //     return PdfWordWrapType.Word;
	            // } else {
	            return this.wordWrapType;
	            // }
	        },
	        set: function (value) {
	            this.wordWrapType = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringFormat.prototype, "horizontalScalingFactor", {
	        /**
	         * Gets or sets the `scaling factor`.
	         * @private
	         */
	        get: function () {
	            // if (typeof this.scalingFactor === 'undefined' || this.scalingFactor == null) {
	            //     return 100;
	            // } else {
	            return this.scalingFactor;
	            // }
	        },
	        set: function (value) {
	            if (value <= 0) {
	                throw new Error('ArgumentOutOfRangeException:The scaling factor cant be less of equal to zero, ScalingFactor');
	            }
	            this.scalingFactor = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringFormat.prototype, "firstLineIndent", {
	        /**
	         * Gets or sets the `indent` of the first line in the text.
	         * @private
	         */
	        get: function () {
	            if (typeof this.initialLineIndent === 'undefined' || this.initialLineIndent == null) {
	                return 0;
	            }
	            else {
	                return this.initialLineIndent;
	            }
	        },
	        set: function (value) {
	            this.initialLineIndent = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * `Clones` the object.
	     * @private
	     */
	    //IClonable implementation
	    PdfStringFormat.prototype.clone = function () {
	        var format = this;
	        return format;
	    };
	    return PdfStringFormat;
	}());

	/**
	 * StringTokenizer.ts class for EJ2-PDF
	 * Utility class for working with strings.
	 * @private
	 */
	var StringTokenizer = /** @class */ (function () {
	    // Constructors
	    /**
	     * Initializes a new instance of the `StringTokenizer` class.
	     * @private
	     */
	    function StringTokenizer(textValue) {
	        /**
	         * Current `position`.
	         * @private
	         */
	        this.currentPosition = 0;
	        if (textValue == null) {
	            throw new Error('ArgumentNullException:text');
	        }
	        this.text = textValue;
	    }
	    Object.defineProperty(StringTokenizer.prototype, "length", {
	        // Properties
	        /**
	         * Gets text `length`.
	         * @private
	         */
	        get: function () {
	            return this.text.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(StringTokenizer.prototype, "end", {
	        get: function () {
	            return (this.currentPosition === this.text.length);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(StringTokenizer.prototype, "position", {
	        /**
	         * Gets or sets the position.
	         * @private
	         */
	        get: function () {
	            return this.currentPosition;
	        },
	        set: function (value) {
	            this.currentPosition = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    StringTokenizer.getCharsCount = function (text, symbols) {
	        if (typeof symbols === 'string') {
	            if (text == null) {
	                throw new Error('ArgumentNullException:wholeText');
	            }
	            var numSymbols = 0;
	            var curIndex = 0;
	            for (;;) {
	                curIndex = text.indexOf(symbols, curIndex);
	                if (curIndex === -1) {
	                    break;
	                }
	                else {
	                    numSymbols++;
	                    curIndex++;
	                }
	            }
	            return numSymbols;
	        }
	        else {
	            if (text == null) {
	                throw new Error('ArgumentNullException:text');
	            }
	            if (symbols == null) {
	                throw new Error('ArgumentNullException:symbols');
	            }
	            var count = 0;
	            for (var i = 0, len = text.length; i < len; i++) {
	                var ch = text[i];
	                if (this.contains(symbols, ch)) {
	                    count++;
	                }
	            }
	            return count;
	        }
	    };
	    /**
	     * Reads line of the text.
	     * @private
	     */
	    StringTokenizer.prototype.readLine = function () {
	        var pos = this.currentPosition;
	        while (pos < this.length) {
	            var ch = this.text[pos];
	            switch (ch) {
	                case '\r':
	                case '\n': {
	                    var text = this.text.substr(this.currentPosition, pos - this.currentPosition);
	                    this.currentPosition = pos + 1;
	                    if (((ch === '\r') && (this.currentPosition < this.length)) && (this.text[this.currentPosition] === '\n')) {
	                        this.currentPosition++;
	                    }
	                    return text;
	                }
	            }
	            pos++;
	        }
	        // The remaining text.
	        if (pos > this.currentPosition) {
	            var text2 = this.text.substr(this.currentPosition, pos - this.currentPosition);
	            this.currentPosition = pos;
	            return text2;
	        }
	        return null;
	    };
	    /**
	     * Reads line of the text.
	     * @private
	     */
	    StringTokenizer.prototype.peekLine = function () {
	        var pos = this.currentPosition;
	        var line = this.readLine();
	        this.currentPosition = pos;
	        return line;
	    };
	    /**
	     * Reads a word from the text.
	     * @private
	     */
	    StringTokenizer.prototype.readWord = function () {
	        var pos = this.currentPosition;
	        while (pos < this.length) {
	            var ch = this.text[pos];
	            switch (ch) {
	                case '\r':
	                case '\n':
	                    var textValue = this.text.substr(this.currentPosition, pos - this.currentPosition);
	                    this.currentPosition = pos + 1;
	                    if (((ch === '\r') && (this.currentPosition < this.length)) && (this.text[this.currentPosition] === '\n')) {
	                        this.currentPosition++;
	                    }
	                    return textValue;
	                case ' ':
	                case '\t': {
	                    if (pos === this.currentPosition) {
	                        pos++;
	                    }
	                    var text = this.text.substr(this.currentPosition, pos - this.currentPosition);
	                    this.currentPosition = pos;
	                    return text;
	                }
	            }
	            pos++;
	        }
	        // The remaining text.
	        if (pos > this.currentPosition) {
	            var text2 = this.text.substr(this.currentPosition, pos - this.currentPosition);
	            this.currentPosition = pos;
	            return text2;
	        }
	        return null;
	    };
	    /**
	     * Peeks a word from the text.
	     * @private
	     */
	    StringTokenizer.prototype.peekWord = function () {
	        var pos = this.currentPosition;
	        var word = this.readWord();
	        this.currentPosition = pos;
	        return word;
	    };
	    StringTokenizer.prototype.read = function (count) {
	        if (typeof count === 'undefined') {
	            var ch = '0';
	            if (!this.end) {
	                ch = this.text[this.currentPosition];
	                this.currentPosition++;
	            }
	            return ch;
	        }
	        else {
	            var num = 0;
	            var builder = '';
	            while (!this.end && num < count) {
	                var ch = this.read();
	                builder = builder + ch;
	                num++;
	            }
	            return builder;
	        }
	    };
	    /**
	     * Peeks char form the data.
	     * @private
	     */
	    StringTokenizer.prototype.peek = function () {
	        var ch = '0';
	        if (!this.end) {
	            ch = this.text[this.currentPosition];
	        }
	        return ch;
	    };
	    /**
	     * Closes a reader.
	     * @private
	     */
	    StringTokenizer.prototype.close = function () {
	        this.text = null;
	    };
	    StringTokenizer.prototype.readToEnd = function () {
	        var text;
	        if (this.currentPosition === 0) {
	            text = this.text;
	        }
	        else {
	            text = this.text.substr(this.currentPosition, this.length - this.currentPosition);
	        }
	        this.currentPosition = this.length;
	        return text;
	    };
	    //Implementation
	    /**
	     * Checks whether array contains a symbol.
	     * @private
	     */
	    StringTokenizer.contains = function (array, symbol) {
	        var contains = false;
	        for (var i = 0; i < array.length; i++) {
	            if (array[i] === symbol) {
	                contains = true;
	                break;
	            }
	        }
	        return contains;
	    };
	    // Constants
	    /**
	     * `Whitespace` symbol.
	     * @private
	     */
	    StringTokenizer.whiteSpace = ' ';
	    /**
	     * `tab` symbol.
	     * @private
	     */
	    StringTokenizer.tab = '\t';
	    /**
	     * Array of `spaces`.
	     * @private
	     */
	    StringTokenizer.spaces = [StringTokenizer.whiteSpace, StringTokenizer.tab];
	    /**
	     * `Pattern` for WhiteSpace.
	     * @private
	     */
	    StringTokenizer.whiteSpacePattern = '^[ \t]+$';
	    return StringTokenizer;
	}());

	/**
	 * Class `lay outing the text`.
	 */
	var PdfStringLayouter = /** @class */ (function () {
	    // Constructors
	    /**
	     * Initializes a new instance of the `StringLayouter` class.
	     * @private
	     */
	    function PdfStringLayouter() {
	        /**
	         * Checks whether the x co-ordinate is need to set as client size or not.
	         * @hidden
	         * @private
	         */
	        this.isOverloadWithPosition = false;
	        //
	    }
	    PdfStringLayouter.prototype.layout = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
	        if (arg4 instanceof RectangleF) {
	            this.initialize(arg1, arg2, arg3, arg4, arg5);
	            this.isOverloadWithPosition = arg6;
	            this.clientSize = arg7;
	            var result = this.doLayout();
	            this.clear();
	            return result;
	        }
	        else {
	            this.initialize(arg1, arg2, arg3, arg4);
	            this.isOverloadWithPosition = arg5;
	            this.clientSize = arg6;
	            var result = this.doLayout();
	            this.clear();
	            return result;
	        }
	    };
	    PdfStringLayouter.prototype.initialize = function (text, font, format, rectSize, pageHeight) {
	        if (typeof pageHeight === 'number') {
	            if (text == null) {
	                throw new Error('ArgumentNullException:text');
	            }
	            if (font == null) {
	                throw new Error('ArgumentNullException:font');
	            }
	            this.text = text;
	            this.font = font;
	            this.format = format;
	            this.size = new SizeF(rectSize.width, rectSize.height);
	            this.rectangle = rectSize;
	            this.pageHeight = pageHeight;
	            this.reader = new StringTokenizer(text);
	        }
	        else {
	            this.initialize(text, font, format, new RectangleF(new PointF(0, 0), rectSize), 0);
	        }
	    };
	    /**
	     * `Clear` all resources.
	     * @private
	     */
	    PdfStringLayouter.prototype.clear = function () {
	        this.font = null;
	        this.format = null;
	        this.reader.close();
	        this.reader = null;
	        this.text = null;
	    };
	    /**
	     * `Layouts` the text.
	     * @private
	     */
	    PdfStringLayouter.prototype.doLayout = function () {
	        var result = new PdfStringLayoutResult();
	        var lineResult = new PdfStringLayoutResult();
	        var lines = [];
	        var line = this.reader.peekLine();
	        var lineIndent = this.getLineIndent(true);
	        while (line != null) {
	            lineResult = this.layoutLine(line, lineIndent);
	            if (lineResult !== null || typeof lineResult !== 'undefined') {
	                var numSymbolsInserted = 0;
	                /* tslint:disable */
	                var returnedValue = this.copyToResult(result, lineResult, lines, /*out*/ numSymbolsInserted);
	                /* tslint:enable */
	                var success = returnedValue.success;
	                numSymbolsInserted = returnedValue.numInserted;
	                if (!success) {
	                    this.reader.read(numSymbolsInserted);
	                    break;
	                }
	            }
	            // if (lineResult.textRemainder != null && lineResult.textRemainder.length > 0 ) {
	            //     break;
	            // }
	            this.reader.readLine();
	            line = this.reader.peekLine();
	            lineIndent = this.getLineIndent(false);
	        }
	        this.finalizeResult(result, lines);
	        return result;
	    };
	    /**
	     * Returns `line indent` for the line.
	     * @private
	     */
	    PdfStringLayouter.prototype.getLineIndent = function (firstLine) {
	        var lineIndent = 0;
	        if (this.format != null) {
	            lineIndent = (firstLine) ? this.format.firstLineIndent : this.format.paragraphIndent;
	            lineIndent = (this.size.width > 0) ? Math.min(this.size.width, lineIndent) : lineIndent;
	        }
	        return lineIndent;
	    };
	    /**
	     * Calculates `height` of the line.
	     * @private
	     */
	    PdfStringLayouter.prototype.getLineHeight = function () {
	        var height = this.font.height;
	        if (this.format != null && this.format.lineSpacing !== 0) {
	            height = this.format.lineSpacing + this.font.height;
	        }
	        return height;
	    };
	    /**
	     * Calculates `width` of the line.
	     * @private
	     */
	    PdfStringLayouter.prototype.getLineWidth = function (line) {
	        var width = this.font.getLineWidth(line, this.format);
	        return width;
	    };
	    // tslint:disable
	    /**
	     * `Layouts` line.
	     * @private
	     */
	    PdfStringLayouter.prototype.layoutLine = function (line, lineIndent) {
	        var lineResult = new PdfStringLayoutResult();
	        lineResult.layoutLineHeight = this.getLineHeight();
	        var lines = [];
	        var maxWidth = this.size.width;
	        var lineWidth = this.getLineWidth(line) + lineIndent;
	        var lineType = LineType.FirstParagraphLine;
	        var readWord = true;
	        // line is in bounds.
	        if (maxWidth <= 0 || Math.round(lineWidth) <= Math.round(maxWidth)) {
	            this.addToLineResult(lineResult, lines, line, lineWidth, LineType.NewLineBreak | lineType);
	        }
	        else {
	            var builder = '';
	            var curLine = '';
	            lineWidth = lineIndent;
	            var curIndent = lineIndent;
	            var reader = new StringTokenizer(line);
	            var word = reader.peekWord();
	            if (word.length !== reader.length) {
	                if (word === ' ') {
	                    curLine = curLine + word;
	                    builder = builder + word;
	                    reader.position += 1;
	                    word = reader.peekWord();
	                }
	            }
	            while (word != null) {
	                curLine = curLine + word;
	                var curLineWidth = this.getLineWidth(curLine.toString()) + curIndent /*)*/;
	                if (curLine.toString() === ' ') {
	                    curLine = '';
	                    curLineWidth = 0;
	                }
	                if (curLineWidth > maxWidth) {
	                    if (this.getWrapType() === PdfWordWrapType.None) {
	                        break;
	                    }
	                    if (curLine.length === word.length) {
	                        //  Character wrap is disabled or one symbol is greater than bounds.
	                        if (this.getWrapType() === PdfWordWrapType.WordOnly) {
	                            lineResult.textRemainder = line.substring(reader.position);
	                            break;
	                        }
	                        else if (curLine.length === 1) {
	                            builder = builder + word;
	                            break;
	                        }
	                        else {
	                            readWord = false;
	                            curLine = '';
	                            word = reader.peek().toString();
	                            continue;
	                        }
	                    }
	                    else {
	                        if (this.getLineWidth(word.toString()) > maxWidth) {
	                            this.format.wordWrap = PdfWordWrapType.Character;
	                        }
	                        else {
	                            if (typeof this.format !== 'undefined' && this.format !== null) {
	                                this.format.wordWrap = PdfWordWrapType.Word;
	                            }
	                        }
	                        if (this.getWrapType() !== PdfWordWrapType.Character || !readWord) {
	                            var ln = builder.toString();
	                            // if (ln.indexOf(' ') === -1) {
	                            //     isSingleWord = true;
	                            //     this.addToLineResult(lineResult, lines, curLine, lineWidth, LineType.LayoutBreak | lineType);
	                            // } else {
	                            //     this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);
	                            // }                          
	                            if (ln !== ' ') {
	                                this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);
	                            }
	                            if (this.isOverloadWithPosition) {
	                                maxWidth = this.clientSize.width;
	                            }
	                            curLine = '';
	                            builder = '';
	                            lineWidth = 0;
	                            curIndent = 0;
	                            curLineWidth = 0;
	                            lineType = LineType.None;
	                            // if (isSingleWord) {
	                            //     reader.readWord();
	                            //     readWord = false;
	                            // }
	                            word = (readWord) ? word : reader.peekWord();
	                            //isSingleWord = false;
	                            readWord = true;
	                        }
	                        else {
	                            readWord = false;
	                            curLine = '';
	                            curLine = curLine + builder.toString();
	                            word = reader.peek().toString();
	                        }
	                        continue;
	                    }
	                }
	                /*tslint:disable:max-func-body-length */
	                builder = builder + word;
	                lineWidth = curLineWidth;
	                if (readWord) {
	                    reader.readWord();
	                    word = reader.peekWord();
	                    //isSingleWord = false;
	                }
	                else {
	                    reader.read();
	                    word = reader.peek().toString();
	                }
	            }
	            if (builder.length > 0) {
	                var ln = builder.toString();
	                this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.NewLineBreak | LineType.LastParagraphLine);
	            }
	            reader.close();
	        }
	        lineResult.layoutLines = [];
	        for (var index = 0; index < lines.length; index++) {
	            lineResult.layoutLines.push(lines[index]);
	        }
	        lines = [];
	        return lineResult;
	    };
	    /**
	     * `Adds` line to line result.
	     * @private
	     */
	    PdfStringLayouter.prototype.addToLineResult = function (lineResult, lines, line, lineWidth, breakType) {
	        var info = new LineInfo();
	        info.text = line;
	        info.width = lineWidth;
	        info.lineType = breakType;
	        lines.push(info);
	        var size = lineResult.actualSize;
	        size.height += this.getLineHeight();
	        size.width = Math.max(size.width, lineWidth);
	        lineResult.size = size;
	    };
	    /**
	     * `Copies` layout result from line result to entire result. Checks whether we can proceed lay outing or not.
	     * @private
	     */
	    PdfStringLayouter.prototype.copyToResult = function (result, lineResult, lines, 
	    /*out*/ numInserted) {
	        var success = true;
	        var allowPartialLines = (this.format != null && !this.format.lineLimit);
	        var height = result.actualSize.height;
	        var maxHeight = this.size.height;
	        if ((this.pageHeight > 0) && (maxHeight + this.rectangle.y > this.pageHeight)) {
	            maxHeight = this.rectangle.y - this.pageHeight;
	            maxHeight = Math.max(maxHeight, -maxHeight);
	        }
	        numInserted = 0;
	        if (lineResult.lines != null) {
	            for (var i = 0, len = lineResult.lines.length; i < len; i++) {
	                var expHeight = height + lineResult.lineHeight;
	                if (expHeight <= maxHeight || maxHeight <= 0 || allowPartialLines) {
	                    var info = lineResult.lines[i];
	                    numInserted += info.text.length;
	                    info = this.trimLine(info, (lines.length === 0));
	                    lines.push(info);
	                    // Update width.
	                    var size = result.actualSize;
	                    size.width = Math.max(size.width, info.width);
	                    result.size = size;
	                    // The part of the line fits only and it's allowed to use partial lines.
	                    // if (expHeight >= maxHeight && maxHeight > 0 && allowPartialLines)
	                    // {
	                    //     let shouldClip : boolean = (this.format == null || !this.format.noClip);
	                    //     if (shouldClip)
	                    //     {
	                    //         let exceededHeight : number = expHeight - maxHeight;
	                    //         let fitHeight : number  = /*Utils.Round(*/ lineResult.lineHeight - exceededHeight /*)*/;
	                    //         height = /*Utils.Round(*/ height + fitHeight /*)*/;
	                    //     }
	                    //     else
	                    //     {
	                    //         height = expHeight;
	                    //     }
	                    //     success = false;
	                    //     break;
	                    // } else {
	                    height = expHeight;
	                    // }
	                }
	                else {
	                    success = false;
	                    break;
	                }
	            }
	        }
	        if (height != result.size.height) {
	            var size1 = result.actualSize;
	            size1.height = height;
	            result.size = size1;
	        }
	        return { success: success, numInserted: numInserted };
	    };
	    /**
	     * `Finalizes` final result.
	     * @private
	     */
	    PdfStringLayouter.prototype.finalizeResult = function (result, lines) {
	        result.layoutLines = [];
	        for (var index = 0; index < lines.length; index++) {
	            result.layoutLines.push(lines[index]);
	        }
	        result.layoutLineHeight = this.getLineHeight();
	        if (!this.reader.end) {
	            result.textRemainder = this.reader.readToEnd();
	        }
	        lines = [];
	    };
	    /**
	     * `Trims` whitespaces at the line.
	     * @private
	     */
	    PdfStringLayouter.prototype.trimLine = function (info, firstLine) {
	        var line = info.text;
	        var lineWidth = info.width;
	        // Trim start whitespaces if the line is not a start of the paragraph only.
	        ((info.lineType & LineType.FirstParagraphLine) === 0);
	        var start = (this.format == null || !this.format.rightToLeft);
	        line = (start) ? line.trim() : line.trim();
	        // Recalculate line width.
	        if (line.length !== info.text.length) {
	            lineWidth = this.getLineWidth(line);
	            if ((info.lineType & LineType.FirstParagraphLine) > 0) {
	                lineWidth += this.getLineIndent(firstLine);
	            }
	        }
	        info.text = line;
	        info.width = lineWidth;
	        return info;
	    };
	    /**
	     * Returns `wrap` type.
	     * @private
	     */
	    PdfStringLayouter.prototype.getWrapType = function () {
	        var wrapType = (this.format != null) ? this.format.wordWrap : PdfWordWrapType.Word;
	        return wrapType;
	    };
	    return PdfStringLayouter;
	}());
	//Internal declaration
	var PdfStringLayoutResult = /** @class */ (function () {
	    function PdfStringLayoutResult() {
	    }
	    Object.defineProperty(PdfStringLayoutResult.prototype, "remainder", {
	        // Properties
	        /**
	         * Gets the `text` which is not lay outed.
	         * @private
	         */
	        get: function () {
	            return this.textRemainder;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringLayoutResult.prototype, "actualSize", {
	        /**
	         * Gets the actual layout text `bounds`.
	         * @private
	         */
	        get: function () {
	            if (typeof this.size === 'undefined') {
	                this.size = new SizeF(0, 0);
	            }
	            return this.size;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringLayoutResult.prototype, "lines", {
	        /**
	         * Gets layout `lines` information.
	         * @private
	         */
	        get: function () {
	            return this.layoutLines;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringLayoutResult.prototype, "lineHeight", {
	        /**
	         * Gets the `height` of the line.
	         * @private
	         */
	        get: function () {
	            return this.layoutLineHeight;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringLayoutResult.prototype, "empty", {
	        /**
	         * Gets value that indicates whether any layout text [`empty`].
	         * @private
	         */
	        get: function () {
	            return (this.layoutLines == null || this.layoutLines.length === 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStringLayoutResult.prototype, "lineCount", {
	        /**
	         * Gets `number of` the layout lines.
	         * @private
	         */
	        get: function () {
	            var count = (!this.empty) ? this.layoutLines.length : 0;
	            return count;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PdfStringLayoutResult;
	}());
	var LineInfo = /** @class */ (function () {
	    function LineInfo() {
	    }
	    Object.defineProperty(LineInfo.prototype, "lineType", {
	        //Properties
	        /**
	         * Gets the `type` of the line text.
	         * @private
	         */
	        get: function () {
	            return this.type;
	        },
	        set: function (value) {
	            this.type = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineInfo.prototype, "text", {
	        /**
	         * Gets the line `text`.
	         * @private
	         */
	        get: function () {
	            return this.content;
	        },
	        set: function (value) {
	            this.content = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineInfo.prototype, "width", {
	        /**
	         * Gets `width` of the line text.
	         * @private
	         */
	        get: function () {
	            return this.lineWidth;
	        },
	        set: function (value) {
	            this.lineWidth = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return LineInfo;
	}());
	/**
	* Break type of the `line`.
	* @private
	*/
	var LineType;
	(function (LineType) {
	    /**
	     * Specifies the type of `None`.
	     * @private
	     */
	    LineType[LineType["None"] = 0] = "None";
	    /**
	     * Specifies the type of `NewLineBreak`.
	     * @private
	     */
	    LineType[LineType["NewLineBreak"] = 1] = "NewLineBreak";
	    /**
	     * Specifies the type of `LayoutBreak`.
	     * @private
	     */
	    LineType[LineType["LayoutBreak"] = 2] = "LayoutBreak";
	    /**
	     * Specifies the type of `FirstParagraphLine`.
	     * @private
	     */
	    LineType[LineType["FirstParagraphLine"] = 4] = "FirstParagraphLine";
	    /**
	     * Specifies the type of `LastParagraphLine`.
	     * @private
	     */
	    LineType[LineType["LastParagraphLine"] = 8] = "LastParagraphLine";
	})(LineType || (LineType = {}));

	/**
	 * PdfFont.ts class for EJ2-PDF
	 */
	/**
	 * Defines a particular format for text, including font face, size, and style attributes.
	 * @private
	 */
	var PdfFont = /** @class */ (function () {
	    function PdfFont(size, style) {
	        /**
	         * `Style` of the font.
	         * @private
	         */
	        this.fontStyle = PdfFontStyle.Regular;
	        if (typeof size === 'number' && typeof style === 'undefined') {
	            this.fontSize = size;
	        }
	        else {
	            this.fontSize = size;
	            this.setStyle(style);
	        }
	    }
	    Object.defineProperty(PdfFont.prototype, "name", {
	        //Properties
	        /**
	         * Gets the face name of this Font.
	         * @private
	         */
	        get: function () {
	            return this.metrics.name;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfFont.prototype, "size", {
	        /**
	         * Gets the size of this font.
	         * @private
	         */
	        get: function () {
	            return this.fontSize;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfFont.prototype, "height", {
	        /**
	         * Gets the height of the font in points.
	         * @private
	         */
	        get: function () {
	            return this.metrics.getHeight(null);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfFont.prototype, "style", {
	        /**
	         * Gets the style information for this font.
	         * @private
	         */
	        get: function () {
	            return this.fontStyle;
	        },
	        set: function (value) {
	            this.fontStyle = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfFont.prototype, "bold", {
	        /**
	         * Gets a value indicating whether this `PdfFont` is `bold`.
	         * @private
	         */
	        get: function () {
	            return ((this.style & PdfFontStyle.Bold) > 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfFont.prototype, "italic", {
	        /**
	         * Gets a value indicating whether this `PdfFont` has the `italic` style applied.
	         * @private
	         */
	        get: function () {
	            return ((this.style & PdfFontStyle.Italic) > 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfFont.prototype, "strikeout", {
	        /**
	         * Gets a value indicating whether this `PdfFont` is `strikeout`.
	         * @private
	         */
	        get: function () {
	            return ((this.style & PdfFontStyle.Strikeout) > 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfFont.prototype, "underline", {
	        /**
	         * Gets a value indicating whether this `PdfFont` is `underline`.
	         * @private
	         */
	        get: function () {
	            return ((this.style & PdfFontStyle.Underline) > 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfFont.prototype, "metrics", {
	        /**
	         * Gets or sets the `metrics` for this font.
	         * @private
	         */
	        get: function () {
	            return this.fontMetrics;
	        },
	        set: function (value) {
	            this.fontMetrics = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfFont.prototype, "element", {
	        // /**
	        //  * Gets and Sets the font `internals`.
	        //  * @private
	        //  */
	        // public get fontInternal() : IPdfPrimitive {
	        //     return this.pdfFontInternals;
	        // }
	        // public set fontInternal(value : IPdfPrimitive) {
	        //     this.pdfFontInternals = value;
	        // }
	        //IPdfWrapper Members
	        /**
	         * Gets the `element` representing the font.
	         * @private
	         */
	        get: function () {
	            return this.pdfFontInternals;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PdfFont.prototype.measureString = function (text, arg2, arg3, arg4, arg5) {
	        if (typeof text === 'string' && typeof arg2 === 'undefined') {
	            return this.measureString(text, null);
	        }
	        else if (typeof text === 'string' && (arg2 instanceof PdfStringFormat || arg2 == null) && typeof arg3 === 'undefined' && typeof arg4 === 'undefined') {
	            var temparg2 = arg2;
	            var charactersFitted = 0;
	            var linesFilled = 0;
	            return this.measureString(text, temparg2, charactersFitted, linesFilled);
	        }
	        else if (typeof text === 'string' && (arg2 instanceof PdfStringFormat || arg2 == null) && typeof arg3 === 'number' && typeof arg4 === 'number') {
	            var temparg2 = arg2;
	            return this.measureString(text, 0, temparg2, arg3, arg4);
	            // } else if (typeof text === 'string' && typeof arg2 === 'number' && typeof arg3 === 'undefined') {
	            //     return this.measureString(text, arg2, null);
	            // } else if (typeof text === 'string' && typeof arg2 === 'number' && (arg3 instanceof PdfStringFormat || arg3 == null) && typeof arg4 === 'undefined' && typeof arg5 === 'undefined') {
	            //     let temparg3 : PdfStringFormat = arg3 as PdfStringFormat;
	            //     let charactersFitted : number = 0;
	            //     let linesFilled : number = 0;
	            //     return this.measureString(text, arg2, temparg3, charactersFitted, linesFilled);
	        }
	        else if (typeof text === 'string' && typeof arg2 === 'number' && (arg3 instanceof PdfStringFormat || arg3 == null) && typeof arg4 === 'number' && typeof arg5 === 'number') {
	            var layoutArea = new SizeF(arg2, 0);
	            var temparg3 = arg3;
	            return this.measureString(text, layoutArea, temparg3, arg4, arg5);
	            // } else if (typeof text === 'string' && arg2 instanceof SizeF && typeof arg3 === 'undefined') {
	            //     return this.measureString(text, arg2, null);
	            // } else if (typeof text === 'string' && arg2 instanceof SizeF && (arg3 instanceof PdfStringFormat || arg3 == null) && typeof arg4 === 'undefined' && typeof arg5 === 'undefined') {
	            //     let temparg3 : PdfStringFormat = arg3 as PdfStringFormat;
	            //     let charactersFitted : number = 0;
	            //     let linesFilled : number = 0;
	            //     return this.measureString(text, arg2, temparg3, charactersFitted, linesFilled);
	        }
	        else {
	            if (text == null) {
	                throw Error("ArgumentNullException(\"text\")");
	            }
	            var temparg2 = arg2;
	            var temparg3 = arg3;
	            var layouter = new PdfStringLayouter();
	            var result = layouter.layout(text, this, temparg3, temparg2, false, new SizeF(0, 0));
	            // arg4 = (result.Remainder == null) ? text.length : text.length - result.Remainder.length;
	            arg4 = text.length;
	            arg5 = (result.empty) ? 0 : result.lines.length;
	            return result.actualSize;
	        }
	    };
	    /* tslint:enable */
	    //IPdfCache Members
	    /**
	     * `Checks` whether the object is similar to another object.
	     * @private
	     */
	    PdfFont.prototype.equalsTo = function (obj) {
	        var result = this.equalsToFont(obj);
	        return result;
	    };
	    /**
	     * Returns `internals` of the object.
	     * @private
	     */
	    PdfFont.prototype.getInternals = function () {
	        return this.pdfFontInternals;
	    };
	    /**
	     * Sets `internals` to the object.
	     * @private
	     */
	    PdfFont.prototype.setInternals = function (internals) {
	        if (internals == null) {
	            throw new Error('ArgumentNullException:internals');
	        }
	        this.pdfFontInternals = internals;
	    };
	    /**
	     * Sets the `style` of the font.
	     * @private
	     */
	    PdfFont.prototype.setStyle = function (style) {
	        this.fontStyle = style;
	    };
	    /**
	     * Applies `settings` to the default line width.
	     * @private
	     */
	    PdfFont.prototype.applyFormatSettings = function (line, format, width) {
	        // if (line == null) {
	        //     throw new Error(`ArgumentNullException:line`);
	        // }
	        var realWidth = width;
	        if (format != null && width > 0) {
	            // Space among characters is not default.
	            if (format.characterSpacing !== 0) {
	                realWidth += (line.length - 1) * format.characterSpacing;
	            }
	            // Space among words is not default.
	            if (format.wordSpacing !== 0) {
	                var symbols = StringTokenizer.spaces;
	                var whitespacesCount = StringTokenizer.getCharsCount(line, symbols);
	                realWidth += whitespacesCount * format.wordSpacing;
	            }
	        }
	        return realWidth;
	    };
	    //Constants
	    /**
	     * `Multiplier` of the symbol width.
	     * @default 0.001
	     * @private
	     */
	    PdfFont.charSizeMultiplier = 0.001;
	    /**
	     * `Synchronization` object.
	     * @private
	     */
	    PdfFont.syncObject = new Object();
	    return PdfFont;
	}());

	/**
	 * Used to `write a string` into output file.
	 * @private
	 */
	var PdfWriter = /** @class */ (function () {
	    /**
	     * Initialize an instance of `PdfWriter` class.
	     * @private
	     */
	    function PdfWriter(stream) {
	        this.streamWriter = stream;
	    }
	    Object.defineProperty(PdfWriter.prototype, "document", {
	        //properties
	        /**
	         * Gets and Sets the `document`.
	         * @private
	         */
	        get: function () {
	            return this.pdfDocument;
	        },
	        set: function (value) {
	            this.pdfDocument = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfWriter.prototype, "position", {
	        /**
	         * Gets the `position`.
	         * @private
	         */
	        get: function () {
	            return this.streamWriter.buffer.size;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfWriter.prototype, "length", {
	        /**
	         * Gets  the `length` of the stream'.
	         * @private
	         */
	        get: function () {
	            return this.streamWriter.buffer.size;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfWriter.prototype, "stream", {
	        /**
	         * Gets the `stream`.
	         * @private
	         */
	        get: function () {
	            var result = this.streamWriter;
	            return result;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //public Methods
	    /**
	     * `Writes the specified data`.
	     * @private
	     */
	    PdfWriter.prototype.write = function (overload) {
	        var tempOverload = overload;
	        this.streamWriter.write(tempOverload);
	    };
	    return PdfWriter;
	}());

	/**
	 * public Enum for `CompositeFontType`.
	 * @private
	 */
	var ObjectStatus;
	(function (ObjectStatus) {
	    /**
	     * Specifies the type of `None`.
	     * @private
	     */
	    ObjectStatus[ObjectStatus["None"] = 0] = "None";
	    /**
	     * Specifies the type of `Registered`.
	     * @private
	     */
	    ObjectStatus[ObjectStatus["Registered"] = 1] = "Registered";
	})(ObjectStatus || (ObjectStatus = {}));

	/**
	 * PdfMainObjectCollection.ts class for EJ2-PDF
	 */
	/**
	 * The collection of all `objects` within a PDF document.
	 * @private
	 */
	var PdfMainObjectCollection = /** @class */ (function () {
	    function PdfMainObjectCollection() {
	        //Fields
	        /**
	         * The collection of the `indirect objects`.
	         * @default []
	         * @private
	         */
	        this.objectCollections = [];
	        /**
	         * The collection of the `Indirect objects`.
	         * @default new Dictionary<number, ObjectInfo>()
	         * @private
	         */
	        this.mainObjectCollection = new Dictionary();
	        /**
	         * The collection of `primitive objects`.
	         * @private
	         */
	        this.primitiveObjectCollection = new Dictionary();
	    }
	    Object.defineProperty(PdfMainObjectCollection.prototype, "count", {
	        //Properties
	        /**
	         * Gets the `count`.
	         * @private
	         */
	        get: function () {
	            return this.objectCollections.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Gets the value of `ObjectInfo` from object collection.
	     * @private
	     */
	    PdfMainObjectCollection.prototype.items = function (index) {
	        return this.objectCollections[index];
	    };
	    Object.defineProperty(PdfMainObjectCollection.prototype, "outIsNew", {
	        //Methods
	        /**
	         * Specifies the value of `IsNew`.
	         * @private
	         */
	        get: function () {
	            return this.isNew;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * `Adds` the specified element.
	     * @private
	     */
	    PdfMainObjectCollection.prototype.add = function (element) {
	        var objInfo = new ObjectInfo(element);
	        this.objectCollections.push(objInfo);
	        if (!this.primitiveObjectCollection.containsKey(element)) {
	            this.primitiveObjectCollection.setValue(element, this.objectCollections.length - 1);
	        }
	        element.position = this.index = this.objectCollections.length - 1;
	        element.status = ObjectStatus.Registered;
	    };
	    /**
	     * `Looks` through the collection for the object specified.
	     * @private
	     */
	    PdfMainObjectCollection.prototype.lookFor = function (obj) {
	        var index = -1;
	        if (obj.position !== -1) {
	            return obj.position;
	        }
	        if (this.primitiveObjectCollection.containsKey(obj) && this.count === this.primitiveObjectCollection.size()) {
	            index = this.primitiveObjectCollection.getValue(obj);
	        }
	        else {
	            for (var i = this.count - 1; i >= 0; i--) {
	                var oi = this.objectCollections[i];
	                if (oi.object === obj) {
	                    index = i;
	                    break;
	                }
	            }
	        }
	        return index;
	    };
	    /**
	     * Gets the `reference of the object`.
	     * @private
	     */
	    PdfMainObjectCollection.prototype.getReference = function (index, isNew) {
	        this.index = this.lookFor(index);
	        var reference;
	        this.isNew = false;
	        var oi = this.objectCollections[this.index];
	        reference = oi.reference;
	        var obj = { reference: reference, wasNew: isNew };
	        return obj;
	    };
	    /**
	     * Tries to set the `reference to the object`.
	     * @private
	     */
	    PdfMainObjectCollection.prototype.trySetReference = function (obj, reference, found) {
	        var result = true;
	        this.index = this.lookFor(obj);
	        var oi = this.objectCollections[this.index];
	        oi.setReference(reference);
	        return result;
	    };
	    PdfMainObjectCollection.prototype.destroy = function () {
	        for (var _i = 0, _a = this.objectCollections; _i < _a.length; _i++) {
	            var obj = _a[_i];
	            if (obj !== undefined) {
	                obj.pdfObject.position = -1;
	                obj.pdfObject.isSaving = undefined;
	                obj.pdfObject.objectCollectionIndex = undefined;
	                obj.pdfObject.position = undefined;
	            }
	        }
	        this.objectCollections = [];
	        this.mainObjectCollection = new Dictionary();
	        this.primitiveObjectCollection = new Dictionary();
	    };
	    return PdfMainObjectCollection;
	}());
	var ObjectInfo = /** @class */ (function () {
	    function ObjectInfo(obj, reference) {
	        this.pdfObject = obj;
	        this.pdfReference = reference;
	    }
	    Object.defineProperty(ObjectInfo.prototype, "object", {
	        //Properties
	        /**
	         * Gets the `object`.
	         * @private
	         */
	        get: function () {
	            return this.pdfObject;
	        },
	        set: function (value) {
	            this.pdfObject = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ObjectInfo.prototype, "reference", {
	        /**
	         * Gets the `reference`.
	         * @private
	         */
	        get: function () {
	            return this.pdfReference;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Sets the `reference`.
	     * @private
	     */
	    ObjectInfo.prototype.setReference = function (reference) {
	        this.pdfReference = reference;
	    };
	    return ObjectInfo;
	}());

	/**
	 * `PdfDocumentBase` class represent common properties of PdfDocument classes.
	 * @private
	 */
	var PdfDocumentBase = /** @class */ (function () {
	    function PdfDocumentBase(document) {
	        /**
	         * If the stream is copied,  then it specifies true.
	         * @private
	         */
	        this.isStreamCopied = false;
	        if (document instanceof PdfDocument) {
	            this.document = document;
	        }
	    }
	    Object.defineProperty(PdfDocumentBase.prototype, "pdfObjects", {
	        //Prpperties
	        /**
	         * Gets the `PDF objects` collection, which stores all objects and references to it..
	         * @private
	         */
	        get: function () {
	            return this.objects;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentBase.prototype, "crossTable", {
	        /**
	         * Gets the `cross-reference` table.
	         * @private
	         */
	        get: function () {
	            return this.pdfCrossTable;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentBase.prototype, "currentSavingObj", {
	        /**
	         * Gets or sets the current saving `object number`.
	         * @private
	         */
	        get: function () {
	            return this.currentSavingObject;
	        },
	        set: function (value) {
	            this.currentSavingObject = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentBase.prototype, "catalog", {
	        /**
	         * Gets the PDF document `catalog`.
	         * @private
	         */
	        get: function () {
	            return this.pdfCatalog;
	        },
	        set: function (value) {
	            this.pdfCatalog = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentBase.prototype, "viewerPreferences", {
	        /**
	         * Gets viewer preferences for presenting the PDF document in a viewer.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets viewer preferences
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            return this.pdfCatalog.viewerPreferences;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //Public methods
	    /**
	     * Sets the `main object collection`.
	     * @private
	     */
	    PdfDocumentBase.prototype.setMainObjectCollection = function (mainObjectCollection) {
	        this.objects = mainObjectCollection;
	    };
	    /**
	     * Sets the `cross table`.
	     * @private
	     */
	    PdfDocumentBase.prototype.setCrossTable = function (cTable) {
	        this.pdfCrossTable = cTable;
	    };
	    /**
	     * Sets the `catalog`.
	     * @private
	     */
	    PdfDocumentBase.prototype.setCatalog = function (catalog) {
	        this.pdfCatalog = catalog;
	    };
	    PdfDocumentBase.prototype.save = function (filename) {
	        var _this = this;
	        var encoding = new Encoding(true);
	        var SW = new StreamWriter(encoding);
	        if (typeof filename === 'undefined') {
	            var encoding_1 = new Encoding(true);
	            var SW_1 = new StreamWriter(encoding_1);
	            return new Promise(function (resolve, reject) {
	                /* tslint:disable-next-line:no-any */
	                var obj = {};
	                obj.blobData = new Blob([_this.document.docSave(SW_1, true)], { type: 'application/pdf' });
	                resolve(obj);
	            });
	        }
	        else {
	            this.document.docSave(SW, filename, true);
	        }
	    };
	    /**
	     * `Clone` of parent object - PdfDocument.
	     * @private
	     */
	    PdfDocumentBase.prototype.clone = function () {
	        return this.document;
	    };
	    return PdfDocumentBase;
	}());

	/**
	 * public Enum for `ObjectType`.
	 * @private
	 */
	var ObjectType;
	(function (ObjectType) {
	    /**
	     * Specifies the type of `Free`.
	     * @private
	     */
	    ObjectType[ObjectType["Free"] = 0] = "Free";
	    /**
	     * Specifies the type of `Normal`.
	     * @private
	     */
	    ObjectType[ObjectType["Normal"] = 1] = "Normal";
	    /**
	     * Specifies the type of `Packed`.
	     * @private
	     */
	    ObjectType[ObjectType["Packed"] = 2] = "Packed";
	})(ObjectType || (ObjectType = {}));

	/**
	 * `PdfBoolean` class is used to perform boolean related primitive operations.
	 * @private
	 */
	var PdfBoolean = /** @class */ (function () {
	    //constructor
	    /**
	     * Initializes a new instance of the `PdfBoolean` class.
	     * @private
	     */
	    function PdfBoolean(value) {
	        /**
	         * Internal variable to store the `position`.
	         * @default -1
	         * @private
	         */
	        this.currentPosition = -1;
	        this.value = value;
	    }
	    Object.defineProperty(PdfBoolean.prototype, "status", {
	        //Properties
	        /**
	         * Gets or sets the `Status` of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.objectStatus;
	        },
	        set: function (value) {
	            this.objectStatus = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfBoolean.prototype, "isSaving", {
	        /**
	         * Gets or sets a value indicating whether this document `is saving` or not.
	         * @private
	         */
	        get: function () {
	            return this.saving;
	        },
	        set: function (value) {
	            this.saving = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfBoolean.prototype, "objectCollectionIndex", {
	        /**
	         * Gets or sets the `index` value of the specified object.
	         * @private
	         */
	        get: function () {
	            return this.index;
	        },
	        set: function (value) {
	            this.index = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfBoolean.prototype, "position", {
	        /**
	         * Gets or sets the `position` of the object.
	         * @private
	         */
	        get: function () {
	            return this.currentPosition;
	        },
	        set: function (value) {
	            this.currentPosition = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfBoolean.prototype, "clonedObject", {
	        /**
	         * Returns `cloned object`.
	         * @private
	         */
	        get: function () {
	            var rValue = null;
	            return rValue;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * `Saves` the object using the specified writer.
	     * @private
	     */
	    PdfBoolean.prototype.save = function (writer) {
	        writer.write(this.boolToStr(this.value));
	    };
	    /**
	     * Creates a `copy of PdfBoolean`.
	     * @private
	     */
	    PdfBoolean.prototype.clone = function (crossTable) {
	        var newNumber = new PdfBoolean(this.value);
	        return newNumber;
	    };
	    // Implementation
	    /**
	     * Converts `boolean to string` - 0/1 'true'/'false'.
	     * @private
	     */
	    PdfBoolean.prototype.boolToStr = function (value) {
	        return value ? 'true' : 'false';
	    };
	    return PdfBoolean;
	}());

	/**
	 * Defines the way the document is to be presented on the screen or in print.
	 * ```typescript
	 * // Create a new PDF document
	 * let document : PdfDocument = new PdfDocument();
	 * // Gets viewer preferences
	 * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	 * // Destroy the document
	 * document.destroy();
	 * ```
	 */
	var PdfViewerPreferences = /** @class */ (function () {
	    /**
	     * Initialize a new instance of `PdfViewerPreferences` class.
	     *
	     * @private
	     * ```
	    */
	    function PdfViewerPreferences(catalog) {
	        this._dictionaryProperties = new DictionaryProperties();
	        this._centerWindow = false;
	        this._fitWindow = false;
	        this._displayTitle = false;
	        this._splitWindow = false;
	        this._hideMenuBar = false;
	        this._hideToolBar = false;
	        this._hideWindowUI = false;
	        this._pageMode = PdfPageMode.UseNone;
	        this._pageLayout = PdfPageLayout.SinglePage;
	        this._dictionary = new PdfDictionary();
	        this._duplex = DuplexMode.None;
	        this._catalog = catalog;
	    }
	    Object.defineProperty(PdfViewerPreferences.prototype, "centerWindow", {
	        /**
	         * A flag specifying whether to position the document’s window in the center of the screen.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Gets the center window
	         * let centerWindow : boolean = viewerPreferences.centerWindow;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            return this._centerWindow;
	        },
	        /**
	         * A flag specifying whether to position the document’s window in the center of the screen.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Sets the center window
	         * viewerPreferences.centerWindow = true;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        set: function (value) {
	            this._centerWindow = value;
	            this._dictionary.items.setValue(this._dictionaryProperties.centerWindow, new PdfBoolean(this._centerWindow));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfViewerPreferences.prototype, "displayTitle", {
	        /**
	         * A flag specifying whether the window’s title bar should display the document title taken
	         * from the Title entry of the document information dictionary. If false, the title bar
	         * should instead display the name of the PDF file containing the document.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Gets the display title
	         * let displayTitle : boolean = viewerPreferences.displayTitle;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            return this._displayTitle;
	        },
	        /**
	         * A flag specifying whether the window’s title bar should display the document title taken
	         * from the Title entry of the document information dictionary. If false, the title bar
	         * should instead display the name of the PDF file containing the document.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Sets the display title
	         * viewerPreferences.displayTitle = true;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        set: function (value) {
	            this._displayTitle = value;
	            this._dictionary.items.setValue(this._dictionaryProperties.displayTitle, new PdfBoolean(this._displayTitle));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfViewerPreferences.prototype, "fitWindow", {
	        /**
	         * A flag specifying whether to resize the document’s window to fit the size of the first
	         * displayed page.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Gets the fit window
	         * let fitWindow : boolean = viewerPreferences.fitWindow;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            return this._fitWindow;
	        },
	        /**
	         * A flag specifying whether to resize the document’s window to fit the size of the first
	         * displayed page.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Sets the fit window
	         * viewerPreferences.fitWindow = true;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        set: function (value) {
	            this._fitWindow = value;
	            this._dictionary.items.setValue(this._dictionaryProperties.fitWindow, new PdfBoolean(this._fitWindow));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfViewerPreferences.prototype, "hideMenuBar", {
	        /**
	         * A flag specifying whether to hide the viewer application’s menu bar when the
	         * document is active.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Gets the hide menu bar
	         * let hideMenuBar: boolean = viewerPreferences.hideMenuBar;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            return this._hideMenuBar;
	        },
	        /**
	         * A flag specifying whether to hide the viewer application’s menu bar when the
	         * document is active.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Sets the hide menu bar
	         * viewerPreferences.hideMenuBar = true;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        set: function (value) {
	            this._hideMenuBar = value;
	            this._dictionary.items.setValue(this._dictionaryProperties.hideMenuBar, new PdfBoolean(this._hideMenuBar));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfViewerPreferences.prototype, "hideToolBar", {
	        /**
	         * A flag specifying whether to hide the viewer application’s tool bar when the
	         * document is active.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Gets the hide tool bar
	         * let hideToolBar: boolean = viewerPreferences.hideToolBar;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            return this._hideToolBar;
	        },
	        /**
	         * A flag specifying whether to hide the viewer application’s tool bar when the
	         * document is active.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Sets the hide tool bar
	         * viewerPreferences.hideToolbar = true;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        set: function (value) {
	            this._hideToolBar = value;
	            this._dictionary.items.setValue(this._dictionaryProperties.hideToolBar, new PdfBoolean(this._hideToolBar));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfViewerPreferences.prototype, "hideWindowUI", {
	        /**
	         * A flag specifying whether to hide user interface elements in the document’s window
	         * (such as scroll bars and navigation controls), leaving only the document’s contents displayed.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Gets the hide window UI
	         * let hideWindowUI: boolean = viewerPreferences.hideWindowUI;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            return this._hideWindowUI;
	        },
	        /**
	         * A flag specifying whether to hide user interface elements in the document’s window
	         * (such as scroll bars and navigation controls), leaving only the document’s contents displayed.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Sets the hide window UI
	         * viewerPreferences.hideWindowUI = true;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        set: function (value) {
	            this._hideWindowUI = value;
	            this._dictionary.items.setValue(this._dictionaryProperties.hideWindowUI, new PdfBoolean(this._hideWindowUI));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfViewerPreferences.prototype, "pageMode", {
	        /**
	         * A name object specifying how the document should be displayed when opened.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Gets the page mode
	         * let pageMode: PdfPageMode = viewerPreferences.pageMode;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            return this._pageMode;
	        },
	        /**
	         * A name object specifying how the document should be displayed when opened.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Sets the page mode
	         * viewerPreferences.pageMode = PdfPageMode.UseOutlines;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        set: function (value) {
	            this._pageMode = value;
	            this._catalog.items.setValue(this._dictionaryProperties.pageMode, new PdfName(this._mapPageMode(this._pageMode)));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfViewerPreferences.prototype, "duplex", {
	        /**
	         * Gets print duplex mode handling option to use when printing the file from the print dialog.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Gets the duplex
	         * let duplex : DuplexMode = viewerPreferences.duplex;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            return this._duplex;
	        },
	        /**
	         * Sets print duplex mode handling option to use when printing the file from the print dialog.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Sets the duplex
	         * viewerPreferences.duplex = DuplexMode.DuplexFlipLongEdge;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        set: function (value) {
	            this._duplex = value;
	            this._catalog.items.setValue(this._dictionaryProperties.duplex, new PdfName(this._mapDuplexMode(this._duplex)));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfViewerPreferences.prototype, "pageLayout", {
	        /**
	         * A name object specifying the page layout to be used when the document is opened.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Gets the page layout
	         * let pageLayout : PdfPageLayout = viewerPreferences.pageLayout;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            return this._pageLayout;
	        },
	        /**
	         * A name object specifying the page layout to be used when the document is opened.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Sets the page layout
	         * viewerPreferences.pageLayout = PdfPageLayout.TwoColumnLeft;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        set: function (value) {
	            this._pageLayout = value;
	            this._catalog.items.setValue(this._dictionaryProperties.pageLayout, new PdfName(this._mapPageLayout(this._pageLayout)));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfViewerPreferences.prototype, "pageScaling", {
	        /**
	         * Gets the page scaling option to be selected
	         * when a print dialog is displayed for this document.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Gets the page scaling
	         * let pageScaling : PageScalingMode = viewerPreferences.pageScaling;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            return this._pageScaling;
	        },
	        /**
	         * Sets the page scaling option to be selected
	         * when a print dialog is displayed for this document.
	         * ```typescript
	         * // Create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // Gets the viewer preferences of the document
	         * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	         * // Sets the page scaling
	         * viewerPreferences.pageScaling = PageScalingMode.None;
	         * // Destroy the document
	         * document.destroy();
	         * ```
	         */
	        set: function (value) {
	            this._pageScaling = value;
	            if (this._pageScaling === PageScalingMode.AppDefault && this._dictionary.items.containsKey(this._dictionaryProperties.printScaling)) {
	                this._dictionary.items.remove(this._dictionaryProperties.printScaling);
	            }
	            else if (this._pageScaling === PageScalingMode.None) {
	                this._dictionary.items.setValue(this._dictionaryProperties.printScaling, new PdfName('None'));
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfViewerPreferences.prototype, "element", {
	        /**
	         * Primivie element
	         *
	         * @private
	         */
	        get: function () {
	            return this._dictionary;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PdfViewerPreferences.prototype._mapDuplexMode = function (mode) {
	        switch (mode) {
	            case DuplexMode.Simplex:
	                return 'Simplex';
	            case DuplexMode.DuplexFlipShortEdge:
	                return 'DuplexFlipShortEdge';
	            case DuplexMode.DuplexFlipLongEdge:
	                return 'DuplexFlipLongEdge';
	            case DuplexMode.None:
	                return 'None';
	        }
	    };
	    PdfViewerPreferences.prototype._mapPageMode = function (mode) {
	        switch (mode) {
	            case PdfPageMode.UseNone:
	                return 'UseNone';
	            case PdfPageMode.UseOutlines:
	                return 'UseOutlines';
	            case PdfPageMode.UseThumbs:
	                return 'UseThumbs';
	            case PdfPageMode.FullScreen:
	                return 'FullScreen';
	            case PdfPageMode.UseOC:
	                return 'UseOC';
	            case PdfPageMode.UseAttachments:
	                return 'UseAttachments';
	        }
	    };
	    PdfViewerPreferences.prototype._mapPageLayout = function (layout) {
	        switch (layout) {
	            case PdfPageLayout.SinglePage:
	                return 'SinglePage';
	            case PdfPageLayout.OneColumn:
	                return 'OneColumn';
	            case PdfPageLayout.TwoColumnLeft:
	                return 'TwoColumnLeft';
	            case PdfPageLayout.TwoColumnRight:
	                return 'TwoColumnRight';
	            case PdfPageLayout.TwoPageLeft:
	                return 'TwoPageLeft';
	            case PdfPageLayout.TwoPageRight:
	                return 'TwoPageRight';
	        }
	    };
	    return PdfViewerPreferences;
	}());
	/**
	 * Represents mode of document displaying.
	 * ```typescript
	 * // Create a new PDF document
	 * let document : PdfDocument = new PdfDocument();
	 * // Gets the viewer preferences of the document
	 * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	 * // Sets the page mode
	 * viewerPreferences.pageMode = PdfPageMode.UseOutlines;
	 * // Destroy the document
	 * document.destroy();
	 * ```
	 */
	var PdfPageMode;
	(function (PdfPageMode) {
	    /**
	     * Default value. Neither document outline nor thumbnail images visible.
	     */
	    PdfPageMode[PdfPageMode["UseNone"] = 0] = "UseNone";
	    /**
	     * Document outline visible.
	     */
	    PdfPageMode[PdfPageMode["UseOutlines"] = 1] = "UseOutlines";
	    /**
	     * Thumbnail images visible.
	     */
	    PdfPageMode[PdfPageMode["UseThumbs"] = 2] = "UseThumbs";
	    /**
	     * Full-screen mode, with no menu bar, window controls, or any other window visible.
	     */
	    PdfPageMode[PdfPageMode["FullScreen"] = 3] = "FullScreen";
	    /**
	     * Optional content group panel visible.
	     */
	    PdfPageMode[PdfPageMode["UseOC"] = 4] = "UseOC";
	    /**
	     * Attachments are visible.
	     */
	    PdfPageMode[PdfPageMode["UseAttachments"] = 5] = "UseAttachments";
	})(PdfPageMode || (PdfPageMode = {}));
	/**
	 * A name object specifying the page layout to be used when the document is opened.
	 * ```typescript
	 * // Create a new PDF document
	 * let document : PdfDocument = new PdfDocument();
	 * // Gets the viewer preferences of the document
	 * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	 * // Sets the page layout
	 * viewerPreferences.pageLayout = PdfPageLayout.TwoColumnLeft;
	 * // Destroy the document
	 * document.destroy();
	 * ```
	 */
	var PdfPageLayout;
	(function (PdfPageLayout) {
	    /**
	     * Default Value. Display one page at a time.
	     */
	    PdfPageLayout[PdfPageLayout["SinglePage"] = 0] = "SinglePage";
	    /**
	     * Display the pages in one column.
	     */
	    PdfPageLayout[PdfPageLayout["OneColumn"] = 1] = "OneColumn";
	    /**
	     * Display the pages in two columns, with odd numbered
	     * pages on the left.
	     */
	    PdfPageLayout[PdfPageLayout["TwoColumnLeft"] = 2] = "TwoColumnLeft";
	    /**
	     * Display the pages in two columns, with odd numbered
	     * pages on the right.
	     */
	    PdfPageLayout[PdfPageLayout["TwoColumnRight"] = 3] = "TwoColumnRight";
	    /**
	     * Display the pages two at a time, with odd-numbered pages on the left.
	     */
	    PdfPageLayout[PdfPageLayout["TwoPageLeft"] = 4] = "TwoPageLeft";
	    /**
	     * Display the pages two at a time, with odd-numbered pages on the right.
	     */
	    PdfPageLayout[PdfPageLayout["TwoPageRight"] = 5] = "TwoPageRight";
	})(PdfPageLayout || (PdfPageLayout = {}));
	/**
	 * The paper handling option to use when printing the file from the print dialog.
	 * ```typescript
	 * // Create a new PDF document
	 * let document : PdfDocument = new PdfDocument();
	 * // Gets the viewer preferences of the document
	 * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	 * // Sets the duplex
	 * viewerPreferences.duplex = DuplexMode.DuplexFlipLongEdge;
	 * // Destroy the document
	 * document.destroy();
	 * ```
	 */
	var DuplexMode;
	(function (DuplexMode) {
	    /**
	     * Print single-sided.
	     */
	    DuplexMode[DuplexMode["Simplex"] = 0] = "Simplex";
	    /**
	     * Duplex and flip on the short edge of the sheet.
	     */
	    DuplexMode[DuplexMode["DuplexFlipShortEdge"] = 1] = "DuplexFlipShortEdge";
	    /**
	     * Duplex and flip on the long edge of the sheet.
	     */
	    DuplexMode[DuplexMode["DuplexFlipLongEdge"] = 2] = "DuplexFlipLongEdge";
	    /**
	     * Default value.
	     */
	    DuplexMode[DuplexMode["None"] = 3] = "None";
	})(DuplexMode || (DuplexMode = {}));
	/**
	 * Specifies the different page scaling option that shall be selected
	 * when a print dialog is displayed for this document.
	 * ```typescript
	 * // Create a new PDF document
	 * let document : PdfDocument = new PdfDocument();
	 * // Gets the viewer preferences of the document
	 * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
	 * // Sets the page scaling
	 * viewerPreferences.pageScaling = PageScalingMode.None;
	 * // Destroy the document
	 * document.destroy();
	 * ```
	 */
	var PageScalingMode;
	(function (PageScalingMode) {
	    /**
	     * Indicates the conforming reader’s default print scaling.
	     */
	    PageScalingMode[PageScalingMode["AppDefault"] = 0] = "AppDefault";
	    /**
	     * Indicates no page scaling.
	     */
	    PageScalingMode[PageScalingMode["None"] = 1] = "None";
	})(PageScalingMode || (PageScalingMode = {}));

	var __extends$p = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `PdfCatalog` class represents internal catalog of the Pdf document.
	 * @private
	 */
	var PdfCatalog = /** @class */ (function (_super) {
	    __extends$p(PdfCatalog, _super);
	    //constructor
	    /**
	     * Initializes a new instance of the `PdfCatalog` class.
	     * @private
	     */
	    function PdfCatalog() {
	        var _this = _super.call(this) || this;
	        //fields
	        /**
	         * Internal variable to store collection of `sections`.
	         * @default null
	         * @private
	         */
	        _this.sections = null;
	        /**
	         * Internal variable for accessing fields from `DictionryProperties` class.
	         * @private
	         */
	        _this.tempDictionaryProperties = new DictionaryProperties();
	        _this.items.setValue(new DictionaryProperties().type, new PdfName('Catalog'));
	        return _this;
	    }
	    Object.defineProperty(PdfCatalog.prototype, "pages", {
	        //Properties
	        /**
	         * Gets or sets the sections, which contain `pages`.
	         * @private
	         */
	        get: function () {
	            return this.sections;
	        },
	        set: function (value) {
	            value.element;
	            // if (this.sections !== value) {
	            //     this.sections = value;
	            //     this.Items.setValue(this.tempDictionaryProperties.pages, new PdfReferenceHolder(value));
	            // }
	            this.sections = value;
	            this.items.setValue(this.tempDictionaryProperties.pages, new PdfReferenceHolder(value));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfCatalog.prototype, "viewerPreferences", {
	        /**
	         * Gets the viewer preferences of the PDF document.
	         * @private
	         */
	        get: function () {
	            if (this._viewerPreferences === null || typeof this._viewerPreferences === 'undefined') {
	                this._viewerPreferences = new PdfViewerPreferences(this);
	                this.items.setValue(this.tempDictionaryProperties.viewerPreferences, new PdfReferenceHolder(this._viewerPreferences.element));
	            }
	            return this._viewerPreferences;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PdfCatalog;
	}(PdfDictionary));

	/**
	 * `PdfCrossTable` is responsible for intermediate level parsing
	 * and savingof a PDF document.
	 * @private
	 */
	var PdfCrossTable = /** @class */ (function () {
	    function PdfCrossTable() {
	        /**
	         * The modified `objects` that should be saved.
	         * @private
	         */
	        this.objects = new Dictionary();
	        /**
	         * Holds `maximal generation number` or offset to object.
	         * @default 0
	         * @private
	         */
	        this.maxGenNumIndex = 0;
	        /**
	         * The `number of the objects`.
	         * @default 0
	         * @private
	         */
	        this.objectCount = 0;
	        /**
	         * Internal variable for accessing fields from `DictionryProperties` class.
	         * @default new PdfDictionaryProperties()
	         * @private
	         */
	        this.dictionaryProperties = new DictionaryProperties();
	    }
	    Object.defineProperty(PdfCrossTable.prototype, "isMerging", {
	        //Properties
	        /**
	         * Gets or sets if the document `is merged`.
	         * @private
	         */
	        get: function () {
	            return this.merging;
	        },
	        set: function (value) {
	            this.merging = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfCrossTable.prototype, "trailer", {
	        /**
	         * Gets the `trailer`.
	         * @private
	         */
	        get: function () {
	            if (this.internalTrailer == null) {
	                this.internalTrailer = new PdfStream();
	            }
	            return this.internalTrailer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfCrossTable.prototype, "document", {
	        /**
	         * Gets or sets the main `PdfDocument` class instance.
	         * @private
	         */
	        get: function () {
	            return this.pdfDocument;
	        },
	        set: function (value) {
	            this.pdfDocument = value;
	            this.items = this.pdfDocument.pdfObjects;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfCrossTable.prototype, "pdfObjects", {
	        /**
	         * Gets the catched `PDF object` main collection.
	         * @private
	         */
	        get: function () {
	            return this.items;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfCrossTable.prototype, "objectCollection", {
	        /**
	         * Gets the `object collection`.
	         * @private
	         */
	        get: function () {
	            return this.pdfDocument.pdfObjects;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfCrossTable.prototype, "count", {
	        /**
	         * Gets or sets the `number of the objects` within the document.
	         * @private
	         */
	        get: function () {
	            return this.objectCount;
	        },
	        set: function (value) {
	            this.objectCount = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfCrossTable.prototype, "nextObjNumber", {
	        /**
	         * Returns `next available object number`.
	         * @private
	         */
	        get: function () {
	            this.count = this.count + 1;
	            return this.count;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PdfCrossTable.prototype.save = function (writer, filename) {
	        this.saveHead(writer);
	        this.mappedReferences = null;
	        this.objects.clear();
	        this.markTrailerReferences();
	        this.saveObjects(writer);
	        var saveCount = this.count;
	        var xrefPos = writer.position;
	        this.registerObject(0, new PdfReference(0, -1), true);
	        var prevXRef = 0;
	        writer.write(Operators.xref);
	        writer.write(Operators.newLine);
	        this.saveSections(writer);
	        this.saveTrailer(writer, this.count, prevXRef);
	        this.saveTheEndess(writer, xrefPos);
	        this.count = saveCount;
	        for (var i = 0; i < this.objectCollection.count; ++i) {
	            var oi = this.objectCollection.items(i);
	            oi.object.isSaving = false;
	        }
	        if (typeof filename === 'undefined') {
	            return writer.stream.buffer;
	        }
	        else {
	            writer.stream.save(filename);
	        }
	    };
	    /**
	     * `Saves the endess` of the file.
	     * @private
	     */
	    PdfCrossTable.prototype.saveTheEndess = function (writer, xrefPos) {
	        writer.write(Operators.newLine + Operators.startxref + Operators.newLine);
	        writer.write(xrefPos.toString() + Operators.newLine);
	        writer.write(Operators.eof + Operators.newLine);
	    };
	    /**
	     * `Saves the new trailer` dictionary.
	     * @private
	     */
	    PdfCrossTable.prototype.saveTrailer = function (writer, count, prevXRef) {
	        writer.write(Operators.trailer + Operators.newLine);
	        // Save the dictionary.
	        var trailer = this.trailer;
	        trailer.items.setValue(this.dictionaryProperties.size, new PdfNumber(this.objectCount + 1));
	        trailer = new PdfDictionary(trailer); // Make it real dictionary.
	        trailer.setEncrypt(false);
	        trailer.save(writer);
	    };
	    /**
	     * `Saves the xref section`.
	     * @private
	     */
	    PdfCrossTable.prototype.saveSections = function (writer) {
	        var objectNum = 0;
	        var count = 0;
	        do {
	            count = this.prepareSubsection(objectNum);
	            this.saveSubsection(writer, objectNum, count);
	            objectNum += count;
	        } while (count !== 0);
	    };
	    /**
	     * `Saves a subsection`.
	     * @private
	     */
	    PdfCrossTable.prototype.saveSubsection = function (writer, objectNum, count) {
	        if (count <= 0 || objectNum >= this.count) {
	            return;
	        }
	        writer.write(objectNum + ' ' + (count + 1) + Operators.newLine);
	        for (var i = objectNum; i <= objectNum + count; ++i) {
	            var obj = this.objects.getValue(i);
	            var str = '';
	            if (obj.type === ObjectType.Free) {
	                str = this.getItem(obj.offset, 65535, true);
	            }
	            else {
	                str = this.getItem(obj.offset, obj.generation, false);
	            }
	            writer.write(str);
	        }
	    };
	    /**
	     * Generates string for `xref table item`.
	     * @private
	     */
	    PdfCrossTable.prototype.getItem = function (offset, genNumber, isFree) {
	        var returnString = '';
	        var addOffsetLength = 10 - offset.toString().length;
	        if (genNumber <= 0) {
	            genNumber = 0;
	        }
	        var addGenNumberLength = (5 - genNumber.toString().length) <= 0 ? 0 : (5 - genNumber.toString().length);
	        for (var index = 0; index < addOffsetLength; index++) {
	            returnString = returnString + '0';
	        }
	        returnString = returnString + offset.toString() + ' ';
	        for (var index = 0; index < addGenNumberLength; index++) {
	            returnString = returnString + '0';
	        }
	        returnString = returnString + genNumber.toString() + ' ';
	        returnString = returnString + ((isFree) ? Operators.f : Operators.n) + Operators.newLine;
	        return returnString;
	    };
	    /**
	     * `Prepares a subsection` of the current section within the cross-reference table.
	     * @private
	     */
	    PdfCrossTable.prototype.prepareSubsection = function (objectNum) {
	        var count = 0;
	        var i;
	        var total = this.count;
	        for (var k = 0; k < this.document.pdfObjects.count; k++) {
	            var reference = this.document.pdfObjects.items(k).reference;
	            var refString = reference.toString();
	            refString.split(' ');
	        }
	        if (objectNum >= total) {
	            return count;
	        }
	        // search for first changed indirect object.
	        for (i = objectNum; i < total; ++i) {
	            break;
	        }
	        objectNum = i;
	        // look up for all indirect objects in one subsection.
	        for (; i < total; ++i) {
	            ++count;
	        }
	        return count;
	    };
	    /**
	     * `Marks the trailer references` being saved.
	     * @private
	     */
	    PdfCrossTable.prototype.markTrailerReferences = function () {
	        this.trailer.items.keys();
	        this.trailer.items.values();
	    };
	    /**
	     * `Saves the head`.
	     * @private
	     */
	    PdfCrossTable.prototype.saveHead = function (writer) {
	        var version = this.generateFileVersion(writer.document);
	        writer.write('%PDF-' + version);
	        writer.write(Operators.newLine);
	    };
	    /**
	     * Generates the `version` of the file.
	     * @private
	     */
	    PdfCrossTable.prototype.generateFileVersion = function (document) {
	        var iVersion = 4;
	        var version = '1.' + iVersion.toString();
	        return version;
	    };
	    PdfCrossTable.prototype.getReference = function (obj, bNew) {
	        if (typeof bNew === 'undefined') {
	            var wasNew = false;
	            return this.getReference(obj, wasNew);
	        }
	        else {
	            //code splitted for reducing lines of code exceeds 100.
	            return this.getSubReference(obj, bNew);
	        }
	    };
	    /**
	     * Retrieves the `reference` of the object given.
	     * @private
	     */
	    PdfCrossTable.prototype.getSubReference = function (obj, bNew) {
	        var isNew = false;
	        var wasNew;
	        var reference = null;
	        // if (obj.IsSaving) {
	        if (this.items.count > 0 && obj.objectCollectionIndex > 0 && this.items.count > obj.objectCollectionIndex - 1) {
	            var tempObj = this.document.pdfObjects.getReference(obj, wasNew);
	            reference = tempObj.reference;
	            wasNew = tempObj.wasNew;
	        }
	        if (reference == null) {
	            if (obj.status === ObjectStatus.Registered) {
	                wasNew = false;
	            }
	            else {
	                wasNew = true;
	            }
	        }
	        else {
	            wasNew = false;
	        }
	        // need to add mapped reference code
	        if (reference == null) {
	            var objnumber = this.nextObjNumber;
	            reference = new PdfReference(objnumber, 0);
	            var found = void 0;
	            if (wasNew) {
	                this.document.pdfObjects.add(obj);
	                this.document.pdfObjects.trySetReference(obj, reference, found);
	                var tempIndex = this.document.pdfObjects.count - 1;
	                var tempkey = this.document.pdfObjects.objectCollections[tempIndex].reference.objNumber;
	                var tempvalue = this.document.pdfObjects.objectCollections[this.document.pdfObjects.count - 1];
	                this.document.pdfObjects.mainObjectCollection.setValue(tempkey, tempvalue);
	                obj.position = -1;
	            }
	            else {
	                this.document.pdfObjects.trySetReference(obj, reference, found);
	            }
	            obj.objectCollectionIndex = reference.objNumber;
	            obj.status = ObjectStatus.None;
	            isNew = true;
	        }
	        isNew || this.bForceNew;
	        return reference;
	    };
	    /**
	     * `Saves all objects` in the collection.
	     * @private
	     */
	    PdfCrossTable.prototype.saveObjects = function (writer) {
	        var objectCollection = this.objectCollection;
	        for (var i = 0; i < objectCollection.count; ++i) {
	            var oi = objectCollection.items(i);
	            var obj = oi.object;
	            obj.isSaving = true;
	            this.saveIndirectObject(obj, writer);
	        }
	    };
	    /**
	     * `Saves indirect object`.
	     * @private
	     */
	    PdfCrossTable.prototype.saveIndirectObject = function (obj, writer) {
	        var reference = this.getReference(obj);
	        if (obj instanceof PdfCatalog) {
	            this.trailer.items.setValue(this.dictionaryProperties.root, reference);
	        }
	        // NOTE :  This is needed for correct string objects encryption.
	        this.pdfDocument.currentSavingObj = reference;
	        obj.getArchive();
	        this.registerObject(writer.position, reference);
	        this.doSaveObject(obj, reference, writer);
	    };
	    /**
	     * Performs `real saving` of the save object.
	     * @private
	     */
	    PdfCrossTable.prototype.doSaveObject = function (obj, reference, writer) {
	        writer.length;
	        writer.write(reference.objNumber.toString());
	        writer.write(Operators.whiteSpace);
	        writer.write(reference.genNumber.toString());
	        writer.write(Operators.whiteSpace);
	        writer.write(Operators.obj);
	        writer.write(Operators.newLine);
	        obj.save(writer);
	        writer.stream;
	        writer.write(Operators.endObj);
	        writer.write(Operators.newLine);
	    };
	    PdfCrossTable.prototype.registerObject = function (offset, reference, free) {
	        if (typeof free === 'boolean') {
	            // Register the object by its number.
	            this.objects.setValue(reference.objNumber, new RegisteredObject(offset, reference, free));
	            this.maxGenNumIndex = Math.max(this.maxGenNumIndex, reference.genNumber);
	        }
	        else if (typeof free === 'undefined') {
	            // Register the object by its number.
	            this.objects.setValue(reference.objNumber, new RegisteredObject(offset, reference));
	            this.maxGenNumIndex = Math.max(this.maxGenNumIndex, reference.genNumber);
	        }
	    };
	    /**
	     * `Dereferences` the specified primitive object.
	     * @private
	     */
	    PdfCrossTable.dereference = function (obj) {
	        var rh = obj;
	        if (rh != null) {
	            obj = rh.object;
	        }
	        return obj;
	    };
	    return PdfCrossTable;
	}());
	var RegisteredObject = /** @class */ (function () {
	    function RegisteredObject(offset, reference, free) {
	        var tempOffset = offset;
	        this.offsetNumber = tempOffset;
	        var tempReference = reference;
	        this.generation = tempReference.genNumber;
	        this.object = tempReference.objNumber;
	        if (typeof free === 'undefined') {
	            this.type = ObjectType.Normal;
	        }
	        else {
	            this.type = ObjectType.Free;
	        }
	    }
	    Object.defineProperty(RegisteredObject.prototype, "objectNumber", {
	        //Properties
	        /**
	         * Gets the `object number`.
	         * @private
	         */
	        get: function () {
	            return this.object;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RegisteredObject.prototype, "offset", {
	        /**
	         * Gets the `offset`.
	         * @private
	         */
	        get: function () {
	            var result;
	            result = this.offsetNumber;
	            return result;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return RegisteredObject;
	}());

	/**
	 * PdfPageSize.ts class for EJ2-PDF
	 */
	/**
	 * Represents information about various predefined `page sizes`.
	 */
	var PdfPageSize = /** @class */ (function () {
	    //constructor
	    /**
	     * Initialize an instance for `PdfPageSize` class.
	     * @private
	     */
	    function PdfPageSize() {
	        // 
	    }
	    /**
	     * Specifies the size of `letter`.
	     * @private
	     */
	    PdfPageSize.letter = new SizeF(612, 792);
	    /**
	     * Specifies the size of `note`.
	     * @private
	     */
	    PdfPageSize.note = new SizeF(540, 720);
	    /**
	     * Specifies the size of `legal`.
	     * @private
	     */
	    PdfPageSize.legal = new SizeF(612, 1008);
	    /**
	     * Specifies the size of `a0`.
	     * @private
	     */
	    PdfPageSize.a0 = new SizeF(2380, 3368);
	    /**
	     * Specifies the size of `a1`.
	     * @private
	     */
	    PdfPageSize.a1 = new SizeF(1684, 2380);
	    /**
	     * Specifies the size of `a2`.
	     * @private
	     */
	    PdfPageSize.a2 = new SizeF(1190, 1684);
	    /**
	     * Specifies the size of `a3`.
	     * @private
	     */
	    PdfPageSize.a3 = new SizeF(842, 1190);
	    /**
	     * Specifies the size of `a4`.
	     * @private
	     */
	    PdfPageSize.a4 = new SizeF(595, 842);
	    /**
	     * Specifies the size of `a5`.
	     * @private
	     */
	    PdfPageSize.a5 = new SizeF(421, 595);
	    /**
	     * Specifies the size of `a6`.
	     * @private
	     */
	    PdfPageSize.a6 = new SizeF(297, 421);
	    /**
	     * Specifies the size of `a7`.
	     * @private
	     */
	    PdfPageSize.a7 = new SizeF(210, 297);
	    /**
	     * Specifies the size of `a8`.
	     * @private
	     */
	    PdfPageSize.a8 = new SizeF(148, 210);
	    /**
	     * Specifies the size of `a9`.
	     * @private
	     */
	    PdfPageSize.a9 = new SizeF(105, 148);
	    /**
	     * Specifies the size of `a10`.
	     * @private
	     */
	    PdfPageSize.a10 = new SizeF(74, 105);
	    /**
	     * Specifies the size of `b0`.
	     * @private
	     */
	    PdfPageSize.b0 = new SizeF(2836, 4008);
	    /**
	     * Specifies the size of `b1`.
	     * @private
	     */
	    PdfPageSize.b1 = new SizeF(2004, 2836);
	    /**
	     * Specifies the size of `b2`.
	     * @private
	     */
	    PdfPageSize.b2 = new SizeF(1418, 2004);
	    /**
	     * Specifies the size of `b3`.
	     * @private
	     */
	    PdfPageSize.b3 = new SizeF(1002, 1418);
	    /**
	     * Specifies the size of `b4`.
	     * @private
	     */
	    PdfPageSize.b4 = new SizeF(709, 1002);
	    /**
	     * Specifies the size of `b5`.
	     * @private
	     */
	    PdfPageSize.b5 = new SizeF(501, 709);
	    /**
	     * Specifies the size of `archE`.
	     * @private
	     */
	    PdfPageSize.archE = new SizeF(2592, 3456);
	    /**
	     * Specifies the size of `archD`.
	     * @private
	     */
	    PdfPageSize.archD = new SizeF(1728, 2592);
	    /**
	     * Specifies the size of `archC`.
	     * @private
	     */
	    PdfPageSize.archC = new SizeF(1296, 1728);
	    /**
	     * Specifies the size of `archB`.
	     * @private
	     */
	    PdfPageSize.archB = new SizeF(864, 1296);
	    /**
	     * Specifies the size of `archA`.
	     * @private
	     */
	    PdfPageSize.archA = new SizeF(648, 864);
	    /**
	     * Specifies the size of `flsa`.
	     * @private
	     */
	    PdfPageSize.flsa = new SizeF(612, 936);
	    /**
	     * Specifies the size of `halfLetter`.
	     * @private
	     */
	    PdfPageSize.halfLetter = new SizeF(396, 612);
	    /**
	     * Specifies the size of `letter11x17`.
	     * @private
	     */
	    PdfPageSize.letter11x17 = new SizeF(792, 1224);
	    /**
	     * Specifies the size of `ledger`.
	     * @private
	     */
	    PdfPageSize.ledger = new SizeF(1224, 792);
	    return PdfPageSize;
	}());

	/**
	 * public Enum for `PdfPageOrientation`.
	 * @private
	 */
	var PdfPageOrientation;
	(function (PdfPageOrientation) {
	    /**
	     * Specifies the type of `Portrait`.
	     * @private
	     */
	    PdfPageOrientation[PdfPageOrientation["Portrait"] = 0] = "Portrait";
	    /**
	     * Specifies the type of `Landscape`.
	     * @private
	     */
	    PdfPageOrientation[PdfPageOrientation["Landscape"] = 1] = "Landscape";
	})(PdfPageOrientation || (PdfPageOrientation = {}));
	/**
	 * public Enum for `PdfPageRotateAngle`.
	 * @private
	 */
	var PdfPageRotateAngle;
	(function (PdfPageRotateAngle) {
	    /**
	     * Specifies the type of `RotateAngle0`.
	     * @private
	     */
	    PdfPageRotateAngle[PdfPageRotateAngle["RotateAngle0"] = 0] = "RotateAngle0";
	    /**
	     * Specifies the type of `RotateAngle90`.
	     * @private
	     */
	    PdfPageRotateAngle[PdfPageRotateAngle["RotateAngle90"] = 1] = "RotateAngle90";
	    /**
	     * Specifies the type of `RotateAngle180`.
	     * @private
	     */
	    PdfPageRotateAngle[PdfPageRotateAngle["RotateAngle180"] = 2] = "RotateAngle180";
	    /**
	     * Specifies the type of `RotateAngle270`.
	     * @private
	     */
	    PdfPageRotateAngle[PdfPageRotateAngle["RotateAngle270"] = 3] = "RotateAngle270";
	})(PdfPageRotateAngle || (PdfPageRotateAngle = {}));
	/**
	 * public Enum for `PdfNumberStyle`.
	 * @private
	 */
	var PdfNumberStyle;
	(function (PdfNumberStyle) {
	    /**
	     * Specifies the type of `None`.
	     * @private
	     */
	    PdfNumberStyle[PdfNumberStyle["None"] = 0] = "None";
	    /**
	     * Specifies the type of `Numeric`.
	     * @private
	     */
	    PdfNumberStyle[PdfNumberStyle["Numeric"] = 1] = "Numeric";
	    /**
	     * Specifies the type of `LowerLatin`.
	     * @private
	     */
	    PdfNumberStyle[PdfNumberStyle["LowerLatin"] = 2] = "LowerLatin";
	    /**
	     * Specifies the type of `LowerRoman`.
	     * @private
	     */
	    PdfNumberStyle[PdfNumberStyle["LowerRoman"] = 3] = "LowerRoman";
	    /**
	     * Specifies the type of `UpperLatin`.
	     * @private
	     */
	    PdfNumberStyle[PdfNumberStyle["UpperLatin"] = 4] = "UpperLatin";
	    /**
	     * Specifies the type of `UpperRoman`.
	     * @private
	     */
	    PdfNumberStyle[PdfNumberStyle["UpperRoman"] = 5] = "UpperRoman";
	})(PdfNumberStyle || (PdfNumberStyle = {}));
	/**
	 * public Enum for `PdfDockStyle`.
	 * @private
	 */
	var PdfDockStyle;
	(function (PdfDockStyle) {
	    /**
	     * Specifies the type of `None`.
	     * @private
	     */
	    PdfDockStyle[PdfDockStyle["None"] = 0] = "None";
	    /**
	     * Specifies the type of `Bottom`.
	     * @private
	     */
	    PdfDockStyle[PdfDockStyle["Bottom"] = 1] = "Bottom";
	    /**
	     * Specifies the type of `Top`.
	     * @private
	     */
	    PdfDockStyle[PdfDockStyle["Top"] = 2] = "Top";
	    /**
	     * Specifies the type of `Left`.
	     * @private
	     */
	    PdfDockStyle[PdfDockStyle["Left"] = 3] = "Left";
	    /**
	     * Specifies the type of `Right`.
	     * @private
	     */
	    PdfDockStyle[PdfDockStyle["Right"] = 4] = "Right";
	    /**
	     * Specifies the type of `Fill`.
	     * @private
	     */
	    PdfDockStyle[PdfDockStyle["Fill"] = 5] = "Fill";
	})(PdfDockStyle || (PdfDockStyle = {}));
	/**
	 * public Enum for `PdfAlignmentStyle`.
	 * @private
	 */
	var PdfAlignmentStyle;
	(function (PdfAlignmentStyle) {
	    /**
	     * Specifies the type of `None`.
	     * @private
	     */
	    PdfAlignmentStyle[PdfAlignmentStyle["None"] = 0] = "None";
	    /**
	     * Specifies the type of `TopLeft`.
	     * @private
	     */
	    PdfAlignmentStyle[PdfAlignmentStyle["TopLeft"] = 1] = "TopLeft";
	    /**
	     * Specifies the type of `TopCenter`.
	     * @private
	     */
	    PdfAlignmentStyle[PdfAlignmentStyle["TopCenter"] = 2] = "TopCenter";
	    /**
	     * Specifies the type of `TopRight`.
	     * @private
	     */
	    PdfAlignmentStyle[PdfAlignmentStyle["TopRight"] = 3] = "TopRight";
	    /**
	     * Specifies the type of `MiddleLeft`.
	     * @private
	     */
	    PdfAlignmentStyle[PdfAlignmentStyle["MiddleLeft"] = 4] = "MiddleLeft";
	    /**
	     * Specifies the type of `MiddleCenter`.
	     * @private
	     */
	    PdfAlignmentStyle[PdfAlignmentStyle["MiddleCenter"] = 5] = "MiddleCenter";
	    /**
	     * Specifies the type of `MiddleRight`.
	     * @private
	     */
	    PdfAlignmentStyle[PdfAlignmentStyle["MiddleRight"] = 6] = "MiddleRight";
	    /**
	     * Specifies the type of `BottomLeft`.
	     * @private
	     */
	    PdfAlignmentStyle[PdfAlignmentStyle["BottomLeft"] = 7] = "BottomLeft";
	    /**
	     * Specifies the type of `BottomCenter`.
	     * @private
	     */
	    PdfAlignmentStyle[PdfAlignmentStyle["BottomCenter"] = 8] = "BottomCenter";
	    /**
	     * Specifies the type of `BottomRight`.
	     * @private
	     */
	    PdfAlignmentStyle[PdfAlignmentStyle["BottomRight"] = 9] = "BottomRight";
	})(PdfAlignmentStyle || (PdfAlignmentStyle = {}));
	/**
	 * public Enum for `TemplateType`.
	 * @private
	 */
	var TemplateType;
	(function (TemplateType) {
	    /**
	     * Specifies the type of `None`.
	     * @private
	     */
	    TemplateType[TemplateType["None"] = 0] = "None";
	    /**
	     * Specifies the type of `Top`.
	     * @private
	     */
	    TemplateType[TemplateType["Top"] = 1] = "Top";
	    /**
	     * Specifies the type of `Bottom`.
	     * @private
	     */
	    TemplateType[TemplateType["Bottom"] = 2] = "Bottom";
	    /**
	     * Specifies the type of `Left`.
	     * @private
	     */
	    TemplateType[TemplateType["Left"] = 3] = "Left";
	    /**
	     * Specifies the type of `Right`.
	     * @private
	     */
	    TemplateType[TemplateType["Right"] = 4] = "Right";
	})(TemplateType || (TemplateType = {}));

	/**
	 * PdfMargins.ts class for EJ2-PDF
	 * A class representing PDF page margins.
	 */
	var PdfMargins = /** @class */ (function () {
	    /**
	     * Initializes a new instance of the `PdfMargins` class.
	     * @private
	     */
	    function PdfMargins() {
	        /**
	         * Represents the `Default Page Margin` value.
	         * @default 0.0
	         * @private
	         */
	        this.pdfMargin = 40.0;
	        this.setMargins(this.pdfMargin);
	    }
	    Object.defineProperty(PdfMargins.prototype, "left", {
	        //Properties
	        /**
	         * Gets or sets the `left margin` size.
	         * @private
	         */
	        get: function () {
	            return this.leftMargin;
	        },
	        set: function (value) {
	            this.leftMargin = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfMargins.prototype, "top", {
	        /**
	         * Gets or sets the `top margin` size.
	         * @private
	         */
	        get: function () {
	            return this.topMargin;
	        },
	        set: function (value) {
	            this.topMargin = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfMargins.prototype, "right", {
	        /**
	         * Gets or sets the `right margin` size.
	         * @private
	         */
	        get: function () {
	            return this.rightMargin;
	        },
	        set: function (value) {
	            this.rightMargin = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfMargins.prototype, "bottom", {
	        /**
	         * Gets or sets the `bottom margin` size.
	         * @private
	         */
	        get: function () {
	            return this.bottomMargin;
	        },
	        set: function (value) {
	            this.bottomMargin = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfMargins.prototype, "all", {
	        /**
	         * Sets the `margins`.
	         * @private
	         */
	        set: function (value) {
	            this.setMargins(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PdfMargins.prototype.setMargins = function (margin1, margin2, margin3, margin4) {
	        if (typeof margin2 === 'undefined') {
	            this.leftMargin = this.topMargin = this.rightMargin = this.bottomMargin = margin1;
	        }
	        else {
	            if (typeof margin3 === 'undefined') {
	                this.leftMargin = this.rightMargin = margin1;
	                this.bottomMargin = this.topMargin = margin2;
	            }
	            else {
	                this.leftMargin = margin1;
	                this.topMargin = margin2;
	                this.rightMargin = margin3;
	                this.bottomMargin = margin4;
	            }
	        }
	    };
	    /**
	     * `Clones` the object.
	     * @private
	     */
	    PdfMargins.prototype.clone = function () {
	        return this;
	    };
	    return PdfMargins;
	}());

	/**
	 * PdfPageSettings.ts class for EJ2-PDF
	 */
	/**
	 * The class provides various `setting` related with PDF pages.
	 */
	var PdfPageSettings = /** @class */ (function () {
	    function PdfPageSettings(margins) {
	        //Fields
	        /**
	         * The page `margins`.
	         * @private
	         */
	        this.pageMargins = new PdfMargins();
	        /**
	         * The page `size`.
	         * @default a4
	         * @private
	         */
	        this.pageSize = PdfPageSize.a4;
	        /**
	         * The page `rotation angle`.
	         * @default PdfPageRotateAngle.RotateAngle0
	         * @private
	         */
	        this.rotateAngle = PdfPageRotateAngle.RotateAngle0;
	        /**
	         * The page `orientation`.
	         * @default PdfPageOrientation.Portrait
	         * @private
	         */
	        this.pageOrientation = PdfPageOrientation.Portrait;
	        /**
	         * The page `origin`.
	         * @default 0,0
	         * @private
	         */
	        this.pageOrigin = new PointF(0, 0);
	        /**
	         * Checks the Whether the `rotation` is applied or not.
	         * @default false
	         * @private
	         */
	        this.isRotation = false;
	        if (typeof margins === 'number') {
	            this.pageMargins.setMargins(margins);
	        }
	    }
	    Object.defineProperty(PdfPageSettings.prototype, "size", {
	        //Properties
	        /**
	         * Gets or sets the `size` of the page.
	         * @private
	         */
	        get: function () {
	            return this.pageSize;
	        },
	        set: function (value) {
	            this.setSize(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageSettings.prototype, "orientation", {
	        /**
	         * Gets or sets the page `orientation`.
	         * @private
	         */
	        get: function () {
	            return this.pageOrientation;
	        },
	        set: function (orientation) {
	            if (this.pageOrientation !== orientation) {
	                this.pageOrientation = orientation;
	                this.updateSize(orientation);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageSettings.prototype, "margins", {
	        /**
	         * Gets or sets the `margins` of the page.
	         * @private
	         */
	        get: function () {
	            return this.pageMargins;
	        },
	        set: function (value) {
	            this.pageMargins = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageSettings.prototype, "width", {
	        /**
	         * Gets or sets the `width` of the page.
	         * @private
	         */
	        get: function () {
	            return this.pageSize.width;
	        },
	        set: function (value) {
	            this.pageSize.width = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageSettings.prototype, "height", {
	        /**
	         * Gets or sets the `height` of the page.
	         * @private
	         */
	        get: function () {
	            return this.pageSize.height;
	        },
	        set: function (value) {
	            this.pageSize.height = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageSettings.prototype, "origin", {
	        /**
	         * Gets or sets the `origin` of the page.
	         * @private
	         */
	        get: function () {
	            return this.pageOrigin;
	        },
	        set: function (value) {
	            this.pageOrigin = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageSettings.prototype, "rotate", {
	        /**
	         * Gets or sets the number of degrees by which the page should be `rotated` clockwise when displayed or printed.
	         * @private
	         */
	        get: function () {
	            return this.rotateAngle;
	        },
	        set: function (value) {
	            this.rotateAngle = value;
	            this.isRotation = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //Methods
	    /**
	     * `Update page size` depending on orientation.
	     * @private
	     */
	    PdfPageSettings.prototype.updateSize = function (orientation) {
	        var min = Math.min(this.pageSize.width, this.pageSize.height);
	        var max = Math.max(this.pageSize.width, this.pageSize.height);
	        switch (orientation) {
	            case PdfPageOrientation.Portrait:
	                this.pageSize = new SizeF(min, max);
	                break;
	            case PdfPageOrientation.Landscape:
	                this.pageSize = new SizeF(max, min);
	                break;
	        }
	    };
	    /**
	     * Creates a `clone` of the object.
	     * @private
	     */
	    PdfPageSettings.prototype.clone = function () {
	        var settings = this;
	        settings.pageMargins = this.pageMargins.clone();
	        // if (GetTransition() != null)
	        // {
	        //     settings.Transition = (PdfPageTransition)Transition.clone();
	        // }
	        return settings;
	    };
	    /**
	     * Returns `size`, shrinked by the margins.
	     * @private
	     */
	    PdfPageSettings.prototype.getActualSize = function () {
	        var width = this.width - (this.margins.left + this.margins.right);
	        var height = this.height - (this.margins.top + this.margins.bottom);
	        var size = new SizeF(width, height);
	        return size;
	    };
	    /**
	     * Sets `size` to the page aaccording to the orientation.
	     * @private
	     */
	    PdfPageSettings.prototype.setSize = function (size) {
	        var min = Math.min(size.width, size.height);
	        var max = Math.max(size.width, size.height);
	        if (this.orientation === PdfPageOrientation.Portrait) {
	            this.pageSize = new SizeF(min, max);
	        }
	        else {
	            this.pageSize = new SizeF(max, min);
	        }
	    };
	    return PdfPageSettings;
	}());

	/**
	 * Helper class to `write PDF graphic streams` easily.
	 * @private
	 */
	var PdfStreamWriter = /** @class */ (function () {
	    /**
	     * Initialize an instance of `PdfStreamWriter` class.
	     * @private
	     */
	    function PdfStreamWriter(stream) {
	        if (stream == null) {
	            throw new Error('ArgumentNullException:stream');
	        }
	        this.stream = stream;
	    }
	    //Implementation
	    /**
	     * `Clear` the stream.
	     * @public
	     */
	    PdfStreamWriter.prototype.clear = function () {
	        this.stream.clearStream();
	    };
	    PdfStreamWriter.prototype.setGraphicsState = function (dictionaryName) {
	        if (dictionaryName instanceof PdfName) {
	            this.stream.write(dictionaryName.toString());
	            this.stream.write(Operators.whiteSpace);
	            this.writeOperator(Operators.setGraphicsState);
	        }
	        else {
	            this.stream.write(Operators.slash);
	            this.stream.write(dictionaryName);
	            this.stream.write(Operators.whiteSpace);
	            this.writeOperator(Operators.setGraphicsState);
	        }
	    };
	    /**
	     * `Executes the XObject`.
	     * @private
	     */
	    PdfStreamWriter.prototype.executeObject = function (name) {
	        this.stream.write(name.toString());
	        this.stream.write(Operators.whiteSpace);
	        this.writeOperator(Operators.paintXObject);
	        this.stream.write(Operators.newLine);
	    };
	    /**
	     * `Closes path object`.
	     * @private
	     */
	    PdfStreamWriter.prototype.closePath = function () {
	        this.writeOperator(Operators.closePath);
	    };
	    /**
	     * `Clips the path`.
	     * @private
	     */
	    PdfStreamWriter.prototype.clipPath = function (useEvenOddRule) {
	        this.stream.write(Operators.clipPath);
	        if (useEvenOddRule) {
	            this.stream.write(Operators.evenOdd);
	        }
	        this.stream.write(Operators.whiteSpace);
	        this.stream.write(Operators.endPath);
	        this.stream.write(Operators.newLine);
	    };
	    /**
	     * `Closes, then fills and strokes the path`.
	     * @private
	     */
	    PdfStreamWriter.prototype.closeFillStrokePath = function (useEvenOddRule) {
	        this.stream.write(Operators.closeFillStrokePath);
	        if (useEvenOddRule) {
	            this.stream.write(Operators.evenOdd);
	            this.stream.write(Operators.newLine);
	        }
	        else {
	            this.stream.write(Operators.newLine);
	        }
	    };
	    /**
	     * `Fills and strokes path`.
	     * @private
	     */
	    PdfStreamWriter.prototype.fillStrokePath = function (useEvenOddRule) {
	        this.stream.write(Operators.fillStroke);
	        if (useEvenOddRule) {
	            this.stream.write(Operators.evenOdd);
	            this.stream.write(Operators.newLine);
	        }
	        else {
	            this.stream.write(Operators.newLine);
	        }
	    };
	    /**
	     * `Fills path`.
	     * @private
	     */
	    PdfStreamWriter.prototype.fillPath = function (useEvenOddRule) {
	        this.stream.write(Operators.fill);
	        if (useEvenOddRule) {
	            this.stream.write(Operators.evenOdd);
	            this.stream.write(Operators.newLine);
	        }
	        else {
	            this.stream.write(Operators.newLine);
	        }
	    };
	    /**
	     * `Ends the path`.
	     * @private
	     */
	    PdfStreamWriter.prototype.endPath = function () {
	        this.writeOperator(Operators.n);
	    };
	    /**
	     * `Closes and fills the path`.
	     * @private
	     */
	    PdfStreamWriter.prototype.closeFillPath = function (useEvenOddRule) {
	        this.writeOperator(Operators.closePath);
	        this.stream.write(Operators.fill);
	        if (useEvenOddRule) {
	            this.stream.write(Operators.evenOdd);
	            this.stream.write(Operators.newLine);
	        }
	        else {
	            this.stream.write(Operators.newLine);
	        }
	    };
	    /**
	     * `Closes and strokes the path`.
	     * @private
	     */
	    PdfStreamWriter.prototype.closeStrokePath = function () {
	        this.writeOperator(Operators.closeStrokePath);
	    };
	    /**
	     * `Sets the text scaling`.
	     * @private
	     */
	    PdfStreamWriter.prototype.setTextScaling = function (textScaling) {
	        this.stream.write(PdfNumber.floatToString(textScaling));
	        this.stream.write(Operators.whiteSpace);
	        this.writeOperator(Operators.setTextScaling);
	    };
	    /**
	     * `Strokes path`.
	     * @private
	     */
	    PdfStreamWriter.prototype.strokePath = function () {
	        this.writeOperator(Operators.stroke);
	    };
	    /**
	     * `Restores` the graphics state.
	     * @private
	     */
	    PdfStreamWriter.prototype.restoreGraphicsState = function () {
	        this.writeOperator(Operators.restoreState);
	    };
	    /**
	     * `Saves` the graphics state.
	     * @private
	     */
	    PdfStreamWriter.prototype.saveGraphicsState = function () {
	        this.writeOperator(Operators.saveState);
	    };
	    PdfStreamWriter.prototype.startNextLine = function (arg1, arg2) {
	        if (typeof arg1 === 'undefined') {
	            this.writeOperator(Operators.goToNextLine);
	        }
	        else if (arg1 instanceof PointF) {
	            this.writePoint(arg1);
	            this.writeOperator(Operators.setCoords);
	        }
	        else {
	            this.writePoint(arg1, arg2);
	            this.writeOperator(Operators.setCoords);
	        }
	    };
	    /**
	     * Shows the `text`.
	     * @private
	     */
	    PdfStreamWriter.prototype.showText = function (text) {
	        this.checkTextParam(text);
	        this.writeText(text);
	        this.writeOperator(Operators.setText);
	    };
	    /**
	     * Sets `text leading`.
	     * @private
	     */
	    PdfStreamWriter.prototype.setLeading = function (leading) {
	        this.stream.write(PdfNumber.floatToString(leading));
	        this.stream.write(Operators.whiteSpace);
	        this.writeOperator(Operators.setTextLeading);
	    };
	    /**
	     * `Begins the path`.
	     * @private
	     */
	    PdfStreamWriter.prototype.beginPath = function (x, y) {
	        this.writePoint(x, y);
	        this.writeOperator(Operators.beginPath);
	    };
	    /**
	     * `Begins text`.
	     * @private
	     */
	    PdfStreamWriter.prototype.beginText = function () {
	        this.writeOperator(Operators.beginText);
	    };
	    /**
	     * `Ends text`.
	     * @private
	     */
	    PdfStreamWriter.prototype.endText = function () {
	        this.writeOperator(Operators.endText);
	    };
	    PdfStreamWriter.prototype.appendRectangle = function (arg1, arg2, arg3, arg4) {
	        if (arg1 instanceof RectangleF) {
	            this.appendRectangle(arg1.x, arg1.y, arg1.width, arg1.height);
	        }
	        else {
	            this.writePoint(arg1, arg2);
	            this.writePoint(arg3, arg4);
	            this.writeOperator(Operators.appendRectangle);
	        }
	    };
	    PdfStreamWriter.prototype.appendLineSegment = function (arg1, arg2) {
	        if (arg1 instanceof PointF) {
	            this.appendLineSegment(arg1.x, arg1.y);
	        }
	        else {
	            this.writePoint(arg1, arg2);
	            this.writeOperator(Operators.appendLineSegment);
	        }
	    };
	    /**
	     * Sets the `text rendering mode`.
	     * @private
	     */
	    PdfStreamWriter.prototype.setTextRenderingMode = function (renderingMode) {
	        this.stream.write(renderingMode.toString());
	        this.stream.write(Operators.whiteSpace);
	        this.writeOperator(Operators.setRenderingMode);
	    };
	    /**
	     * Sets the `character spacing`.
	     * @private
	     */
	    PdfStreamWriter.prototype.setCharacterSpacing = function (charSpacing) {
	        this.stream.write(PdfNumber.floatToString(charSpacing));
	        this.stream.write(Operators.whiteSpace);
	        this.stream.write(Operators.setCharacterSpace);
	        this.stream.write(Operators.newLine);
	    };
	    /**
	     * Sets the `word spacing`.
	     * @private
	     */
	    PdfStreamWriter.prototype.setWordSpacing = function (wordSpacing) {
	        this.stream.write(PdfNumber.floatToString(wordSpacing));
	        this.stream.write(Operators.whiteSpace);
	        this.writeOperator(Operators.setWordSpace);
	    };
	    PdfStreamWriter.prototype.showNextLineText = function (arg1, arg2) {
	        if (arg1 instanceof PdfString) {
	            this.checkTextParam(arg1);
	            this.writeText(arg1);
	            this.writeOperator(Operators.setTextOnNewLine);
	        }
	        else {
	            this.checkTextParam(arg1);
	            this.writeText(arg1, arg2);
	            this.writeOperator(Operators.setTextOnNewLine);
	        }
	    };
	    PdfStreamWriter.prototype.setColorSpace = function (arg1, arg2) {
	        if (arg1 instanceof PdfName && typeof arg2 === 'boolean') {
	            var temparg1 = arg1;
	            var temparg2 = arg2;
	            // if (temparg1 == null) {
	            //     throw new Error('ArgumentNullException:name');
	            // }
	            var op = (temparg2) ? Operators.selectcolorspaceforstroking : Operators.selectcolorspacefornonstroking;
	            this.stream.write(temparg1.toString());
	            this.stream.write(Operators.whiteSpace);
	            this.stream.write(op);
	            this.stream.write(Operators.newLine);
	        }
	        else {
	            var temparg1 = arg1;
	            var temparg2 = arg2;
	            this.setColorSpace(new PdfName(temparg1), temparg2);
	        }
	    };
	    /**
	     * Modifies current `transformation matrix`.
	     * @private
	     */
	    PdfStreamWriter.prototype.modifyCtm = function (matrix) {
	        if (matrix == null) {
	            throw new Error('ArgumentNullException:matrix');
	        }
	        this.stream.write(matrix.toString());
	        this.stream.write(Operators.whiteSpace);
	        this.writeOperator(Operators.modifyCtm);
	    };
	    PdfStreamWriter.prototype.setFont = function (font, name, size) {
	        if (typeof name === 'string') {
	            this.setFont(font, new PdfName(name), size);
	        }
	        else {
	            if (font == null) {
	                throw new Error('ArgumentNullException:font');
	            }
	            this.stream.write(name.toString());
	            this.stream.write(Operators.whiteSpace);
	            this.stream.write(PdfNumber.floatToString(size));
	            this.stream.write(Operators.whiteSpace);
	            this.writeOperator(Operators.setFont);
	        }
	    };
	    /**
	     * `Writes the operator`.
	     * @private
	     */
	    PdfStreamWriter.prototype.writeOperator = function (opcode) {
	        this.stream.write(opcode);
	        this.stream.write(Operators.newLine);
	    };
	    PdfStreamWriter.prototype.checkTextParam = function (text) {
	        if (text == null) {
	            throw new Error('ArgumentNullException:text');
	        }
	        if (typeof text === 'string' && text === '') {
	            throw new Error('ArgumentException:The text can not be an empty string, text');
	        }
	    };
	    PdfStreamWriter.prototype.writeText = function (arg1, arg2) {
	        if ((arg1 instanceof PdfString) && (typeof arg2 === 'undefined')) {
	            this.stream.write(arg1.pdfEncode());
	        }
	        else {
	            var start = void 0;
	            var end = void 0;
	            if (arg2) {
	                start = PdfString.hexStringMark[0];
	                end = PdfString.hexStringMark[1];
	            }
	            else {
	                start = PdfString.stringMark[0];
	                end = PdfString.stringMark[1];
	            }
	            this.stream.write(start);
	            this.stream.write(arg1);
	            this.stream.write(end);
	        }
	    };
	    PdfStreamWriter.prototype.writePoint = function (arg1, arg2) {
	        if ((arg1 instanceof PointF) && (typeof arg2 === 'undefined')) {
	            this.writePoint(arg1.x, arg1.y);
	        }
	        else {
	            var temparg1 = arg1;
	            this.stream.write(PdfNumber.floatToString(temparg1));
	            this.stream.write(Operators.whiteSpace);
	            // NOTE: Change Y co-ordinate because we shifted co-ordinate system only.
	            arg2 = this.updateY(arg2);
	            this.stream.write(PdfNumber.floatToString(arg2));
	            this.stream.write(Operators.whiteSpace);
	        }
	    };
	    /**
	     * `Updates y` co-ordinate.
	     * @private
	     */
	    PdfStreamWriter.prototype.updateY = function (arg) {
	        return -arg;
	    };
	    /**
	     * `Writes string` to the file.
	     * @private
	     */
	    PdfStreamWriter.prototype.write = function (string) {
	        var builder = '';
	        builder += string;
	        builder += Operators.newLine;
	        this.writeOperator(builder);
	    };
	    /**
	     * `Writes comment` to the file.
	     * @private
	     */
	    PdfStreamWriter.prototype.writeComment = function (comment) {
	        if (comment != null && comment.length > 0) {
	            var builder = '';
	            builder += Operators.comment;
	            builder += Operators.whiteSpace;
	            builder += comment;
	            //builder.Append( Operators.NewLine );
	            this.writeOperator(builder);
	        }
	        else {
	            throw new Error('Invalid comment');
	        }
	    };
	    /**
	     * Sets the `color and space`.
	     * @private
	     */
	    PdfStreamWriter.prototype.setColorAndSpace = function (color, colorSpace, forStroking) {
	        if (!color.isEmpty) {
	            // bool test = color is PdfExtendedColor;
	            this.stream.write(color.toString(colorSpace, forStroking));
	            this.stream.write(Operators.newLine);
	        }
	    };
	    // public setLineDashPattern(pattern : number[], patternOffset : number) : void
	    // {
	    //     let pat : PdfArray = new PdfArray(pattern);
	    //     let off : PdfNumber = new PdfNumber(patternOffset);
	    //     this.setLineDashPatternHelper(pat, off);
	    // }
	    // private setLineDashPatternHelper(pattern : PdfArray, patternOffset : PdfNumber) : void
	    // {
	    //     pattern.Save(this);
	    //     this.m_stream.write(Operators.whiteSpace);
	    //     patternOffset.Save(this);
	    //     this.m_stream.write(Operators.whiteSpace);
	    //     this.writeOperator(Operators.setDashPattern);
	    // }
	    /**
	     * Sets the `line dash pattern`.
	     * @private
	     */
	    PdfStreamWriter.prototype.setLineDashPattern = function (pattern, patternOffset) {
	        // let pat : PdfArray = new PdfArray(pattern);
	        // let off : PdfNumber = new PdfNumber(patternOffset);
	        // this.setLineDashPatternHelper(pat, off);
	        this.setLineDashPatternHelper(pattern, patternOffset);
	    };
	    /**
	     * Sets the `line dash pattern`.
	     * @private
	     */
	    PdfStreamWriter.prototype.setLineDashPatternHelper = function (pattern, patternOffset) {
	        var tempPattern = '[';
	        if (pattern.length > 1) {
	            for (var index = 0; index < pattern.length; index++) {
	                if (index === pattern.length - 1) {
	                    tempPattern += pattern[index].toString();
	                }
	                else {
	                    tempPattern += pattern[index].toString() + ' ';
	                }
	            }
	        }
	        tempPattern += '] ';
	        tempPattern += patternOffset.toString();
	        tempPattern += ' ' + Operators.setDashPattern;
	        this.stream.write(tempPattern);
	        this.stream.write(Operators.newLine);
	    };
	    /**
	     * Sets the `miter limit`.
	     * @private
	     */
	    PdfStreamWriter.prototype.setMiterLimit = function (miterLimit) {
	        this.stream.write(PdfNumber.floatToString(miterLimit));
	        this.stream.write(Operators.whiteSpace);
	        this.writeOperator(Operators.setMiterLimit);
	    };
	    /**
	     * Sets the `width of the line`.
	     * @private
	     */
	    PdfStreamWriter.prototype.setLineWidth = function (width) {
	        this.stream.write(PdfNumber.floatToString(width));
	        this.stream.write(Operators.whiteSpace);
	        this.writeOperator(Operators.setLineWidth);
	    };
	    /**
	     * Sets the `line cap`.
	     * @private
	     */
	    PdfStreamWriter.prototype.setLineCap = function (lineCapStyle) {
	        this.stream.write((lineCapStyle).toString());
	        this.stream.write(Operators.whiteSpace);
	        this.writeOperator(Operators.setLineCapStyle);
	    };
	    /**
	     * Sets the `line join`.
	     * @private
	     */
	    PdfStreamWriter.prototype.setLineJoin = function (lineJoinStyle) {
	        this.stream.write((lineJoinStyle).toString());
	        this.stream.write(Operators.whiteSpace);
	        this.writeOperator(Operators.setLineJoinStyle);
	    };
	    Object.defineProperty(PdfStreamWriter.prototype, "position", {
	        //IPdfWriter members
	        /**
	         * Gets or sets the current `position` within the stream.
	         * @private
	         */
	        get: function () {
	            return this.stream.position;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStreamWriter.prototype, "length", {
	        /**
	         * Gets `stream length`.
	         * @private
	         */
	        get: function () {
	            var returnValue = 0;
	            if (this.stream.data.length !== 0 && this.stream.data.length !== -1) {
	                for (var index = 0; index < this.stream.data.length; index++) {
	                    returnValue += this.stream.data[index].length;
	                }
	            }
	            return returnValue;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfStreamWriter.prototype, "document", {
	        /**
	         * Gets and Sets the `current document`.
	         * @private
	         */
	        get: function () {
	            return null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /* tslint:disable-next-line:max-line-length */
	    PdfStreamWriter.prototype.appendBezierSegment = function (arg1, arg2, arg3, arg4, arg5, arg6) {
	        if (arg1 instanceof PointF && arg2 instanceof PointF && arg3 instanceof PointF) {
	            this.writePoint(arg1.x, arg1.y);
	            this.writePoint(arg2.x, arg2.y);
	            this.writePoint(arg3.x, arg3.y);
	        }
	        else {
	            this.writePoint(arg1, arg2);
	            this.writePoint(arg3, arg4);
	            this.writePoint(arg5, arg6);
	        }
	        this.writeOperator(Operators.appendbeziercurve);
	    };
	    PdfStreamWriter.prototype.setColourWithPattern = function (colours, patternName, forStroking) {
	        if ((colours != null)) {
	            var count = colours.length;
	            var i = 0;
	            for (i = 0; i < count; ++i) {
	                this.stream.write(colours[i].toString());
	                this.stream.write(Operators.whiteSpace);
	            }
	        }
	        if ((patternName != null)) {
	            this.stream.write(patternName.toString());
	            this.stream.write(Operators.whiteSpace);
	        }
	        if (forStroking) {
	            this.writeOperator(Operators.setColorAndPatternStroking);
	        }
	        else {
	            this.writeOperator(Operators.setColorAndPattern);
	        }
	    };
	    return PdfStreamWriter;
	}());

	/**
	 * PdfPen.ts class for EJ2-PDF
	 */
	/**
	 * `PdfPen` class defining settings for drawing operations, that determines the color,
	 * width, and style of the drawing elements.
	 * ```typescript
	 * // create a new PDF document
	 * let document : PdfDocument = new PdfDocument();
	 * // create a new page
	 * let page1 : PdfPage = document.pages.add();
	 * // set pen
	 * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
	 * // draw rectangle
	 * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
	 * // save the document.
	 * document.save('output.pdf');
	 * // destroy the document
	 * document.destroy();
	 * ```
	 */
	var PdfPen = /** @class */ (function () {
	    function PdfPen(arg1, arg2) {
	        //Fields
	        /**
	         * Specifies the `color of the pen`.
	         * @default new PdfColor()
	         * @private
	         */
	        this.pdfColor = new PdfColor(0, 0, 0);
	        /**
	         * Specifies the `dash offset of the pen`.
	         * @default 0
	         * @private
	         */
	        this.dashOffsetValue = 0;
	        /**
	         * Specifies the `dash pattern of the pen`.
	         * @default [0]
	         * @private
	         */
	        this.penDashPattern = [0];
	        /**
	         * Specifies the `dash style of the pen`.
	         * @default Solid
	         * @private
	         */
	        this.pdfDashStyle = PdfDashStyle.Solid;
	        /**
	         * Specifies the `line cap of the pen`.
	         * @default 0
	         * @private
	         */
	        this.pdfLineCap = 0;
	        /**
	         * Specifies the `line join of the pen`.
	         * @default 0
	         * @private
	         */
	        this.pdfLineJoin = 0;
	        /**
	         * Specifies the `width of the pen`.
	         * @default 1.0
	         * @private
	         */
	        this.penWidth = 1.0;
	        /**
	         * Specifies the `mitter limit of the pen`.
	         * @default 0.0
	         * @private
	         */
	        this.internalMiterLimit = 0.0;
	        /**
	         * Stores the `colorspace` value.
	         * @default Rgb
	         * @private
	         */
	        this.colorSpace = PdfColorSpace.Rgb;
	        if (arg1 instanceof PdfBrush) {
	            this.setBrush(arg1);
	        }
	        else if (arg1 instanceof PdfColor) {
	            this.color = arg1;
	        }
	        if (typeof arg2 === 'number') {
	            this.width = arg2;
	        }
	    }
	    Object.defineProperty(PdfPen.prototype, "color", {
	        //Properties
	        /**
	         * Gets or sets the `color of the pen`.
	         * @private
	         */
	        get: function () {
	            return this.pdfColor;
	        },
	        set: function (value) {
	            this.pdfColor = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPen.prototype, "dashOffset", {
	        /**
	         * Gets or sets the `dash offset of the pen`.
	         * @private
	         */
	        get: function () {
	            if (typeof this.dashOffsetValue === 'undefined' || this.dashOffsetValue == null) {
	                return 0;
	            }
	            else {
	                return this.dashOffsetValue;
	            }
	        },
	        set: function (value) {
	            this.dashOffsetValue = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPen.prototype, "dashPattern", {
	        /**
	         * Gets or sets the `dash pattern of the pen`.
	         * @private
	         */
	        get: function () {
	            return this.penDashPattern;
	        },
	        set: function (value) {
	            this.penDashPattern = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPen.prototype, "dashStyle", {
	        /**
	         * Gets or sets the `dash style of the pen`.
	         * ```typescript
	         * // create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // create a new page
	         * let page1 : PdfPage = document.pages.add();
	         * // set pen
	         * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
	         * //
	         * // set pen style
	         * pen.dashStyle = PdfDashStyle.DashDot;
	         * // get pen style
	         * let style : PdfDashStyle = pen.dashStyle;
	         * //
	         * // draw rectangle
	         * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
	         * // save the document.
	         * document.save('output.pdf');
	         * // destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            return this.pdfDashStyle;
	        },
	        set: function (value) {
	            if (this.pdfDashStyle !== value) {
	                this.pdfDashStyle = value;
	                switch (this.pdfDashStyle) {
	                    case PdfDashStyle.Custom:
	                        break;
	                    case PdfDashStyle.Dash:
	                        this.penDashPattern = [3, 1];
	                        break;
	                    case PdfDashStyle.Dot:
	                        this.penDashPattern = [1, 1];
	                        break;
	                    case PdfDashStyle.DashDot:
	                        this.penDashPattern = [3, 1, 1, 1];
	                        break;
	                    case PdfDashStyle.DashDotDot:
	                        this.penDashPattern = [3, 1, 1, 1, 1, 1];
	                        break;
	                    case PdfDashStyle.Solid:
	                        break;
	                    default:
	                        this.pdfDashStyle = PdfDashStyle.Solid;
	                        this.penDashPattern = [0];
	                        break;
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPen.prototype, "lineCap", {
	        /**
	         * Gets or sets the `line cap of the pen`.
	         * @private
	         */
	        get: function () {
	            return this.pdfLineCap;
	        },
	        set: function (value) {
	            this.pdfLineCap = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPen.prototype, "lineJoin", {
	        /**
	         * Gets or sets the `line join style of the pen`.
	         * @private
	         */
	        get: function () {
	            return this.pdfLineJoin;
	        },
	        set: function (value) {
	            this.pdfLineJoin = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPen.prototype, "miterLimit", {
	        /**
	         * Gets or sets the `miter limit`.
	         * @private
	         */
	        get: function () {
	            return this.internalMiterLimit;
	        },
	        set: function (value) {
	            this.internalMiterLimit = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPen.prototype, "width", {
	        /**
	         * Gets or sets the `width of the pen`.
	         * ```typescript
	         * // create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // create a new page
	         * let page1 : PdfPage = document.pages.add();
	         * // set pen
	         * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
	         * //
	         * // set pen width
	         * pen.width = 2;
	         * //
	         * // draw rectangle
	         * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
	         * // save the document.
	         * document.save('output.pdf');
	         * // destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            return this.penWidth;
	        },
	        set: function (value) {
	            this.penWidth = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //Helper
	    /**
	     * `Clones` this instance of PdfPen class.
	     * @private
	     */
	    PdfPen.prototype.clone = function () {
	        var pen = this;
	        return pen;
	    };
	    /**
	     * `Sets the brush`.
	     * @private
	     */
	    PdfPen.prototype.setBrush = function (brush) {
	        var sBrush = brush;
	        if ((sBrush != null && sBrush instanceof PdfSolidBrush)) {
	            this.color = sBrush.color;
	            this.pdfBrush = sBrush;
	        }
	        this.color = sBrush.color;
	        this.pdfBrush = sBrush;
	    };
	    /**
	     * `Monitors the changes`.
	     * @private
	     */
	    PdfPen.prototype.monitorChanges = function (currentPen, streamWriter, getResources, saveState, currentColorSpace, matrix) {
	        var diff = false;
	        saveState = true;
	        if (currentPen == null) {
	            diff = true;
	        }
	        diff = this.dashControl(currentPen, saveState, streamWriter);
	        streamWriter.setLineWidth(this.width);
	        streamWriter.setLineJoin(this.lineJoin);
	        streamWriter.setLineCap(this.lineCap);
	        var miterLimit = this.miterLimit;
	        if (miterLimit > 0) {
	            streamWriter.setMiterLimit(miterLimit);
	            diff = true;
	        }
	        this.pdfBrush;
	        streamWriter.setColorAndSpace(this.color, currentColorSpace, true);
	        diff = true;
	        return diff;
	    };
	    /**
	     * `Controls the dash style` and behaviour of each line.
	     * @private
	     */
	    PdfPen.prototype.dashControl = function (pen, saveState, streamWriter) {
	        saveState = true;
	        var lineWidth = this.width;
	        var pattern = this.getPattern();
	        streamWriter.setLineDashPattern(pattern, this.dashOffset * lineWidth);
	        return saveState;
	    };
	    /**
	     * `Gets the pattern` of PdfPen.
	     * @private
	     */
	    PdfPen.prototype.getPattern = function () {
	        var pattern = this.dashPattern;
	        for (var i = 0; i < pattern.length; ++i) {
	            pattern[i] *= this.width;
	        }
	        return pattern;
	    };
	    return PdfPen;
	}());

	/**
	 * PdfTransformationMatrix.ts class for EJ2-PDF
	 */
	/**
	 * Class for representing Root `transformation matrix`.
	 */
	var PdfTransformationMatrix = /** @class */ (function () {
	    function PdfTransformationMatrix(value) {
	        /**
	         * Value for `angle converting`.
	         * @default 180.0 / Math.PI
	         * @private
	         */
	        this.radDegFactor = 180.0 / Math.PI;
	        if (typeof value === 'undefined') {
	            this.transformationMatrix = new Matrix(1.00, 0.00, 0.00, 1.00, 0.00, 0.00);
	        }
	        else {
	            this.transformationMatrix = new Matrix(1.00, 0.00, 0.00, -1.00, 0.00, 0.00);
	        }
	    }
	    Object.defineProperty(PdfTransformationMatrix.prototype, "matrix", {
	        // Properties
	        /**
	         * Gets or sets the `internal matrix object`.
	         * @private
	         */
	        get: function () {
	            return this.transformationMatrix;
	        },
	        set: function (value) {
	            this.transformationMatrix = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    // Public methods
	    /**
	     * `Translates` coordinates by specified coordinates.
	     * @private
	     */
	    PdfTransformationMatrix.prototype.translate = function (offsetX, offsetY) {
	        this.transformationMatrix.translate(offsetX, offsetY);
	    };
	    /**
	     * `Scales` coordinates by specified coordinates.
	     * @private
	     */
	    PdfTransformationMatrix.prototype.scale = function (scaleX, scaleY) {
	        this.transformationMatrix.elements[0] = scaleX;
	        this.transformationMatrix.elements[3] = scaleY;
	    };
	    /**
	     * `Rotates` coordinate system in counterclockwise direction.
	     * @private
	     */
	    PdfTransformationMatrix.prototype.rotate = function (angle) {
	        //Convert from degree to radian 
	        angle = (angle * Math.PI) / 180;
	        //Rotation 
	        this.transformationMatrix.elements[0] = Math.cos(angle);
	        this.transformationMatrix.elements[1] = Math.sin(angle);
	        this.transformationMatrix.elements[2] = -Math.sin(angle);
	        this.transformationMatrix.elements[3] = Math.cos(angle);
	    };
	    // Overrides
	    /**
	     * Gets `PDF representation`.
	     * @private
	     */
	    PdfTransformationMatrix.prototype.toString = function () {
	        var builder = '';
	        var whitespace = ' ';
	        for (var i = 0, len = this.transformationMatrix.elements.length; i < len; i++) {
	            this.matrix.elements[i];
	            builder += PdfNumber.floatToString(this.transformationMatrix.elements[i]);
	            builder += whitespace;
	        }
	        return builder;
	    };
	    // Implementation
	    /**
	     * `Multiplies` matrices (changes coordinate system.)
	     * @private
	     */
	    PdfTransformationMatrix.prototype.multiply = function (matrix) {
	        this.transformationMatrix.multiply(matrix.matrix);
	    };
	    /**
	     * Converts `degrees to radians`.
	     * @private
	     */
	    PdfTransformationMatrix.degreesToRadians = function (degreesX) {
	        return this.degRadFactor * degreesX;
	    };
	    /**
	     * Converts `radians to degrees`.
	     * @private
	     */
	    PdfTransformationMatrix.prototype.radiansToDegrees = function (radians) {
	        return this.radDegFactor * radians;
	    };
	    /**
	     * `Clones` this instance of PdfTransformationMatrix.
	     * @private
	     */
	    PdfTransformationMatrix.prototype.clone = function () {
	        return this;
	    };
	    // Constants
	    /**
	     * Value for `angle converting`.
	     * @default Math.PI / 180.0
	     * @private
	     */
	    PdfTransformationMatrix.degRadFactor = Math.PI / 180.0;
	    return PdfTransformationMatrix;
	}());
	var Matrix = /** @class */ (function () {
	    function Matrix(arg1, arg2, arg3, arg4, arg5, arg6) {
	        if (typeof arg1 === 'undefined') {
	            this.metrixElements = [];
	        }
	        else if (typeof arg1 === 'number') {
	            this.metrixElements = [];
	            this.metrixElements.push(arg1);
	            this.metrixElements.push(arg2);
	            this.metrixElements.push(arg3);
	            this.metrixElements.push(arg4);
	            this.metrixElements.push(arg5);
	            this.metrixElements.push(arg6);
	        }
	        else {
	            this.metrixElements = arg1;
	        }
	    }
	    Object.defineProperty(Matrix.prototype, "elements", {
	        // Properties
	        /**
	         * Gets the `elements`.
	         * @private
	         */
	        get: function () {
	            return this.metrixElements;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Matrix.prototype, "offsetX", {
	        /**
	         * Gets the off set `X`.
	         * @private
	         */
	        get: function () {
	            return this.metrixElements[4];
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Matrix.prototype, "offsetY", {
	        /**
	         * Gets the off set `Y`.
	         * @private
	         */
	        get: function () {
	            return this.metrixElements[5];
	        },
	        enumerable: true,
	        configurable: true
	    });
	    // Implementation
	    /**
	     * `Translates` coordinates by specified coordinates.
	     * @private
	     */
	    Matrix.prototype.translate = function (offsetX, offsetY) {
	        this.metrixElements[4] = offsetX;
	        this.metrixElements[5] = offsetY;
	    };
	    /**
	     * `Translates` the specified offset X.
	     * @private
	     */
	    Matrix.prototype.transform = function (point) {
	        var x = point.x;
	        var y = point.y;
	        var x2 = x * this.elements[0] + y * this.elements[2] + this.offsetX;
	        var y2 = x * this.elements[1] + y * this.elements[3] + this.offsetY;
	        return new PointF(x2, y2);
	    };
	    /**
	     * `Multiplies matrices` (changes coordinate system.)
	     * @private
	     */
	    Matrix.prototype.multiply = function (matrix) {
	        var tempMatrix = [];
	        tempMatrix.push(this.elements[0] * matrix.elements[0] + this.elements[1] * matrix.elements[2]);
	        tempMatrix[1] = (this.elements[0] * matrix.elements[1] + this.elements[1] * matrix.elements[3]);
	        tempMatrix[2] = (this.elements[2] * matrix.elements[0] + this.elements[3] * matrix.elements[2]);
	        tempMatrix[3] = (this.elements[2] * matrix.elements[1] + this.elements[3] * matrix.elements[3]);
	        tempMatrix[4] = (this.offsetX * matrix.elements[0] + this.offsetY * matrix.elements[2] + matrix.offsetX);
	        tempMatrix[5] = (this.offsetX * matrix.elements[1] + this.offsetY * matrix.elements[3] + matrix.offsetY);
	        for (var i = 0; i < tempMatrix.length; i++) {
	            this.elements[i] = tempMatrix[i];
	        }
	    };
	    // IDisposable Members
	    /**
	     * `Dispose` this instance of PdfTransformationMatrix class.
	     * @private
	     */
	    Matrix.prototype.dispose = function () {
	        this.metrixElements = null;
	    };
	    // ICloneable Members
	    /**
	     * `Clones` this instance of PdfTransformationMatrix class.
	     * @private
	     */
	    Matrix.prototype.clone = function () {
	        var m = new Matrix(this.metrixElements);
	        return m;
	    };
	    return Matrix;
	}());

	/**
	 * `constants.ts` class for EJ2-PDF
	 * @private
	 */
	var ProcedureSets = /** @class */ (function () {
	    function ProcedureSets() {
	        /**
	         * Specifies the `PDF` procedure set.
	         * @private
	         */
	        this.pdf = 'PDF';
	        /**
	         * Specifies the `Text` procedure set.
	         * @private
	         */
	        this.text = 'Text';
	        /**
	         * Specifies the `ImageB` procedure set.
	         * @private
	         */
	        this.imageB = 'ImageB';
	        /**
	         * Specifies the `ImageC` procedure set.
	         * @private
	         */
	        this.imageC = 'ImageC';
	        /**
	         * Specifies the `ImageI` procedure set.
	         * @private
	         */
	        this.imageI = 'ImageI';
	    }
	    return ProcedureSets;
	}());

	/**
	 * Dictionary class
	 * @private
	 * @hidden
	 */
	var TemporaryDictionary = /** @class */ (function () {
	    function TemporaryDictionary() {
	        /**
	         * @hidden
	         * @private
	         */
	        this.mKeys = [];
	        /**
	         * @hidden
	         * @private
	         */
	        this.mValues = [];
	    }
	    /**
	     * @hidden
	     * @private
	     */
	    TemporaryDictionary.prototype.size = function () {
	        return this.mKeys.length;
	    };
	    /**
	     * @hidden
	     * @private
	     */
	    TemporaryDictionary.prototype.add = function (key, value) {
	        if (key === undefined || key === null || value === undefined || value === null) {
	            throw new ReferenceError('Provided key or value is not valid.');
	        }
	        var index = this.mKeys.indexOf(key);
	        if (index < 0) {
	            this.mKeys.push(key);
	            this.mValues.push(value);
	            return 1;
	        }
	        else {
	            throw new RangeError('An item with the same key has already been added.');
	        }
	    };
	    /**
	     * @hidden
	     * @private
	     */
	    TemporaryDictionary.prototype.keys = function () {
	        return this.mKeys;
	    };
	    /**
	     * @hidden
	     * @private
	     */
	    TemporaryDictionary.prototype.values = function () {
	        return this.mValues;
	    };
	    /**
	     * @hidden
	     * @private
	     */
	    TemporaryDictionary.prototype.getValue = function (key) {
	        if (key === undefined || key === null) {
	            throw new ReferenceError('Provided key is not valid.');
	        }
	        var index = this.mKeys.indexOf(key);
	        if (index < 0) {
	            throw new RangeError('No item with the specified key has been added.');
	        }
	        else {
	            return this.mValues[index];
	        }
	    };
	    /**
	     * @hidden
	     * @private
	     */
	    TemporaryDictionary.prototype.setValue = function (key, value) {
	        if (key === undefined || key === null) {
	            throw new ReferenceError('Provided key is not valid.');
	        }
	        var index = this.mKeys.indexOf(key);
	        if (index < 0) {
	            this.mKeys.push(key);
	            this.mValues.push(value);
	        }
	        else {
	            this.mValues[index] = value;
	        }
	    };
	    /**
	     * @hidden
	     * @private
	     */
	    TemporaryDictionary.prototype.remove = function (key) {
	        if (key === undefined || key === null) {
	            throw new ReferenceError('Provided key is not valid.');
	        }
	        var index = this.mKeys.indexOf(key);
	        if (index < 0) {
	            throw new RangeError('No item with the specified key has been added.');
	        }
	        else {
	            this.mKeys.splice(index, 1);
	            this.mValues.splice(index, 1);
	            return true;
	        }
	    };
	    /**
	     * @hidden
	     * @private
	     */
	    TemporaryDictionary.prototype.containsKey = function (key) {
	        if (key === undefined || key === null) {
	            throw new ReferenceError('Provided key is not valid.');
	        }
	        var index = this.mKeys.indexOf(key);
	        if (index < 0) {
	            return false;
	        }
	        return true;
	    };
	    /**
	     * @hidden
	     * @private
	     */
	    TemporaryDictionary.prototype.clear = function () {
	        this.mKeys = [];
	        this.mValues = [];
	    };
	    return TemporaryDictionary;
	}());

	/**
	 * Represents a simple `transparency`.
	 * @private
	 */
	var PdfTransparency = /** @class */ (function () {
	    // Properties
	    // /**
	    //  * Gets the `stroke` operation alpha value.
	    //  * @private
	    //  */
	    // public get stroke() : number {
	    //     let result : number = this.getNumber(this.dictionaryProperties.CA);
	    //     return result;
	    // }
	    // /**
	    //  * Gets the `fill` operation alpha value.
	    //  * @private
	    //  */
	    // public get fill() : number {
	    //     let result : number = this.getNumber(this.dictionaryProperties.ca);
	    //     return result;
	    // }
	    // /**
	    //  * Gets the `blend mode`.
	    //  * @private
	    //  */
	    // public get mode() : PdfBlendMode {
	    //     let result : string = this.getName(this.dictionaryProperties.ca);
	    //     return PdfBlendMode.Normal;
	    // }
	    // Constructors
	    /**
	     * Initializes a new instance of the `Transparency` class.
	     * @private
	     */
	    function PdfTransparency(stroke, fill, mode) {
	        // Fields
	        /**
	         * Internal variable to store `dictionary`.
	         * @default new PdfDictionary()
	         * @private
	         */
	        this.dictionary = new PdfDictionary();
	        /**
	         * Internal variable for accessing fields from `DictionryProperties` class.
	         * @default new DictionaryProperties()
	         * @private
	         */
	        this.dictionaryProperties = new DictionaryProperties();
	        this.dictionary.items.setValue(this.dictionaryProperties.CA, new PdfNumber(stroke));
	        this.dictionary.items.setValue(this.dictionaryProperties.ca, new PdfNumber(fill));
	        this.dictionary.items.setValue(this.dictionaryProperties.BM, new PdfName(mode.toString()));
	    }
	    Object.defineProperty(PdfTransparency.prototype, "element", {
	        // // Implementation
	        // /**
	        //  * Gets the `number value`.
	        //  * @private
	        //  */
	        // private getNumber(keyName : string) : number {
	        //     let result : number = 0.0;
	        //     let numb : PdfNumber = this.dictionary.items.getValue(keyName) as PdfNumber;
	        //     result = numb.intValue;
	        //     return result;
	        // }
	        // /**
	        //  * Gets the `name value`.
	        //  * @private
	        //  */
	        // private getName(keyName : string) : string {
	        //     let result : string = null;
	        //     let name : PdfName = this.dictionary.items.getValue(keyName) as PdfName;
	        //     result = name.value;
	        //     return result;
	        // }
	        // IPdfWrapper Members
	        /**
	         * Gets the `element`.
	         * @private
	         */
	        get: function () {
	            return this.dictionary;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PdfTransparency;
	}());

	/**
	 * Represent a `collection of automatic fields information`.
	 * @private
	 */
	var PdfAutomaticFieldInfoCollection = /** @class */ (function () {
	    /**
	     * Initializes a new instance of the 'PdfPageNumberFieldInfoCollection' class.
	     * @private
	     */
	    function PdfAutomaticFieldInfoCollection() {
	        /**
	         * Internal variable to store instance of `pageNumberFields` class.
	         * @private
	         */
	        this.automaticFieldsInformation = [];
	        //
	    }
	    Object.defineProperty(PdfAutomaticFieldInfoCollection.prototype, "automaticFields", {
	        /**
	         * Gets the `page number fields collection`.
	         * @private
	         */
	        get: function () {
	            return this.automaticFieldsInformation;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    // Public methods
	    /// Adds the specified field info.
	    /**
	     * Add page number field into collection.
	     * @private
	     */
	    PdfAutomaticFieldInfoCollection.prototype.add = function (fieldInfo) {
	        return this.automaticFields.push(fieldInfo);
	    };
	    return PdfAutomaticFieldInfoCollection;
	}());

	/**
	 * Represents a base class for all page graphics elements.
	 */
	var PdfGraphicsElement = /** @class */ (function () {
	    // Constructors
	    function PdfGraphicsElement() {
	        //
	    }
	    /**
	     * `Draws` the page number field.
	     * @public
	     */
	    PdfGraphicsElement.prototype.drawHelper = function (graphics, x, y) {
	        var bNeedSave = (x !== 0 || y !== 0);
	        var gState = null;
	        // Translate co-ordinates.
	        if (bNeedSave) {
	            // Save state.
	            gState = graphics.save();
	            graphics.translateTransform(x, y);
	        }
	        this.drawInternal(graphics);
	        if (bNeedSave) {
	            // Restore state.
	            graphics.restore(gState);
	        }
	    };
	    return PdfGraphicsElement;
	}());

	var __extends$o = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Represents a fields which is calculated before the document saves.
	 */
	var PdfAutomaticField = /** @class */ (function (_super) {
	    __extends$o(PdfAutomaticField, _super);
	    // Constructors
	    function PdfAutomaticField() {
	        var _this = _super.call(this) || this;
	        // Fields
	        _this.internalBounds = new RectangleF(0, 0, 0, 0);
	        _this.internalTemplateSize = new SizeF(0, 0);
	        return _this;
	    }
	    Object.defineProperty(PdfAutomaticField.prototype, "bounds", {
	        // Properties
	        get: function () {
	            return this.internalBounds;
	        },
	        set: function (value) {
	            this.internalBounds = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfAutomaticField.prototype, "size", {
	        get: function () {
	            return new SizeF(this.bounds.width, this.bounds.height);
	        },
	        set: function (value) {
	            this.bounds.width = value.width;
	            this.bounds.height = value.height;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfAutomaticField.prototype, "location", {
	        get: function () {
	            return new PointF(this.bounds.x, this.bounds.y);
	        },
	        set: function (value) {
	            this.bounds.x = value.x;
	            this.bounds.y = value.y;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfAutomaticField.prototype, "font", {
	        get: function () {
	            return this.internalFont;
	        },
	        set: function (value) {
	            this.internalFont = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfAutomaticField.prototype, "brush", {
	        get: function () {
	            return this.internalBrush;
	        },
	        set: function (value) {
	            this.internalBrush = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfAutomaticField.prototype, "pen", {
	        get: function () {
	            return this.internalPen;
	        },
	        set: function (value) {
	            this.internalPen = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfAutomaticField.prototype, "stringFormat", {
	        get: function () {
	            return this.internalStringFormat;
	        },
	        set: function (value) {
	            this.internalStringFormat = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PdfAutomaticField.prototype.performDrawHelper = function (graphics, location, scalingX, scalingY) {
	        if (this.bounds.height === 0 || this.bounds.width === 0) {
	            var text = this.getValue(graphics);
	            this.internalTemplateSize = this.getFont().measureString(text, this.size, this.stringFormat);
	        }
	    };
	    PdfAutomaticField.prototype.draw = function (arg1, arg2, arg3) {
	        if (typeof arg2 === 'undefined') {
	            var location_1 = new PointF(0, 0);
	            this.draw(arg1, location_1);
	        }
	        else if (arg2 instanceof PointF) {
	            this.draw(arg1, arg2.x, arg2.y);
	        }
	        else {
	            this.drawHelper(arg1, arg2, arg3);
	            var info = new PdfAutomaticFieldInfo(this, new PointF(arg2, arg3));
	            arg1.automaticFields.add(info);
	        }
	    };
	    PdfAutomaticField.prototype.getSize = function () {
	        if (this.bounds.height === 0 || this.bounds.width === 0) {
	            return this.internalTemplateSize;
	        }
	        else {
	            return this.size;
	        }
	    };
	    PdfAutomaticField.prototype.drawInternal = function (graphics) {
	        //
	    };
	    /* tslint:disable */
	    PdfAutomaticField.prototype.getBrush = function () {
	        return (typeof this.internalBrush === 'undefined' || this.internalBrush == null) ? new PdfSolidBrush(new PdfColor(0, 0, 0)) : this.internalBrush;
	    };
	    PdfAutomaticField.prototype.getFont = function () {
	        return (typeof this.internalFont === 'undefined' || this.internalFont == null) ? PdfDocument.defaultFont : this.internalFont;
	    };
	    /* tslint:enable */
	    PdfAutomaticField.prototype.getPageFromGraphics = function (graphics) {
	        if (typeof graphics.page !== 'undefined' && graphics.page !== null) {
	            var page = graphics.page;
	            return page;
	        }
	        else {
	            var page = graphics.currentPage;
	            return page;
	        }
	    };
	    return PdfAutomaticField;
	}(PdfGraphicsElement));

	/**
	 * PdfAutomaticFieldInfo.ts class for EJ2-PDF
	 * @private
	 */
	/**
	 * Represents information about the automatic field.
	 * @private
	 */
	var PdfAutomaticFieldInfo = /** @class */ (function () {
	    function PdfAutomaticFieldInfo(field, location, scaleX, scaleY) {
	        // Fields
	        /**
	         * Internal variable to store location of the field.
	         * @private
	         */
	        this.pageNumberFieldLocation = new PointF();
	        /**
	         * Internal variable to store field.
	         * @private
	         */
	        this.pageNumberField = null;
	        /**
	         * Internal variable to store x scaling factor.
	         * @private
	         */
	        this.scaleX = 1;
	        /**
	         * Internal variable to store y scaling factor.
	         * @private
	         */
	        this.scaleY = 1;
	        if (typeof location === 'undefined' && field instanceof PdfAutomaticFieldInfo) {
	            this.pageNumberField = field.field;
	            this.pageNumberFieldLocation = field.location;
	            this.scaleX = field.scalingX;
	            this.scaleY = field.scalingY;
	        }
	        else if (typeof scaleX === 'undefined' && location instanceof PointF && field instanceof PdfAutomaticField) {
	            this.pageNumberField = field;
	            this.pageNumberFieldLocation = location;
	        }
	        else {
	            this.pageNumberField = field;
	            this.pageNumberFieldLocation = location;
	            this.scaleX = scaleX;
	            this.scaleY = scaleY;
	        }
	    }
	    Object.defineProperty(PdfAutomaticFieldInfo.prototype, "location", {
	        /* tslint:enable */
	        // Properties
	        /**
	         * Gets or sets the location.
	         * @private
	         */
	        get: function () {
	            return this.pageNumberFieldLocation;
	        },
	        set: function (value) {
	            this.pageNumberFieldLocation = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfAutomaticFieldInfo.prototype, "field", {
	        /**
	         * Gets or sets the field.
	         * @private
	         */
	        get: function () {
	            return this.pageNumberField;
	        },
	        set: function (value) {
	            this.pageNumberField = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfAutomaticFieldInfo.prototype, "scalingX", {
	        /**
	         * Gets or sets the scaling X factor.
	         * @private
	         */
	        get: function () {
	            return this.scaleX;
	        },
	        set: function (value) {
	            this.scaleX = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfAutomaticFieldInfo.prototype, "scalingY", {
	        /**
	         * Gets or sets the scaling Y factor.
	         * @private
	         */
	        get: function () {
	            return this.scaleY;
	        },
	        set: function (value) {
	            this.scaleY = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PdfAutomaticFieldInfo;
	}());

	/**
	 * ByteArray class
	 * Used to keep information about image stream as byte array.
	 * @private
	 */
	var ByteArray = /** @class */ (function () {
	    /**
	     * Initialize the new instance for `byte-array` class
	     * @hidden
	     * @private
	     */
	    function ByteArray(length) {
	        /**
	         * Current stream `position`.
	         * @default 0
	         * @private
	         */
	        this.mPosition = 0;
	        this.buffer = new Uint8Array(length);
	        this.dataView = new DataView(this.buffer.buffer);
	    }
	    Object.defineProperty(ByteArray.prototype, "position", {
	        /**
	         * Gets and Sets a current `position` of byte array.
	         * @hidden
	         * @private
	         */
	        get: function () {
	            return this.mPosition;
	        },
	        set: function (value) {
	            this.mPosition = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * `Read` from current stream position.
	     * @default 0
	     * @hidden
	     * @private
	     */
	    ByteArray.prototype.read = function (buffer, offset, count) {
	        for (var index = offset; index < count; index++) {
	            var position = this.position;
	            buffer.buffer[index] = this.readByte(position);
	            this.position++;
	        }
	    };
	    /**
	     * @hidden
	     */
	    ByteArray.prototype.getBuffer = function (index) {
	        return this.buffer[index];
	    };
	    /**
	     * @hidden
	     */
	    ByteArray.prototype.writeFromBase64String = function (base64) {
	        var arr = this.encodedString(base64);
	        this.buffer = arr;
	    };
	    /**
	     * @hidden
	     */
	    ByteArray.prototype.encodedString = function (input) {
	        var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	        var chr1;
	        var chr2;
	        var chr3;
	        var enc1;
	        var enc2;
	        var enc3;
	        var enc4;
	        var i = 0;
	        var resultIndex = 0;
	        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
	        var totalLength = input.length * 3 / 4;
	        if (input.charAt(input.length - 1) === keyStr.charAt(64)) {
	            totalLength--;
	        }
	        var output = new Uint8Array(totalLength | 0);
	        while (i < input.length) {
	            enc1 = keyStr.indexOf(input.charAt(i++));
	            enc2 = keyStr.indexOf(input.charAt(i++));
	            enc3 = keyStr.indexOf(input.charAt(i++));
	            enc4 = keyStr.indexOf(input.charAt(i++));
	            chr1 = (enc1 << 2) | (enc2 >> 4);
	            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
	            chr3 = ((enc3 & 3) << 6) | enc4;
	            output[resultIndex++] = chr1;
	            output[resultIndex++] = chr2;
	            output[resultIndex++] = chr3;
	        }
	        return output;
	    };
	    /**
	     * @hidden
	     */
	    ByteArray.prototype.readByte = function (offset) {
	        return (this.buffer[offset]);
	    };
	    Object.defineProperty(ByteArray.prototype, "internalBuffer", {
	        /**
	         * @hidden
	         */
	        get: function () {
	            return this.buffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ByteArray.prototype, "count", {
	        /**
	         * @hidden
	         */
	        get: function () {
	            return this.buffer.byteLength;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * 'readNextTwoBytes' stream
	     * @hidden
	     * @private
	     */
	    ByteArray.prototype.readNextTwoBytes = function (stream) {
	        var data = stream.readByte(this.position);
	        this.position++;
	        data <<= 8;
	        data |= stream.readByte(this.position);
	        this.position++;
	        return data;
	    };
	    return ByteArray;
	}());

	/**
	 * ImageDecoder class
	 */
	/**
	 * Specifies the image `format`.
	 * @private
	 */
	var ImageFormat;
	(function (ImageFormat) {
	    /**
	     * Specifies the type of `Unknown`.
	     * @hidden
	     * @private
	     */
	    ImageFormat[ImageFormat["Unknown"] = 0] = "Unknown";
	    /**
	     * Specifies the type of `Bmp`.
	     * @hidden
	     * @private
	     */
	    ImageFormat[ImageFormat["Bmp"] = 1] = "Bmp";
	    /**
	     * Specifies the type of `Emf`.
	     * @hidden
	     * @private
	     */
	    ImageFormat[ImageFormat["Emf"] = 2] = "Emf";
	    /**
	     * Specifies the type of `Gif`.
	     * @hidden
	     * @private
	     */
	    ImageFormat[ImageFormat["Gif"] = 3] = "Gif";
	    /**
	     * Specifies the type of `Jpeg`.
	     * @hidden
	     * @private
	     */
	    ImageFormat[ImageFormat["Jpeg"] = 4] = "Jpeg";
	    /**
	     * Specifies the type of `Png`.
	     * @hidden
	     * @private
	     */
	    ImageFormat[ImageFormat["Png"] = 5] = "Png";
	    /**
	     * Specifies the type of `Wmf`.
	     * @hidden
	     * @private
	     */
	    ImageFormat[ImageFormat["Wmf"] = 6] = "Wmf";
	    /**
	     * Specifies the type of `Icon`.
	     * @hidden
	     * @private
	     */
	    ImageFormat[ImageFormat["Icon"] = 7] = "Icon";
	})(ImageFormat || (ImageFormat = {}));
	/**
	 * `Decode the image stream`.
	 * @private
	 */
	var ImageDecoder = /** @class */ (function () {
	    /**
	     * Initialize the new instance for `image-decoder` class.
	     * @private
	     */
	    function ImageDecoder(stream) {
	        /**
	         * Start of file markers.
	         * @hidden
	         * @private
	         */
	        this.sof1Marker = 0x00C1;
	        this.sof2Marker = 0x00C2;
	        this.sof3Marker = 0x00C3;
	        this.sof5Marker = 0x00C5;
	        this.sof6Marker = 0x00C6;
	        this.sof7Marker = 0x00C7;
	        this.sof9Marker = 0x00C9;
	        this.sof10Marker = 0x00CA;
	        this.sof11Marker = 0x00CB;
	        this.sof13Marker = 0x00CD;
	        this.sof14Marker = 0x00CE;
	        this.sof15Marker = 0x00CF;
	        /**
	         * Specifies `format` of image.
	         * @hidden
	         * @private
	         */
	        this.mFormat = ImageFormat.Unknown;
	        /**
	         * `Bits per component`.
	         * @default 8
	         * @hidden
	         * @private
	         */
	        this.mbitsPerComponent = 8;
	        /**
	         * Internal variable for accessing fields from `DictionryProperties` class.
	         * @hidden
	         * @private
	         */
	        this.dictionaryProperties = new DictionaryProperties();
	        this.mStream = stream;
	        this.initialize();
	    }
	    Object.defineProperty(ImageDecoder.prototype, "height", {
	        /**
	         * Gets the `height` of image.
	         * @hidden
	         * @private
	         */
	        get: function () {
	            return this.mHeight;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ImageDecoder.prototype, "width", {
	        /**
	         * Gets the `width` of image.
	         * @hidden
	         * @private
	         */
	        get: function () {
	            return this.mWidth;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ImageDecoder.prototype, "bitsPerComponent", {
	        /**
	         * Gets `bits per component`.
	         * @hidden
	         * @private
	         */
	        get: function () {
	            return this.mbitsPerComponent;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ImageDecoder.prototype, "size", {
	        /**
	         * Gets the `size` of an image data.
	         * @hidden
	         * @private
	         */
	        get: function () {
	            return this.mImageData.count;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ImageDecoder.prototype, "imageData", {
	        /**
	         * Gets the value of an `image data`.
	         * @hidden
	         * @private
	         */
	        get: function () {
	            return this.mImageData;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ImageDecoder.prototype, "imageDataAsNumberArray", {
	        /**
	         * Gets the value of an `image data as number array`.
	         * @hidden
	         * @private
	         */
	        get: function () {
	            return this.mImageData.internalBuffer.buffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * `Initialize` image data and image stream.
	     * @hidden
	     * @private
	     */
	    ImageDecoder.prototype.initialize = function () {
	        if (this.mFormat === ImageFormat.Unknown && this.checkIfJpeg()) {
	            this.mFormat = ImageFormat.Jpeg;
	            this.parseJpegImage();
	        }
	        else {
	            throw new TypeError('Only the JPEG format is supported');
	        }
	        this.reset();
	        this.mImageData = new ByteArray(this.mStream.count);
	        this.mStream.read(this.mImageData, 0, this.mImageData.count);
	    };
	    /**
	     * `Reset` stream position into 0.
	     * @hidden
	     * @private
	     */
	    ImageDecoder.prototype.reset = function () {
	        this.mStream.position = 0;
	    };
	    /**
	     * `Parse` Jpeg image.
	     * @hidden
	     * @private
	     */
	    ImageDecoder.prototype.parseJpegImage = function () {
	        this.reset();
	        var imgData = new ByteArray(this.mStream.count);
	        this.mStream.read(imgData, 0, imgData.count);
	        var i = 4;
	        var isLengthExceed = false;
	        /* tslint:disable */
	        var length = imgData.getBuffer(i) * 256 + imgData.getBuffer(i + 1);
	        while (i < imgData.count) {
	            i += length;
	            if (i < imgData.count) {
	                if (imgData.getBuffer(i + 1) === 192) {
	                    this.mHeight = imgData.getBuffer(i + 5) * 256 + imgData.getBuffer(i + 6);
	                    this.mWidth = imgData.getBuffer(i + 7) * 256 + imgData.getBuffer(i + 8);
	                    return;
	                }
	                else {
	                    i += 2;
	                    length = imgData.getBuffer(i) * 256 + imgData.getBuffer(i + 1);
	                }
	            }
	            else {
	                isLengthExceed = true;
	                break;
	            }
	        }
	        if (isLengthExceed) {
	            this.mStream.position = 0;
	            this.skip(this.mStream, 2);
	            this.readExceededJPGImage(this.mStream);
	        }
	        /* tslint:enable */
	    };
	    Object.defineProperty(ImageDecoder.prototype, "format", {
	        /**
	         * Gets the image `format`.
	         * @private
	         * @hidden
	         */
	        get: function () {
	            return this.mFormat;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * `Checks if JPG`.
	     * @private
	     * @hidden
	     */
	    ImageDecoder.prototype.checkIfJpeg = function () {
	        this.reset();
	        for (var i = 0; i < ImageDecoder.mJpegHeader.length; i++) {
	            if (ImageDecoder.mJpegHeader[i] !== this.mStream.readByte(i)) {
	                return false;
	            }
	            this.mStream.position++;
	        }
	        return true;
	    };
	    /**
	     * Return image `dictionary`.
	     * @hidden
	     * @private
	     */
	    ImageDecoder.prototype.getImageDictionary = function () {
	        if (this.mFormat === ImageFormat.Jpeg) {
	            this.imageData.internalBuffer.length;
	            this.imageStream = new PdfStream();
	            this.imageStream.isResource = true;
	            var tempString = '';
	            var decodedString = '';
	            for (var i = 0; i < this.imageDataAsNumberArray.byteLength; i++) {
	                tempString += String.fromCharCode(null, this.mStream.readByte(i));
	            }
	            for (var i = 0; i < tempString.length; i++) {
	                if (i % 2 !== 0) {
	                    decodedString += tempString[i];
	                }
	            }
	            this.imageStream.data = [decodedString];
	            this.imageStream.compress = false;
	            this.imageStream.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.xObject));
	            this.imageStream.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.image));
	            this.imageStream.items.setValue(this.dictionaryProperties.width, new PdfNumber(this.width));
	            this.imageStream.items.setValue(this.dictionaryProperties.height, new PdfNumber(this.height));
	            this.imageStream.items.setValue(this.dictionaryProperties.bitsPerComponent, new PdfNumber(this.bitsPerComponent));
	            this.imageStream.items.setValue(this.dictionaryProperties.filter, new PdfName(this.dictionaryProperties.dctdecode));
	            this.imageStream.items.setValue(this.dictionaryProperties.colorSpace, new PdfName(this.getColorSpace()));
	            this.imageStream.items.setValue(this.dictionaryProperties.decodeParms, this.getDecodeParams());
	            return this.imageStream;
	        }
	        else {
	            return this.imageStream;
	        }
	    };
	    /**
	     * Return `colorSpace` of an image.
	     * @hidden
	     * @private
	     */
	    ImageDecoder.prototype.getColorSpace = function () {
	        return this.dictionaryProperties.deviceRgb;
	    };
	    /**
	     * Return `decode parameters` of an image.
	     * @hidden
	     * @private
	     */
	    ImageDecoder.prototype.getDecodeParams = function () {
	        var decodeParams = new PdfDictionary();
	        decodeParams.items.setValue(this.dictionaryProperties.columns, new PdfNumber(this.width));
	        decodeParams.items.setValue(this.dictionaryProperties.blackIs1, new PdfBoolean(true));
	        decodeParams.items.setValue(this.dictionaryProperties.k, new PdfNumber(-1));
	        decodeParams.items.setValue(this.dictionaryProperties.predictor, new PdfNumber(15));
	        decodeParams.items.setValue(this.dictionaryProperties.bitsPerComponent, new PdfNumber(this.bitsPerComponent));
	        return decodeParams;
	    };
	    /**
	     * 'readExceededJPGImage' stream
	     * @hidden
	     * @private
	     */
	    ImageDecoder.prototype.readExceededJPGImage = function (stream) {
	        this.mStream = stream;
	        var isContinueReading = true;
	        while (isContinueReading) {
	            var marker = this.getMarker(stream);
	            switch (marker) {
	                case this.sof1Marker:
	                case this.sof2Marker:
	                case this.sof3Marker:
	                case this.sof5Marker:
	                case this.sof6Marker:
	                case this.sof7Marker:
	                case this.sof9Marker:
	                case this.sof10Marker:
	                case this.sof11Marker:
	                case this.sof13Marker:
	                case this.sof14Marker:
	                case this.sof15Marker:
	                    stream.position += 3;
	                    this.mHeight = this.mStream.readNextTwoBytes(stream);
	                    this.mWidth = this.mStream.readNextTwoBytes(stream);
	                    isContinueReading = false;
	                    break;
	                default:
	                    this.skipStream(stream);
	                    break;
	            }
	        }
	    };
	    /**
	     * 'skip' stream
	     * @hidden
	     * @private
	     */
	    ImageDecoder.prototype.skip = function (stream, noOfBytes) {
	        this.mStream = stream;
	        var temp = new ByteArray(noOfBytes);
	        this.mStream.read(temp, 0, temp.count);
	    };
	    /**
	     * 'getMarker' stream
	     * @hidden
	     * @private
	     */
	    ImageDecoder.prototype.getMarker = function (stream) {
	        var marker = 32;
	        marker = stream.readByte(this.mStream.position);
	        stream.position++;
	        while (marker !== 255) {
	            marker = stream.readByte(this.mStream.position);
	            stream.position++;
	        }
	        do {
	            marker = stream.readByte(this.mStream.position);
	            stream.position++;
	        } while (marker === 255);
	        return marker;
	    };
	    /**
	     * 'skipStream' stream
	     * @hidden
	     * @private
	     */
	    ImageDecoder.prototype.skipStream = function (stream) {
	        var markerLength = this.mStream.readNextTwoBytes(stream) - 2;
	        if (markerLength > 0) {
	            stream.position += markerLength;
	        }
	    };
	    /**
	     * Number array for `png header`.
	     * @hidden
	     * @private
	     */
	    ImageDecoder.mPngHeader = [137, 80, 78, 71, 13, 10, 26, 10];
	    /**
	     * Number Array for `jpeg header`.
	     * @hidden
	     * @private
	     */
	    ImageDecoder.mJpegHeader = [255, 216];
	    /**
	     * Number array for `gif header`.
	     * @hidden
	     * @private
	     */
	    ImageDecoder.GIF_HEADER = 'G,I,F,8';
	    /**
	     * Number array for `bmp header.`
	     * @hidden
	     * @private
	     */
	    ImageDecoder.BMP_HEADER = 'B,M';
	    return ImageDecoder;
	}());

	/**
	 * Used to perform `convertion between pixels and points`.
	 * @private
	 */
	var PdfUnitConverter = /** @class */ (function () {
	    //constructors
	    /**
	     * Initializes a new instance of the `UnitConvertor` class with DPI value.
	     * @private
	     */
	    function PdfUnitConverter(dpi) {
	        this.updateProportionsHelper(dpi);
	    }
	    /**
	     * `Converts` the value, from one graphics unit to another graphics unit.
	     * @private
	     */
	    PdfUnitConverter.prototype.convertUnits = function (value, from, to) {
	        return this.convertFromPixels(this.convertToPixels(value, from), to);
	    };
	    /**
	     * Converts the value `to pixel` from specified graphics unit.
	     * @private
	     */
	    PdfUnitConverter.prototype.convertToPixels = function (value, from) {
	        var index = from;
	        var result = (value * this.proportions[index]);
	        return result;
	    };
	    /**
	     * Converts value, to specified graphics unit `from Pixel`.
	     * @private
	     */
	    PdfUnitConverter.prototype.convertFromPixels = function (value, to) {
	        var index = to;
	        var result = (value / this.proportions[index]);
	        return result;
	    };
	    /**
	     * `Update proportions` matrix according to Graphics settings.
	     * @private
	     */
	    PdfUnitConverter.prototype.updateProportionsHelper = function (pixelPerInch) {
	        this.proportions = [
	            pixelPerInch / 2.54,
	            pixelPerInch / 6.0,
	            1,
	            pixelPerInch / 72.0,
	            pixelPerInch,
	            pixelPerInch / 300.0,
	            pixelPerInch / 25.4 // Millimeter
	        ];
	    };
	    //Fields
	    /**
	     * Indicates default `horizontal resolution`.
	     * @default 96
	     * @private
	     */
	    PdfUnitConverter.horizontalResolution = 96;
	    /**
	     * Indicates default `vertical resolution`.
	     * @default 96
	     * @private
	     */
	    PdfUnitConverter.verticalResolution = 96;
	    return PdfUnitConverter;
	}());

	/**
	 * `PdfImage` class represents the base class for images and provides functionality for the 'PdfBitmap' class.
	 * @private
	 */
	var PdfImage = /** @class */ (function () {
	    function PdfImage() {
	    }
	    Object.defineProperty(PdfImage.prototype, "width", {
	        /**
	         * Gets and Sets the `width` of an image.
	         * @private
	         */
	        get: function () {
	            return this.imageWidth;
	        },
	        set: function (value) {
	            this.imageWidth = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfImage.prototype, "height", {
	        /**
	         * Gets and Sets the `height` of an image.
	         * @private
	         */
	        get: function () {
	            return this.imageHeight;
	        },
	        set: function (value) {
	            this.imageHeight = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfImage.prototype, "size", {
	        /**
	         * Gets or sets the size of the image.
	         * @private
	         */
	        set: function (value) {
	            this.width = value.width;
	            this.height = value.height;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfImage.prototype, "physicalDimension", {
	        /**
	         * Gets the `physical dimension` of an image.
	         * @private
	         */
	        get: function () {
	            this.imagePhysicalDimension = this.getPointSize(this.width, this.height, this.horizontalResolution, this.verticalResolution);
	            return new SizeF(this.width, this.height);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfImage.prototype, "element", {
	        // /**
	        //  * Gets the `image stream as string`.
	        //  * @private
	        //  */
	        // public static fromString(string : string) : PdfImage {
	        //     let image : PdfImage = new PdfBitmap(string);
	        //     return image;
	        // }
	        /**
	         * Gets the `element` image stream.
	         * @private
	         */
	        get: function () {
	            return this.imageStream;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PdfImage.prototype.getPointSize = function (width, height, horizontalResolution, verticalResolution) {
	        if (typeof horizontalResolution === 'undefined') {
	            var dpiX = PdfUnitConverter.horizontalResolution;
	            var dpiY = PdfUnitConverter.verticalResolution;
	            var size = this.getPointSize(width, height, dpiX, dpiY);
	            return size;
	        }
	        else {
	            var ucX = new PdfUnitConverter(horizontalResolution);
	            var ucY = new PdfUnitConverter(verticalResolution);
	            var ptWidth = ucX.convertUnits(width, PdfGraphicsUnit.Pixel, PdfGraphicsUnit.Point);
	            var ptHeight = ucY.convertUnits(height, PdfGraphicsUnit.Pixel, PdfGraphicsUnit.Point);
	            var size = new SizeF(ptWidth, ptHeight);
	            return size;
	        }
	    };
	    return PdfImage;
	}());

	var __extends$n = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The 'PdfBitmap' contains methods and properties to handle the Bitmap images.
	 * ```typescript
	 * // create a new PDF document.
	 * let document : PdfDocument = new PdfDocument();
	 * // add a page to the document.
	 * let page1 : PdfPage = document.pages.add();
	 * // base64 string of an image
	 * let imageString : string = '/9j/3+2w7em7HzY/KiijFw … 1OEYRUYrQ45yc5OUtz/9k=';
	 * // load the image from the base64 string of original image.
	 * let image : PdfBitmap = new PdfBitmap(imageString);
	 * // draw the image
	 * page1.graphics.drawImage(image, new RectangleF({x : 10, y : 10}, {width : 200, height : 200}));
	 * // save the document.
	 * document.save('output.pdf');
	 * // destroy the document
	 * document.destroy();
	 * ```
	 */
	var PdfBitmap = /** @class */ (function (_super) {
	    __extends$n(PdfBitmap, _super);
	    /**
	     * Create an instance for `PdfBitmap` class.
	     * @param encodedString Base64 string of an image.
	     * ```typescript
	     * // create a new PDF document.
	     * let document : PdfDocument = new PdfDocument();
	     * // add a page to the document.
	     * let page1 : PdfPage = document.pages.add();
	     * // base64 string of an image
	     * let imageString : string = '/9j/3+2w7em7HzY/KiijFw … 1OEYRUYrQ45yc5OUtz/9k=';
	     * //
	     * // load the image from the base64 string of original image.
	     * let image : PdfBitmap = new PdfBitmap(imageString);
	     * //
	     * // draw the image
	     * page1.graphics.drawImage(image, new RectangleF({x : 10, y : 10}, {width : 200, height : 200}));
	     * // save the document.
	     * document.save('output.pdf');
	     * // destroy the document
	     * document.destroy();
	     * ```
	     */
	    function PdfBitmap(encodedString) {
	        var _this = _super.call(this) || this;
	        //Fields
	        /**
	         * Specifies the `status` of an image.
	         * @default true.
	         * @hidden
	         * @private
	         */
	        _this.imageStatus = true;
	        /**
	         * Internal variable for accessing fields from `DictionryProperties` class.
	         * @hidden
	         * @private
	         */
	        _this.dictionaryProperties = new DictionaryProperties();
	        _this.loadImage(encodedString);
	        return _this;
	    }
	    /**
	     * `Load image`.
	     * @hidden
	     * @private
	     */
	    PdfBitmap.prototype.loadImage = function (encodedString) {
	        this.initializeAsync(encodedString);
	    };
	    /**
	     * `Initialize` image parameters.
	     * @private
	     */
	    PdfBitmap.prototype.initializeAsync = function (encodedString) {
	        var byteArray = new ByteArray(encodedString.length);
	        byteArray.writeFromBase64String(encodedString);
	        this.decoder = new ImageDecoder(byteArray);
	        this.height = this.decoder.height;
	        this.width = this.decoder.width;
	        // FrameCount = BitmapImageDecoder.FrameCount;
	        this.bitsPerComponent = this.decoder.bitsPerComponent;
	    };
	    /**
	     * `Saves` the image into stream.
	     * @private
	     */
	    PdfBitmap.prototype.save = function () {
	        this.imageStatus = true;
	        this.imageStream = this.decoder.getImageDictionary();
	    };
	    return PdfBitmap;
	}(PdfImage));

	/**
	 * TtfTableInfo.ts class for EJ2-PDF
	 */
	var TtfTableInfo = /** @class */ (function () {
	    function TtfTableInfo() {
	    }
	    Object.defineProperty(TtfTableInfo.prototype, "empty", {
	        //Properties
	        /**
	         * Gets a value indicating whether this table is empty.
	         * @private
	         */
	        get: function () {
	            var empty = (this.offset === this.length && this.length === this.checksum && this.checksum === 0);
	            return empty;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return TtfTableInfo;
	}());

	var TtfNameTable = /** @class */ (function () {
	    function TtfNameTable() {
	    }
	    return TtfNameTable;
	}());

	/**
	 * TtfNameRecord.ts class for EJ2-PDF
	 */
	var TtfNameRecord = /** @class */ (function () {
	    function TtfNameRecord() {
	    }
	    return TtfNameRecord;
	}());

	/**
	 * TtfHeadTable.ts class for EJ2-PDF
	 */
	var TtfHeadTable = /** @class */ (function () {
	    function TtfHeadTable() {
	    }
	    return TtfHeadTable;
	}());

	var TtfMetrics = /** @class */ (function () {
	    function TtfMetrics() {
	    }
	    Object.defineProperty(TtfMetrics.prototype, "isItalic", {
	        //Properties
	        /**
	         * Gets a value indicating whether this instance is italic.
	         */
	        get: function () {
	            return ((this.macStyle & 2) !== 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TtfMetrics.prototype, "isBold", {
	        /**
	         * Gets a value indicating whether this instance is bold.
	         */
	        get: function () {
	            return ((this.macStyle & 1) !== 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return TtfMetrics;
	}());

	/**
	 * TtfHorizontalHeaderTable.ts class for EJ2-PDF
	 */
	var TtfHorizontalHeaderTable = /** @class */ (function () {
	    function TtfHorizontalHeaderTable() {
	    }
	    return TtfHorizontalHeaderTable;
	}());

	/**
	 * TtfOS2Table.ts class for EJ2-PDF
	 * The OS/2 table consists of a set of metrics that are required by Windows and OS/2.
	 */
	var TtfOS2Table = /** @class */ (function () {
	    function TtfOS2Table() {
	    }
	    return TtfOS2Table;
	}());

	/**
	 * TtfPostTable.ts class for EJ2-PDF
	 */
	var TtfPostTable = /** @class */ (function () {
	    function TtfPostTable() {
	    }
	    return TtfPostTable;
	}());

	/**
	 * TtfLongHorMetric.ts class for EJ2-PDF
	 */
	var TtfLongHorMetric = /** @class */ (function () {
	    function TtfLongHorMetric() {
	    }
	    return TtfLongHorMetric;
	}());

	/**
	 * TtfCmapSubTable.ts class for EJ2-PDF
	 */
	var TtfCmapSubTable = /** @class */ (function () {
	    function TtfCmapSubTable() {
	    }
	    return TtfCmapSubTable;
	}());

	/**
	 * TtfCmapTable.ts class for EJ2-PDF
	 */
	var TtfCmapTable = /** @class */ (function () {
	    function TtfCmapTable() {
	    }
	    return TtfCmapTable;
	}());

	/**
	 * TtfGlyphInfo.ts class for EJ2-PDF
	 */
	var TtfGlyphInfo = /** @class */ (function () {
	    function TtfGlyphInfo() {
	    }
	    Object.defineProperty(TtfGlyphInfo.prototype, "empty", {
	        //Properties
	        /**
	         * Gets a value indicating whether this TtfGlyphInfo is empty.
	         */
	        get: function () {
	            var empty = (this.index === this.width && this.width === this.charCode && this.charCode === 0);
	            return empty;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //IComparable implementation
	    /**
	     * Compares two WidthDescriptor objects.
	     */
	    TtfGlyphInfo.prototype.compareTo = function (obj) {
	        var glyph = obj;
	        return this.index - glyph.index;
	    };
	    return TtfGlyphInfo;
	}());

	/**
	 * TtfLocaTable.ts class for EJ2-PDF
	 */
	var TtfLocaTable = /** @class */ (function () {
	    function TtfLocaTable() {
	    }
	    return TtfLocaTable;
	}());

	/**
	 * TtfAppleCmapSubTable.ts class for EJ2-PDF
	 */
	var TtfAppleCmapSubTable = /** @class */ (function () {
	    function TtfAppleCmapSubTable() {
	    }
	    return TtfAppleCmapSubTable;
	}());

	/**
	 * TtfMicrosoftCmapSubTable.ts class for EJ2-PDF
	 */
	var TtfMicrosoftCmapSubTable = /** @class */ (function () {
	    function TtfMicrosoftCmapSubTable() {
	    }
	    return TtfMicrosoftCmapSubTable;
	}());

	/**
	 * TtfTrimmedCmapSubTable.ts class for EJ2-PDF
	 */
	var TtfTrimmedCmapSubTable = /** @class */ (function () {
	    function TtfTrimmedCmapSubTable() {
	    }
	    return TtfTrimmedCmapSubTable;
	}());

	/**
	 * TtfLocaTable.ts class for EJ2-PDF
	 */
	var TtfGlyphHeader = /** @class */ (function () {
	    function TtfGlyphHeader() {
	    }
	    return TtfGlyphHeader;
	}());

	/**
	 * Writes data in BigEndian order.
	 */
	var BigEndianWriter = /** @class */ (function () {
	    //Constructors
	    /**
	     * Creates a new writer.
	     */
	    function BigEndianWriter(capacity) {
	        //Constants
	        /**
	         * Size of Int32 type.
	         */
	        this.int32Size = 4;
	        /**
	         * Size of Int16 type.
	         */
	        this.int16Size = 2;
	        /**
	         * Size of long type.
	         */
	        this.int64Size = 8;
	        this.bufferLength = capacity;
	        this.buffer = [];
	    }
	    Object.defineProperty(BigEndianWriter.prototype, "data", {
	        //Properties
	        /**
	         * Gets data written to the writer.
	         */
	        get: function () {
	            if (this.buffer.length < this.bufferLength) {
	                var length_1 = this.bufferLength - this.buffer.length;
	                for (var i = 0; i < length_1; i++) {
	                    this.buffer.push(0);
	                }
	            }
	            return this.buffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BigEndianWriter.prototype, "position", {
	        /// <summary>
	        /// Gets position of the internal buffer.
	        /// </summary>
	        get: function () {
	            if (this.internalPosition === undefined || this.internalPosition === null) {
	                this.internalPosition = 0;
	            }
	            return this.internalPosition;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Writes short value.
	     */
	    BigEndianWriter.prototype.writeShort = function (value) {
	        var bytes = [((value & 0x0000ff00) >> 8), value & 0x000000ff];
	        this.flush(bytes);
	    };
	    /**
	     * Writes int value.
	     */
	    BigEndianWriter.prototype.writeInt = function (value) {
	        var bytes = [(value & 0xff000000) >> 24, (value & 0x00ff0000) >> 16, (value & 0x0000ff00) >> 8, value & 0x000000ff];
	        this.flush(bytes);
	    };
	    /**
	     * Writes u int value.
	     */
	    BigEndianWriter.prototype.writeUInt = function (value) {
	        var buff = [(value & 0xff000000) >> 24, (value & 0x00ff0000) >> 16, (value & 0x0000ff00) >> 8, value & 0x000000ff];
	        this.flush(buff);
	    };
	    /**
	     * Writes string value.
	     */
	    BigEndianWriter.prototype.writeString = function (value) {
	        if (value == null) {
	            throw new Error('Argument Null Exception : value');
	        }
	        var bytes = [];
	        for (var i = 0; i < value.length; i++) {
	            bytes.push(value.charCodeAt(i));
	        }
	        this.flush(bytes);
	    };
	    /**
	     * Writes byte[] value.
	     */
	    BigEndianWriter.prototype.writeBytes = function (value) {
	        this.flush(value);
	    };
	    // //Implementation
	    BigEndianWriter.prototype.flush = function (buff) {
	        if (buff === null) {
	            throw new Error('Argument Null Exception : buff');
	        }
	        var position = this.position;
	        for (var i = 0; i < buff.length; i++) {
	            this.buffer[position] = buff[i];
	            position++;
	        }
	        this.internalPosition += buff.length;
	    };
	    return BigEndianWriter;
	}());

	/**
	 * TtfReader.ts class for EJ2-PDF
	 */
	var TtfReader = /** @class */ (function () {
	    //Constructors
	    function TtfReader(fontData) {
	        this.int32Size = 4;
	        this.isTtcFont = false;
	        this.isMacTtf = false;
	        this.metricsName = '';
	        this.isMacTTF = false;
	        this.missedGlyphs = 0;
	        this.tableNames = ['cvt ', 'fpgm', 'glyf', 'head', 'hhea', 'hmtx', 'loca', 'maxp', 'prep'];
	        this.entrySelectors = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4];
	        this.fontData = fontData;
	        this.initialize();
	    }
	    Object.defineProperty(TtfReader.prototype, "macintosh", {
	        //Properties
	        /**
	         * Gets glyphs for Macintosh or Symbol fonts (char - key, glyph - value).
	         */
	        get: function () {
	            if (this.macintoshDictionary === null || this.macintoshDictionary === undefined) {
	                this.macintoshDictionary = new Dictionary();
	            }
	            return this.macintoshDictionary;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TtfReader.prototype, "microsoft", {
	        /**
	         * Gets glyphs for Microsoft or Symbol fonts (char - key, glyph - value).
	         */
	        get: function () {
	            if (this.microsoftDictionary === null || this.microsoftDictionary === undefined) {
	                this.microsoftDictionary = new Dictionary();
	            }
	            return this.microsoftDictionary;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TtfReader.prototype, "macintoshGlyphs", {
	        /**
	         * Gets glyphs for Macintosh or Symbol fonts (glyph index - key, glyph - value).
	         */
	        get: function () {
	            if (this.internalMacintoshGlyphs === null || this.internalMacintoshGlyphs === undefined) {
	                this.internalMacintoshGlyphs = new Dictionary();
	            }
	            return this.internalMacintoshGlyphs;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TtfReader.prototype, "microsoftGlyphs", {
	        /**
	         * Gets glyphs for Microsoft Unicode fonts (glyph index - key, glyph - value).
	         */
	        get: function () {
	            if (this.internalMicrosoftGlyphs === null || this.internalMicrosoftGlyphs === undefined) {
	                this.internalMicrosoftGlyphs = new Dictionary();
	            }
	            return this.internalMicrosoftGlyphs;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //Implementation
	    TtfReader.prototype.initialize = function () {
	        if (this.metrics === undefined) {
	            this.metrics = new TtfMetrics();
	        }
	        this.readFontDictionary();
	        var nameTable = this.readNameTable();
	        var headTable = this.readHeadTable();
	        this.initializeFontName(nameTable);
	        this.metrics.macStyle = headTable.macStyle;
	    };
	    TtfReader.prototype.readFontDictionary = function () {
	        this.offset = 0;
	        this.checkPreambula();
	        //this.offset += 4;
	        var numTables = this.readInt16(this.offset);
	        this.readInt16(this.offset);
	        this.readInt16(this.offset);
	        this.readInt16(this.offset);
	        if (this.tableDirectory === undefined) {
	            this.tableDirectory = new Dictionary();
	        }
	        for (var i = 0; i < numTables; ++i) {
	            var table = new TtfTableInfo();
	            var tableKey = this.readString(this.int32Size);
	            table.checksum = this.readInt32(this.offset);
	            table.offset = this.readInt32(this.offset);
	            table.length = this.readInt32(this.offset);
	            this.tableDirectory.setValue(tableKey, table);
	        }
	        this.lowestPosition = this.offset;
	        if (!this.isTtcFont) {
	            this.fixOffsets();
	        }
	    };
	    TtfReader.prototype.fixOffsets = function () {
	        var minOffset = Number.MAX_VALUE;
	        // Search for a smallest offset and compare it with the lowest position found.
	        var tableKeys = this.tableDirectory.keys();
	        for (var i = 0; i < tableKeys.length; i++) {
	            var value = this.tableDirectory.getValue(tableKeys[i]);
	            var offset = value.offset;
	            if (minOffset > offset) {
	                minOffset = offset;
	                if (minOffset <= this.lowestPosition) {
	                    break;
	                }
	            }
	        }
	        var shift = minOffset - this.lowestPosition;
	        if (shift !== 0) {
	            var table = new Dictionary();
	            for (var i = 0; i < tableKeys.length; i++) {
	                var value = this.tableDirectory.getValue(tableKeys[i]);
	                value.offset -= shift;
	                table.setValue(tableKeys[i], value);
	            }
	            this.tableDirectory = table;
	        }
	    };
	    TtfReader.prototype.checkPreambula = function () {
	        var version = this.readInt32(this.offset);
	        this.isMacTtf = (version === 0x74727565) ? true : false;
	        if (version !== 0x10000 && version !== 0x74727565 && version !== 0x4f54544f) {
	            this.isTtcFont = true;
	            this.offset = 0;
	            var fontTag = this.readString(4);
	            if (fontTag !== 'ttcf') {
	                throw new Error('Can not read TTF font data');
	            }
	            //skip 4
	            this.offset += 4;
	            var ttcIdentificationNumber = this.readInt32(this.offset);
	            if (ttcIdentificationNumber < 0) {
	                throw new Error('Can not read TTF font data');
	            }
	            this.offset = this.readInt32(this.offset);
	            version = this.readInt32(this.offset);
	        }
	        return version;
	    };
	    TtfReader.prototype.readNameTable = function () {
	        var tableInfo = this.getTable('name');
	        this.offset = tableInfo.offset;
	        var table = new TtfNameTable();
	        table.formatSelector = this.readUInt16(this.offset);
	        table.recordsCount = this.readUInt16(this.offset);
	        table.offset = this.readUInt16(this.offset);
	        table.nameRecords = [];
	        var recordSize = 12;
	        var position = this.offset;
	        for (var i = 0; i < table.recordsCount; i++) {
	            this.offset = position;
	            var record = new TtfNameRecord();
	            record.platformID = this.readUInt16(this.offset);
	            record.encodingID = this.readUInt16(this.offset);
	            record.languageID = this.readUInt16(this.offset);
	            record.nameID = this.readUInt16(this.offset);
	            record.length = this.readUInt16(this.offset);
	            record.offset = this.readUInt16(this.offset);
	            this.offset = tableInfo.offset + table.offset + record.offset;
	            var unicode = (record.platformID === 0 || record.platformID === 3);
	            record.name = this.readString(record.length, unicode);
	            table.nameRecords[i] = record;
	            position += recordSize;
	        }
	        return table;
	    };
	    TtfReader.prototype.readHeadTable = function () {
	        var tableInfo = this.getTable('head');
	        this.offset = tableInfo.offset;
	        var table = new TtfHeadTable();
	        table.version = this.readFixed(this.offset);
	        table.fontRevision = this.readFixed(this.offset);
	        table.checkSumAdjustment = this.readUInt32(this.offset);
	        table.magicNumber = this.readUInt32(this.offset);
	        table.flags = this.readUInt16(this.offset);
	        table.unitsPerEm = this.readUInt16(this.offset);
	        table.created = this.readInt64(this.offset);
	        table.modified = this.readInt64(this.offset);
	        table.xMin = this.readInt16(this.offset);
	        table.yMin = this.readInt16(this.offset);
	        table.xMax = this.readInt16(this.offset);
	        table.yMax = this.readInt16(this.offset);
	        table.macStyle = this.readUInt16(this.offset);
	        table.lowestReadableSize = this.readUInt16(this.offset);
	        table.fontDirectionHint = this.readInt16(this.offset);
	        table.indexToLocalFormat = this.readInt16(this.offset);
	        table.glyphDataFormat = this.readInt16(this.offset);
	        return table;
	    };
	    TtfReader.prototype.readHorizontalHeaderTable = function () {
	        var tableInfo = this.getTable('hhea');
	        this.offset = tableInfo.offset;
	        var table = new TtfHorizontalHeaderTable();
	        table.version = this.readFixed(this.offset);
	        table.ascender = this.readInt16(this.offset);
	        table.descender = this.readInt16(this.offset);
	        table.lineGap = this.readInt16(this.offset);
	        table.advanceWidthMax = this.readUInt16(this.offset);
	        table.minLeftSideBearing = this.readInt16(this.offset);
	        table.minRightSideBearing = this.readInt16(this.offset);
	        table.xMaxExtent = this.readInt16(this.offset);
	        table.caretSlopeRise = this.readInt16(this.offset);
	        table.caretSlopeRun = this.readInt16(this.offset);
	        //skip 2 * 5
	        this.offset += 10;
	        table.metricDataFormat = this.readInt16(this.offset);
	        table.numberOfHMetrics = this.readUInt16(this.offset);
	        return table;
	    };
	    TtfReader.prototype.readOS2Table = function () {
	        var tableInfo = this.getTable('OS/2');
	        this.offset = tableInfo.offset;
	        var table = new TtfOS2Table();
	        table.version = this.readUInt16(this.offset);
	        table.xAvgCharWidth = this.readInt16(this.offset);
	        table.usWeightClass = this.readUInt16(this.offset);
	        table.usWidthClass = this.readUInt16(this.offset);
	        table.fsType = this.readInt16(this.offset);
	        table.ySubscriptXSize = this.readInt16(this.offset);
	        table.ySubscriptYSize = this.readInt16(this.offset);
	        table.ySubscriptXOffset = this.readInt16(this.offset);
	        table.ySubscriptYOffset = this.readInt16(this.offset);
	        table.ySuperscriptXSize = this.readInt16(this.offset);
	        table.ySuperscriptYSize = this.readInt16(this.offset);
	        table.ySuperscriptXOffset = this.readInt16(this.offset);
	        table.ySuperscriptYOffset = this.readInt16(this.offset);
	        table.yStrikeoutSize = this.readInt16(this.offset);
	        table.yStrikeoutPosition = this.readInt16(this.offset);
	        table.sFamilyClass = this.readInt16(this.offset);
	        table.panose = this.readBytes(10);
	        table.ulUnicodeRange1 = this.readUInt32(this.offset);
	        table.ulUnicodeRange2 = this.readUInt32(this.offset);
	        table.ulUnicodeRange3 = this.readUInt32(this.offset);
	        table.ulUnicodeRange4 = this.readUInt32(this.offset);
	        table.vendorIdentifier = this.readBytes(4);
	        table.fsSelection = this.readUInt16(this.offset);
	        table.usFirstCharIndex = this.readUInt16(this.offset);
	        table.usLastCharIndex = this.readUInt16(this.offset);
	        table.sTypoAscender = this.readInt16(this.offset);
	        table.sTypoDescender = this.readInt16(this.offset);
	        table.sTypoLineGap = this.readInt16(this.offset);
	        table.usWinAscent = this.readUInt16(this.offset);
	        table.usWinDescent = this.readUInt16(this.offset);
	        table.ulCodePageRange1 = this.readUInt32(this.offset);
	        table.ulCodePageRange2 = this.readUInt32(this.offset);
	        if (table.version > 1) {
	            table.sxHeight = this.readInt16(this.offset);
	            table.sCapHeight = this.readInt16(this.offset);
	            table.usDefaultChar = this.readUInt16(this.offset);
	            table.usBreakChar = this.readUInt16(this.offset);
	            table.usMaxContext = this.readUInt16(this.offset);
	        }
	        else {
	            table.sxHeight = 0;
	            table.sCapHeight = 0;
	            table.usDefaultChar = 0;
	            table.usBreakChar = 0;
	            table.usMaxContext = 0;
	        }
	        return table;
	    };
	    TtfReader.prototype.readPostTable = function () {
	        var tableInfo = this.getTable('post');
	        this.offset = tableInfo.offset;
	        var table = new TtfPostTable();
	        table.formatType = this.readFixed(this.offset);
	        table.italicAngle = this.readFixed(this.offset);
	        table.underlinePosition = this.readInt16(this.offset);
	        table.underlineThickness = this.readInt16(this.offset);
	        table.isFixedPitch = this.readUInt32(this.offset);
	        table.minType42 = this.readUInt32(this.offset);
	        table.maxType42 = this.readUInt32(this.offset);
	        table.minType1 = this.readUInt32(this.offset);
	        table.maxType1 = this.readUInt32(this.offset);
	        return table;
	    };
	    /**
	     * Reads Width of the glyphs.
	     */
	    TtfReader.prototype.readWidthTable = function (glyphCount, unitsPerEm) {
	        var tableInfo = this.getTable('hmtx');
	        this.offset = tableInfo.offset;
	        var width = [];
	        for (var i = 0; i < glyphCount; i++) {
	            var glyph = new TtfLongHorMetric();
	            glyph.advanceWidth = this.readUInt16(this.offset);
	            glyph.lsb = this.readInt16(this.offset);
	            var glyphWidth = glyph.advanceWidth * 1000 / unitsPerEm;
	            width.push(Math.floor(glyphWidth));
	        }
	        return width;
	    };
	    /**
	     * Reads the cmap table.
	     */
	    TtfReader.prototype.readCmapTable = function () {
	        var tableInfo = this.getTable('cmap');
	        this.offset = tableInfo.offset;
	        var table = new TtfCmapTable();
	        table.version = this.readUInt16(this.offset);
	        table.tablesCount = this.readUInt16(this.offset);
	        var position = this.offset;
	        var subTables = [];
	        for (var i = 0; i < table.tablesCount; i++) {
	            this.offset = position;
	            var subTable = new TtfCmapSubTable();
	            subTable.platformID = this.readUInt16(this.offset);
	            subTable.encodingID = this.readUInt16(this.offset);
	            subTable.offset = this.readUInt32(this.offset);
	            position = this.offset;
	            this.readCmapSubTable(subTable);
	            subTables[i] = subTable;
	        }
	        return subTables;
	    };
	    /**
	     * Reads the cmap sub table.
	     */
	    TtfReader.prototype.readCmapSubTable = function (subTable) {
	        var tableInfo = this.getTable('cmap');
	        this.offset = tableInfo.offset + subTable.offset;
	        var format = this.readUInt16(this.offset);
	        var encoding = this.getCmapEncoding(subTable.platformID, subTable.encodingID);
	        (encoding === TtfCmapEncoding.Macintosh) ? TtfPlatformID.Macintosh : TtfPlatformID.Microsoft;
	        if (encoding !== TtfCmapEncoding.Unknown) {
	            switch (format) {
	                case TtfCmapFormat.Apple:
	                    this.readAppleCmapTable(subTable, encoding);
	                    break;
	                case TtfCmapFormat.Microsoft:
	                    this.readMicrosoftCmapTable(subTable, encoding);
	                    break;
	                case TtfCmapFormat.Trimmed:
	                    this.readTrimmedCmapTable(subTable, encoding);
	                    break;
	            }
	        }
	    };
	    /**
	     * Reads Symbol cmap table.
	     */
	    TtfReader.prototype.readAppleCmapTable = function (subTable, encoding) {
	        var tableInfo = this.getTable('cmap');
	        this.offset = tableInfo.offset + subTable.offset;
	        var table = new TtfAppleCmapSubTable();
	        table.format = this.readUInt16(this.offset);
	        table.length = this.readUInt16(this.offset);
	        table.version = this.readUInt16(this.offset);
	        if (this.maxMacIndex === null || this.maxMacIndex === undefined) {
	            this.maxMacIndex = 0;
	        }
	        for (var i = 0; i < 256; ++i) {
	            var glyphInfo = new TtfGlyphInfo();
	            glyphInfo.index = this.readByte(this.offset);
	            glyphInfo.width = this.getWidth(glyphInfo.index);
	            glyphInfo.charCode = i;
	            this.macintosh.setValue(i, glyphInfo);
	            this.addGlyph(glyphInfo, encoding);
	            // NOTE: this code fixes char codes that extends 0x100. However, it might corrupt something.
	            this.maxMacIndex = Math.max(i, this.maxMacIndex);
	        }
	    };
	    /**
	     * Reads Symbol cmap table.
	     */
	    TtfReader.prototype.readMicrosoftCmapTable = function (subTable, encoding) {
	        var tableInfo = this.getTable('cmap');
	        this.offset = tableInfo.offset + subTable.offset;
	        var collection = (encoding === TtfCmapEncoding.Unicode) ? this.microsoft : this.macintosh;
	        var table = new TtfMicrosoftCmapSubTable();
	        table.format = this.readUInt16(this.offset);
	        table.length = this.readUInt16(this.offset);
	        table.version = this.readUInt16(this.offset);
	        table.segCountX2 = this.readUInt16(this.offset);
	        table.searchRange = this.readUInt16(this.offset);
	        table.entrySelector = this.readUInt16(this.offset);
	        table.rangeShift = this.readUInt16(this.offset);
	        var segCount = table.segCountX2 / 2;
	        table.endCount = this.readUshortArray(segCount);
	        table.reservedPad = this.readUInt16(this.offset);
	        table.startCount = this.readUshortArray(segCount);
	        table.idDelta = this.readUshortArray(segCount);
	        table.idRangeOffset = this.readUshortArray(segCount);
	        var length = (table.length / 2 - 8) - (segCount * 4);
	        table.glyphID = this.readUshortArray(length);
	        // Process glyphIdArray array.
	        var codeOffset = 0;
	        var index = 0;
	        for (var j = 0; j < segCount; j++) {
	            for (var k = table.startCount[j]; k <= table.endCount[j] && k !== 65535; k++) {
	                if (table.idRangeOffset[j] === 0) {
	                    codeOffset = (k + table.idDelta[j]) & 65535;
	                }
	                else {
	                    index = j + table.idRangeOffset[j] / 2 - segCount + k - table.startCount[j];
	                    if (index >= table.glyphID.length) {
	                        continue;
	                    }
	                    codeOffset = (table.glyphID[index] + table.idDelta[j]) & 65535;
	                }
	                var glyph = new TtfGlyphInfo();
	                glyph.index = codeOffset;
	                glyph.width = this.getWidth(glyph.index);
	                var id = (encoding === TtfCmapEncoding.Symbol) ? ((k & 0xff00) === 0xf000 ? k & 0xff : k) : k;
	                glyph.charCode = id;
	                collection.setValue(id, glyph);
	                this.addGlyph(glyph, encoding);
	            }
	        }
	    };
	    /**
	     * Reads Trimed cmap table.
	     */
	    TtfReader.prototype.readTrimmedCmapTable = function (subTable, encoding) {
	        var tableInfo = this.getTable('cmap');
	        this.offset = tableInfo.offset + subTable.offset;
	        var table = new TtfTrimmedCmapSubTable();
	        table.format = this.readUInt16(this.offset);
	        table.length = this.readUInt16(this.offset);
	        table.version = this.readUInt16(this.offset);
	        table.firstCode = this.readUInt16(this.offset);
	        table.entryCount = this.readUInt16(this.offset);
	        for (var i = 0; i < table.entryCount; ++i) {
	            var glyphInfo = new TtfGlyphInfo();
	            glyphInfo.index = this.readUInt16(this.offset);
	            glyphInfo.width = this.getWidth(glyphInfo.index);
	            glyphInfo.charCode = i + table.firstCode;
	            this.macintosh.setValue(i, glyphInfo);
	            this.addGlyph(glyphInfo, encoding);
	            // NOTE: this code fixes char codes that extends 0x100. However, it might corrupt something.
	            this.maxMacIndex = Math.max(i, this.maxMacIndex);
	        }
	    };
	    TtfReader.prototype.initializeFontName = function (nameTable) {
	        for (var i = 0; i < nameTable.recordsCount; i++) {
	            var record = nameTable.nameRecords[i];
	            if (record.nameID === 1) {
	                //font family
	                this.metrics.fontFamily = record.name;
	            }
	            else if (record.nameID === 6) {
	                //post script name
	                this.metrics.postScriptName = record.name;
	            }
	            /* tslint:disable */
	            if (this.metrics.fontFamily !== null && this.metrics.fontFamily !== undefined && this.metrics.postScriptName !== null && this.metrics.postScriptName !== undefined) {
	                break;
	            }
	            /* tslint:disable */
	        }
	    };
	    TtfReader.prototype.getTable = function (name) {
	        // if (name === null) {
	        //     throw new Error('Argument Null Exception : name');
	        // }
	        var table = new TtfTableInfo();
	        var obj;
	        if (this.tableDirectory.containsKey(name)) {
	            obj = this.tableDirectory.getValue(name);
	        }
	        if (obj !== null && obj !== undefined) {
	            table = obj;
	        }
	        return table;
	    };
	    /**
	     * Returns width of the glyph.
	     */
	    TtfReader.prototype.getWidth = function (glyphCode) {
	        glyphCode = (glyphCode < this.width.length) ? glyphCode : this.width.length - 1;
	        return this.width[glyphCode];
	    };
	    /**
	     * Gets CMAP encoding based on platform ID and encoding ID.
	     */
	    /* tslint:disable */
	    TtfReader.prototype.getCmapEncoding = function (platformID, encodingID) {
	        var format = TtfCmapEncoding.Unknown;
	        if (platformID == TtfPlatformID.Microsoft && encodingID == TtfMicrosoftEncodingID.Undefined) {
	            // When building a symbol font for Windows,
	            // the platform ID should be 3 and the encoding ID should be 0.
	            format = TtfCmapEncoding.Symbol;
	        }
	        else if (platformID == TtfPlatformID.Microsoft && encodingID == TtfMicrosoftEncodingID.Unicode) {
	            // When building a Unicode font for Windows,
	            // the platform ID should be 3 and the encoding ID should be 1.
	            format = TtfCmapEncoding.Unicode;
	        }
	        else if (platformID == TtfPlatformID.Macintosh && encodingID == TtfMacintoshEncodingID.Roman) {
	            // When building a font that will be used on the Macintosh,
	            // the platform ID should be 1 and the encoding ID should be 0.
	            format = TtfCmapEncoding.Macintosh;
	        }
	        return format;
	    };
	    /* tslint:enable */
	    /**
	     * Adds glyph to the collection.
	     */
	    TtfReader.prototype.addGlyph = function (glyph, encoding) {
	        var collection = null;
	        switch (encoding) {
	            case TtfCmapEncoding.Unicode:
	                collection = this.microsoftGlyphs;
	                break;
	            case TtfCmapEncoding.Macintosh:
	            case TtfCmapEncoding.Symbol:
	                collection = this.macintoshGlyphs;
	                break;
	        }
	        collection.setValue(glyph.index, glyph);
	    };
	    /**
	     * Initializes metrics.
	     */
	    /* tslint:disable */
	    TtfReader.prototype.initializeMetrics = function (nameTable, headTable, horizontalHeadTable, os2Table, postTable, cmapTables) {
	        /* tslint:enable */
	        // if (cmapTables === null) {
	        //     throw new Error('ArgumentNullException : cmapTables');
	        // }
	        this.initializeFontName(nameTable);
	        // Get font encoding.
	        var bSymbol = false;
	        for (var i = 0; i < cmapTables.length; i++) {
	            var subTable = cmapTables[i];
	            var encoding = this.getCmapEncoding(subTable.platformID, subTable.encodingID);
	            if (encoding === TtfCmapEncoding.Symbol) {
	                bSymbol = true;
	                break;
	            }
	        }
	        this.metrics.isSymbol = bSymbol;
	        this.metrics.macStyle = headTable.macStyle;
	        this.metrics.isFixedPitch = (postTable.isFixedPitch !== 0);
	        this.metrics.italicAngle = postTable.italicAngle;
	        var factor = 1000 / headTable.unitsPerEm;
	        this.metrics.winAscent = os2Table.sTypoAscender * factor;
	        this.metrics.macAscent = horizontalHeadTable.ascender * factor;
	        //m_metrics.MacAscent = os2Table.UsWinAscent * factor;
	        // NOTE: This is stange workaround. The value is good if os2Table.SCapHeight != 0, otherwise it should be properly computed.
	        this.metrics.capHeight = (os2Table.sCapHeight !== 0) ? os2Table.sCapHeight : 0.7 * headTable.unitsPerEm * factor;
	        this.metrics.winDescent = os2Table.sTypoDescender * factor;
	        this.metrics.macDescent = horizontalHeadTable.descender * factor;
	        //m_metrics.MacDescent = -os2Table.UsWinDescent * factor;
	        this.metrics.leading = (os2Table.sTypoAscender - os2Table.sTypoDescender + os2Table.sTypoLineGap) * factor;
	        this.metrics.lineGap = Math.ceil(horizontalHeadTable.lineGap * factor);
	        var left = headTable.xMin * factor;
	        var top = Math.ceil(this.metrics.macAscent + this.metrics.lineGap);
	        var right = headTable.xMax * factor;
	        var bottom = this.metrics.macDescent;
	        this.metrics.fontBox = new Rectangle(left, top, right, bottom);
	        // NOTE: Strange!
	        this.metrics.stemV = 80;
	        this.metrics.widthTable = this.updateWidth();
	        this.metrics.contains = this.tableDirectory.containsKey('CFF');
	        this.metrics.subScriptSizeFactor = headTable.unitsPerEm / os2Table.ySubscriptYSize;
	        this.metrics.superscriptSizeFactor = headTable.unitsPerEm / os2Table.ySuperscriptYSize;
	    };
	    /**
	     * Updates chars structure which is used in the case of ansi encoding (256 bytes).
	     */
	    TtfReader.prototype.updateWidth = function () {
	        var count = 256;
	        var bytes = [];
	        if (this.metrics.isSymbol) {
	            for (var i = 0; i < count; i++) {
	                var glyphInfo = this.getGlyph(String.fromCharCode(i));
	                bytes[i] = (glyphInfo.empty) ? 0 : glyphInfo.width;
	            }
	        }
	        else {
	            var byteToProcess = [];
	            var unknown = '?';
	            var space = String.fromCharCode(32);
	            for (var i = 0; i < count; i++) {
	                byteToProcess[0] = i;
	                var text = this.getString(byteToProcess, 0, byteToProcess.length);
	                var ch = (text.length > 0) ? text[0] : unknown;
	                var glyphInfo = this.getGlyph(ch);
	                if (!glyphInfo.empty) {
	                    bytes[i] = glyphInfo.width;
	                }
	                else {
	                    glyphInfo = this.getGlyph(space);
	                    bytes[i] = (glyphInfo.empty) ? 0 : glyphInfo.width;
	                }
	            }
	        }
	        return bytes;
	    };
	    /**
	     * Returns default glyph.
	     */
	    TtfReader.prototype.getDefaultGlyph = function () {
	        var glyph = this.getGlyph(StringTokenizer.whiteSpace);
	        return glyph;
	    };
	    /**
	     * Reads unicode string from byte array.
	     */
	    TtfReader.prototype.getString = function (byteToProcess, start, length) {
	        var result = '';
	        for (var index = 0; index < length; index++) {
	            result += String.fromCharCode(byteToProcess[index + start]);
	        }
	        return result;
	    };
	    /**
	     * Reads loca table.
	     */
	    TtfReader.prototype.readLocaTable = function (bShort) {
	        var tableInfo = this.getTable('loca');
	        this.offset = tableInfo.offset;
	        var table = new TtfLocaTable();
	        var buffer = null;
	        if (bShort) {
	            var len = tableInfo.length / 2;
	            buffer = [];
	            for (var i = 0; i < len; i++) {
	                buffer[i] = this.readUInt16(this.offset) * 2;
	            }
	        }
	        else {
	            var len = tableInfo.length / 4;
	            buffer = [];
	            for (var i = 0; i < len; i++) {
	                buffer[i] = this.readUInt32(this.offset);
	            }
	        }
	        table.offsets = buffer;
	        return table;
	    };
	    /**
	     * Updates hash table of used glyphs.
	     */
	    TtfReader.prototype.updateGlyphChars = function (glyphChars, locaTable) {
	        // if (glyphChars === null) {
	        //     throw new Error('Argument Null Exception : glyphChars');
	        // }
	        // Add zero key.
	        if (!glyphChars.containsKey(0)) {
	            glyphChars.setValue(0, 0);
	        }
	        var clone = new Dictionary();
	        var glyphCharKeys = glyphChars.keys();
	        for (var i = 0; i < glyphCharKeys.length; i++) {
	            clone.setValue(glyphCharKeys[i], glyphChars.getValue(glyphCharKeys[i]));
	        }
	        for (var i = 0; i < glyphCharKeys.length; i++) {
	            var nextKey = glyphCharKeys[i];
	            this.processCompositeGlyph(glyphChars, nextKey, locaTable);
	        }
	    };
	    /**
	     * Checks if glyph is composite or not.
	     */
	    TtfReader.prototype.processCompositeGlyph = function (glyphChars, glyph, locaTable) {
	        // if (glyphChars === null) {
	        //     throw new Error('Argument Null Exception : glyphChars');
	        // }
	        // Is in range.
	        if (glyph < locaTable.offsets.length - 1) {
	            var glyphOffset = locaTable.offsets[glyph];
	            if (glyphOffset !== locaTable.offsets[glyph + 1]) {
	                var tableInfo = this.getTable('glyf');
	                this.offset = tableInfo.offset + glyphOffset;
	                var glyphHeader = new TtfGlyphHeader();
	                glyphHeader.numberOfContours = this.readInt16(this.offset);
	                glyphHeader.xMin = this.readInt16(this.offset);
	                glyphHeader.yMin = this.readInt16(this.offset);
	                glyphHeader.xMax = this.readInt16(this.offset);
	                glyphHeader.yMax = this.readInt16(this.offset);
	                // Glyph is composite.
	                if (glyphHeader.numberOfContours < 0) {
	                    var skipBytes = 0;
	                    var entry = true;
	                    while (entry) {
	                        var flags = this.readUInt16(this.offset);
	                        var glyphIndex = this.readUInt16(this.offset);
	                        if (!glyphChars.containsKey(glyphIndex)) {
	                            glyphChars.setValue(glyphIndex, 0);
	                        }
	                        if ((flags & TtfCompositeGlyphFlags.MoreComponents) === 0) {
	                            break;
	                        }
	                        skipBytes = ((flags & TtfCompositeGlyphFlags.Arg1And2AreWords) !== 0) ? 4 : 2;
	                        if ((flags & TtfCompositeGlyphFlags.WeHaveScale) !== 0) {
	                            skipBytes += 2;
	                        }
	                        else if ((flags & TtfCompositeGlyphFlags.WeHaveAnXyScale) !== 0) {
	                            skipBytes += 4;
	                        }
	                        else if ((flags & TtfCompositeGlyphFlags.WeHaveTwoByTwo) !== 0) {
	                            skipBytes += 2 * 4;
	                        }
	                        this.offset += skipBytes;
	                    }
	                }
	            }
	        }
	    };
	    /**
	     * Creates new glyph tables based on chars that are used for output.
	     */
	    /* tslint:disable */
	    TtfReader.prototype.generateGlyphTable = function (glyphChars, locaTable, newLocaTable, newGlyphTable) {
	        /* tslint:enable */
	        // if (glyphChars === null) {
	        //     throw new Error('Argument Null Exception : glyphChars');
	        // }
	        newLocaTable = [];
	        // Sorting used glyphs keys.
	        var activeGlyphs = glyphChars.keys();
	        activeGlyphs.sort(function (a, b) { return a - b; });
	        var glyphSize = 0;
	        for (var i = 0; i < activeGlyphs.length; i++) {
	            var glyphIndex = activeGlyphs[i];
	            if (locaTable.offsets.length > 0) {
	                glyphSize += locaTable.offsets[glyphIndex + 1] - locaTable.offsets[glyphIndex];
	            }
	        }
	        var glyphSizeAligned = this.align(glyphSize);
	        newGlyphTable = [];
	        for (var i = 0; i < glyphSizeAligned; i++) {
	            newGlyphTable.push(0);
	        }
	        var nextGlyphOffset = 0;
	        var nextGlyphIndex = 0;
	        var table = this.getTable('glyf');
	        // Creating NewLocaTable - that would hold offsets for filtered glyphs.
	        for (var i = 0; i < locaTable.offsets.length; i++) {
	            newLocaTable.push(nextGlyphOffset);
	            if (nextGlyphIndex < activeGlyphs.length && activeGlyphs[nextGlyphIndex] === i) {
	                ++nextGlyphIndex;
	                newLocaTable[i] = nextGlyphOffset;
	                var oldGlyphOffset = locaTable.offsets[i];
	                var oldNextGlyphOffset = locaTable.offsets[i + 1] - oldGlyphOffset;
	                if (oldNextGlyphOffset > 0) {
	                    this.offset = table.offset + oldGlyphOffset;
	                    var result = this.read(newGlyphTable, nextGlyphOffset, oldNextGlyphOffset);
	                    newGlyphTable = result.buffer;
	                    nextGlyphOffset += oldNextGlyphOffset;
	                }
	            }
	        }
	        return { glyphTableSize: glyphSize, newLocaTable: newLocaTable, newGlyphTable: newGlyphTable };
	    };
	    /**
	     * Updates new Loca table.
	     */
	    /* tslint:disable */
	    TtfReader.prototype.updateLocaTable = function (newLocaTable, bLocaIsShort, newLocaTableOut) {
	        /* tslint:enable */
	        if (newLocaTable === null) {
	            throw new Error('Argument Null Exception : newLocaTable');
	        }
	        var size = (bLocaIsShort) ? newLocaTable.length * 2 : newLocaTable.length * 4;
	        var count = this.align(size);
	        //BigEndianWiter
	        var writer = new BigEndianWriter(count);
	        for (var i = 0; i < newLocaTable.length; i++) {
	            var value = newLocaTable[i];
	            if (bLocaIsShort) {
	                value /= 2;
	                writer.writeShort(value);
	            }
	            else {
	                writer.writeInt(value);
	            }
	        }
	        return { newLocaUpdated: writer.data, newLocaSize: size };
	    };
	    /**
	     * Aligns number to be divisible on 4.
	     */
	    TtfReader.prototype.align = function (value) {
	        return (value + 3) & (~3);
	    };
	    /**
	     * Returns font program data.
	     */
	    /* tslint:disable */
	    TtfReader.prototype.getFontProgram = function (newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {
	        /* tslint:enable */
	        if (newLocaTableOut === null) {
	            throw new Error('Argument Null Exception : newLocaTableOut');
	        }
	        if (newGlyphTable === null) {
	            throw new Error('Argument Null Exception : newGlyphTable');
	        }
	        this.tableNames;
	        var result = this.getFontProgramLength(newLocaTableOut, newGlyphTable, 0);
	        var fontProgramLength = result.fontProgramLength;
	        var numTables = result.numTables;
	        var writer = new BigEndianWriter(fontProgramLength);
	        writer.writeInt(0x10000);
	        writer.writeShort(numTables);
	        var entrySelector = this.entrySelectors[numTables];
	        writer.writeShort((1 << (entrySelector & 31)) * 16);
	        writer.writeShort(entrySelector);
	        writer.writeShort((numTables - (1 << (entrySelector & 31))) * 16);
	        // Writing to destination buffer - checksums && sizes of used tables.
	        this.writeCheckSums(writer, numTables, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize);
	        // // Writing to destination buffer - used glyphs.
	        this.writeGlyphs(writer, newLocaTableOut, newGlyphTable);
	        return writer.data;
	    };
	    /* tslint:disable */
	    TtfReader.prototype.getFontProgramLength = function (newLocaTableOut, newGlyphTable, numTables) {
	        /* tslint:enable */
	        if (newLocaTableOut === null) {
	            throw new Error('Argument Null Exception : newLocaTableOut');
	        }
	        if (newGlyphTable === null) {
	            throw new Error('Argument Null Exception : newGlyphTable');
	        }
	        // glyf and loca are used by default;
	        numTables = 2;
	        var tableNames = this.tableNames;
	        var fontProgramLength = 0;
	        for (var i = 0; i < tableNames.length; i++) {
	            var tableName = tableNames[i];
	            if (tableName !== 'glyf' && tableName !== 'loca') {
	                var table = this.getTable(tableName);
	                if (!table.empty) {
	                    ++numTables;
	                    fontProgramLength += this.align(table.length);
	                }
	            }
	        }
	        fontProgramLength += newLocaTableOut.length;
	        fontProgramLength += newGlyphTable.length;
	        var usedTablesSize = numTables * 16 + (3 * 4);
	        fontProgramLength += usedTablesSize;
	        return { fontProgramLength: fontProgramLength, numTables: numTables };
	    };
	    /**
	     * Writing to destination buffer - checksums and sizes of used tables.
	     */
	    /* tslint:disable */
	    TtfReader.prototype.writeCheckSums = function (writer, numTables, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {
	        /* tslint:enable */
	        if (writer === null) {
	            throw new Error('Argument Null Exception : writer');
	        }
	        if (newLocaTableOut === null) {
	            throw new Error('Argument Null Exception : newLocaTableOut');
	        }
	        if (newGlyphTable === null) {
	            throw new Error('Argument Null Exception : newGlyphTable');
	        }
	        var tableNames = this.tableNames;
	        var usedTablesSize = numTables * 16 + (3 * 4);
	        var nextTableSize = 0;
	        for (var i = 0; i < tableNames.length; i++) {
	            var tableName = tableNames[i];
	            var tableInfo = this.getTable(tableName);
	            if (tableInfo.empty) {
	                continue;
	            }
	            writer.writeString(tableName);
	            if (tableName === 'glyf') {
	                var checksum = this.calculateCheckSum(newGlyphTable);
	                writer.writeInt(checksum);
	                nextTableSize = glyphTableSize;
	            }
	            else if (tableName === 'loca') {
	                var checksum = this.calculateCheckSum(newLocaTableOut);
	                writer.writeInt(checksum);
	                nextTableSize = locaTableSize;
	            }
	            else {
	                writer.writeInt(tableInfo.checksum);
	                nextTableSize = tableInfo.length;
	            }
	            writer.writeUInt(usedTablesSize);
	            writer.writeUInt(nextTableSize);
	            usedTablesSize += this.align(nextTableSize);
	        }
	    };
	    /**
	     * Gets checksum from source buffer.
	     */
	    TtfReader.prototype.calculateCheckSum = function (bytes) {
	        if (bytes === null) {
	            throw new Error('Argument Null Exception : bytes');
	        }
	        var pos = 0;
	        var byte1 = 0;
	        var byte2 = 0;
	        var byte3 = 0;
	        var byte4 = 0;
	        for (var i = 0; i < (bytes.length + 1) / 4; i++) {
	            byte4 += (bytes[pos++] & 255);
	            byte3 += (bytes[pos++] & 255);
	            byte2 += (bytes[pos++] & 255);
	            byte1 += (bytes[pos++] & 255);
	        }
	        var result = byte1;
	        result += (byte2 << 8);
	        result += (byte3 << 16);
	        result += (byte4 << 24);
	        return result;
	    };
	    /**
	     * Writing to destination buffer - used glyphs.
	     */
	    TtfReader.prototype.writeGlyphs = function (writer, newLocaTable, newGlyphTable) {
	        if (writer === null) {
	            throw new Error('Argument Null Exception : writer');
	        }
	        if (newLocaTable === null) {
	            throw new Error('Argument Null Exception : newLocaTableOut');
	        }
	        if (newGlyphTable === null) {
	            throw new Error('Argument Null Exception : newGlyphTable');
	        }
	        var tableNames = this.tableNames;
	        for (var i = 0; i < tableNames.length; i++) {
	            var tableName = tableNames[i];
	            var tableInfo = this.getTable(tableName);
	            if (tableInfo.empty) {
	                continue;
	            }
	            if (tableName === 'glyf') {
	                writer.writeBytes(newGlyphTable);
	            }
	            else if (tableName === 'loca') {
	                writer.writeBytes(newLocaTable);
	            }
	            else {
	                var count = this.align(tableInfo.length);
	                var buff = [];
	                for (var i_1 = 0; i_1 < count; i_1++) {
	                    buff.push(0);
	                }
	                this.offset = tableInfo.offset;
	                var result = this.read(buff, 0, tableInfo.length);
	                writer.writeBytes(result.buffer);
	            }
	        }
	    };
	    //public methods
	    /**
	     * Sets position value of font data.
	     */
	    TtfReader.prototype.setOffset = function (offset) {
	        this.offset = offset;
	    };
	    /**
	     * Creates font Internals
	     * @private
	     */
	    TtfReader.prototype.createInternals = function () {
	        this.metrics = new TtfMetrics();
	        var nameTable = this.readNameTable();
	        var headTable = this.readHeadTable();
	        this.bIsLocaShort = (headTable.indexToLocalFormat === 0);
	        var horizontalHeadTable = this.readHorizontalHeaderTable();
	        var os2Table = this.readOS2Table();
	        var postTable = this.readPostTable();
	        this.width = this.readWidthTable(horizontalHeadTable.numberOfHMetrics, headTable.unitsPerEm);
	        var subTables = this.readCmapTable();
	        this.initializeMetrics(nameTable, headTable, horizontalHeadTable, os2Table, postTable, subTables);
	    };
	    TtfReader.prototype.getGlyph = function (charCode) {
	        if (typeof charCode === 'number') {
	            var obj1 = null;
	            if (!this.metrics.isSymbol && this.microsoftGlyphs != null) {
	                if (this.microsoftGlyphs.containsKey(charCode)) {
	                    obj1 = this.microsoftGlyphs.getValue(charCode);
	                }
	            }
	            else if (this.metrics.isSymbol && this.macintoshGlyphs != null) {
	                if (this.macintoshGlyphs.containsKey(charCode)) {
	                    obj1 = this.macintoshGlyphs.getValue(charCode);
	                }
	            }
	            var glyph = (obj1 != null) ? obj1 : this.getDefaultGlyph();
	            return glyph;
	        }
	        else {
	            var obj = null;
	            var code = charCode.charCodeAt(0);
	            if (!this.metrics.isSymbol && this.microsoft !== null) {
	                if (this.microsoft.containsKey(code)) {
	                    obj = this.microsoft.getValue(code);
	                    if (code !== StringTokenizer.whiteSpace.charCodeAt(0)) {
	                        this.isFontPresent = true;
	                    }
	                }
	                else if (code !== StringTokenizer.whiteSpace.charCodeAt(0)) {
	                    this.isFontPresent = false;
	                }
	            }
	            else if (this.metrics.isSymbol && this.macintosh !== null || this.isMacTTF) {
	                // NOTE: this code fixes char codes that extends 0x100. However, it might corrupt something.
	                if (this.maxMacIndex !== 0) {
	                    code %= this.maxMacIndex + 1;
	                }
	                else {
	                    code = ((code & 0xff00) === 0xf000 ? code & 0xff : code);
	                }
	                if (this.macintosh.containsKey(code)) {
	                    obj = this.macintosh.getValue(code);
	                    this.isFontPresent = true;
	                }
	            }
	            // Fix for StackOverFlow exception in XPS to PDF converter
	            if (charCode === StringTokenizer.whiteSpace && obj === null) {
	                obj = new TtfGlyphInfo();
	            }
	            var glyph = (obj !== null) ? obj : this.getDefaultGlyph();
	            return glyph;
	        }
	    };
	    /**
	     * Gets hash table with chars indexed by glyph index.
	     */
	    TtfReader.prototype.getGlyphChars = function (chars) {
	        if (chars === null || chars === undefined) {
	            throw new Error('Argument Null Exception : chars');
	        }
	        var dictionary = new Dictionary();
	        var charKeys = chars.keys();
	        for (var i = 0; i < charKeys.length; i++) {
	            var ch = charKeys[i];
	            var glyph = this.getGlyph(ch);
	            if (!glyph.empty) {
	                dictionary.setValue(glyph.index, ch.charCodeAt(0));
	            }
	        }
	        return dictionary;
	    };
	    /**
	     * Gets all glyphs.
	     */
	    TtfReader.prototype.getAllGlyphs = function () {
	        var allGlyphInfo = [];
	        var info = new TtfGlyphInfo();
	        var index = 0;
	        for (var i = 0; i < this.width.length; i++) {
	            var width = this.width[i];
	            info.index = index;
	            info.width = width;
	            allGlyphInfo.push(info);
	            index++;
	        }
	        return allGlyphInfo;
	    };
	    /**
	     * Reads a font's program.
	     * @private
	     */
	    TtfReader.prototype.readFontProgram = function (chars) {
	        var glyphChars = this.getGlyphChars(chars);
	        var locaTable = this.readLocaTable(this.bIsLocaShort);
	        if (glyphChars.size() < chars.size()) {
	            this.missedGlyphs = chars.size() - glyphChars.size();
	        }
	        this.updateGlyphChars(glyphChars, locaTable);
	        /* tslint:disable */
	        var result1 = this.generateGlyphTable(glyphChars, locaTable, null, null);
	        /* tslint:enable */
	        var glyphTableSize = result1.glyphTableSize;
	        var newLocaTable = result1.newLocaTable;
	        var newGlyphTable = result1.newGlyphTable;
	        var result2 = this.updateLocaTable(newLocaTable, this.bIsLocaShort, null);
	        var newLocaSize = result2.newLocaSize;
	        var newLocaUpdated = result2.newLocaUpdated;
	        var fontProgram = this.getFontProgram(newLocaUpdated, newGlyphTable, glyphTableSize, newLocaSize);
	        return fontProgram;
	    };
	    /**
	     * Reconverts string to be in proper format saved into PDF file.
	     */
	    TtfReader.prototype.convertString = function (text) {
	        if (text === null) {
	            throw new Error('Argument Null Exception : text');
	        }
	        var glyph = '';
	        for (var k = 0; k < text.length; k++) {
	            var ch = text[k];
	            var glyphInfo = this.getGlyph(ch);
	            if (!glyphInfo.empty) {
	                glyph += String.fromCharCode(glyphInfo.index);
	            }
	        }
	        return glyph;
	    };
	    /**
	     * Gets char width.
	     */
	    TtfReader.prototype.getCharWidth = function (code) {
	        var glyphInfo = this.getGlyph(code);
	        glyphInfo = (!glyphInfo.empty) ? glyphInfo : this.getDefaultGlyph();
	        var codeWidth = (!glyphInfo.empty) ? glyphInfo.width : 0;
	        return codeWidth;
	    };
	    TtfReader.prototype.readString = function (length, isUnicode) {
	        if (isUnicode === undefined) {
	            return this.readString(length, false);
	        }
	        else {
	            //let buffer : number[] = this.readBytes(length);
	            var result = '';
	            if (isUnicode) {
	                for (var i = 0; i < length; i++) {
	                    if (i % 2 !== 0) {
	                        result += String.fromCharCode(this.fontData[this.offset]);
	                    }
	                    this.offset += 1;
	                }
	            }
	            else {
	                for (var i = 0; i < length; i++) {
	                    result += String.fromCharCode(this.fontData[this.offset]);
	                    this.offset += 1;
	                }
	            }
	            return result;
	        }
	    };
	    TtfReader.prototype.readFixed = function (offset) {
	        var integer = this.readInt16(offset);
	        var sFraction = this.readInt16(offset + 2);
	        var fraction = sFraction / 16384;
	        return integer + fraction;
	    };
	    TtfReader.prototype.readInt32 = function (offset) {
	        var i1 = this.fontData[offset + 3];
	        var i2 = this.fontData[offset + 2];
	        var i3 = this.fontData[offset + 1];
	        var i4 = this.fontData[offset];
	        this.offset += 4;
	        return i1 + (i2 << 8) + (i3 << 16) + (i4 << 24);
	    };
	    TtfReader.prototype.readUInt32 = function (offset) {
	        var i1 = this.fontData[offset + 3];
	        var i2 = this.fontData[offset + 2];
	        var i3 = this.fontData[offset + 1];
	        var i4 = this.fontData[offset];
	        this.offset += 4;
	        return (i1 | i2 << 8 | i3 << 16 | i4 << 24);
	    };
	    // private readInt16(offset : number) : number {
	    //     let result : number = (this.fontData[offset] << 8) + this.fontData[offset + 1];
	    //     this.offset += 2;
	    //     return result;
	    // }
	    TtfReader.prototype.readInt16 = function (offset) {
	        var result = (this.fontData[offset] << 8) + this.fontData[offset + 1];
	        result = result & (1 << 15) ? result - 0x10000 : result;
	        this.offset += 2;
	        return result;
	    };
	    TtfReader.prototype.readInt64 = function (offset) {
	        var low = this.readInt32(offset + 4);
	        var n = this.readInt32(offset) * 4294967296.0 + low;
	        if (low < 0) {
	            n += 4294967296;
	        }
	        return n;
	    };
	    TtfReader.prototype.readUInt16 = function (offset) {
	        var result = (this.fontData[offset] << 8) | this.fontData[offset + 1];
	        this.offset += 2;
	        return result;
	    };
	    /**
	     * Reads ushort array.
	     */
	    TtfReader.prototype.readUshortArray = function (length) {
	        var buffer = [];
	        for (var i = 0; i < length; i++) {
	            buffer[i] = this.readUInt16(this.offset);
	        }
	        return buffer;
	    };
	    TtfReader.prototype.readBytes = function (length) {
	        var result = [];
	        for (var i = 0; i < length; i++) {
	            result.push(this.fontData[this.offset]);
	            this.offset += 1;
	        }
	        return result;
	    };
	    TtfReader.prototype.readByte = function (offset) {
	        var result = this.fontData[offset];
	        this.offset += 1;
	        return result;
	    };
	    /**
	     * Reads bytes to array in BigEndian order.
	     * @private
	     */
	    TtfReader.prototype.read = function (buffer, index, count) {
	        if (buffer === null) {
	            throw new Error('Argument Null Exception : buffer');
	        }
	        var written = 0;
	        var read = 0;
	        do {
	            for (var i = 0; (i < count - written) && (this.offset + i < this.fontData.length); i++) {
	                buffer[index + i] = this.fontData[this.offset + i];
	            }
	            read = count - written;
	            this.offset += read;
	            written += read;
	        } while (written < count);
	        return { buffer: buffer, written: written };
	    };
	    return TtfReader;
	}());

	var __extends$m = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `Metrics` of the font.
	 * @private
	 */
	var PdfFontMetrics = /** @class */ (function () {
	    function PdfFontMetrics() {
	        /**
	         * `Line gap`.
	         * @private
	         */
	        this.lineGap = 0;
	    }
	    //  Public methods
	    /**
	     * Returns `ascent` taking into consideration font`s size.
	     * @private
	     */
	    PdfFontMetrics.prototype.getAscent = function (format) {
	        var returnValue = this.ascent * PdfFont.charSizeMultiplier * this.getSize(format);
	        return returnValue;
	    };
	    /**
	     * Returns `descent` taking into consideration font`s size.
	     * @private
	     */
	    PdfFontMetrics.prototype.getDescent = function (format) {
	        var returnValue = this.descent * PdfFont.charSizeMultiplier * this.getSize(format);
	        return returnValue;
	    };
	    /**
	     * Returns `Line gap` taking into consideration font`s size.
	     * @private
	     */
	    PdfFontMetrics.prototype.getLineGap = function (format) {
	        var returnValue = this.lineGap * PdfFont.charSizeMultiplier * this.getSize(format);
	        return returnValue;
	    };
	    /**
	     * Returns `height` taking into consideration font`s size.
	     * @private
	     */
	    PdfFontMetrics.prototype.getHeight = function (format) {
	        var height;
	        if (this.getDescent(format) < 0) {
	            // if ((clearTypeFontCollection.indexOf(this.name.toLowerCase()) !== -1) && !this.isUnicodeFont) {
	            //     height = (this.GetAscent(format) - this.GetDescent(format) - this.GetLineGap(format));
	            // } else {
	            height = (this.getAscent(format) - this.getDescent(format) + this.getLineGap(format));
	            // }
	        }
	        else {
	            height = (this.getAscent(format) + this.getDescent(format) + this.getLineGap(format));
	        }
	        return height;
	    };
	    /**
	     * Calculates `size` of the font depending on the subscript/superscript value.
	     * @private
	     */
	    PdfFontMetrics.prototype.getSize = function (format) {
	        var size = this.size;
	        if (format != null) {
	            switch (format.subSuperScript) {
	                case PdfSubSuperScript.SubScript:
	                    size /= this.subScriptSizeFactor;
	                    break;
	                case PdfSubSuperScript.SuperScript:
	                    size /= this.superscriptSizeFactor;
	                    break;
	            }
	        }
	        return size;
	    };
	    /**
	     * `Clones` the metrics.
	     * @private
	     */
	    PdfFontMetrics.prototype.clone = function () {
	        var metrics = this;
	        metrics.widthTable = WidthTable.clone();
	        return metrics;
	    };
	    Object.defineProperty(PdfFontMetrics.prototype, "widthTable", {
	        //  Properies
	        /**
	         * Gets or sets the `width table`.
	         * @private
	         */
	        get: function () {
	            return this.internalWidthTable;
	        },
	        set: function (value) {
	            this.internalWidthTable = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PdfFontMetrics;
	}());
	var WidthTable = /** @class */ (function () {
	    function WidthTable() {
	    }
	    /**
	     * Static `clones` this instance of the WidthTable class.
	     * @private
	     */
	    WidthTable.clone = function () {
	        return null;
	    };
	    return WidthTable;
	}());
	var StandardWidthTable = /** @class */ (function (_super) {
	    __extends$m(StandardWidthTable, _super);
	    // Constructors
	    /**
	     * Initializes a new instance of the `StandardWidthTable` class.
	     * @private
	     */
	    function StandardWidthTable(widths) {
	        var _this = _super.call(this) || this;
	        if (widths == null) {
	            throw new Error('ArgumentNullException:widths');
	        }
	        _this.widths = widths;
	        return _this;
	    }
	    //Properties
	    /**
	     * Gets the `32 bit number` at the specified index.
	     * @private
	     */
	    StandardWidthTable.prototype.items = function (index) {
	        if (index < 0 || index >= this.widths.length) {
	            throw new Error('ArgumentOutOfRangeException:index, The character is not supported by the font.');
	        }
	        var result = this.widths[index];
	        return result;
	    };
	    Object.defineProperty(StandardWidthTable.prototype, "length", {
	        /**
	         * Gets the `length` of the internal array.
	         * @private
	         */
	        get: function () {
	            return this.widths.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //Overrides
	    /**
	     * `Clones` this instance of the WidthTable class.
	     * @private
	     */
	    StandardWidthTable.prototype.clone = function () {
	        var swt = this;
	        swt.widths = this.widths;
	        return swt;
	    };
	    /**
	     * Converts width table to a `PDF array`.
	     * @private
	     */
	    StandardWidthTable.prototype.toArray = function () {
	        var arr = new PdfArray(this.widths);
	        return arr;
	    };
	    return StandardWidthTable;
	}(WidthTable));

	/**
	 * TrueTypeFont.ts class for EJ2-PDF
	 */
	var UnicodeTrueTypeFont = /** @class */ (function () {
	    /* tslint:enable */
	    //Constructors
	    /**
	     * Initializes a new instance of the `PdfTrueTypeFont` class.
	     * @private
	     */
	    function UnicodeTrueTypeFont(base64String, size) {
	        // Fields
	        this.nameString = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
	        /**
	         * Specifies the Internal variable to store fields of `PdfDictionaryProperties`.
	         * @private
	         */
	        this.dictionaryProperties = new DictionaryProperties();
	        /**
	         * Indicates whether the font program is compressed or not.
	         * @private
	         */
	        this.isCompress = false;
	        /**
	         * Indicates whether the font is embedded or not.
	         */
	        this.isEmbedFont = false;
	        /**
	         * Cmap table's start prefix.
	         */
	        /* tslint:disable */
	        this.cmapPrefix = '/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap' + Operators.newLine + '/CIDSystemInfo << /Registry (Adobe)/Ordering (UCS)/Supplement 0>> def\n/CMapName ' + '/Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange' + Operators.newLine;
	        /* tslint:enable */
	        /**
	         * Cmap table's start suffix.
	         */
	        this.cmapEndCodespaceRange = 'endcodespacerange' + Operators.newLine;
	        /**
	         * Cmap's begin range marker.
	         */
	        this.cmapBeginRange = 'beginbfrange' + Operators.newLine;
	        /**
	         * Cmap's end range marker.
	         */
	        this.cmapEndRange = 'endbfrange' + Operators.newLine;
	        /**
	         * Cmap table's end
	         */
	        /* tslint:disable */
	        this.cmapSuffix = 'endbfrange\nendcmap\nCMapName currentdict ' + '/CMap defineresource pop\nend end' + Operators.newLine;
	        if (base64String === null || base64String === undefined) {
	            throw new Error('ArgumentNullException:base64String');
	        }
	        this.fontSize = size;
	        this.fontString = base64String;
	        this.Initialize();
	    }
	    //Implementation
	    /**
	     * Returns width of the char symbol.
	     */
	    UnicodeTrueTypeFont.prototype.getCharWidth = function (charCode) {
	        var codeWidth = this.ttfReader.getCharWidth(charCode);
	        return codeWidth;
	    };
	    /**
	     * Returns width of the text line.
	     */
	    UnicodeTrueTypeFont.prototype.getLineWidth = function (line) {
	        // if (line == null) {
	        //     throw new Error('ArgumentNullException : line');
	        // }
	        var width = 0;
	        for (var i = 0, len = line.length; i < len; i++) {
	            var ch = line[i];
	            var charWidth = this.getCharWidth(ch);
	            width += charWidth;
	        }
	        return width;
	    };
	    /**
	     * Initializes a new instance of the `PdfTrueTypeFont` class.
	     * @private
	     */
	    UnicodeTrueTypeFont.prototype.Initialize = function () {
	        var byteArray = new ByteArray(this.fontString.length);
	        byteArray.writeFromBase64String(this.fontString);
	        this.fontData = byteArray.internalBuffer;
	        this.ttfReader = new TtfReader(this.fontData);
	        this.ttfMetrics = this.ttfReader.metrics;
	    };
	    UnicodeTrueTypeFont.prototype.createInternals = function () {
	        this.fontDictionary = new PdfDictionary();
	        this.fontProgram = new PdfStream();
	        this.cmap = new PdfStream();
	        this.descendantFont = new PdfDictionary();
	        this.metrics = new PdfFontMetrics();
	        this.ttfReader.createInternals();
	        this.ttfMetrics = this.ttfReader.metrics;
	        this.initializeMetrics();
	        // Create all the dictionaries of the font.
	        this.subsetName = this.getFontName();
	        this.createDescendantFont();
	        this.createCmap();
	        this.createFontDictionary();
	        this.createFontProgram();
	    };
	    UnicodeTrueTypeFont.prototype.getInternals = function () {
	        return this.fontDictionary;
	    };
	    /**
	     * Initializes metrics.
	     */
	    UnicodeTrueTypeFont.prototype.initializeMetrics = function () {
	        var ttfMetrics = this.ttfReader.metrics;
	        this.metrics.ascent = ttfMetrics.macAscent;
	        this.metrics.descent = ttfMetrics.macDescent;
	        this.metrics.height = ttfMetrics.macAscent - ttfMetrics.macDescent + ttfMetrics.lineGap;
	        this.metrics.name = ttfMetrics.fontFamily;
	        this.metrics.postScriptName = ttfMetrics.postScriptName;
	        this.metrics.size = this.fontSize;
	        this.metrics.widthTable = new StandardWidthTable(ttfMetrics.widthTable);
	        this.metrics.lineGap = ttfMetrics.lineGap;
	        this.metrics.subScriptSizeFactor = ttfMetrics.subScriptSizeFactor;
	        this.metrics.superscriptSizeFactor = ttfMetrics.superscriptSizeFactor;
	        this.metrics.isBold = ttfMetrics.isBold;
	    };
	    /**
	     * Gets random string.
	     */
	    UnicodeTrueTypeFont.prototype.getFontName = function () {
	        var builder = '';
	        var name;
	        // if (this.isEmbed === false) {
	        for (var i = 0; i < 6; i++) {
	            var index = Math.floor(Math.random() * (25 - 0 + 1)) + 0;
	            builder += this.nameString[index];
	        }
	        builder += '+';
	        // }
	        builder += this.ttfReader.metrics.postScriptName;
	        name = builder.toString();
	        // if (name === '') {
	        //     name = this.ttfReader.metrics.fontFamily;
	        // }
	        name = this.formatName(name);
	        return name;
	    };
	    /**
	     * Generates name of the font.
	     */
	    UnicodeTrueTypeFont.prototype.formatName = function (fontName) {
	        // if (fontName === null) {
	        //     throw new Error('ArgumentNullException : fontName');
	        // }
	        // if (fontName === '') {
	        //     throw new Error('ArgumentOutOfRangeException : fontName, Parameter can not be empty');
	        // }
	        var ret = fontName.replace('(', '#28');
	        ret = ret.replace(')', '#29');
	        ret = ret.replace('[', '#5B');
	        ret = ret.replace(']', '#5D');
	        ret = ret.replace('<', '#3C');
	        ret = ret.replace('>', '#3E');
	        ret = ret.replace('{', '#7B');
	        ret = ret.replace('}', '#7D');
	        ret = ret.replace('/', '#2F');
	        ret = ret.replace('%', '#25');
	        return ret.replace(' ', '#20');
	    };
	    /**
	     * Creates descendant font.
	     */
	    UnicodeTrueTypeFont.prototype.createDescendantFont = function () {
	        // Set property used to clone Font every time
	        this.descendantFont.isResource = true;
	        this.descendantFont.descendantFontBeginSave = new SaveDescendantFontEventHandler(this);
	        this.descendantFont.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.font));
	        this.descendantFont.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.cIDFontType2));
	        this.descendantFont.items.setValue(this.dictionaryProperties.baseFont, new PdfName(this.subsetName));
	        this.descendantFont.items.setValue(this.dictionaryProperties.cIDToGIDMap, new PdfName(this.dictionaryProperties.identity));
	        this.descendantFont.items.setValue(this.dictionaryProperties.dw, new PdfNumber(1000));
	        this.fontDescriptor = this.createFontDescriptor();
	        this.descendantFont.items.setValue(this.dictionaryProperties.fontDescriptor, new PdfReferenceHolder(this.fontDescriptor));
	        var systemInfo = this.createSystemInfo();
	        this.descendantFont.items.setValue(this.dictionaryProperties.cIDSystemInfo, systemInfo);
	    };
	    /**
	     * Creates font descriptor.
	     */
	    UnicodeTrueTypeFont.prototype.createFontDescriptor = function () {
	        var descriptor = new PdfDictionary();
	        var metrics = this.ttfReader.metrics;
	        // Set property used to clone Font every time
	        descriptor.isResource = true;
	        descriptor.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.fontDescriptor));
	        descriptor.items.setValue(this.dictionaryProperties.fontName, new PdfName(this.subsetName));
	        descriptor.items.setValue(this.dictionaryProperties.flags, new PdfNumber(this.getDescriptorFlags()));
	        descriptor.items.setValue(this.dictionaryProperties.fontBBox, PdfArray.fromRectangle(this.getBoundBox()));
	        descriptor.items.setValue(this.dictionaryProperties.missingWidth, new PdfNumber(metrics.widthTable[32]));
	        descriptor.items.setValue(this.dictionaryProperties.stemV, new PdfNumber(metrics.stemV));
	        descriptor.items.setValue(this.dictionaryProperties.italicAngle, new PdfNumber(metrics.italicAngle));
	        descriptor.items.setValue(this.dictionaryProperties.capHeight, new PdfNumber(metrics.capHeight));
	        descriptor.items.setValue(this.dictionaryProperties.ascent, new PdfNumber(metrics.winAscent));
	        descriptor.items.setValue(this.dictionaryProperties.descent, new PdfNumber(metrics.winDescent));
	        descriptor.items.setValue(this.dictionaryProperties.leading, new PdfNumber(metrics.leading));
	        descriptor.items.setValue(this.dictionaryProperties.avgWidth, new PdfNumber(metrics.widthTable[32]));
	        descriptor.items.setValue(this.dictionaryProperties.fontFile2, new PdfReferenceHolder(this.fontProgram));
	        descriptor.items.setValue(this.dictionaryProperties.maxWidth, new PdfNumber(metrics.widthTable[32]));
	        descriptor.items.setValue(this.dictionaryProperties.xHeight, new PdfNumber(0));
	        descriptor.items.setValue(this.dictionaryProperties.stemH, new PdfNumber(0));
	        return descriptor;
	    };
	    /**
	     * Generates cmap.
	     * @private
	     */
	    UnicodeTrueTypeFont.prototype.createCmap = function () {
	        this.cmap.cmapBeginSave = new SaveCmapEventHandler(this);
	    };
	    /**
	     * Generates font dictionary.
	     */
	    UnicodeTrueTypeFont.prototype.createFontDictionary = function () {
	        // Set property used to clone Font every time
	        this.fontDictionary.isResource = true;
	        this.fontDictionary.fontDictionaryBeginSave = new SaveFontDictionaryEventHandler(this);
	        this.fontDictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.font));
	        this.fontDictionary.items.setValue(this.dictionaryProperties.baseFont, new PdfName(this.subsetName));
	        this.fontDictionary.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.type0));
	        this.fontDictionary.items.setValue(this.dictionaryProperties.encoding, new PdfName(this.dictionaryProperties.identityH));
	        var descFonts = new PdfArray();
	        var reference = new PdfReferenceHolder(this.descendantFont);
	        // Set property used to clone Font every time
	        descFonts.isFont = true;
	        descFonts.add(reference);
	        this.fontDictionary.items.setValue(this.dictionaryProperties.descendantFonts, descFonts);
	    };
	    /**
	     * Creates font program.
	     */
	    UnicodeTrueTypeFont.prototype.createFontProgram = function () {
	        this.fontProgram.fontProgramBeginSave = new SaveFontProgramEventHandler(this);
	    };
	    /**
	     * Creates system info dictionary for CID font.
	     * @private
	     */
	    UnicodeTrueTypeFont.prototype.createSystemInfo = function () {
	        var systemInfo = new PdfDictionary();
	        systemInfo.items.setValue(this.dictionaryProperties.registry, new PdfString('Adobe'));
	        systemInfo.items.setValue(this.dictionaryProperties.ordering, new PdfString(this.dictionaryProperties.identity));
	        systemInfo.items.setValue(this.dictionaryProperties.supplement, new PdfNumber(0));
	        return systemInfo;
	    };
	    /**
	     * Runs before font Dictionary will be saved.
	     */
	    UnicodeTrueTypeFont.prototype.descendantFontBeginSave = function () {
	        if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0) {
	            var width = this.getDescendantWidth();
	            if (width !== null) {
	                this.descendantFont.items.setValue(this.dictionaryProperties.w, width);
	            }
	        }
	    };
	    /**
	     * Runs before font Dictionary will be saved.
	     */
	    UnicodeTrueTypeFont.prototype.cmapBeginSave = function () {
	        this.generateCmap();
	    };
	    /**
	     * Runs before font Dictionary will be saved.
	     */
	    /* tslint:disable */
	    UnicodeTrueTypeFont.prototype.fontDictionaryBeginSave = function () {
	        if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0 && !this.fontDictionary.containsKey(this.dictionaryProperties.toUnicode)) {
	            this.fontDictionary.items.setValue(this.dictionaryProperties.toUnicode, new PdfReferenceHolder(this.cmap));
	        }
	    };
	    /* tslint:enable */
	    /**
	     * Runs before font program stream save.
	     */
	    UnicodeTrueTypeFont.prototype.fontProgramBeginSave = function () {
	        this.isCompress = true;
	        this.generateFontProgram();
	    };
	    /**
	     * Gets width description pad array for c i d font.
	     */
	    UnicodeTrueTypeFont.prototype.getDescendantWidth = function () {
	        var array = new PdfArray();
	        if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0) {
	            var glyphInfo = [];
	            // if (!this.isEmbedFont) {
	            var keys = this.usedChars.keys();
	            for (var i = 0; i < keys.length; i++) {
	                var chLen = keys[i];
	                var glyph = this.ttfReader.getGlyph(chLen);
	                if (glyph.empty) {
	                    continue;
	                }
	                glyphInfo.push(glyph);
	            }
	            // } else {
	            //     glyphInfo = this.ttfReader.getAllGlyphs();
	            // }
	            glyphInfo.sort(function (a, b) { return a.index - b.index; });
	            var firstGlyphIndex = 0;
	            var lastGlyphIndex = 0;
	            var firstGlyphIndexWasSet = false;
	            var widthDetails = new PdfArray();
	            // if (!this.isEmbedFont) {
	            for (var i = 0; i < glyphInfo.length; i++) {
	                var glyph = glyphInfo[i];
	                if (!firstGlyphIndexWasSet) {
	                    firstGlyphIndexWasSet = true;
	                    firstGlyphIndex = glyph.index;
	                    lastGlyphIndex = glyph.index - 1;
	                }
	                if ((lastGlyphIndex + 1 !== glyph.index || (i + 1 === glyphInfo.length)) && glyphInfo.length > 1) {
	                    // Add glyph index / width.
	                    array.add(new PdfNumber(firstGlyphIndex));
	                    if (i !== 0) {
	                        array.add(widthDetails);
	                    }
	                    firstGlyphIndex = glyph.index;
	                    widthDetails = new PdfArray();
	                }
	                widthDetails.add(new PdfNumber(glyph.width));
	                if (i + 1 === glyphInfo.length) {
	                    array.add(new PdfNumber(firstGlyphIndex));
	                    array.add(widthDetails);
	                }
	                lastGlyphIndex = glyph.index;
	            }
	            // } else {
	            //     for (let i : number = 0; i < glyphInfo.length; i++) {
	            //         let glyph : TtfGlyphInfo = glyphInfo[i];
	            //         if (!firstGlyphIndexWasSet) {
	            //             firstGlyphIndexWasSet = true;
	            //             lastGlyphIndex = glyph.index - 1;
	            //         }
	            //         firstGlyphIndex = glyph.index;
	            //         if ((lastGlyphIndex + 1 === glyph.index || (i + 1 === glyphInfo.length)) && glyphInfo.length > 1) {
	            //             // Add glyph index / width.
	            //             widthDetails.add(new PdfNumber(glyph.width));
	            //             array.add(new PdfNumber(firstGlyphIndex));
	            //             array.add(widthDetails);
	            //             widthDetails = new PdfArray();
	            //         }
	            //         lastGlyphIndex = glyph.index;
	            //     }
	            // }
	        }
	        return array;
	    };
	    /**
	     * Creates cmap.
	     */
	    UnicodeTrueTypeFont.prototype.generateCmap = function () {
	        if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0) {
	            var glyphChars = this.ttfReader.getGlyphChars(this.usedChars);
	            if (glyphChars.size() > 0) {
	                var keys = glyphChars.keys().sort();
	                // add first and last glyph indexes
	                var first = keys[0];
	                var last = keys[keys.length - 1];
	                var middlePart = this.toHexString(first, false) + this.toHexString(last, false) + Operators.newLine;
	                var builder = '';
	                builder += this.cmapPrefix;
	                builder += middlePart;
	                builder += this.cmapEndCodespaceRange;
	                var nextRange = 0;
	                for (var i = 0; i < keys.length; i++) {
	                    if (nextRange === 0) {
	                        if (i !== 0) {
	                            builder += this.cmapEndRange;
	                        }
	                        nextRange = Math.min(100, keys.length - i);
	                        builder += nextRange;
	                        builder += Operators.whiteSpace;
	                        builder += this.cmapBeginRange;
	                    }
	                    nextRange -= 1;
	                    var key = keys[i];
	                    /* tslint:disable */
	                    builder += this.toHexString(key, true) + this.toHexString(key, true) + this.toHexString(glyphChars.getValue(key), true) + '\n';
	                    /* tslint:enable */
	                }
	                builder += this.cmapSuffix;
	                this.cmap.clearStream();
	                this.cmap.isResource = true;
	                this.cmap.write(builder);
	            }
	        }
	    };
	    /**
	     * Generates font program.
	     */
	    UnicodeTrueTypeFont.prototype.generateFontProgram = function () {
	        var fontProgram = null;
	        this.usedChars = (this.usedChars === null || this.usedChars === undefined) ? new Dictionary() : this.usedChars;
	        this.ttfReader.setOffset(0);
	        fontProgram = this.ttfReader.readFontProgram(this.usedChars);
	        this.fontProgram.clearStream();
	        this.fontProgram.isResource = true;
	        this.fontProgram.writeBytes(fontProgram);
	    };
	    /**
	     * Calculates flags for the font descriptor.
	     * @private
	     */
	    UnicodeTrueTypeFont.prototype.getDescriptorFlags = function () {
	        var flags = 0;
	        var metrics = this.ttfReader.metrics;
	        if (metrics.isFixedPitch) {
	            flags |= FontDescriptorFlags.FixedPitch;
	        }
	        if (metrics.isSymbol) {
	            flags |= FontDescriptorFlags.Symbolic;
	        }
	        else {
	            flags |= FontDescriptorFlags.Nonsymbolic;
	        }
	        if (metrics.isItalic) {
	            flags |= FontDescriptorFlags.Italic;
	        }
	        if (metrics.isBold) {
	            flags |= FontDescriptorFlags.ForceBold;
	        }
	        return flags;
	    };
	    /**
	     * Calculates BoundBox of the descriptor.
	     * @private
	     */
	    UnicodeTrueTypeFont.prototype.getBoundBox = function () {
	        var rect = this.ttfReader.metrics.fontBox;
	        var width = Math.abs(rect.right - rect.left);
	        var height = Math.abs(rect.top - rect.bottom);
	        var rectangle = new RectangleF(rect.left, rect.bottom, width, height);
	        return rectangle;
	    };
	    /**
	     * Converts integer of decimal system to hex integer.
	     */
	    UnicodeTrueTypeFont.prototype.toHexString = function (n, isCaseChange) {
	        var s = n.toString(16);
	        if (isCaseChange) {
	            s = s.toUpperCase();
	        }
	        return '<0000'.substring(0, 5 - s.length) + s + '>';
	    };
	    /**
	     * Stores used symbols.
	     */
	    UnicodeTrueTypeFont.prototype.setSymbols = function (text) {
	        if (text === null) {
	            throw new Error('Argument Null Exception : text');
	        }
	        if (this.usedChars === null || this.usedChars === undefined) {
	            this.usedChars = new Dictionary();
	        }
	        for (var i = 0; i < text.length; i++) {
	            var ch = text[i];
	            this.usedChars.setValue(ch, String.fromCharCode(0));
	        }
	        // else {
	        //     if (text === null) {
	        //         throw new Error('Argument Null Exception : glyphs');
	        //     }
	        //     if (this.usedChars === null || this.usedChars === undefined) {
	        //             this.usedChars = new Dictionary<string, string>();
	        //     }
	        //     for (let i : number = 0; i < text.length; i++) {
	        //         let glyphIndex : number = text[i];
	        //         let glyph : TtfGlyphInfo =  this.ttfReader.getGlyph(glyphIndex);
	        //         if (!glyph == null) {
	        //             let c : string = glyph.charCode.toLocaleString();
	        //             this.usedChars.setValue(c, String.fromCharCode(0));
	        //         }
	        //     }
	        // }
	        if (this.isEmbedFont === false) {
	            this.getDescendantWidth();
	        }
	    };
	    return UnicodeTrueTypeFont;
	}());

	/**
	 * ArabicShapeRenderer.ts class for EJ2-PDF
	 */
	var ArabicShapeRenderer = /** @class */ (function () {
	    //#endregion
	    //#region Constructor
	    function ArabicShapeRenderer() {
	        //#region Constants
	        this.arabicCharTable = [['\u0621', '\uFE80'], ['\u0622', '\uFE81', '\uFE82'],
	            ['\u0623', '\uFE83', '\uFE84'],
	            ['\u0624', '\uFE85', '\uFE86'],
	            ['\u0625', '\uFE87', '\uFE88'],
	            ['\u0626', '\uFE89', '\uFE8A', '\uFE8B', '\uFE8C'],
	            ['\u0627', '\uFE8D', '\uFE8E'],
	            ['\u0628', '\uFE8F', '\uFE90', '\uFE91', '\uFE92'],
	            ['\u0629', '\uFE93', '\uFE94'],
	            ['\u062A', '\uFE95', '\uFE96', '\uFE97', '\uFE98'],
	            ['\u062B', '\uFE99', '\uFE9A', '\uFE9B', '\uFE9C'],
	            ['\u062C', '\uFE9D', '\uFE9E', '\uFE9F', '\uFEA0'],
	            ['\u062D', '\uFEA1', '\uFEA2', '\uFEA3', '\uFEA4'],
	            ['\u062E', '\uFEA5', '\uFEA6', '\uFEA7', '\uFEA8'],
	            ['\u062F', '\uFEA9', '\uFEAA'],
	            ['\u0630', '\uFEAB', '\uFEAC'],
	            ['\u0631', '\uFEAD', '\uFEAE'],
	            ['\u0632', '\uFEAF', '\uFEB0'],
	            ['\u0633', '\uFEB1', '\uFEB2', '\uFEB3', '\uFEB4'],
	            ['\u0634', '\uFEB5', '\uFEB6', '\uFEB7', '\uFEB8'],
	            ['\u0635', '\uFEB9', '\uFEBA', '\uFEBB', '\uFEBC'],
	            ['\u0636', '\uFEBD', '\uFEBE', '\uFEBF', '\uFEC0'],
	            ['\u0637', '\uFEC1', '\uFEC2', '\uFEC3', '\uFEC4'],
	            ['\u0638', '\uFEC5', '\uFEC6', '\uFEC7', '\uFEC8'],
	            ['\u0639', '\uFEC9', '\uFECA', '\uFECB', '\uFECC'],
	            ['\u063A', '\uFECD', '\uFECE', '\uFECF', '\uFED0'],
	            ['\u0640', '\u0640', '\u0640', '\u0640', '\u0640'],
	            ['\u0641', '\uFED1', '\uFED2', '\uFED3', '\uFED4'],
	            ['\u0642', '\uFED5', '\uFED6', '\uFED7', '\uFED8'],
	            ['\u0643', '\uFED9', '\uFEDA', '\uFEDB', '\uFEDC'],
	            ['\u0644', '\uFEDD', '\uFEDE', '\uFEDF', '\uFEE0'],
	            ['\u0645', '\uFEE1', '\uFEE2', '\uFEE3', '\uFEE4'],
	            ['\u0646', '\uFEE5', '\uFEE6', '\uFEE7', '\uFEE8'],
	            ['\u0647', '\uFEE9', '\uFEEA', '\uFEEB', '\uFEEC'],
	            ['\u0648', '\uFEED', '\uFEEE'],
	            ['\u0649', '\uFEEF', '\uFEF0', '\uFBE8', '\uFBE9'],
	            ['\u064A', '\uFEF1', '\uFEF2', '\uFEF3', '\uFEF4'],
	            ['\u0671', '\uFB50', '\uFB51'],
	            ['\u0679', '\uFB66', '\uFB67', '\uFB68', '\uFB69'],
	            ['\u067A', '\uFB5E', '\uFB5F', '\uFB60', '\uFB61'],
	            ['\u067B', '\uFB52', '\uFB53', '\uFB54', '\uFB55'],
	            ['\u067E', '\uFB56', '\uFB57', '\uFB58', '\uFB59'],
	            ['\u067F', '\uFB62', '\uFB63', '\uFB64', '\uFB65'],
	            ['\u0680', '\uFB5A', '\uFB5B', '\uFB5C', '\uFB5D'],
	            ['\u0683', '\uFB76', '\uFB77', '\uFB78', '\uFB79'],
	            ['\u0684', '\uFB72', '\uFB73', '\uFB74', '\uFB75'],
	            ['\u0686', '\uFB7A', '\uFB7B', '\uFB7C', '\uFB7D'],
	            ['\u0687', '\uFB7E', '\uFB7F', '\uFB80', '\uFB81'],
	            ['\u0688', '\uFB88', '\uFB89'],
	            ['\u068C', '\uFB84', '\uFB85'],
	            ['\u068D', '\uFB82', '\uFB83'],
	            ['\u068E', '\uFB86', '\uFB87'],
	            ['\u0691', '\uFB8C', '\uFB8D'],
	            ['\u0698', '\uFB8A', '\uFB8B'],
	            ['\u06A4', '\uFB6A', '\uFB6B', '\uFB6C', '\uFB6D'],
	            ['\u06A6', '\uFB6E', '\uFB6F', '\uFB70', '\uFB71'],
	            ['\u06A9', '\uFB8E', '\uFB8F', '\uFB90', '\uFB91'],
	            ['\u06AD', '\uFBD3', '\uFBD4', '\uFBD5', '\uFBD6'],
	            ['\u06AF', '\uFB92', '\uFB93', '\uFB94', '\uFB95'],
	            ['\u06B1', '\uFB9A', '\uFB9B', '\uFB9C', '\uFB9D'],
	            ['\u06B3', '\uFB96', '\uFB97', '\uFB98', '\uFB99'],
	            ['\u06BA', '\uFB9E', '\uFB9F'],
	            ['\u06BB', '\uFBA0', '\uFBA1', '\uFBA2', '\uFBA3'],
	            ['\u06BE', '\uFBAA', '\uFBAB', '\uFBAC', '\uFBAD'],
	            ['\u06C0', '\uFBA4', '\uFBA5'],
	            ['\u06C1', '\uFBA6', '\uFBA7', '\uFBA8', '\uFBA9'],
	            ['\u06C5', '\uFBE0', '\uFBE1'],
	            ['\u06C6', '\uFBD9', '\uFBDA'],
	            ['\u06C7', '\uFBD7', '\uFBD8'],
	            ['\u06C8', '\uFBDB', '\uFBDC'],
	            ['\u06C9', '\uFBE2', '\uFBE3'],
	            ['\u06CB', '\uFBDE', '\uFBDF'],
	            ['\u06CC', '\uFBFC', '\uFBFD', '\uFBFE', '\uFBFF'],
	            ['\u06D0', '\uFBE4', '\uFBE5', '\uFBE6', '\uFBE7'],
	            ['\u06D2', '\uFBAE', '\uFBAF'],
	            ['\u06D3', '\uFBB0', '\uFBB1']
	        ];
	        this.alef = '\u0627';
	        this.alefHamza = '\u0623';
	        this.alefHamzaBelow = '\u0625';
	        this.alefMadda = '\u0622';
	        this.lam = '\u0644';
	        this.hamza = '\u0621';
	        this.zeroWidthJoiner = '\u200D';
	        this.hamzaAbove = '\u0654';
	        this.hamzaBelow = '\u0655';
	        this.wawHamza = '\u0624';
	        this.yehHamza = '\u0626';
	        this.waw = '\u0648';
	        this.alefMaksura = '\u0649';
	        this.yeh = '\u064A';
	        this.farsiYeh = '\u06CC';
	        this.shadda = '\u0651';
	        this.madda = '\u0653';
	        this.lwa = '\uFEFB';
	        this.lwawh = '\uFEF7';
	        this.lwawhb = '\uFEF9';
	        this.lwawm = '\uFEF5';
	        this.bwhb = '\u06D3';
	        this.fathatan = '\u064B';
	        this.superScriptalef = '\u0670';
	        this.vowel = 0x1;
	        // #endregion
	        //#region Fields
	        this.arabicMapTable = new Dictionary();
	        for (var i = 0; i < this.arabicCharTable.length; i++) {
	            this.arabicMapTable.setValue(this.arabicCharTable[i][0], this.arabicCharTable[i]);
	        }
	    }
	    //#endregion
	    //#region implementation
	    ArabicShapeRenderer.prototype.getCharacterShape = function (input, index) {
	        if ((input >= this.hamza) && (input <= this.bwhb)) {
	            var value = [];
	            if (this.arabicMapTable.getValue(input)) {
	                value = this.arabicMapTable.getValue(input);
	                return value[index + 1];
	            }
	        }
	        else if (input >= this.lwawm && input <= this.lwa) {
	            return (input);
	        }
	        return input;
	    };
	    ArabicShapeRenderer.prototype.shape = function (text, level) {
	        var builder = '';
	        var str2 = '';
	        for (var i = 0; i < text.length; i++) {
	            var c = text[i];
	            if (c >= '؀' && c <= 'ۿ') {
	                //if(c>= 0x0600.toString() && c<= 0x06FF.toString()) {
	                str2 = str2 + c;
	            }
	            else {
	                if (str2.length > 0) {
	                    var st = this.doShape(str2.toString(), 0);
	                    builder = builder + st;
	                    str2 = '';
	                }
	                builder = builder + c;
	            }
	        }
	        if (str2.length > 0) {
	            var st = this.doShape(str2.toString(), 0);
	            builder = builder + st;
	        }
	        return builder.toString();
	    };
	    ArabicShapeRenderer.prototype.doShape = function (input, level) {
	        var str = '';
	        var ligature = 0;
	        var len = 0;
	        var i = 0;
	        var next = '';
	        var previous = new ArabicShape();
	        var present = new ArabicShape();
	        while (i < input.length) {
	            next = input[i++];
	            ligature = this.ligature(next, present);
	            if (ligature === 0) {
	                var shapeCount = this.getShapeCount(next);
	                len = (shapeCount === 1) ? 0 : 2;
	                if (previous.Shapes > 2) {
	                    len += 1;
	                }
	                len = len % (present.Shapes);
	                present.Value = this.getCharacterShape(present.Value, len);
	                str = this.append(str, previous, level);
	                previous = present;
	                present = new ArabicShape();
	                present.Value = next;
	                present.Shapes = shapeCount;
	                present.Ligature++;
	            }
	        }
	        len = (previous.Shapes > 2) ? 1 : 0;
	        len = len % (present.Shapes);
	        present.Value = this.getCharacterShape(present.Value, len);
	        str = this.append(str, previous, level);
	        str = this.append(str, present, level);
	        return str.toString();
	    };
	    ArabicShapeRenderer.prototype.append = function (builder, shape, level) {
	        if (shape.Value !== '') {
	            builder = builder + shape.Value;
	            shape.Ligature -= 1;
	            if (shape.Type !== '') {
	                if ((level & this.vowel) === 0) {
	                    builder = builder + shape.Type;
	                    shape.Ligature -= 1;
	                }
	                else {
	                    shape.Ligature -= 1;
	                }
	            }
	            if (shape.vowel !== '') {
	                if ((level & this.vowel) === 0) {
	                    builder = builder + shape.vowel;
	                    shape.Ligature -= 1;
	                }
	                else {
	                    shape.Ligature -= 1;
	                }
	            }
	        }
	        return builder;
	    };
	    ArabicShapeRenderer.prototype.ligature = function (value, shape) {
	        if (shape.Value !== '') {
	            var result = 0;
	            if ((value >= this.fathatan && value <= this.hamzaBelow) || value === this.superScriptalef) {
	                result = 1;
	                if ((shape.vowel !== '') && (value !== this.shadda)) {
	                    result = 2;
	                }
	                if (value === this.shadda) {
	                    if (shape.Type == null) {
	                        shape.Type = this.shadda;
	                    }
	                    else {
	                        return 0;
	                    }
	                }
	                else if (value === this.hamzaBelow) {
	                    if (shape.Value === this.alef) {
	                        shape.Value = this.alefHamzaBelow;
	                        result = 2;
	                    }
	                    else if (value === this.lwa) {
	                        shape.Value = this.lwawhb;
	                        result = 2;
	                    }
	                    else {
	                        shape.Type = this.hamzaBelow;
	                    }
	                }
	                else if (value === this.hamzaAbove) {
	                    if (shape.Value === this.alef) {
	                        shape.Value = this.alefHamza;
	                        result = 2;
	                    }
	                    else if (shape.Value === this.lwa) {
	                        shape.Value = this.lwawh;
	                        result = 2;
	                    }
	                    else if (shape.Value === this.waw) {
	                        shape.Value = this.wawHamza;
	                        result = 2;
	                    }
	                    else if (shape.Value === this.yeh || shape.Value === this.alefMaksura || shape.Value === this.farsiYeh) {
	                        shape.Value = this.yehHamza;
	                        result = 2;
	                    }
	                    else {
	                        shape.Type = this.hamzaAbove;
	                    }
	                }
	                else if (value === this.madda) {
	                    if (shape.Value === this.alef) {
	                        shape.Value = this.alefMadda;
	                        result = 2;
	                    }
	                }
	                else {
	                    shape.vowel = value;
	                }
	                if (result === 1) {
	                    shape.Ligature++;
	                }
	                return result;
	            }
	            if (shape.vowel !== '') {
	                return 0;
	            }
	            if (shape.Value === this.lam) {
	                if (value === this.alef) {
	                    shape.Value = this.lwa;
	                    shape.Shapes = 2;
	                    result = 3;
	                }
	                else if (value === this.alefHamza) {
	                    shape.Value = this.lwawh;
	                    shape.Shapes = 2;
	                    result = 3;
	                }
	                else if (value === this.alefHamzaBelow) {
	                    shape.Value = this.lwawhb;
	                    shape.Shapes = 2;
	                    result = 3;
	                }
	                else if (value === this.alefMadda) {
	                    shape.Value = this.lwawm;
	                    shape.Shapes = 2;
	                    result = 3;
	                }
	            }
	            // else if (shape.Value === '') {
	            //     shape.Value = value;
	            //     shape.Shapes = this.getShapeCount(value);
	            //     result = 1;
	            // }
	            return result;
	        }
	        else {
	            return 0;
	        }
	    };
	    ArabicShapeRenderer.prototype.getShapeCount = function (shape) {
	        if ((shape >= this.hamza) && (shape <= this.bwhb) && !((shape >= this.fathatan && shape <= this.hamzaBelow)
	            || shape === this.superScriptalef)) {
	            var c = [];
	            if (this.arabicMapTable.getValue(shape)) {
	                c = this.arabicMapTable.getValue(shape);
	                return c.length - 1;
	            }
	        }
	        else if (shape === this.zeroWidthJoiner) {
	            return 4;
	        }
	        return 1;
	    };
	    return ArabicShapeRenderer;
	}());
	//#endregion
	//#region Internals
	var ArabicShape = /** @class */ (function () {
	    function ArabicShape() {
	        //#region Fields
	        this.shapeValue = '';
	        this.shapeType = '';
	        this.shapeVowel = '';
	        this.shapeLigature = 0;
	        this.shapeShapes = 1;
	        //#endregion
	    }
	    Object.defineProperty(ArabicShape.prototype, "Value", {
	        //#endregion
	        //#region Properties 
	        /**
	         * Gets or sets the values.
	         * @private
	         */
	        get: function () {
	            return this.shapeValue;
	        },
	        set: function (value) {
	            this.shapeValue = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ArabicShape.prototype, "Type", {
	        /**
	         * Gets or sets the values.
	         * @private
	         */
	        get: function () {
	            return this.shapeType;
	        },
	        set: function (value) {
	            this.shapeType = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ArabicShape.prototype, "vowel", {
	        /**
	         * Gets or sets the values.
	         * @private
	         */
	        get: function () {
	            return this.shapeVowel;
	        },
	        set: function (value) {
	            this.shapeVowel = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ArabicShape.prototype, "Ligature", {
	        /**
	         * Gets or sets the values.
	         * @private
	         */
	        get: function () {
	            return this.shapeLigature;
	        },
	        set: function (value) {
	            this.shapeLigature = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ArabicShape.prototype, "Shapes", {
	        /**
	         * Gets or sets the values.
	         * @private
	         */
	        get: function () {
	            return this.shapeShapes;
	        },
	        set: function (value) {
	            this.shapeShapes = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ArabicShape;
	}());
	//#endregion

	/**
	 * Bidi.ts class for EJ2-PDF
	 */
	/**
	 * `Metrics` of the font.
	 * @private
	 */
	var Bidi = /** @class */ (function () {
	    //#endregion
	    //#region Constructor
	    function Bidi() {
	        //#region Fields
	        this.indexes = [];
	        this.indexLevels = [];
	        this.mirroringShapeCharacters = new Dictionary();
	        this.update();
	    }
	    //#endregion
	    //#region implementation
	    Bidi.prototype.doMirrorShaping = function (text) {
	        var result = [];
	        for (var i = 0; i < text.length; i++) {
	            if (((this.indexLevels[i] & 1) === 1) && this.mirroringShapeCharacters.containsKey(text[i].charCodeAt(0))) {
	                result[i] = String.fromCharCode(this.mirroringShapeCharacters.getValue(text[i].charCodeAt(0)));
	            }
	            else {
	                result[i] = text[i].toString();
	            }
	        }
	        var res = '';
	        for (var j = 0; j < result.length; j++) {
	            res = res + result[j];
	        }
	        return res;
	    };
	    Bidi.prototype.getLogicalToVisualString = function (inputText, isRtl) {
	        var rtlCharacters = new RtlCharacters();
	        this.indexLevels = rtlCharacters.getVisualOrder(inputText, isRtl);
	        this.setDefaultIndexLevel();
	        this.doOrder(0, this.indexLevels.length - 1);
	        var text = this.doMirrorShaping(inputText);
	        //let text : string = inputText;
	        var resultBuilder = '';
	        for (var i = 0; i < this.indexes.length; i++) {
	            var index = this.indexes[i];
	            resultBuilder += text[index];
	        }
	        return resultBuilder.toString();
	    };
	    Bidi.prototype.setDefaultIndexLevel = function () {
	        for (var i = 0; i < this.indexLevels.length; i++) {
	            this.indexes[i] = i;
	        }
	    };
	    Bidi.prototype.doOrder = function (sIndex, eIndex) {
	        var max = this.indexLevels[sIndex];
	        var min = max;
	        var odd = max;
	        var even = max;
	        for (var i = sIndex + 1; i <= eIndex; ++i) {
	            var data = this.indexLevels[i];
	            if (data > max) {
	                max = data;
	            }
	            else if (data < min) {
	                min = data;
	            }
	            odd &= data;
	            even |= data;
	        }
	        if ((even & 1) === 0) {
	            return;
	        }
	        if ((odd & 1) === 1) {
	            this.reArrange(sIndex, eIndex + 1);
	            return;
	        }
	        min |= 1;
	        while (max >= min) {
	            var pstart = sIndex;
	            /*tslint:disable:no-constant-condition */
	            while (true) {
	                while (pstart <= eIndex) {
	                    if (this.indexLevels[pstart] >= max) {
	                        break;
	                    }
	                    pstart += 1;
	                }
	                if (pstart > eIndex) {
	                    break;
	                }
	                var pend = pstart + 1;
	                while (pend <= eIndex) {
	                    if (this.indexLevels[pend] < max) {
	                        break;
	                    }
	                    pend += 1;
	                }
	                this.reArrange(pstart, pend);
	                pstart = pend + 1;
	            }
	            max -= 1;
	        }
	    };
	    Bidi.prototype.reArrange = function (i, j) {
	        var length = (i + j) / 2;
	        --j;
	        for (; i < length; ++i, --j) {
	            var temp = this.indexes[i];
	            this.indexes[i] = this.indexes[j];
	            this.indexes[j] = temp;
	        }
	    };
	    Bidi.prototype.update = function () {
	        this.mirroringShapeCharacters.setValue(40, 41);
	        this.mirroringShapeCharacters.setValue(41, 40);
	        this.mirroringShapeCharacters.setValue(60, 62);
	        this.mirroringShapeCharacters.setValue(62, 60);
	        this.mirroringShapeCharacters.setValue(91, 93);
	        this.mirroringShapeCharacters.setValue(93, 91);
	        this.mirroringShapeCharacters.setValue(123, 125);
	        this.mirroringShapeCharacters.setValue(125, 123);
	        this.mirroringShapeCharacters.setValue(171, 187);
	        this.mirroringShapeCharacters.setValue(187, 171);
	        this.mirroringShapeCharacters.setValue(8249, 8250);
	        this.mirroringShapeCharacters.setValue(8250, 8249);
	        this.mirroringShapeCharacters.setValue(8261, 8262);
	        this.mirroringShapeCharacters.setValue(8262, 8261);
	        this.mirroringShapeCharacters.setValue(8317, 8318);
	        this.mirroringShapeCharacters.setValue(8318, 8317);
	        this.mirroringShapeCharacters.setValue(8333, 8334);
	        this.mirroringShapeCharacters.setValue(8334, 8333);
	        this.mirroringShapeCharacters.setValue(8712, 8715);
	        this.mirroringShapeCharacters.setValue(8713, 8716);
	        this.mirroringShapeCharacters.setValue(8714, 8717);
	        this.mirroringShapeCharacters.setValue(8715, 8712);
	        this.mirroringShapeCharacters.setValue(8716, 8713);
	        this.mirroringShapeCharacters.setValue(8717, 8714);
	        this.mirroringShapeCharacters.setValue(8725, 10741);
	        this.mirroringShapeCharacters.setValue(8764, 8765);
	        this.mirroringShapeCharacters.setValue(8765, 8764);
	        this.mirroringShapeCharacters.setValue(8771, 8909);
	        this.mirroringShapeCharacters.setValue(8786, 8787);
	        this.mirroringShapeCharacters.setValue(8787, 8786);
	        this.mirroringShapeCharacters.setValue(8788, 8789);
	        this.mirroringShapeCharacters.setValue(8789, 8788);
	        this.mirroringShapeCharacters.setValue(8804, 8805);
	        this.mirroringShapeCharacters.setValue(8805, 8804);
	        this.mirroringShapeCharacters.setValue(8806, 8807);
	        this.mirroringShapeCharacters.setValue(8807, 8806);
	        this.mirroringShapeCharacters.setValue(8808, 8809);
	        this.mirroringShapeCharacters.setValue(8809, 8808);
	        this.mirroringShapeCharacters.setValue(8810, 8811);
	        this.mirroringShapeCharacters.setValue(8811, 8810);
	        this.mirroringShapeCharacters.setValue(8814, 8815);
	        this.mirroringShapeCharacters.setValue(8815, 8814);
	        this.mirroringShapeCharacters.setValue(8816, 8817);
	        this.mirroringShapeCharacters.setValue(8817, 8816);
	        this.mirroringShapeCharacters.setValue(8818, 8819);
	        this.mirroringShapeCharacters.setValue(8819, 8818);
	        this.mirroringShapeCharacters.setValue(8820, 8821);
	        this.mirroringShapeCharacters.setValue(8821, 8820);
	        this.mirroringShapeCharacters.setValue(8822, 8823);
	        this.mirroringShapeCharacters.setValue(8823, 8822);
	        this.mirroringShapeCharacters.setValue(8824, 8825);
	        this.mirroringShapeCharacters.setValue(8825, 8824);
	        this.mirroringShapeCharacters.setValue(8826, 8827);
	        this.mirroringShapeCharacters.setValue(8827, 8826);
	        this.mirroringShapeCharacters.setValue(8828, 8829);
	        this.mirroringShapeCharacters.setValue(8829, 8828);
	        this.mirroringShapeCharacters.setValue(8830, 8831);
	        this.mirroringShapeCharacters.setValue(8831, 8830);
	        this.mirroringShapeCharacters.setValue(8832, 8833);
	        this.mirroringShapeCharacters.setValue(8833, 8832);
	        this.mirroringShapeCharacters.setValue(8834, 8835);
	        this.mirroringShapeCharacters.setValue(8835, 8834);
	        this.mirroringShapeCharacters.setValue(8836, 8837);
	        this.mirroringShapeCharacters.setValue(8837, 8836);
	        this.mirroringShapeCharacters.setValue(8838, 8839);
	        this.mirroringShapeCharacters.setValue(8839, 8838);
	        this.mirroringShapeCharacters.setValue(8840, 8841);
	        this.mirroringShapeCharacters.setValue(8841, 8840);
	        this.mirroringShapeCharacters.setValue(8842, 8843);
	        this.mirroringShapeCharacters.setValue(8843, 8842);
	        this.mirroringShapeCharacters.setValue(8847, 8848);
	        this.mirroringShapeCharacters.setValue(8848, 8847);
	        this.mirroringShapeCharacters.setValue(8849, 8850);
	        this.mirroringShapeCharacters.setValue(8850, 8849);
	        this.mirroringShapeCharacters.setValue(8856, 10680);
	        this.mirroringShapeCharacters.setValue(8866, 8867);
	        this.mirroringShapeCharacters.setValue(8867, 8866);
	        this.mirroringShapeCharacters.setValue(8870, 10974);
	        this.mirroringShapeCharacters.setValue(8872, 10980);
	        this.mirroringShapeCharacters.setValue(8873, 10979);
	        this.mirroringShapeCharacters.setValue(8875, 10981);
	        this.mirroringShapeCharacters.setValue(8880, 8881);
	        this.mirroringShapeCharacters.setValue(8881, 8880);
	        this.mirroringShapeCharacters.setValue(8882, 8883);
	        this.mirroringShapeCharacters.setValue(8883, 8882);
	        this.mirroringShapeCharacters.setValue(8884, 8885);
	        this.mirroringShapeCharacters.setValue(8885, 8884);
	        /*tslint:disable:max-func-body-length */
	        this.mirroringShapeCharacters.setValue(8886, 8887);
	        this.mirroringShapeCharacters.setValue(8887, 8886);
	        this.mirroringShapeCharacters.setValue(8905, 8906);
	        this.mirroringShapeCharacters.setValue(8906, 8905);
	        this.mirroringShapeCharacters.setValue(8907, 8908);
	        this.mirroringShapeCharacters.setValue(8908, 8907);
	        this.mirroringShapeCharacters.setValue(8909, 8771);
	        this.mirroringShapeCharacters.setValue(8912, 8913);
	        this.mirroringShapeCharacters.setValue(8913, 8912);
	        this.mirroringShapeCharacters.setValue(8918, 8919);
	        this.mirroringShapeCharacters.setValue(8919, 8918);
	        this.mirroringShapeCharacters.setValue(8920, 8921);
	        this.mirroringShapeCharacters.setValue(8921, 8920);
	        this.mirroringShapeCharacters.setValue(8922, 8923);
	        this.mirroringShapeCharacters.setValue(8923, 8922);
	        this.mirroringShapeCharacters.setValue(8924, 8925);
	        this.mirroringShapeCharacters.setValue(8925, 8924);
	        this.mirroringShapeCharacters.setValue(8926, 8927);
	        this.mirroringShapeCharacters.setValue(8927, 8926);
	        this.mirroringShapeCharacters.setValue(8928, 8929);
	        this.mirroringShapeCharacters.setValue(8929, 8928);
	        this.mirroringShapeCharacters.setValue(8930, 8931);
	        this.mirroringShapeCharacters.setValue(8931, 8930);
	        this.mirroringShapeCharacters.setValue(8932, 8933);
	        this.mirroringShapeCharacters.setValue(8933, 8932);
	        this.mirroringShapeCharacters.setValue(8934, 8935);
	        this.mirroringShapeCharacters.setValue(8935, 8934);
	        this.mirroringShapeCharacters.setValue(8936, 8937);
	        this.mirroringShapeCharacters.setValue(8937, 8936);
	        this.mirroringShapeCharacters.setValue(8938, 8939);
	        this.mirroringShapeCharacters.setValue(8939, 8938);
	        this.mirroringShapeCharacters.setValue(8940, 8941);
	        this.mirroringShapeCharacters.setValue(8941, 8940);
	        this.mirroringShapeCharacters.setValue(8944, 8945);
	        this.mirroringShapeCharacters.setValue(8945, 8944);
	        this.mirroringShapeCharacters.setValue(8946, 8954);
	        this.mirroringShapeCharacters.setValue(8947, 8955);
	        this.mirroringShapeCharacters.setValue(8948, 8956);
	        this.mirroringShapeCharacters.setValue(8950, 8957);
	        this.mirroringShapeCharacters.setValue(8951, 8958);
	        this.mirroringShapeCharacters.setValue(8954, 8946);
	        this.mirroringShapeCharacters.setValue(8955, 8947);
	        this.mirroringShapeCharacters.setValue(8956, 8948);
	        this.mirroringShapeCharacters.setValue(8957, 8950);
	        this.mirroringShapeCharacters.setValue(8958, 8951);
	        this.mirroringShapeCharacters.setValue(8968, 8969);
	        this.mirroringShapeCharacters.setValue(8969, 8968);
	        this.mirroringShapeCharacters.setValue(8970, 8971);
	        this.mirroringShapeCharacters.setValue(8971, 8970);
	        this.mirroringShapeCharacters.setValue(9001, 9002);
	        this.mirroringShapeCharacters.setValue(9002, 9001);
	        this.mirroringShapeCharacters.setValue(10088, 10089);
	        this.mirroringShapeCharacters.setValue(10089, 10088);
	        this.mirroringShapeCharacters.setValue(10090, 10091);
	        this.mirroringShapeCharacters.setValue(10091, 10090);
	        this.mirroringShapeCharacters.setValue(10092, 10093);
	        this.mirroringShapeCharacters.setValue(10093, 10092);
	        this.mirroringShapeCharacters.setValue(10094, 10095);
	        this.mirroringShapeCharacters.setValue(10095, 10094);
	        this.mirroringShapeCharacters.setValue(10096, 10097);
	        this.mirroringShapeCharacters.setValue(10097, 10096);
	        this.mirroringShapeCharacters.setValue(10098, 10099);
	        this.mirroringShapeCharacters.setValue(10099, 10098);
	        this.mirroringShapeCharacters.setValue(10100, 10101);
	        this.mirroringShapeCharacters.setValue(10101, 10100);
	        this.mirroringShapeCharacters.setValue(10197, 10198);
	        this.mirroringShapeCharacters.setValue(10198, 10197);
	        this.mirroringShapeCharacters.setValue(10205, 10206);
	        this.mirroringShapeCharacters.setValue(10206, 10205);
	        this.mirroringShapeCharacters.setValue(10210, 10211);
	        this.mirroringShapeCharacters.setValue(10211, 10210);
	        this.mirroringShapeCharacters.setValue(10212, 10213);
	        this.mirroringShapeCharacters.setValue(10213, 10212);
	        this.mirroringShapeCharacters.setValue(10214, 10215);
	        this.mirroringShapeCharacters.setValue(10215, 10214);
	        this.mirroringShapeCharacters.setValue(10216, 10217);
	        this.mirroringShapeCharacters.setValue(10217, 10216);
	        this.mirroringShapeCharacters.setValue(10218, 10219);
	        this.mirroringShapeCharacters.setValue(10219, 10218);
	        this.mirroringShapeCharacters.setValue(10627, 10628);
	        this.mirroringShapeCharacters.setValue(10628, 10627);
	        this.mirroringShapeCharacters.setValue(10629, 10630);
	        this.mirroringShapeCharacters.setValue(10630, 10629);
	        this.mirroringShapeCharacters.setValue(10631, 10632);
	        this.mirroringShapeCharacters.setValue(10632, 10631);
	        this.mirroringShapeCharacters.setValue(10633, 10634);
	        this.mirroringShapeCharacters.setValue(10634, 10633);
	        this.mirroringShapeCharacters.setValue(10635, 10636);
	        this.mirroringShapeCharacters.setValue(10636, 10635);
	        this.mirroringShapeCharacters.setValue(10637, 10640);
	        this.mirroringShapeCharacters.setValue(10638, 10639);
	        this.mirroringShapeCharacters.setValue(10639, 10638);
	        this.mirroringShapeCharacters.setValue(10640, 10637);
	        this.mirroringShapeCharacters.setValue(10641, 10642);
	        this.mirroringShapeCharacters.setValue(10642, 10641);
	        this.mirroringShapeCharacters.setValue(10643, 10644);
	        this.mirroringShapeCharacters.setValue(10644, 10643);
	        this.mirroringShapeCharacters.setValue(10645, 10646);
	        this.mirroringShapeCharacters.setValue(10646, 10645);
	        this.mirroringShapeCharacters.setValue(10647, 10648);
	        this.mirroringShapeCharacters.setValue(10648, 10647);
	        this.mirroringShapeCharacters.setValue(10680, 8856);
	        this.mirroringShapeCharacters.setValue(10688, 10689);
	        this.mirroringShapeCharacters.setValue(10689, 10688);
	        this.mirroringShapeCharacters.setValue(10692, 10693);
	        this.mirroringShapeCharacters.setValue(10693, 10692);
	        this.mirroringShapeCharacters.setValue(10703, 10704);
	        this.mirroringShapeCharacters.setValue(10704, 10703);
	        this.mirroringShapeCharacters.setValue(10705, 10706);
	        this.mirroringShapeCharacters.setValue(10706, 10705);
	        this.mirroringShapeCharacters.setValue(10708, 10709);
	        this.mirroringShapeCharacters.setValue(10709, 10708);
	        this.mirroringShapeCharacters.setValue(10712, 10713);
	        this.mirroringShapeCharacters.setValue(10713, 10712);
	        this.mirroringShapeCharacters.setValue(10714, 10715);
	        this.mirroringShapeCharacters.setValue(10715, 10714);
	        this.mirroringShapeCharacters.setValue(10741, 8725);
	        this.mirroringShapeCharacters.setValue(10744, 10745);
	        this.mirroringShapeCharacters.setValue(10745, 10744);
	        this.mirroringShapeCharacters.setValue(10748, 10749);
	        this.mirroringShapeCharacters.setValue(10749, 10748);
	        this.mirroringShapeCharacters.setValue(10795, 10796);
	        this.mirroringShapeCharacters.setValue(10796, 10795);
	        this.mirroringShapeCharacters.setValue(10797, 10796);
	        this.mirroringShapeCharacters.setValue(10798, 10797);
	        this.mirroringShapeCharacters.setValue(10804, 10805);
	        this.mirroringShapeCharacters.setValue(10805, 10804);
	        this.mirroringShapeCharacters.setValue(10812, 10813);
	        this.mirroringShapeCharacters.setValue(10813, 10812);
	        this.mirroringShapeCharacters.setValue(10852, 10853);
	        this.mirroringShapeCharacters.setValue(10853, 10852);
	        this.mirroringShapeCharacters.setValue(10873, 10874);
	        this.mirroringShapeCharacters.setValue(10874, 10873);
	        this.mirroringShapeCharacters.setValue(10877, 10878);
	        this.mirroringShapeCharacters.setValue(10878, 10877);
	        this.mirroringShapeCharacters.setValue(10879, 10880);
	        this.mirroringShapeCharacters.setValue(10880, 10879);
	        this.mirroringShapeCharacters.setValue(10881, 10882);
	        this.mirroringShapeCharacters.setValue(10882, 10881);
	        this.mirroringShapeCharacters.setValue(10883, 10884);
	        this.mirroringShapeCharacters.setValue(10884, 10883);
	        this.mirroringShapeCharacters.setValue(10891, 10892);
	        this.mirroringShapeCharacters.setValue(10892, 10891);
	        this.mirroringShapeCharacters.setValue(10897, 10898);
	        this.mirroringShapeCharacters.setValue(10898, 10897);
	        this.mirroringShapeCharacters.setValue(10899, 10900);
	        this.mirroringShapeCharacters.setValue(10900, 10899);
	        this.mirroringShapeCharacters.setValue(10901, 10902);
	        this.mirroringShapeCharacters.setValue(10902, 10901);
	        this.mirroringShapeCharacters.setValue(10903, 10904);
	        this.mirroringShapeCharacters.setValue(10904, 10903);
	        this.mirroringShapeCharacters.setValue(10905, 10906);
	        this.mirroringShapeCharacters.setValue(10906, 10905);
	        this.mirroringShapeCharacters.setValue(10907, 10908);
	        this.mirroringShapeCharacters.setValue(10908, 10907);
	        this.mirroringShapeCharacters.setValue(10913, 10914);
	        this.mirroringShapeCharacters.setValue(10914, 10913);
	        this.mirroringShapeCharacters.setValue(10918, 10919);
	        this.mirroringShapeCharacters.setValue(10919, 10918);
	        this.mirroringShapeCharacters.setValue(10920, 10921);
	        this.mirroringShapeCharacters.setValue(10921, 10920);
	        this.mirroringShapeCharacters.setValue(10922, 10923);
	        this.mirroringShapeCharacters.setValue(10923, 10922);
	        this.mirroringShapeCharacters.setValue(10924, 10925);
	        this.mirroringShapeCharacters.setValue(10925, 10924);
	        this.mirroringShapeCharacters.setValue(10927, 10928);
	        this.mirroringShapeCharacters.setValue(10928, 10927);
	        this.mirroringShapeCharacters.setValue(10931, 10932);
	        this.mirroringShapeCharacters.setValue(10932, 10931);
	        this.mirroringShapeCharacters.setValue(10939, 10940);
	        this.mirroringShapeCharacters.setValue(10940, 10939);
	        this.mirroringShapeCharacters.setValue(10941, 10942);
	        this.mirroringShapeCharacters.setValue(10942, 10941);
	        this.mirroringShapeCharacters.setValue(10943, 10944);
	        this.mirroringShapeCharacters.setValue(10944, 10943);
	        this.mirroringShapeCharacters.setValue(10945, 10946);
	        this.mirroringShapeCharacters.setValue(10946, 10945);
	        this.mirroringShapeCharacters.setValue(10947, 10948);
	        this.mirroringShapeCharacters.setValue(10948, 10947);
	        this.mirroringShapeCharacters.setValue(10949, 10950);
	        this.mirroringShapeCharacters.setValue(10950, 10949);
	        this.mirroringShapeCharacters.setValue(10957, 10958);
	        this.mirroringShapeCharacters.setValue(10958, 10957);
	        this.mirroringShapeCharacters.setValue(10959, 10960);
	        this.mirroringShapeCharacters.setValue(10960, 10959);
	        this.mirroringShapeCharacters.setValue(10961, 10962);
	        this.mirroringShapeCharacters.setValue(10962, 10961);
	        this.mirroringShapeCharacters.setValue(10963, 10964);
	        this.mirroringShapeCharacters.setValue(10964, 10963);
	        this.mirroringShapeCharacters.setValue(10965, 10966);
	        this.mirroringShapeCharacters.setValue(10966, 10965);
	        this.mirroringShapeCharacters.setValue(10974, 8870);
	        this.mirroringShapeCharacters.setValue(10979, 8873);
	        this.mirroringShapeCharacters.setValue(10980, 8872);
	        this.mirroringShapeCharacters.setValue(10981, 8875);
	        this.mirroringShapeCharacters.setValue(10988, 10989);
	        this.mirroringShapeCharacters.setValue(10989, 10988);
	        this.mirroringShapeCharacters.setValue(10999, 11000);
	        this.mirroringShapeCharacters.setValue(11000, 10999);
	        this.mirroringShapeCharacters.setValue(11001, 11002);
	        this.mirroringShapeCharacters.setValue(11002, 11001);
	        this.mirroringShapeCharacters.setValue(12296, 12297);
	        this.mirroringShapeCharacters.setValue(12297, 12296);
	        this.mirroringShapeCharacters.setValue(12298, 12299);
	        this.mirroringShapeCharacters.setValue(12299, 12298);
	        this.mirroringShapeCharacters.setValue(12300, 12301);
	        this.mirroringShapeCharacters.setValue(12301, 12300);
	        this.mirroringShapeCharacters.setValue(12302, 12303);
	        this.mirroringShapeCharacters.setValue(12303, 12302);
	        this.mirroringShapeCharacters.setValue(12304, 12305);
	        this.mirroringShapeCharacters.setValue(12305, 12304);
	        this.mirroringShapeCharacters.setValue(12308, 12309);
	        this.mirroringShapeCharacters.setValue(12309, 12308);
	        this.mirroringShapeCharacters.setValue(12310, 12311);
	        this.mirroringShapeCharacters.setValue(12311, 12310);
	        this.mirroringShapeCharacters.setValue(12312, 12313);
	        this.mirroringShapeCharacters.setValue(12313, 12312);
	        this.mirroringShapeCharacters.setValue(12314, 12315);
	        this.mirroringShapeCharacters.setValue(12315, 12314);
	        this.mirroringShapeCharacters.setValue(65288, 65289);
	        this.mirroringShapeCharacters.setValue(65289, 65288);
	        this.mirroringShapeCharacters.setValue(65308, 65310);
	        this.mirroringShapeCharacters.setValue(65310, 65308);
	        this.mirroringShapeCharacters.setValue(65339, 65341);
	        this.mirroringShapeCharacters.setValue(65341, 65339);
	        this.mirroringShapeCharacters.setValue(65371, 65373);
	        this.mirroringShapeCharacters.setValue(65373, 65371);
	        this.mirroringShapeCharacters.setValue(65375, 65376);
	        this.mirroringShapeCharacters.setValue(65376, 65375);
	        this.mirroringShapeCharacters.setValue(65378, 65379);
	        this.mirroringShapeCharacters.setValue(65379, 65378);
	    };
	    return Bidi;
	}());
	var RtlCharacters = /** @class */ (function () {
	    //#endregion
	    //#region constructors
	    function RtlCharacters() {
	        //#region fields
	        /// <summary>
	        /// Specifies the character types.
	        /// </summary>
	        this.types = [];
	        /// <summary>
	        /// Specifies the text order (RTL or LTR).
	        /// </summary>
	        this.textOrder = -1;
	        /// <summary>
	        /// Specifies the RTL character types.
	        /// </summary>
	        /* tslint:disable-next-line:prefer-array-literal */
	        this.rtlCharacterTypes = new Array(65536);
	        //#endregion
	        //#region constants
	        /// <summary>
	        /// Left-to-Right (Non-European or non-Arabic digits).
	        /// </summary>
	        this.L = 0;
	        /// <summary>
	        /// Left-to-Right Embedding
	        /// </summary>
	        this.LRE = 1;
	        /// <summary>
	        /// Left-to-Right Override
	        /// </summary>
	        this.LRO = 2;
	        /// <summary>
	        /// Right-to-Left (Hebrew alphabet, and related punctuation).
	        /// </summary>
	        this.R = 3;
	        /// <summary>
	        /// Right-to-Left Arabic 
	        /// </summary>
	        this.AL = 4;
	        /// <summary>
	        /// Right-to-Left Embedding.
	        /// </summary>
	        this.RLE = 5;
	        /// <summary>
	        /// Right-to-Left Override
	        /// </summary>
	        this.RLO = 6;
	        /// <summary>
	        /// Pop Directional Format
	        /// </summary>
	        this.PDF = 7;
	        /// <summary>
	        /// European Number (European digits, Eastern Arabic-Indic digits).
	        /// </summary>
	        this.EN = 8;
	        /// <summary>
	        /// European Number Separator (Plus sign, Minus sign).
	        /// </summary>
	        this.ES = 9;
	        /// <summary>
	        /// European Number Terminator (Degree sign, currency symbols).
	        /// </summary>
	        this.ET = 10;
	        /// <summary>
	        /// Arabic Number (Arabic-Indic digits, Arabic decimal and thousands separators).
	        /// </summary>
	        this.AN = 11;
	        /// <summary>
	        /// Common Number Separator (Colon, Comma, Full Stop, No-Break Space.
	        /// </summary>
	        this.CS = 12;
	        /// <summary>
	        /// Nonspacing Mark (Characters with the General_Category values).
	        /// </summary>
	        this.NSM = 13;
	        /// <summary>
	        /// Boundary Neutral (Default ignorables, non-characters, and control characters, other than those explicitly given other types.)
	        /// </summary>
	        this.BN = 14;
	        /// <summary>
	        /// Paragraph Separator (Paragraph separator, appropriate Newline Functions, higher-level protocol paragraph determination).
	        /// </summary>
	        this.B = 15;
	        /// <summary>
	        /// 	Segment Separator (tab).
	        /// </summary>
	        this.S = 16;
	        /// <summary>
	        /// Whitespace (Space, Figure space, Line separator, Form feed, General Punctuation spaces).
	        /// </summary>
	        this.WS = 17;
	        /// <summary>
	        /// Other Neutrals (All other characters, including object replacement character).
	        /// </summary>
	        this.ON = 18;
	        /// <summary>
	        /// RTL character types.
	        /// </summary>
	        this.charTypes = [
	            this.L, this.EN, this.BN, this.ES, this.ES, this.S, this.ET, this.ET, this.B, this.AN, this.AN, this.S, this.CS, this.CS,
	            this.WS, this.NSM, this.NSM, this.B, this.BN, 27, this.BN, 28, 30, this.B, 31, 31, this.S, 32, 32, this.WS, 33, 34,
	            this.ON, 35, 37, this.ET, 38, 42, this.ON, 43, 43, this.ET, 44, 44, this.CS, 45, 45, this.ET, 46, 46, this.CS,
	            47, 47, this.CS, 48, 57, this.EN, 58, 58, this.CS, 59, 64, this.ON, 65, 90, this.L, 91, 96, this.ON, 97, 122, this.L,
	            123, 126, this.ON, 127, 132, this.BN, 133, 133, this.B, 134, 159, this.BN, 160, 160, this.CS,
	            161, 161, this.ON, 162, 165, this.ET, 166, 169, this.ON, 170, 170, this.L, 171, 175, this.ON,
	            176, 177, this.ET, 178, 179, this.EN, 180, 180, this.ON, 181, 181, this.L, 182, 184, this.ON,
	            185, 185, this.EN, 186, 186, this.L, 187, 191, this.ON, 192, 214, this.L, 215, 215, this.ON,
	            216, 246, this.L, 247, 247, this.ON, 248, 696, this.L, 697, 698, this.ON, 699, 705, this.L,
	            706, 719, this.ON, 720, 721, this.L, 722, 735, this.ON, 736, 740, this.L, 741, 749, this.ON,
	            750, 750, this.L, 751, 767, this.ON, 768, 855, this.NSM, 856, 860, this.L, 861, 879, this.NSM,
	            880, 883, this.L, 884, 885, this.ON, 886, 893, this.L, 894, 894, this.ON, 895, 899, this.L,
	            900, 901, this.ON, 902, 902, this.L, 903, 903, this.ON, 904, 1013, this.L, 1014, 1014, this.ON,
	            1015, 1154, this.L, 1155, 1158, this.NSM, 1159, 1159, this.L, 1160, 1161, this.NSM,
	            1162, 1417, this.L, 1418, 1418, this.ON, 1419, 1424, this.L, 1425, 1441, this.NSM,
	            1442, 1442, this.L, 1443, 1465, this.NSM, 1466, 1466, this.L, 1467, 1469, this.NSM,
	            1470, 1470, this.R, 1471, 1471, this.NSM, 1472, 1472, this.R, 1473, 1474, this.NSM,
	            1475, 1475, this.R, 1476, 1476, this.NSM, 1477, 1487, this.L, 1488, 1514, this.R,
	            1515, 1519, this.L, 1520, 1524, this.R, 1525, 1535, this.L, 1536, 1539, this.AL,
	            1540, 1547, this.L, 1548, 1548, this.CS, 1549, 1549, this.AL, 1550, 1551, this.ON,
	            1552, 1557, this.NSM, 1558, 1562, this.L, 1563, 1563, this.AL, 1564, 1566, this.L,
	            1567, 1567, this.AL, 1568, 1568, this.L, 1569, 1594, this.AL, 1595, 1599, this.L,
	            1600, 1610, this.AL, 1611, 1624, this.NSM, 1625, 1631, this.L, 1632, 1641, this.AN,
	            1642, 1642, this.ET, 1643, 1644, this.AN, 1645, 1647, this.AL, 1648, 1648, this.NSM,
	            1649, 1749, this.AL, 1750, 1756, this.NSM, 1757, 1757, this.AL, 1758, 1764, this.NSM,
	            1765, 1766, this.AL, 1767, 1768, this.NSM, 1769, 1769, this.ON, 1770, 1773, this.NSM,
	            1774, 1775, this.AL, 1776, 1785, this.EN, 1786, 1805, this.AL, 1806, 1806, this.L,
	            1807, 1807, this.BN, 1808, 1808, this.AL, 1809, 1809, this.NSM, 1810, 1839, this.AL,
	            1840, 1866, this.NSM, 1867, 1868, this.L, 1869, 1871, this.AL, 1872, 1919, this.L,
	            1920, 1957, this.AL, 1958, 1968, this.NSM, 1969, 1969, this.AL, 1970, 2304, this.L,
	            2305, 2306, this.NSM, 2307, 2363, this.L, 2364, 2364, this.NSM, 2365, 2368, this.L,
	            2369, 2376, this.NSM, 2377, 2380, this.L, 2381, 2381, this.NSM, 2382, 2384, this.L,
	            2385, 2388, this.NSM, 2389, 2401, this.L, 2402, 2403, this.NSM, 2404, 2432, this.L,
	            2433, 2433, this.NSM, 2434, 2491, this.L, 2492, 2492, this.NSM, 2493, 2496, this.L,
	            2497, 2500, this.NSM, 2501, 2508, this.L, 2509, 2509, this.NSM, 2510, 2529, this.L,
	            2530, 2531, this.NSM, 2532, 2545, this.L, 2546, 2547, this.ET, 2548, 2560, this.L,
	            2561, 2562, this.NSM, 2563, 2619, this.L, 2620, 2620, this.NSM, 2621, 2624, this.L,
	            2625, 2626, this.NSM, 2627, 2630, this.L, 2631, 2632, this.NSM, 2633, 2634, this.L,
	            2635, 2637, this.NSM, 2638, 2671, this.L, 2672, 2673, this.NSM, 2674, 2688, this.L,
	            2689, 2690, this.NSM, 2691, 2747, this.L, 2748, 2748, this.NSM, 2749, 2752, this.L,
	            2753, 2757, this.NSM, 2758, 2758, this.L, 2759, 2760, this.NSM, 2761, 2764, this.L,
	            2765, 2765, this.NSM, 2766, 2785, this.L, 2786, 2787, this.NSM, 2788, 2800, this.L,
	            2801, 2801, this.ET, 2802, 2816, this.L, 2817, 2817, this.NSM, 2818, 2875, this.L,
	            2876, 2876, this.NSM, 2877, 2878, this.L, 2879, 2879, this.NSM, 2880, 2880, this.L,
	            2881, 2883, this.NSM, 2884, 2892, this.L, 2893, 2893, this.NSM, 2894, 2901, this.L,
	            2902, 2902, this.NSM, 2903, 2945, this.L, 2946, 2946, this.NSM, 2947, 3007, this.L,
	            3008, 3008, this.NSM, 3009, 3020, this.L, 3021, 3021, this.NSM, 3022, 3058, this.L,
	            3059, 3064, this.ON, 3065, 3065, this.ET, 3066, 3066, this.ON, 3067, 3133, this.L,
	            3134, 3136, this.NSM, 3137, 3141, this.L, 3142, 3144, this.NSM, 3145, 3145, this.L,
	            3146, 3149, this.NSM, 3150, 3156, this.L, 3157, 3158, this.NSM, 3159, 3259, this.L,
	            3260, 3260, this.NSM, 3261, 3275, this.L, 3276, 3277, this.NSM, 3278, 3392, this.L,
	            3393, 3395, this.NSM, 3396, 3404, this.L, 3405, 3405, this.NSM, 3406, 3529, this.L,
	            3530, 3530, this.NSM, 3531, 3537, this.L, 3538, 3540, this.NSM, 3541, 3541, this.L,
	            3542, 3542, this.NSM, 3543, 3632, this.L, 3633, 3633, this.NSM, 3634, 3635, this.L,
	            3636, 3642, this.NSM, 3643, 3646, this.L, 3647, 3647, this.ET, 3648, 3654, this.L,
	            3655, 3662, this.NSM, 3663, 3760, this.L, 3761, 3761, this.NSM, 3762, 3763, this.L,
	            3764, 3769, this.NSM, 3770, 3770, this.L, 3771, 3772, this.NSM, 3773, 3783, this.L,
	            3784, 3789, this.NSM, 3790, 3863, this.L, 3864, 3865, this.NSM, 3866, 3892, this.L,
	            3893, 3893, this.NSM, 3894, 3894, this.L, 3895, 3895, this.NSM, 3896, 3896, this.L,
	            3897, 3897, this.NSM, 3898, 3901, this.ON, 3902, 3952, this.L, 3953, 3966, this.NSM,
	            3967, 3967, this.L, 3968, 3972, this.NSM, 3973, 3973, this.L, 3974, 3975, this.NSM,
	            3976, 3983, this.L, 3984, 3991, this.NSM, 3992, 3992, this.L, 3993, 4028, this.NSM,
	            4029, 4037, this.L, 4038, 4038, this.NSM, 4039, 4140, this.L, 4141, 4144, this.NSM,
	            4145, 4145, this.L, 4146, 4146, this.NSM, 4147, 4149, this.L, 4150, 4151, this.NSM,
	            4152, 4152, this.L, 4153, 4153, this.NSM, 4154, 4183, this.L, 4184, 4185, this.NSM,
	            4186, 5759, this.L, 5760, 5760, this.WS, 5761, 5786, this.L, 5787, 5788, this.ON,
	            5789, 5905, this.L, 5906, 5908, this.NSM, 5909, 5937, this.L, 5938, 5940, this.NSM,
	            5941, 5969, this.L, 5970, 5971, this.NSM, 5972, 6001, this.L, 6002, 6003, this.NSM,
	            6004, 6070, this.L, 6071, 6077, this.NSM, 6078, 6085, this.L, 6086, 6086, this.NSM,
	            6087, 6088, this.L, 6089, 6099, this.NSM, 6100, 6106, this.L, 6107, 6107, this.ET,
	            6108, 6108, this.L, 6109, 6109, this.NSM, 6110, 6127, this.L, 6128, 6137, this.ON,
	            6138, 6143, this.L, 6144, 6154, this.ON, 6155, 6157, this.NSM, 6158, 6158, this.WS,
	            6159, 6312, this.L, 6313, 6313, this.NSM, 6314, 6431, this.L, 6432, 6434, this.NSM,
	            6435, 6438, this.L, 6439, 6443, this.NSM, 6444, 6449, this.L, 6450, 6450, this.NSM,
	            6451, 6456, this.L, 6457, 6459, this.NSM, 6460, 6463, this.L, 6464, 6464, this.ON,
	            6465, 6467, this.L, 6468, 6469, this.ON, 6470, 6623, this.L, 6624, 6655, this.ON,
	            6656, 8124, this.L, 8125, 8125, this.ON, 8126, 8126, this.L, 8127, 8129, this.ON,
	            8130, 8140, this.L, 8141, 8143, this.ON, 8144, 8156, this.L, 8157, 8159, this.ON,
	            8160, 8172, this.L, 8173, 8175, this.ON, 8176, 8188, this.L, 8189, 8190, this.ON,
	            8191, 8191, this.L, 8192, 8202, this.WS, 8203, 8205, this.BN, 8206, 8206, this.L,
	            8207, 8207, this.R, 8208, 8231, this.ON, 8232, 8232, this.WS, 8233, 8233, this.B,
	            8234, 8234, this.LRE, 8235, 8235, this.RLE, 8236, 8236, this.PDF, 8237, 8237, this.LRO,
	            8238, 8238, this.RLO, 8239, 8239, this.WS, 8240, 8244, this.ET, 8245, 8276, this.ON,
	            8277, 8278, this.L, 8279, 8279, this.ON, 8280, 8286, this.L, 8287, 8287, this.WS,
	            8288, 8291, this.BN, 8292, 8297, this.L, 8298, 8303, this.BN, 8304, 8304, this.EN,
	            8305, 8307, this.L, 8308, 8313, this.EN, 8314, 8315, this.ET, 8316, 8318, this.ON,
	            8319, 8319, this.L, 8320, 8329, this.EN, 8330, 8331, this.ET, 8332, 8334, this.ON,
	            8335, 8351, this.L, 8352, 8369, this.ET, 8370, 8399, this.L, 8400, 8426, this.NSM,
	            8427, 8447, this.L, 8448, 8449, this.ON, 8450, 8450, this.L, 8451, 8454, this.ON,
	            8455, 8455, this.L, 8456, 8457, this.ON, 8458, 8467, this.L, 8468, 8468, this.ON,
	            8469, 8469, this.L, 8470, 8472, this.ON, 8473, 8477, this.L, 8478, 8483, this.ON,
	            8484, 8484, this.L, 8485, 8485, this.ON, 8486, 8486, this.L, 8487, 8487, this.ON,
	            8488, 8488, this.L, 8489, 8489, this.ON, 8490, 8493, this.L, 8494, 8494, this.ET,
	            8495, 8497, this.L, 8498, 8498, this.ON, 8499, 8505, this.L, 8506, 8507, this.ON,
	            8508, 8511, this.L, 8512, 8516, this.ON, 8517, 8521, this.L, 8522, 8523, this.ON,
	            8524, 8530, this.L, 8531, 8543, this.ON, 8544, 8591, this.L, 8592, 8721, this.ON,
	            8722, 8723, this.ET, 8724, 9013, this.ON, 9014, 9082, this.L, 9083, 9108, this.ON,
	            9109, 9109, this.L, 9110, 9168, this.ON, 9169, 9215, this.L, 9216, 9254, this.ON,
	            9255, 9279, this.L, 9280, 9290, this.ON, 9291, 9311, this.L, 9312, 9371, this.EN,
	            9372, 9449, this.L, 9450, 9450, this.EN, 9451, 9751, this.ON, 9752, 9752, this.L,
	            9753, 9853, this.ON, 9854, 9855, this.L, 9856, 9873, this.ON, 9874, 9887, this.L,
	            9888, 9889, this.ON, 9890, 9984, this.L, 9985, 9988, this.ON, 9989, 9989, this.L,
	            9990, 9993, this.ON, 9994, 9995, this.L, 9996, 10023, this.ON, 10024, 10024, this.L,
	            10025, 10059, this.ON, 10060, 10060, this.L, 10061, 10061, this.ON, 10062, 10062, this.L,
	            10063, 10066, this.ON, 10067, 10069, this.L, 10070, 10070, this.ON, 10071, 10071, this.L,
	            10072, 10078, this.ON, 10079, 10080, this.L, 10081, 10132, this.ON, 10133, 10135, this.L,
	            10136, 10159, this.ON, 10160, 10160, this.L, 10161, 10174, this.ON, 10175, 10191, this.L,
	            10192, 10219, this.ON, 10220, 10223, this.L, 10224, 11021, this.ON, 11022, 11903, this.L,
	            11904, 11929, this.ON, 11930, 11930, this.L, 11931, 12019, this.ON, 12020, 12031, this.L,
	            12032, 12245, this.ON, 12246, 12271, this.L, 12272, 12283, this.ON, 12284, 12287, this.L,
	            12288, 12288, this.WS, 12289, 12292, this.ON, 12293, 12295, this.L, 12296, 12320, this.ON,
	            12321, 12329, this.L, 12330, 12335, this.NSM, 12336, 12336, this.ON, 12337, 12341, this.L,
	            12342, 12343, this.ON, 12344, 12348, this.L, 12349, 12351, this.ON, 12352, 12440, this.L,
	            12441, 12442, this.NSM, 12443, 12444, this.ON, 12445, 12447, this.L, 12448, 12448, this.ON,
	            12449, 12538, this.L, 12539, 12539, this.ON, 12540, 12828, this.L, 12829, 12830, this.ON,
	            12831, 12879, this.L, 12880, 12895, this.ON, 12896, 12923, this.L, 12924, 12925, this.ON,
	            12926, 12976, this.L, 12977, 12991, this.ON, 12992, 13003, this.L, 13004, 13007, this.ON,
	            13008, 13174, this.L, 13175, 13178, this.ON, 13179, 13277, this.L, 13278, 13279, this.ON,
	            13280, 13310, this.L, 13311, 13311, this.ON, 13312, 19903, this.L, 19904, 19967, this.ON,
	            19968, 42127, this.L, 42128, 42182, this.ON, 42183, 64284, this.L, 64285, 64285, this.R,
	            64286, 64286, this.NSM, 64287, 64296, this.R, 64297, 64297, this.ET, 64298, 64310, this.R,
	            64311, 64311, this.L, 64312, 64316, this.R, 64317, 64317, this.L, 64318, 64318, this.R,
	            64319, 64319, this.L, 64320, 64321, this.R, 64322, 64322, this.L, 64323, 64324, this.R,
	            64325, 64325, this.L, 64326, 64335, this.R, 64336, 64433, this.AL, 64434, 64466, this.L,
	            64467, 64829, this.AL, 64830, 64831, this.ON, 64832, 64847, this.L, 64848, 64911, this.AL,
	            64912, 64913, this.L, 64914, 64967, this.AL, 64968, 65007, this.L, 65008, 65020, this.AL,
	            65021, 65021, this.ON, 65022, 65023, this.L, 65024, 65039, this.NSM, 65040, 65055, this.L,
	            65056, 65059, this.NSM, 65060, 65071, this.L, 65072, 65103, this.ON, 65104, 65104, this.CS,
	            65105, 65105, this.ON, 65106, 65106, this.CS, 65107, 65107, this.L, 65108, 65108, this.ON,
	            65109, 65109, this.CS, 65110, 65118, this.ON, 65119, 65119, this.ET, 65120, 65121, this.ON,
	            65122, 65123, this.ET, 65124, 65126, this.ON, 65127, 65127, this.L, 65128, 65128, this.ON,
	            65129, 65130, this.ET, 65131, 65131, this.ON, 65132, 65135, this.L, 65136, 65140, this.AL,
	            65141, 65141, this.L, 65142, 65276, this.AL, 65277, 65278, this.L, 65279, 65279, this.BN,
	            65280, 65280, this.L, 65281, 65282, this.ON, 65283, 65285, this.ET, 65286, 65290, this.ON,
	            65291, 65291, this.ET, 65292, 65292, this.CS, 65293, 65293, this.ET, 65294, 65294, this.CS,
	            65295, 65295, this.ES, 65296, 65305, this.EN, 65306, 65306, this.CS, 65307, 65312, this.ON,
	            65313, 65338, this.L, 65339, 65344, this.ON, 65345, 65370, this.L, 65371, 65381, this.ON,
	            65382, 65503, this.L, 65504, 65505, this.ET, 65506, 65508, this.ON, 65509, 65510, this.ET,
	            65511, 65511, this.L, 65512, 65518, this.ON, 65519, 65528, this.L, 65529, 65531, this.BN,
	            65532, 65533, this.ON, 65534, 65535, this.L
	        ];
	        for (var i = 0; i < this.charTypes.length; ++i) {
	            var start = this.charTypes[i];
	            var end = this.charTypes[++i];
	            var b = this.charTypes[++i];
	            while (start <= end) {
	                this.rtlCharacterTypes[start++] = b;
	            }
	        }
	    }
	    //#endregion
	    //#region implementation
	    RtlCharacters.prototype.getVisualOrder = function (inputText, isRtl) {
	        this.types = this.getCharacterCode(inputText);
	        this.textOrder = isRtl ? this.LRE : this.L;
	        this.doVisualOrder();
	        var result = [];
	        for (var i = 0; i < this.levels.length; i++) {
	            result[i] = this.levels[i];
	        }
	        return result;
	    };
	    RtlCharacters.prototype.getCharacterCode = function (text) {
	        var characterCodes = [];
	        for (var i = 0; i < text.length; i++) {
	            characterCodes[i] = this.rtlCharacterTypes[text[i].charCodeAt(0)];
	        }
	        return characterCodes;
	    };
	    RtlCharacters.prototype.setDefaultLevels = function () {
	        for (var i = 0; i < this.length; i++) {
	            this.levels[i] = this.textOrder;
	        }
	    };
	    RtlCharacters.prototype.setLevels = function () {
	        this.setDefaultLevels();
	        for (var n = 0; n < this.length; ++n) {
	            var level = this.levels[n];
	            if ((level & 0x80) !== 0) {
	                level &= 0x7f;
	                this.result[n] = ((level & 0x1) === 0) ? this.L : this.R;
	            }
	            this.levels[n] = level;
	        }
	    };
	    RtlCharacters.prototype.updateLevels = function (index, level, length) {
	        if ((level & 1) === 0) {
	            for (var i = index; i < length; ++i) {
	                if (this.result[i] === this.R) {
	                    this.levels[i] += 1;
	                }
	                else if (this.result[i] !== this.L) {
	                    this.levels[i] += 2;
	                }
	            }
	        }
	        else {
	            for (var i = index; i < length; ++i) {
	                if (this.result[i] !== this.R) {
	                    this.levels[i] += 1;
	                }
	            }
	        }
	    };
	    RtlCharacters.prototype.doVisualOrder = function () {
	        this.length = this.types.length;
	        this.result = this.types;
	        this.levels = [];
	        this.setLevels();
	        this.length = this.getEmbeddedCharactersLength();
	        var preview = this.textOrder;
	        var i = 0;
	        while (i < this.length) {
	            var level = this.levels[i];
	            var preType = ((Math.max(preview, level) & 0x1) === 0) ? this.L : this.R;
	            var length_1 = i + 1;
	            while (length_1 < this.length && this.levels[length_1] === level) {
	                ++length_1;
	            }
	            var success = length_1 < this.length ? this.levels[length_1] : this.textOrder;
	            var type = ((Math.max(success, level) & 0x1) === 0) ? this.L : this.R;
	            this.checkNSM(i, length_1, level, preType, type);
	            this.updateLevels(i, level, length_1);
	            preview = level;
	            i = length_1;
	        }
	        this.checkEmbeddedCharacters(this.length);
	    };
	    RtlCharacters.prototype.getEmbeddedCharactersLength = function () {
	        var index = 0;
	        for (var i = 0; i < this.length; ++i) {
	            if (!(this.types[i] === this.LRE || this.types[i] === this.RLE || this.types[i] === this.LRO ||
	                this.types[i] === this.RLO || this.types[i] === this.PDF || this.types[i] === this.BN)) {
	                this.result[index] = this.result[i];
	                this.levels[index] = this.levels[i];
	                index++;
	            }
	        }
	        return index;
	    };
	    RtlCharacters.prototype.checkEmbeddedCharacters = function (length) {
	        for (var i = this.types.length - 1; i >= 0; --i) {
	            if (this.types[i] === this.LRE || this.types[i] === this.RLE || this.types[i] === this.LRO ||
	                this.types[i] === this.RLO || this.types[i] === this.PDF || this.types[i] === this.BN) {
	                this.result[i] = this.types[i];
	                this.levels[i] = -1;
	            }
	            else {
	                length -= 1;
	                this.result[i] = this.result[length];
	                this.levels[i] = this.levels[length];
	            }
	        }
	        for (var i = 0; i < this.types.length; i++) {
	            if (this.levels[i] === -1) {
	                if (i === 0) {
	                    this.levels[i] = this.textOrder;
	                }
	                else {
	                    this.levels[i] = this.levels[i - 1];
	                }
	            }
	        }
	    };
	    RtlCharacters.prototype.checkNSM = function (index, length, level, startType, endType) {
	        var charType = startType;
	        for (var i = index; i < length; ++i) {
	            if (this.result[i] === this.NSM) {
	                this.result[i] = charType;
	            }
	            else {
	                charType = this.result[i];
	            }
	        }
	        this.checkEuropeanDigits(index, length, level, startType, endType);
	    };
	    RtlCharacters.prototype.checkEuropeanDigits = function (index, length, level, startType, endType) {
	        for (var i = index; i < length; ++i) {
	            if (this.result[i] === this.EN) {
	                for (var j = i - 1; j >= index; --j) {
	                    if (this.result[j] === this.L || this.result[j] === this.R || this.result[j] === this.AL) {
	                        if (this.result[j] === this.AL) {
	                            this.result[i] = this.AN;
	                        }
	                        break;
	                    }
	                }
	            }
	        }
	        this.checkArabicCharacters(index, length, level, startType, endType);
	    };
	    RtlCharacters.prototype.checkArabicCharacters = function (index, length, level, startType, endType) {
	        for (var i = index; i < length; ++i) {
	            if (this.result[i] === this.AL) {
	                this.result[i] = this.R;
	            }
	        }
	        this.checkEuropeanNumberSeparator(index, length, level, startType, endType);
	    };
	    RtlCharacters.prototype.checkEuropeanNumberSeparator = function (index, length, level, startType, endType) {
	        for (var i = index + 1; i < length - 1; ++i) {
	            if (this.result[i] === this.ES || this.result[i] === this.CS) {
	                var preview = this.result[i - 1];
	                var success = this.result[i + 1];
	                if (preview === this.EN && success === this.EN) {
	                    this.result[i] = this.EN;
	                }
	                else if (this.result[i] === this.CS && preview === this.AN && success === this.AN) {
	                    this.result[i] = this.AN;
	                }
	            }
	        }
	        this.checkEuropeanNumberTerminator(index, length, level, startType, endType);
	    };
	    RtlCharacters.prototype.checkEuropeanNumberTerminator = function (index, length, level, startType, endType) {
	        for (var i = index; i < length; ++i) {
	            if (this.result[i] === this.ET) {
	                var s = i;
	                var b = [];
	                b.push(this.ET);
	                var l = this.getLength(s, length, b);
	                var data = s === index ? startType : this.result[s - 1];
	                if (data !== this.EN) {
	                    data = (l === length) ? endType : this.result[l];
	                }
	                if (data === this.EN) {
	                    for (var j = s; j < l; ++j) {
	                        this.result[j] = this.EN;
	                    }
	                }
	                i = l;
	            }
	        }
	        this.checkOtherNeutrals(index, length, level, startType, endType);
	    };
	    RtlCharacters.prototype.checkOtherNeutrals = function (index, length, level, startType, endType) {
	        for (var i = index; i < length; ++i) {
	            if (this.result[i] === this.ES || this.result[i] === this.ET || this.result[i] === this.CS) {
	                this.result[i] = this.ON;
	            }
	        }
	        this.checkOtherCharacters(index, length, level, startType, endType);
	    };
	    RtlCharacters.prototype.checkOtherCharacters = function (index, length, level, startType, endType) {
	        for (var i = index; i < length; ++i) {
	            if (this.result[i] === this.EN) {
	                var pst = startType;
	                for (var j = i - 1; j >= index; --j) {
	                    if (this.result[j] === this.L || this.result[j] === this.R) {
	                        pst = this.result[j];
	                        break;
	                    }
	                }
	                if (pst === this.L) {
	                    this.result[i] = this.L;
	                }
	            }
	        }
	        this.checkCommanCharacters(index, length, level, startType, endType);
	    };
	    RtlCharacters.prototype.getLength = function (index, length, validSet) {
	        --index;
	        while (++index < length) {
	            var t = this.result[index];
	            for (var i = 0; i < validSet.length; ++i) {
	                if (t === validSet[i]) {
	                    index = this.getLength(++index, length, validSet);
	                }
	            }
	            return index;
	        }
	        return length;
	    };
	    RtlCharacters.prototype.checkCommanCharacters = function (index, length, level, startType, endType) {
	        for (var i = index; i < length; ++i) {
	            if (this.result[i] === this.WS || this.result[i] === this.ON || this.result[i] === this.B ||
	                this.result[i] === this.S) {
	                var s = i;
	                var byte = [this.B, this.S, this.WS, this.ON];
	                var l = this.getLength(s, length, byte);
	                var lt = 0;
	                var tt = 0;
	                var rt = 0;
	                if (s === index) {
	                    lt = startType;
	                }
	                else {
	                    lt = this.result[s - 1];
	                    if (lt === this.AN) {
	                        lt = this.R;
	                    }
	                    else if (lt === this.EN) {
	                        lt = this.R;
	                    }
	                }
	                if (l === length) {
	                    tt = endType;
	                }
	                else {
	                    tt = this.result[l];
	                    if (tt === this.AN) {
	                        tt = this.R;
	                    }
	                    else if (tt === this.EN) {
	                        tt = this.R;
	                    }
	                }
	                if (lt === tt) {
	                    rt = lt;
	                }
	                else {
	                    rt = ((level & 0x1) === 0) ? this.L : this.R;
	                }
	                for (var j = s; j < l; ++j) {
	                    this.result[j] = rt;
	                }
	                i = l;
	            }
	        }
	    };
	    return RtlCharacters;
	}());

	/**
	 * `Metrics` of the font.
	 * @private
	 */
	var RtlRenderer = /** @class */ (function () {
	    function RtlRenderer() {
	        //region Constants
	        /// Open bracket symbol.
	        /// </summary>
	        this.openBracket = '(';
	        /// <summary>
	        /// Close bracket symbol.
	        /// </summary>
	        this.closeBracket = ')';
	        //#endregion
	    }
	    //#region Constructors
	    /// <summary>
	    /// Initializes a new instance of the <see cref="RtlRenderer"/> class.
	    /// </summary>
	    // public constructor() {
	    // }
	    //#region Public Methods
	    /// <summary>
	    /// Layouts text. Changes blocks position in the RTL text.
	    /// Ligates the text if needed.
	    /// </summary>
	    /// <param name="line">Line of the text.</param>
	    /// <param name="font">Font to be used for string printing.</param>
	    /// <param name="rtl">Font alignment.</param>
	    /// <param name="wordSpace">Indicates whether Word Spacing used or not.</param>
	    /// <returns>Layout string.</returns>
	    RtlRenderer.prototype.layout = function (line, font, rtl, wordSpace, format) {
	        if (line == null) {
	            throw new Error('ArgumentNullException : line');
	        }
	        if (font == null) {
	            throw new Error('ArgumentNullException : font');
	        }
	        var result = [];
	        if (font.Unicode) {
	            result = this.customLayout(line, rtl, format, font, wordSpace);
	        }
	        else {
	            result = [];
	            result[0] = line;
	        }
	        return result;
	    };
	    /// <summary>
	    /// Layouts a string and splits it by the words and using correct lay outing.
	    /// </summary>
	    /// <param name="line">Text line.</param>
	    /// <param name="font">Font object.</param>
	    /// <param name="rtl">Indicates whether RTL should be applied.</param>
	    /// <param name="wordSpace">Indicates whether word spacing is used.</param>
	    /// <returns>Array of words if converted, null otherwise.</returns>
	    RtlRenderer.prototype.splitLayout = function (line, font, rtl, wordSpace, format) {
	        if (line == null) {
	            throw new Error('ArgumentNullException : line');
	        }
	        if (font == null) {
	            throw new Error('ArgumentNullException : font');
	        }
	        var words = [];
	        {
	            words = this.customSplitLayout(line, font, rtl, wordSpace, format);
	        }
	        return words;
	    };
	    //#endregion
	    //#region Implementation
	    // private isEnglish( word : string) : boolean
	    // {
	    //     let c : string = (word.length > 0) ? word[0] : '';
	    //     return (c >= '0' && c < 'ÿ');
	    // }
	    // private keepOrder( words : string, startIndex : number, count: number, result : string[], resultIndex : number) : void
	    // {
	    //     for (let i : number = 0, ri = resultIndex - count + 1; i < count; ++i, ++ri) {
	    //         result[ri] = words[i + startIndex];
	    //     }
	    // }
	    /// <summary>
	    /// Uses system API to layout the text.
	    /// </summary>
	    /// <param name="line">Line of the text to be layouted.</param>
	    /// <param name="font">Font which is used for text printing.</param>
	    /// <param name="rtl">Indicates whether we use RTL or RTL lay outing of the text container.</param>
	    /// <returns>Layout string.</returns>
	    /* tslint:disable-next-line:max-line-length */
	    RtlRenderer.prototype.getGlyphIndex = function (line, font, rtl, /*out*/ glyphs, custom) {
	        var success = true;
	        var fail = false;
	        if (line == null) {
	            throw new Error('ArgumentNullException : line');
	        }
	        if (font == null) {
	            throw new Error('ArgumentNullException : font');
	        }
	        glyphs = null;
	        if (line.length === 0) {
	            return { success: fail, glyphs: glyphs };
	        }
	        var renderer = new ArabicShapeRenderer();
	        var text = renderer.shape(line, 0);
	        var internalFont = font.fontInternal;
	        var ttfReader = internalFont.ttfReader;
	        glyphs = new Uint16Array(text.length);
	        var i = 0;
	        for (var k = 0, len = text.length; k < len; k++) {
	            var ch = text[k];
	            var glyphInfo = ttfReader.getGlyph(ch);
	            if (glyphInfo !== null && typeof glyphInfo !== 'undefined') {
	                glyphs[i++] = (glyphInfo).index;
	            }
	        }
	        return { success: success, glyphs: glyphs };
	    };
	    /* tslint:disable-next-line:max-line-length */
	    RtlRenderer.prototype.customLayout = function (line, rtl, format, font, wordSpace) {
	        if (wordSpace === null || typeof wordSpace === 'undefined') {
	            if (line == null) {
	                throw new Error('ArgumentNullException : line');
	            }
	            var result = null;
	            //bidirectional order.
	            if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.None) {
	                var bidi = new Bidi();
	                result = bidi.getLogicalToVisualString(line, rtl);
	            }
	            return result;
	        }
	        else {
	            if (line == null) {
	                throw new Error('ArgumentNullException : line');
	            }
	            if (font == null) {
	                throw new Error('ArgumentNullException : font');
	            }
	            var layouted = null;
	            if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.None) {
	                var renderer = new ArabicShapeRenderer();
	                var txt = renderer.shape(line, 0);
	                layouted = this.customLayout(txt, rtl, format);
	            }
	            // else {
	            //     layouted = this.customLayout(line, rtl, format);
	            // }
	            // We have unicode font, but from the file.        
	            var result = [];
	            // Split the text by words if word spacing is not default.
	            if (wordSpace) {
	                var words = layouted.split('');
	                var count = words.length;
	                for (var i = 0; i < count; i++) {
	                    words[i] = this.addChars(font, words[i]);
	                }
	                result = words;
	            }
	            else {
	                result = [];
	                result[0] = this.addChars(font, layouted);
	            }
	            return result;
	        }
	    };
	    /// <summary>
	    /// Add information about used glyphs to the font.
	    /// </summary>
	    /// <param name="font">Font used for text rendering.</param>
	    /// <param name="glyphs">Array of used glyphs.</param>
	    /// <returns>String in the form to be written to the file.</returns>
	    RtlRenderer.prototype.addChars = function (font, glyphs) {
	        var line = glyphs;
	        if (font == null) {
	            throw new Error('ArgumentNullException : font');
	        }
	        if (line == null) {
	            throw new Error('ArgumentNullException : line');
	        }
	        var text = line;
	        var internalFont = font.fontInternal;
	        var ttfReader = internalFont.ttfReader;
	        font.setSymbols(text);
	        // Reconvert string according to unicode standard.
	        text = ttfReader.convertString(text);
	        var bytes = PdfString.toUnicodeArray(text, false);
	        text = PdfString.byteToString(bytes);
	        return text;
	        // else {
	        //     if (font == null) {
	        //         throw new Error('ArgumentNullException : font');
	        //     }
	        //     if (glyphs == null) {
	        //         throw new Error('ArgumentNullException : glyphs');
	        //     }
	        //     // Mark the chars as used.
	        //     let text : string = '';
	        //     font.setSymbols(glyphs);
	        //     // Create string from the glyphs.
	        //     
	        //     let chars : string[] = [];
	        //     for (let i : number = 0; i < glyphs.length; i++) {
	        //         chars[i] = glyphs[i].toString();
	        //     }
	        //     for (let j : number = 0 ; j < chars.length; j++) {
	        //         text = text + chars[j];
	        //     }
	        //     let bytes : number[] = PdfString.toUnicodeArray(text, false);
	        //     text = PdfString.byteToString(bytes);
	        //     return text;
	        // }
	    };
	    /// <summary>
	    /// Layouts a string and splits it by the words by using custom lay outing.
	    /// </summary>
	    /// <param name="line">Text line.</param>
	    /// <param name="font">Font object.</param>
	    /// <param name="rtl">Indicates whether RTL should be applied.</param>
	    /// <param name="wordSpace">Indicates whether word spacing is used.</param>
	    /// <returns>Array of words if converted, null otherwise.</returns>
	    /* tslint:disable-next-line:max-line-length */
	    RtlRenderer.prototype.customSplitLayout = function (line, font, rtl, wordSpace, format) {
	        if (line == null) {
	            throw new Error('ArgumentNullException : line');
	        }
	        if (font == null) {
	            throw new Error('ArgumentNullException : font');
	        }
	        var reversedLine = this.customLayout(line, rtl, format);
	        var words = reversedLine.split('');
	        return words;
	    };
	    return RtlRenderer;
	}());

	/**
	 * public Enum for `PdfLayoutType`.
	 * @private
	 */
	var PdfLayoutType;
	(function (PdfLayoutType) {
	    /**
	     * Specifies the type of `Paginate`.
	     * @private
	     */
	    PdfLayoutType[PdfLayoutType["Paginate"] = 0] = "Paginate";
	    /**
	     * Specifies the type of `OnePage`.
	     * @private
	     */
	    PdfLayoutType[PdfLayoutType["OnePage"] = 1] = "OnePage";
	})(PdfLayoutType || (PdfLayoutType = {}));
	/**
	 * public Enum for `PdfLayoutBreakType`.
	 * @private
	 */
	var PdfLayoutBreakType;
	(function (PdfLayoutBreakType) {
	    /**
	     * Specifies the type of `FitPage`.
	     * @private
	     */
	    PdfLayoutBreakType[PdfLayoutBreakType["FitPage"] = 0] = "FitPage";
	    /**
	     * Specifies the type of `FitElement`.
	     * @private
	     */
	    PdfLayoutBreakType[PdfLayoutBreakType["FitElement"] = 1] = "FitElement";
	    /**
	     * Specifies the type of `FitColumnsToPage`.
	     * @private
	     */
	    PdfLayoutBreakType[PdfLayoutBreakType["FitColumnsToPage"] = 2] = "FitColumnsToPage";
	})(PdfLayoutBreakType || (PdfLayoutBreakType = {}));
	var PathPointType;
	(function (PathPointType) {
	    /**
	     * Specifies the path point type of `Start`.
	     * @private
	     */
	    PathPointType[PathPointType["Start"] = 0] = "Start";
	    /**
	     * Specifies the path point type of `Line`.
	     * @private
	     */
	    PathPointType[PathPointType["Line"] = 1] = "Line";
	    /**
	     * Specifies the path point type of `Bezier3`.
	     * @private
	     */
	    PathPointType[PathPointType["Bezier3"] = 3] = "Bezier3";
	    /**
	     * Specifies the path point type of `Bezier`.
	     * @private
	     */
	    PathPointType[PathPointType["Bezier"] = 3] = "Bezier";
	    /**
	     * Specifies the path point type of `PathTypeMask`.
	     * @private
	     */
	    PathPointType[PathPointType["PathTypeMask"] = 7] = "PathTypeMask";
	    /**
	     * Specifies the path point type of `DashMode`.
	     * @private
	     */
	    PathPointType[PathPointType["DashMode"] = 16] = "DashMode";
	    /**
	     * Specifies the path point type of `PathMarker`.
	     * @private
	     */
	    PathPointType[PathPointType["PathMarker"] = 32] = "PathMarker";
	    /**
	     * Specifies the path point type of `CloseSubpath`.
	     * @private
	     */
	    PathPointType[PathPointType["CloseSubpath"] = 128] = "CloseSubpath";
	})(PathPointType || (PathPointType = {}));

	var __extends$l = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `PdfGradientBrush` class provides objects used to fill the interiors of graphical shapes such as rectangles,
	 * ellipses, pies, polygons, and paths.
	 * @private
	 */
	var PdfGradientBrush = /** @class */ (function (_super) {
	    __extends$l(PdfGradientBrush, _super);
	    //Constructor
	    /**
	     * Initializes a new instance of the `PdfGradientBrush` class.
	     * @public
	     */
	    /* tslint:disable-next-line:max-line-length */
	    function PdfGradientBrush(shading) {
	        var _this = _super.call(this) || this;
	        // Fields
	        /**
	         * Local variable to store the background color.
	         * @private
	         */
	        _this.mbackground = new PdfColor(255, 255, 255);
	        /**
	         * Local variable to store the stroking color.
	         * @private
	         */
	        _this.mbStroking = false;
	        /**
	         * Local variable to store the function.
	         * @private
	         */
	        _this.mfunction = null;
	        /**
	         * Local variable to store the DictionaryProperties.
	         * @private
	         */
	        _this.dictionaryProperties = new DictionaryProperties();
	        _this.mpatternDictionary = new PdfDictionary();
	        _this.mpatternDictionary.items.setValue(_this.dictionaryProperties.type, new PdfName(_this.dictionaryProperties.pattern));
	        _this.mpatternDictionary.items.setValue(_this.dictionaryProperties.patternType, new PdfNumber(2));
	        _this.shading = shading;
	        _this.colorSpace = PdfColorSpace.Rgb;
	        return _this;
	    }
	    Object.defineProperty(PdfGradientBrush.prototype, "background", {
	        //Properties
	        /**
	         * Gets or sets the background color of the brush.
	         * @public
	         */
	        get: function () {
	            return this.mbackground;
	        },
	        set: function (value) {
	            this.mbackground = value;
	            var sh = this.shading;
	            if (value.isEmpty) {
	                sh.remove(this.dictionaryProperties.background);
	            }
	            else {
	                sh.items.setValue(this.dictionaryProperties.background, value.toArray(this.colorSpace));
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGradientBrush.prototype, "antiAlias", {
	        /**
	         * Gets or sets a value indicating whether use anti aliasing algorithm.
	         * @public
	         */
	        get: function () {
	            var sh = this.shading;
	            var aa = (sh.items.getValue(this.dictionaryProperties.antiAlias));
	            return aa.value;
	        },
	        set: function (value) {
	            var sh = this.shading;
	            var aa = (sh.items.getValue(this.dictionaryProperties.antiAlias));
	            if ((aa == null && typeof aa === 'undefined')) {
	                aa = new PdfBoolean(value);
	                sh.items.setValue(this.dictionaryProperties.antiAlias, aa);
	            }
	            else {
	                aa.value = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGradientBrush.prototype, "function", {
	        /**
	         * Gets or sets the function of the brush.
	         * @protected
	         */
	        get: function () {
	            return this.mfunction;
	        },
	        set: function (value) {
	            this.mfunction = value;
	            if (value != null && typeof value !== 'undefined') {
	                this.shading.items.setValue(this.dictionaryProperties.function, new PdfReferenceHolder(this.mfunction));
	            }
	            else {
	                this.shading.remove(this.dictionaryProperties.function);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGradientBrush.prototype, "bBox", {
	        /**
	         * Gets or sets the boundary box of the brush.
	         * @protected
	         */
	        get: function () {
	            var sh = this.shading;
	            var box = (sh.items.getValue(this.dictionaryProperties.bBox));
	            return box;
	        },
	        set: function (value) {
	            var sh = this.shading;
	            if (value == null && typeof value === 'undefined') {
	                sh.remove(this.dictionaryProperties.bBox);
	            }
	            else {
	                sh.items.setValue(this.dictionaryProperties.bBox, value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGradientBrush.prototype, "colorSpace", {
	        /**
	         * Gets or sets the color space of the brush.
	         * @public
	         */
	        get: function () {
	            return this.mcolorSpace;
	        },
	        set: function (value) {
	            var colorSpace = this.shading.items.getValue(this.dictionaryProperties.colorSpace);
	            if ((value !== this.mcolorSpace) || (colorSpace == null)) {
	                this.mcolorSpace = value;
	                var csValue = this.colorSpaceToDeviceName(value);
	                this.shading.items.setValue(this.dictionaryProperties.colorSpace, new PdfName(csValue));
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGradientBrush.prototype, "stroking", {
	        /**
	         * Gets or sets a value indicating whether this PdfGradientBrush is stroking.
	         * @public
	         */
	        get: function () {
	            return this.mbStroking;
	        },
	        set: function (value) {
	            this.mbStroking = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGradientBrush.prototype, "patternDictionary", {
	        /**
	         * Gets the pattern dictionary.
	         * @protected
	         */
	        get: function () {
	            if (this.mpatternDictionary == null) {
	                this.mpatternDictionary = new PdfDictionary();
	            }
	            return this.mpatternDictionary;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGradientBrush.prototype, "shading", {
	        /**
	         * Gets or sets the shading dictionary.
	         * @protected
	         */
	        get: function () {
	            return this.mshading;
	        },
	        set: function (value) {
	            if (value == null) {
	                throw new Error('ArgumentNullException : Shading');
	            }
	            if (value !== this.mshading) {
	                this.mshading = value;
	                this.patternDictionary.items.setValue(this.dictionaryProperties.shading, new PdfReferenceHolder(this.mshading));
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGradientBrush.prototype, "matrix", {
	        /**
	         * Gets or sets the transformation matrix.
	         * @public
	         */
	        get: function () {
	            return this.mmatrix;
	        },
	        set: function (value) {
	            if (value == null) {
	                throw new Error('ArgumentNullException : Matrix');
	            }
	            if (value !== this.mmatrix) {
	                this.mmatrix = value.clone();
	                var m = new PdfArray(this.mmatrix.matrix.elements);
	                this.mpatternDictionary.items.setValue(this.dictionaryProperties.matrix, m);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //Overrides
	    /**
	     * Monitors the changes of the brush and modify PDF state respectfully.
	     * @param brush The brush.
	     * @param streamWriter The stream writer.
	     * @param getResources The get resources delegate.
	     * @param saveChanges if set to true the changes should be saved anyway.
	     * @param currentColorSpace The current color space.
	     */
	    /* tslint:disable-next-line:max-line-length */
	    PdfGradientBrush.prototype.monitorChanges = function (brush, streamWriter, getResources, saveChanges, currentColorSpace) {
	        var diff = false;
	        if (brush instanceof PdfGradientBrush) {
	            if ((this.colorSpace !== currentColorSpace)) {
	                this.colorSpace = currentColorSpace;
	                this.resetFunction();
	            }
	            //  Set the /Pattern colour space.
	            streamWriter.setColorSpace('Pattern', this.mbStroking);
	            //  Set the pattern for non-stroking operations.
	            var resources = getResources.getResources();
	            var name_1 = resources.getName(this);
	            streamWriter.setColourWithPattern(null, name_1, this.mbStroking);
	            diff = true;
	        }
	        return diff;
	    };
	    /**
	     * Resets the changes, which were made by the brush.
	     * In other words resets the state to the initial one.
	     * @param streamWriter The stream writer.
	     */
	    PdfGradientBrush.prototype.resetChanges = function (streamWriter) {
	        //  Unable reset.
	    };
	    //Implementation
	    /**
	     * Converts colorspace enum to a PDF name.
	     * @param colorSpace The color space enum value.
	     */
	    PdfGradientBrush.prototype.colorSpaceToDeviceName = function (colorSpace) {
	        var result;
	        switch (colorSpace) {
	            case PdfColorSpace.Rgb:
	                result = 'DeviceRGB';
	                break;
	        }
	        return result;
	    };
	    /**
	     * Resets the pattern dictionary.
	     * @param dictionary A new pattern dictionary.
	     */
	    PdfGradientBrush.prototype.resetPatternDictionary = function (dictionary) {
	        this.mpatternDictionary = dictionary;
	    };
	    /**
	     * Clones the anti aliasing value.
	     * @param brush The brush.
	     */
	    PdfGradientBrush.prototype.cloneAntiAliasingValue = function (brush) {
	        if ((brush == null)) {
	            throw new Error('ArgumentNullException : brush');
	        }
	        var sh = this.shading;
	        var aa = (sh.items.getValue(this.dictionaryProperties.antiAlias));
	        if ((aa != null)) {
	            brush.shading.items.setValue(this.dictionaryProperties.antiAlias, new PdfBoolean(aa.value));
	        }
	    };
	    /**
	     * Clones the background value.
	     * @param brush The brush.
	     */
	    PdfGradientBrush.prototype.cloneBackgroundValue = function (brush) {
	        var background = this.background;
	        if (!background.isEmpty) {
	            brush.background = background;
	        }
	    };
	    Object.defineProperty(PdfGradientBrush.prototype, "element", {
	        /* tslint:enable */
	        // IPdfWrapper Members
	        /**
	         * Gets the `element`.
	         * @private
	         */
	        get: function () {
	            return this.patternDictionary;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PdfGradientBrush;
	}(PdfBrush));

	/**
	 * PdfTemplate.ts class for EJ2-PDF
	 */
	/**
	 * Represents `Pdf Template` object.
	 * @private
	 */
	var PdfTemplate = /** @class */ (function () {
	    function PdfTemplate(arg1, arg2) {
	        /**
	         * Initialize an instance for `DictionaryProperties` class.
	         * @private
	         * @hidden
	         */
	        this.dictionaryProperties = new DictionaryProperties();
	        /**
	         * Checks whether the transformation 'is performed'.
	         * @default true
	         * @private
	         */
	        this.writeTransformation = true;
	        if (typeof arg1 === 'undefined') ;
	        else if (arg1 instanceof SizeF && typeof arg2 === 'undefined') {
	            this.content = new PdfStream();
	            var tempSize = new SizeF(arg1.width, arg1.height);
	            this.setSize(tempSize);
	            this.initialize();
	        }
	        else {
	            this.content = new PdfStream();
	            this.setSize(new SizeF(arg1, arg2));
	            this.initialize();
	        }
	    }
	    Object.defineProperty(PdfTemplate.prototype, "size", {
	        //Properties
	        /**
	         * Gets the size of the 'PdfTemplate'.
	         */
	        get: function () {
	            return this.templateSize;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfTemplate.prototype, "width", {
	        /**
	         * Gets the width of the 'PdfTemplate'.
	         */
	        get: function () {
	            return this.size.width;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfTemplate.prototype, "height", {
	        /**
	         * Gets the height of the 'PdfTemplate'.
	         */
	        get: function () {
	            return this.size.height;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfTemplate.prototype, "graphics", {
	        /**
	         * Gets the `graphics` of the 'PdfTemplate'.
	         */
	        get: function () {
	            if (this.pdfGraphics == null || typeof this.pdfGraphics === 'undefined') {
	                var gr = new GetResourceEventHandler(this);
	                var g = new PdfGraphics(this.size, gr, this.content);
	                this.pdfGraphics = g;
	                // if(this.writeTransformation) {
	                // Transform co-ordinates to Top/Left.
	                this.pdfGraphics.initializeCoordinates();
	                // }
	            }
	            return this.pdfGraphics;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Gets the resources and modifies the template dictionary.
	     * @private
	     */
	    PdfTemplate.prototype.getResources = function () {
	        if (this.resources == null) {
	            this.resources = new PdfResources();
	            this.content.items.setValue(this.dictionaryProperties.resources, this.resources);
	        }
	        return this.resources;
	    };
	    // Public methods
	    /**
	     * `Initialize` the type and subtype of the template.
	     * @private
	     */
	    PdfTemplate.prototype.initialize = function () {
	        this.addType();
	        this.addSubType();
	    };
	    /**
	     * `Adds type key`.
	     * @private
	     */
	    PdfTemplate.prototype.addType = function () {
	        var value = new PdfName(this.dictionaryProperties.xObject);
	        this.content.items.setValue(this.dictionaryProperties.type, value);
	    };
	    /**
	     * `Adds SubType key`.
	     * @private
	     */
	    PdfTemplate.prototype.addSubType = function () {
	        var value = new PdfName(this.dictionaryProperties.form);
	        this.content.items.setValue(this.dictionaryProperties.subtype, value);
	    };
	    PdfTemplate.prototype.reset = function (size) {
	        if (typeof size === 'undefined') {
	            if (this.resources != null) {
	                this.resources = null;
	                this.content.remove(this.dictionaryProperties.resources);
	            }
	            if (this.graphics != null) {
	                this.graphics.reset(this.size);
	            }
	        }
	        else {
	            this.setSize(size);
	            this.reset();
	        }
	    };
	    /**
	     * `Set the size` of the 'PdfTemplate'.
	     * @private
	     */
	    PdfTemplate.prototype.setSize = function (size) {
	        var rect = new RectangleF(new PointF(0, 0), size);
	        var val = PdfArray.fromRectangle(rect);
	        this.content.items.setValue(this.dictionaryProperties.bBox, val);
	        this.templateSize = size;
	    };
	    Object.defineProperty(PdfTemplate.prototype, "element", {
	        // /**
	        //  * Returns the value of current graphics.
	        //  * @private
	        //  */
	        // public GetGraphics(g : PdfGraphics) : PdfGraphics {
	        //     if (this.graphics == null || typeof this.graphics === 'undefined') {
	        //         this.graphics = g;
	        //         this.graphics.Size = this.Size;
	        //         this.graphics.StreamWriter = new PdfStreamWriter(this.content)
	        //         this.graphics.Initialize();
	        //         if(this.writeTransformation) {
	        //             this.graphics.InitializeCoordinates();
	        //         }
	        //     }
	        //     return this.graphics;
	        // }
	        // IPdfWrapper Members
	        /**
	         * Gets the `content stream` of 'PdfTemplate' class.
	         * @private
	         */
	        get: function () {
	            return this.content;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PdfTemplate;
	}());

	var __extends$k = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `PdfResources` class used to set resource contents like font, image.
	 * @private
	 */
	var PdfResources = /** @class */ (function (_super) {
	    __extends$k(PdfResources, _super);
	    function PdfResources(baseDictionary) {
	        var _this = _super.call(this, baseDictionary) || this;
	        /**
	         * Dictionary for the `properties names`.
	         * @private
	         */
	        _this.properties = new PdfDictionary();
	        return _this;
	    }
	    Object.defineProperty(PdfResources.prototype, "names", {
	        //Properties
	        /**
	         * Gets the `font names`.
	         * @private
	         */
	        get: function () {
	            return this.getNames();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfResources.prototype, "document", {
	        /**
	         * Get or set the `page document`.
	         * @private
	         */
	        get: function () {
	            return this.pdfDocument;
	        },
	        set: function (value) {
	            this.pdfDocument = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //Public Methods
	    /**
	     * `Generates name` for the object and adds to the resource if the object is new.
	     * @private
	     */
	    PdfResources.prototype.getName = function (obj) {
	        var primitive = obj.element;
	        var name = null;
	        if (this.names.containsKey(primitive)) {
	            name = this.names.getValue(primitive);
	        }
	        // Object is new.
	        if (name == null) {
	            var sName = this.generateName();
	            name = new PdfName(sName);
	            this.names.setValue(primitive, name);
	            if (obj instanceof PdfFont) {
	                this.add(obj, name);
	            }
	            else if (obj instanceof PdfTemplate) {
	                this.add(obj, name);
	            }
	            else if (obj instanceof PdfGradientBrush || obj instanceof PdfTilingBrush) {
	                this.add(obj, name);
	            }
	            else if (obj instanceof PdfTransparency) {
	                this.add(obj, name);
	            }
	            else if (obj instanceof PdfImage || obj instanceof PdfBitmap) {
	                this.add(obj, name);
	            }
	        }
	        return name;
	    };
	    /**
	     * Gets `resource names` to font dictionaries.
	     * @private
	     */
	    PdfResources.prototype.getNames = function () {
	        if (this.pdfNames == null) {
	            this.pdfNames = new TemporaryDictionary();
	        }
	        var fonts = this.items.getValue(this.dictionaryProperties.font);
	        if (fonts != null) {
	            PdfCrossTable.dereference(fonts);
	        }
	        return this.pdfNames;
	    };
	    /**
	     * Add `RequireProcedureSet` into procset array.
	     * @private
	     */
	    PdfResources.prototype.requireProcedureSet = function (procedureSetName) {
	        if (procedureSetName == null) {
	            throw new Error('ArgumentNullException:procedureSetName');
	        }
	        var procSets = this.items.getValue(this.dictionaryProperties.procset);
	        if (procSets == null) {
	            procSets = new PdfArray();
	            this.items.setValue(this.dictionaryProperties.procset, procSets);
	        }
	        var name = new PdfName(procedureSetName);
	        if (!procSets.contains(name)) {
	            procSets.add(name);
	        }
	    };
	    //Helper Methods
	    /**
	     * `Remove font` from array.
	     * @private
	     */
	    PdfResources.prototype.removeFont = function (name) {
	        var key = null;
	        var keys = this.pdfNames.keys();
	        for (var index = 0; index < this.pdfNames.size(); index++) {
	            if (this.pdfNames.getValue(keys[index]) === new PdfName(name)) {
	                key = keys[index];
	                break;
	            }
	        }
	        if (key != null) {
	            this.pdfNames.remove(key);
	        }
	    };
	    /**
	     * Generates `Unique string name`.
	     * @private
	     */
	    PdfResources.prototype.generateName = function () {
	        var name = Guid.getNewGuidString();
	        return name;
	    };
	    PdfResources.prototype.add = function (arg1, arg2) {
	        if (arg1 instanceof PdfFont) {
	            var dictionary = null;
	            var fonts = this.items.getValue(this.dictionaryProperties.font);
	            if (fonts != null) {
	                var reference = fonts;
	                dictionary = fonts;
	                dictionary = fonts;
	            }
	            else {
	                dictionary = new PdfDictionary();
	                this.items.setValue(this.dictionaryProperties.font, dictionary);
	            }
	            dictionary.items.setValue(arg2.value, new PdfReferenceHolder(arg1.element));
	        }
	        else if (arg1 instanceof PdfTemplate) {
	            var xobjects = void 0;
	            xobjects = this.items.getValue(this.dictionaryProperties.xObject);
	            // Create fonts dictionary.
	            if (xobjects == null) {
	                xobjects = new PdfDictionary();
	                this.items.setValue(this.dictionaryProperties.xObject, xobjects);
	            }
	            xobjects.items.setValue(arg2.value, new PdfReferenceHolder(arg1.element));
	        }
	        else if (arg1 instanceof PdfBrush) {
	            if (arg1 instanceof PdfGradientBrush || arg1 instanceof PdfTilingBrush) {
	                var savable = arg1.element;
	                if (savable != null) {
	                    var pattern = this.items.getValue(this.dictionaryProperties.pattern);
	                    // Create a new pattern dictionary.
	                    if (pattern == null) {
	                        pattern = new PdfDictionary();
	                        this.items.setValue(this.dictionaryProperties.pattern, pattern);
	                    }
	                    pattern.items.setValue(arg2.value, new PdfReferenceHolder(savable));
	                }
	            }
	        }
	        else if (arg1 instanceof PdfTransparency) {
	            var savable = arg1.element;
	            var transDic = null;
	            transDic = this.items.getValue(this.dictionaryProperties.extGState);
	            // Create a new pattern dictionary.
	            if (transDic == null) {
	                transDic = new PdfDictionary();
	                this.items.setValue(this.dictionaryProperties.extGState, transDic);
	            }
	            transDic.items.setValue(arg2.value, new PdfReferenceHolder(savable));
	        }
	        else {
	            /* tslint:disable */
	            var xobjects = this.Dictionary.items.getValue(this.dictionaryProperties.xObject);
	            var parentXObjects = void 0;
	            if (typeof this.pdfDocument !== 'undefined') {
	                parentXObjects = this.pdfDocument.sections.element.items.getValue(this.dictionaryProperties.resources).items.getValue(this.dictionaryProperties.xObject);
	            }
	            this.Dictionary.items.values();
	            var hasSameImageStream = false;
	            var oldReference = void 0;
	            if (typeof this.pdfDocument !== 'undefined' && (typeof parentXObjects === undefined || parentXObjects == null)) {
	                parentXObjects = new PdfDictionary();
	                this.pdfDocument.sections.element.items.getValue(this.dictionaryProperties.resources).items.setValue(this.dictionaryProperties.xObject, parentXObjects);
	            }
	            else if (typeof this.pdfDocument !== 'undefined') {
	                var values_1 = parentXObjects.items.values();
	                for (var i = 0; i < values_1.length; i++) {
	                    if (typeof values_1[i] !== 'undefined' && typeof values_1[i].element !== 'undefined') {
	                        if (values_1[i].element.data[0] === arg1.element.data[0]) {
	                            oldReference = values_1[i];
	                            hasSameImageStream = true;
	                        }
	                    }
	                }
	            }
	            if (xobjects == null) {
	                xobjects = new PdfDictionary();
	                this.Dictionary.items.setValue(this.dictionaryProperties.xObject, xobjects);
	            }
	            if (hasSameImageStream && typeof oldReference !== 'undefined') {
	                xobjects.items.setValue(arg2.value, oldReference);
	            }
	            else {
	                var reference = new PdfReferenceHolder(arg1.element);
	                xobjects.items.setValue(arg2.value, reference);
	                if (typeof this.pdfDocument !== 'undefined') {
	                    parentXObjects.items.setValue(arg2.value, reference);
	                }
	            }
	            /* tslint:enable */
	        }
	    };
	    return PdfResources;
	}(PdfDictionary));
	/* tslint:disable */
	/**
	 * Used to create new guid for resources.
	 * @private
	 */
	var Guid = /** @class */ (function () {
	    function Guid() {
	    }
	    /**
	     * Generate `new GUID`.
	     * @private
	     */
	    Guid.getNewGuidString = function () {
	        return 'aaaaaaaa-aaaa-4aaa-baaa-aaaaaaaaaaaa'.replace(/[ab]/g, function (c) {
	            var random = Math.random() * 16 | 0;
	            var result = c === 'a' ? random : (random & 0x3 | 0x8);
	            return result.toString(16);
	        });
	    };
	    return Guid;
	}());
	/* tslint:enable */

	var __extends$j = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `PdfTilingBrush` Implements a colored tiling brush.
	 */
	var PdfTilingBrush = /** @class */ (function (_super) {
	    __extends$j(PdfTilingBrush, _super);
	    /**
	     * Initializes a new instance of the `PdfTilingBrush` class.
	     * @public
	     */
	    function PdfTilingBrush(arg1, arg2) {
	        var _this = _super.call(this) || this;
	        /**
	         * Local variable to store Stroking.
	         * @private
	         */
	        _this.mStroking = false;
	        /**
	         * Local variable to store the tile start location.
	         * @private
	         */
	        _this.mLocation = new PointF(0, 0);
	        /**
	         * Local variable to store the dictionary properties.
	         * @private
	         */
	        _this.mDictionaryProperties = new DictionaryProperties();
	        var rect = null;
	        if (arg1 instanceof Rectangle) {
	            rect = arg1;
	        }
	        else if (arg1 instanceof SizeF) {
	            rect = new Rectangle(0, 0, arg1.width, arg1.height);
	        }
	        if (arg2 !== null && arg2 instanceof PdfPage) {
	            _this.mPage = arg2;
	        }
	        _this.brushStream = new PdfStream();
	        _this.mResources = new PdfResources();
	        _this.brushStream.items.setValue(_this.mDictionaryProperties.resources, _this.mResources);
	        _this.setBox(rect);
	        _this.setObligatoryFields();
	        if (arg2 !== null && arg2 instanceof PdfPage) {
	            _this.mPage = arg2;
	            _this.graphics.colorSpace = arg2.document.colorSpace;
	        }
	        return _this;
	    }
	    /**
	     * Initializes a new instance of the `PdfTilingBrush` class.
	     * @private
	     * @param rectangle The size of the smallest brush cell.
	     * @param page The Current Page Object.
	     * @param location The Tile start location.
	     * @param matrix The matrix.
	     */
	    PdfTilingBrush.prototype.initialize = function (rectangle, page, location, matrix) {
	        this.mPage = page;
	        this.mLocation = location;
	        this.mTransformationMatrix = matrix;
	        this.tempBrushStream = this.brushStream;
	        this.brushStream = new PdfStream();
	        var tempResource = new PdfResources();
	        this.brushStream.items.setValue(this.mDictionaryProperties.resources, tempResource);
	        this.setBox(rectangle);
	        this.setObligatoryFields();
	        return this;
	    };
	    Object.defineProperty(PdfTilingBrush.prototype, "location", {
	        //Properties
	        /**
	         * Location representing the start position of the tiles.
	         * @public
	         */
	        get: function () {
	            return this.mLocation;
	        },
	        set: function (value) {
	            this.mLocation = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Sets the obligatory fields.
	     * @private
	     */
	    PdfTilingBrush.prototype.setObligatoryFields = function () {
	        this.brushStream.items.setValue(this.mDictionaryProperties.patternType, new PdfNumber(1));
	        //  Tiling brush.
	        this.brushStream.items.setValue(this.mDictionaryProperties.paintType, new PdfNumber(1));
	        //  Coloured.
	        this.brushStream.items.setValue(this.mDictionaryProperties.tilingType, new PdfNumber(1));
	        //  Constant spacing.
	        this.brushStream.items.setValue(this.mDictionaryProperties.xStep, new PdfNumber((this.mBox.right - this.mBox.left)));
	        this.brushStream.items.setValue(this.mDictionaryProperties.yStep, new PdfNumber((this.mBox.bottom - this.mBox.top)));
	        if ((this.mPage != null) && (this.mLocation != null)) {
	            if ((this.mTransformationMatrix == null && typeof this.mTransformationMatrix === 'undefined')) {
	                // Transform the tile origin to fit the location
	                var tileTransform = (this.mPage.size.height % this.rectangle.size.height) - (this.mLocation.y);
	                /* tslint:disable-next-line:max-line-length */
	                this.brushStream.items.setValue(this.mDictionaryProperties.matrix, new PdfArray([1, 0, 0, 1, this.mLocation.x, tileTransform]));
	            }
	            else {
	                var tileTransform = 0;
	                // Transform the tile origin to fit the location
	                var elements = this.mTransformationMatrix.matrix.elements;
	                if ((this.mPage.size.height > this.rectangle.size.height)) {
	                    tileTransform = (this.mTransformationMatrix.matrix.offsetY
	                        - (this.mPage.size.height % this.rectangle.size.height));
	                }
	                else {
	                    tileTransform = ((this.mPage.size.height % this.rectangle.size.height) + this.mTransformationMatrix.matrix.offsetY);
	                }
	                this.brushStream.items.setValue(this.mDictionaryProperties.matrix, new PdfArray([
	                    elements[0], elements[1], elements[2], elements[3], elements[4], tileTransform
	                ]));
	            }
	        }
	    };
	    /**
	     * Sets the BBox coordinates.
	     * @private
	     */
	    PdfTilingBrush.prototype.setBox = function (box) {
	        this.mBox = box;
	        var rect = new RectangleF(this.mBox.left, this.mBox.top, this.mBox.right, this.mBox.bottom);
	        this.brushStream.items.setValue(this.mDictionaryProperties.bBox, PdfArray.fromRectangle(rect));
	    };
	    Object.defineProperty(PdfTilingBrush.prototype, "rectangle", {
	        //Properties
	        /**
	         * Gets the boundary box of the smallest brush cell.
	         * @public
	         */
	        get: function () {
	            return this.mBox;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfTilingBrush.prototype, "size", {
	        /**
	         * Gets the size of the smallest brush cell.
	         * @public
	         */
	        get: function () {
	            return this.mBox.size;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfTilingBrush.prototype, "graphics", {
	        /**
	         * Gets Graphics context of the brush.
	         */
	        get: function () {
	            if ((this.mGraphics == null && typeof this.mGraphics === 'undefined')) {
	                var gr = new GetResourceEventHandler(this);
	                var g = new PdfGraphics(this.size, gr, this.brushStream);
	                this.mGraphics = g;
	                this.mResources = this.getResources();
	                this.mGraphics.initializeCoordinates();
	            }
	            return this.mGraphics;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Gets the resources and modifies the template dictionary.
	     * @public
	     */
	    PdfTilingBrush.prototype.getResources = function () {
	        return this.mResources;
	    };
	    Object.defineProperty(PdfTilingBrush.prototype, "stroking", {
	        /**
	         * Gets or sets a value indicating whether this PdfTilingBrush
	         * is used for stroking operations.
	         */
	        get: function () {
	            return this.mStroking;
	        },
	        set: function (value) {
	            this.mStroking = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //PdfBrush methods
	    /**
	     * Creates a new copy of a brush.
	     * @public
	     */
	    PdfTilingBrush.prototype.clone = function () {
	        var brush = this.initialize(this.rectangle, this.mPage, this.location, this.mTransformationMatrix);
	        if ((this.mTransformationMatrix != null) && (this.mTransformationMatrix.matrix != null)) {
	            /* tslint:disable-next-line:max-line-length */
	            brush.brushStream.items.setValue(this.mDictionaryProperties.matrix, new PdfArray(this.mTransformationMatrix.matrix.elements));
	        }
	        brush.brushStream.data = this.tempBrushStream.data;
	        brush.mResources = new PdfResources(this.mResources);
	        brush.brushStream.items.setValue(this.mDictionaryProperties.resources, brush.mResources);
	        return brush;
	    };
	    /**
	     * Monitors the changes of the brush and modify PDF state respectfully.
	     * @param brush The brush
	     * @param streamWriter The stream writer
	     * @param getResources The get resources delegate.
	     * @param saveChanges if set to true the changes should be saved anyway.
	     * @param currentColorSpace The current color space.
	     */
	    /* tslint:disable-next-line:max-line-length */
	    PdfTilingBrush.prototype.monitorChanges = function (brush, streamWriter, getResources, saveChanges, currentColorSpace) {
	        var diff = false;
	        if (brush !== this) {
	            //  Set the Pattern colour space.
	            streamWriter.setColorSpace('Pattern', this.mStroking);
	            //  Set the pattern for non-stroking operations.
	            var resources1 = getResources.getResources();
	            var name1 = resources1.getName(this);
	            streamWriter.setColourWithPattern(null, name1, this.mStroking);
	            diff = true;
	        }
	        else if (brush instanceof PdfTilingBrush) {
	            //  Set the /Pattern colour space.
	            streamWriter.setColorSpace('Pattern', this.mStroking);
	            //  Set the pattern for non-stroking operations.
	            var resources = getResources.getResources();
	            var name_1 = resources.getName(this);
	            streamWriter.setColourWithPattern(null, name_1, this.mStroking);
	            diff = true;
	        }
	        return diff;
	    };
	    /**
	     * Resets the changes, which were made by the brush.
	     * In other words resets the state to the initial one.
	     * @param streamWriter The stream writer.
	     */
	    PdfTilingBrush.prototype.resetChanges = function (streamWriter) {
	        //  We shouldn't do anything to reset changes.
	        //  All changes will be reset automatically by setting a new colour space.
	    };
	    Object.defineProperty(PdfTilingBrush.prototype, "element", {
	        /* tslint:enable */
	        // IPdfWrapper Members
	        /**
	         * Gets the `element`.
	         * @public
	         */
	        get: function () {
	            return this.brushStream;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PdfTilingBrush;
	}(PdfBrush));

	/**
	 * PdfGraphics.ts class for EJ2-PDF
	 */
	/**
	 * `PdfGraphics` class represents a graphics context of the objects.
	 * It's used for performing all the graphics operations.
	 * ```typescript
	 * // create a new PDF document
	 * let document : PdfDocument = new PdfDocument();
	 * // add a new page to the document
	 * let page1 : PdfPage = document.pages.add();
	 * // set the font
	 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	 * // create black brush
	 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	 * //
	 * //graphics of the page
	 * let page1Graphics : PdfGraphics = page1.graphics;
	 * // draw the text on the page1 graphics
	 * page1Graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
	 * //
	 * // save the document
	 * document.save('output.pdf');
	 * // destroy the document
	 * document.destroy();
	 * ```
	 */
	var PdfGraphics = /** @class */ (function () {
	    function PdfGraphics(arg1, arg2, arg3) {
	        /**
	         * Represents the `Current color space`.
	         * @private
	         */
	        this.currentColorSpace = PdfColorSpace.Rgb;
	        /**
	         * Stores `previous rendering mode`.
	         * @private
	         */
	        this.previousTextRenderingMode = TextRenderingMode.Fill;
	        /**
	         * Previous `character spacing` value or 0.
	         * @private
	         */
	        this.previousCharacterSpacing = 0.0;
	        /**
	         * Previous `word spacing` value or 0.
	         * @private
	         */
	        this.previousWordSpacing = 0.0;
	        /**
	         * The `previously used text scaling` value.
	         * @private
	         */
	        this.previousTextScaling = 100.0;
	        /**
	         * Instance of `ProcedureSets` class.
	         * @private
	         */
	        this.procedureSets = new ProcedureSets();
	        /**
	         * To check wihether it is a `direct text rendering`.
	         * @default true
	         * @private
	         */
	        this.isNormalRender = true;
	        /**
	         * check whether to `use font size` to calculate the shift.
	         * @default false
	         * @private
	         */
	        this.isUseFontSize = false;
	        /**
	         * check whether the font is in `italic type`.
	         * @default false
	         * @private
	         */
	        this.isItalic = false;
	        /**
	         * Check whether it is an `emf Text Matrix`.
	         * @default false
	         * @private
	         */
	        this.isEmfTextScaled = false;
	        /**
	         * Check whether it is an `emf` call.
	         * @default false
	         * @private
	         */
	        this.isEmf = false;
	        /**
	         * Check whether it is an `emf plus` call.
	         * @default false
	         * @private
	         */
	        this.isEmfPlus = false;
	        /**
	         * Check whether it is in `base line format`.
	         * @default true
	         * @private
	         */
	        this.isBaselineFormat = true;
	        /**
	         * Emf Text `Scaling Factor`.
	         * @private
	         */
	        this.emfScalingFactor = new SizeF(0, 0);
	        /**
	         * To check whether the `last color space` of document and garphics is saved.
	         * @private
	         */
	        this.colorSpaceChanged = false;
	        /**
	         * Stores an instance of `DictionaryProperties`.
	         * @private
	         */
	        this.dictionaryProperties = new DictionaryProperties();
	        /**
	         * Checks whether the x co-ordinate is need to set as client size or not.
	         * @hidden
	         * @private
	         */
	        this.isOverloadWithPosition = false;
	        /**
	         * Checks whether the x co-ordinate is need to set as client size or not.
	         * @hidden
	         * @private
	         */
	        this.isPointOverload = false;
	        /**
	         * Current colorspaces.
	         * @hidden
	         * @private
	         */
	        this.currentColorSpaces = ['RGB', 'CMYK', 'GrayScale', 'Indexed'];
	        /**
	         * Checks the current image `is optimized` or not.
	         * @default false.
	         * @private
	         */
	        this.isImageOptimized = false;
	        /**
	         * Stores the `graphics states`.
	         * @private
	         */
	        this.graphicsState = [];
	        /**
	         * Indicates whether the object `had trasparency`.
	         * @default false
	         * @private
	         */
	        this.istransparencySet = false;
	        /**
	         * Stores the instance of `PdfAutomaticFieldInfoCollection` class .
	         * @default null
	         * @private
	         */
	        this.internalAutomaticFields = null;
	        /**
	         * Stores the index of the start line that should draw with in the next page.
	         * @private
	         */
	        this.startCutIndex = -1;
	        this.getResources = arg2;
	        this.canvasSize = arg1;
	        if (arg3 instanceof PdfStreamWriter) {
	            this.pdfStreamWriter = arg3;
	        }
	        else {
	            this.pdfStreamWriter = new PdfStreamWriter(arg3);
	        }
	        this.initialize();
	    }
	    Object.defineProperty(PdfGraphics.prototype, "stringLayoutResult", {
	        //  Properties
	        /**
	         * Returns the `result` after drawing string.
	         * @private
	         */
	        get: function () {
	            return this.pdfStringLayoutResult;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphics.prototype, "size", {
	        /**
	         * Gets the `size` of the canvas.
	         * @private
	         */
	        get: function () {
	            return this.canvasSize;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphics.prototype, "mediaBoxUpperRightBound", {
	        /**
	         * Gets and Sets the value of `MediaBox upper right bound`.
	         * @private
	         */
	        get: function () {
	            if (typeof this.internalMediaBoxUpperRightBound === 'undefined') {
	                this.internalMediaBoxUpperRightBound = 0;
	            }
	            return this.internalMediaBoxUpperRightBound;
	        },
	        set: function (value) {
	            this.internalMediaBoxUpperRightBound = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphics.prototype, "clientSize", {
	        /**
	         * Gets the `size` of the canvas reduced by margins and page templates.
	         * @private
	         */
	        get: function () {
	            return new SizeF(this.clipBounds.width, this.clipBounds.height);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphics.prototype, "colorSpace", {
	        /**
	         * Gets or sets the current `color space` of the document
	         * @private
	         */
	        get: function () {
	            return this.currentColorSpace;
	        },
	        set: function (value) {
	            this.currentColorSpace = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphics.prototype, "streamWriter", {
	        /**
	         * Gets the `stream writer`.
	         * @private
	         */
	        get: function () {
	            return this.pdfStreamWriter;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphics.prototype, "matrix", {
	        /**
	         * Gets the `transformation matrix` reflecting current transformation.
	         * @private
	         */
	        get: function () {
	            if (this.transformationMatrix == null) {
	                this.transformationMatrix = new PdfTransformationMatrix();
	            }
	            return this.transformationMatrix;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphics.prototype, "layer", {
	        /**
	         * Gets the `layer` for the graphics, if exists.
	         * @private
	         */
	        get: function () {
	            return this.pageLayer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphics.prototype, "page", {
	        /**
	         * Gets the `page` for this graphics, if exists.
	         * @private
	         */
	        get: function () {
	            return this.pageLayer.page;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphics.prototype, "automaticFields", {
	        get: function () {
	            if (this.internalAutomaticFields == null || typeof this.internalAutomaticFields === 'undefined') {
	                this.internalAutomaticFields = new PdfAutomaticFieldInfoCollection();
	            }
	            return this.internalAutomaticFields;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //Implementation
	    /**
	     * `Initializes` this instance.
	     * @private
	     */
	    PdfGraphics.prototype.initialize = function () {
	        this.bStateSaved = false;
	        this.currentPen = null;
	        this.currentBrush = null;
	        this.currentFont = null;
	        this.currentColorSpace = PdfColorSpace.Rgb;
	        this.bCSInitialized = false;
	        this.transformationMatrix = null;
	        this.previousTextRenderingMode = (-1); //.Fill;
	        this.previousCharacterSpacing = -1.0;
	        this.previousWordSpacing = -1.0;
	        this.previousTextScaling = -100.0;
	        // this.m_trasparencies = null;
	        this.currentStringFormat = null;
	        this.clipBounds = new RectangleF(new PointF(0, 0), this.size);
	        this.getResources.getResources().requireProcedureSet(this.procedureSets.pdf);
	    };
	    PdfGraphics.prototype.drawPdfTemplate = function (template, location, size) {
	        if (typeof size === 'undefined') {
	            if (template == null) {
	                throw Error('ArgumentNullException-template');
	            }
	            this.drawPdfTemplate(template, location, template.size);
	        }
	        else {
	            // let crossTable : PdfCrossTable = null;
	            // if (this.pageLayer != null) {
	            //     crossTable = (this.page as PdfPage).section.parentDocument.crossTable;
	            // }
	            if (template == null) {
	                throw Error('ArgumentNullException-template');
	            }
	            var scaleX = (template.width > 0) ? size.width / template.width : 1;
	            var scaleY = (template.height > 0) ? size.height / template.height : 1;
	            var bNeedScale = !(scaleX === 1 && scaleY === 1);
	            // Save state.
	            var state = this.save();
	            // Take into consideration that rect location is bottom/left.
	            var matrix = new PdfTransformationMatrix();
	            if (this.pageLayer != null) {
	                this.getTranslateTransform(location.x, location.y + size.height, matrix);
	            }
	            if (bNeedScale) {
	                this.getScaleTransform(scaleX, scaleY, matrix);
	            }
	            this.pdfStreamWriter.modifyCtm(matrix);
	            // Output template.
	            var resources = this.getResources.getResources();
	            var name_1 = resources.getName(template);
	            this.pdfStreamWriter.executeObject(name_1);
	            // Restore state.
	            this.restore(state);
	            //Transfer automatic fields from template.
	            var g = template.graphics;
	            if (g != null) {
	                for (var index = 0; index < g.automaticFields.automaticFields.length; index++) {
	                    var fieldInfo = g.automaticFields.automaticFields[index];
	                    var newLocation = new PointF(fieldInfo.location.x + location.x, fieldInfo.location.y + location.y);
	                    var scalingX = template.size.width == 0 ? 0 : size.width / template.size.width;
	                    var scalingY = template.size.height == 0 ? 0 : size.height / template.size.height;
	                    this.automaticFields.add(new PdfAutomaticFieldInfo(fieldInfo.field, newLocation, scalingX, scalingY));
	                    this.page.dictionary.modify();
	                }
	            }
	            this.getResources.getResources().requireProcedureSet(this.procedureSets.imageB);
	            this.getResources.getResources().requireProcedureSet(this.procedureSets.imageC);
	            this.getResources.getResources().requireProcedureSet(this.procedureSets.imageI);
	            this.getResources.getResources().requireProcedureSet(this.procedureSets.text);
	        }
	    };
	    /* tslint:disable */
	    /**
	     * @public
	     */
	    PdfGraphics.prototype.drawString = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
	        if (typeof arg1 === 'string' && arg2 instanceof PdfFont && (arg3 instanceof PdfPen || arg3 === null) && (arg4 instanceof PdfBrush || arg4 === null) && typeof arg5 === 'number' && typeof arg6 === 'number' && (arg7 instanceof PdfStringFormat || arg7 === null) && typeof arg8 === 'undefined') {
	            this.isOverloadWithPosition = true;
	            this.drawString(arg1, arg2, arg3, arg4, arg5, arg6, (this.clientSize.width - arg5), 0, arg7);
	        }
	        else {
	            var temparg3 = arg3;
	            var temparg4 = arg4;
	            var temparg5 = arg5;
	            var temparg6 = arg6;
	            var temparg7 = arg7;
	            var temparg8 = arg8;
	            var temparg9 = arg9;
	            var layouter = new PdfStringLayouter();
	            var result = layouter.layout(arg1, arg2, temparg9, new SizeF(temparg7, temparg8), this.isOverloadWithPosition, this.clientSize);
	            if (!result.empty) {
	                var rect = this.checkCorrectLayoutRectangle(result.actualSize, temparg5, temparg6, temparg9);
	                if (temparg7 <= 0) {
	                    temparg5 = rect.x;
	                    temparg7 = rect.width;
	                }
	                if (temparg8 <= 0) {
	                    temparg6 = rect.y;
	                    temparg8 = rect.height;
	                }
	                this.drawStringLayoutResult(result, arg2, temparg3, temparg4, new RectangleF(temparg5, temparg6, temparg7, temparg8), temparg9);
	                this.isEmfTextScaled = false;
	                this.emfScalingFactor = new SizeF(0, 0);
	            }
	            this.getResources.getResources().requireProcedureSet(this.procedureSets.text);
	            this.isNormalRender = true;
	            this.pdfStringLayoutResult = result;
	            this.isUseFontSize = false;
	        }
	    }; /* tslint:enable */
	    PdfGraphics.prototype.drawLine = function (arg1, arg2, arg3, arg4, arg5) {
	        if (arg2 instanceof PointF) {
	            var temparg2 = arg2;
	            var temparg3 = arg3;
	            this.drawLine(arg1, temparg2.x, temparg2.y, temparg3.x, temparg3.y);
	        }
	        else {
	            var temparg2 = arg2;
	            var temparg3 = arg3;
	            var temparg4 = arg4;
	            var temparg5 = arg5;
	            this.stateControl(arg1, null, null);
	            var sw = this.streamWriter;
	            sw.beginPath(temparg2, temparg3);
	            sw.appendLineSegment(temparg4, temparg5);
	            sw.strokePath();
	            this.getResources.getResources().requireProcedureSet(this.procedureSets.pdf);
	        }
	    };
	    /* tslint:disable */
	    PdfGraphics.prototype.drawRectangle = function (arg1, arg2, arg3, arg4, arg5, arg6) {
	        if (arg1 instanceof PdfPen && typeof arg2 === 'number') {
	            var temparg3 = arg3;
	            this.drawRectangle(arg1, null, arg2, temparg3, arg4, arg5);
	        }
	        else if (arg1 instanceof PdfBrush && typeof arg2 === 'number') {
	            var temparg3 = arg3;
	            this.drawRectangle(null, arg1, arg2, temparg3, arg4, arg5);
	        }
	        else {
	            var temparg3 = arg3;
	            var temparg4 = arg4;
	            var temparg5 = arg5;
	            var temparg6 = arg6;
	            if ((arg2 instanceof PdfTilingBrush)) {
	                this.bCSInitialized = false;
	                var xOffset = (this.matrix.matrix.offsetX + temparg3);
	                var yOffset = void 0;
	                if (((this.layer != null) && (this.layer.page != null))) {
	                    yOffset = ((this.layer.page.size.height - this.matrix.matrix.offsetY) + temparg4);
	                }
	                else {
	                    yOffset = ((this.clientSize.height - this.matrix.matrix.offsetY) + temparg4);
	                }
	                (arg2).location = new PointF(xOffset, yOffset);
	                (arg2).graphics.colorSpace = this.colorSpace;
	            }
	            else if ((arg2 instanceof PdfGradientBrush)) {
	                arg2.colorSpace = this.colorSpace;
	            }
	            if (arg2 instanceof PdfSolidBrush && arg2.color.isEmpty) {
	                arg2 = null;
	            }
	            var temparg1 = arg1;
	            var temparg2 = arg2;
	            this.stateControl(temparg1, temparg2, null);
	            this.streamWriter.appendRectangle(temparg3, temparg4, temparg5, temparg6);
	            this.drawPathHelper(temparg1, temparg2, false);
	        }
	    };
	    PdfGraphics.prototype.drawPathHelper = function (arg1, arg2, arg3, arg4) {
	        if (typeof arg3 === 'boolean') {
	            var temparg3 = arg3;
	            this.drawPathHelper(arg1, arg2, PdfFillMode.Winding, temparg3);
	        }
	        else {
	            var temparg3 = arg3;
	            var isPen = arg1 != null;
	            var isBrush = arg2 != null;
	            var isEvenOdd = (temparg3 === PdfFillMode.Alternate);
	            if (isPen && isBrush) {
	                this.streamWriter.fillStrokePath(isEvenOdd);
	            }
	            else if (!isPen && !isBrush) {
	                this.streamWriter.endPath();
	            }
	            else if (isPen) {
	                this.streamWriter.strokePath();
	            }
	            else {
	                this.streamWriter.fillPath(isEvenOdd);
	            }
	        }
	    };
	    /* tslint:disable */
	    PdfGraphics.prototype.drawImage = function (arg1, arg2, arg3, arg4, arg5) {
	        if (typeof arg2 === 'number' && typeof arg3 === 'number' && typeof arg4 === 'undefined') {
	            var size = arg1.physicalDimension;
	            this.drawImage(arg1, arg2, arg3, size.width, size.height);
	        }
	        else {
	            var temparg2 = arg2;
	            var temparg3 = arg3;
	            var temparg5 = arg5;
	            arg1.save();
	            var matrix = new PdfTransformationMatrix();
	            this.getTranslateTransform(temparg2, (temparg3 + temparg5), matrix);
	            this.getScaleTransform(arg4, arg5, matrix);
	            this.pdfStreamWriter.write('q');
	            this.pdfStreamWriter.modifyCtm(matrix);
	            // Output template.
	            var resources = this.getResources.getResources();
	            if (typeof this.pageLayer !== 'undefined' && this.page != null) {
	                resources.document = this.page.document;
	            }
	            var name_2 = resources.getName(arg1);
	            if (typeof this.pageLayer !== 'undefined') {
	                this.page.setResources(resources);
	            }
	            this.pdfStreamWriter.executeObject(name_2);
	            this.pdfStreamWriter.write(Operators.restoreState);
	            this.pdfStreamWriter.write(Operators.newLine);
	            var resource = this.getResources.getResources();
	            resource.requireProcedureSet(this.procedureSets.imageB);
	            resource.requireProcedureSet(this.procedureSets.imageC);
	            resource.requireProcedureSet(this.procedureSets.imageI);
	            resource.requireProcedureSet(this.procedureSets.text);
	        }
	    };
	    //Implementation
	    /* tslint:disable */
	    /**
	     * Returns `bounds` of the line info.
	     * @private
	     */
	    PdfGraphics.prototype.getLineBounds = function (lineIndex, result, font, layoutRectangle, format) {
	        var bounds;
	        if (!result.empty && lineIndex < result.lineCount && lineIndex >= 0) {
	            var line = result.lines[lineIndex];
	            var vShift = this.getTextVerticalAlignShift(result.actualSize.height, layoutRectangle.height, format);
	            var y = vShift + layoutRectangle.y + (result.lineHeight * lineIndex);
	            var lineWidth = line.width;
	            var hShift = this.getHorizontalAlignShift(lineWidth, layoutRectangle.width, format);
	            var lineIndent = this.getLineIndent(line, format, layoutRectangle, (lineIndex === 0));
	            hShift += (!this.rightToLeft(format)) ? lineIndent : 0;
	            var x = layoutRectangle.x + hShift;
	            /* tslint:disable */
	            var width = (!this.shouldJustify(line, layoutRectangle.width, format)) ? lineWidth - lineIndent : layoutRectangle.width - lineIndent; /* tslint:enable */
	            var height = result.lineHeight;
	            bounds = new RectangleF(x, y, width, height);
	        }
	        else {
	            bounds = new RectangleF(0, 0, 0, 0);
	        }
	        return bounds;
	    };
	    /**
	     * Creates `lay outed rectangle` depending on the text settings.
	     * @private
	     */
	    PdfGraphics.prototype.checkCorrectLayoutRectangle = function (textSize, x, y, format) {
	        var layoutedRectangle = new RectangleF(x, y, textSize.width, textSize.width);
	        if (format != null) {
	            switch (format.alignment) {
	                case PdfTextAlignment.Center:
	                    layoutedRectangle.x -= layoutedRectangle.width / 2;
	                    break;
	                case PdfTextAlignment.Right:
	                    layoutedRectangle.x -= layoutedRectangle.width;
	                    break;
	            }
	            switch (format.lineAlignment) {
	                case PdfVerticalAlignment.Middle:
	                    layoutedRectangle.y -= layoutedRectangle.height / 2;
	                    break;
	                case PdfVerticalAlignment.Bottom:
	                    layoutedRectangle.y -= layoutedRectangle.height;
	                    break;
	            }
	        }
	        return layoutedRectangle;
	    };
	    /**
	     * Sets the `layer` for the graphics.
	     * @private
	     */
	    PdfGraphics.prototype.setLayer = function (layer) {
	        this.pageLayer = layer;
	        var page = layer.page;
	        if (page != null && typeof page !== 'undefined') {
	            page.beginSave = this.pageSave;
	        }
	    };
	    /**
	     * Adding page number field before page saving.
	     * @private
	     */
	    /* tslint:disable */
	    PdfGraphics.prototype.pageSave = function (page) {
	        if (page.graphics.automaticFields != null) {
	            for (var i = 0; i < page.graphics.automaticFields.automaticFields.length; i++) {
	                var fieldInfo = page.graphics.automaticFields.automaticFields[i];
	                fieldInfo.field.performDraw(page.graphics, fieldInfo.location, fieldInfo.scalingX, fieldInfo.scalingY);
	            }
	        }
	    };
	    /**
	     * `Draws a layout result`.
	     * @private
	     */
	    PdfGraphics.prototype.drawStringLayoutResult = function (result, font, pen, brush, layoutRectangle, format) {
	        if (!result.empty) {
	            this.applyStringSettings(font, pen, brush, format, layoutRectangle);
	            // Set text scaling
	            var textScaling = (format != null) ? format.horizontalScalingFactor : 100.0;
	            if (textScaling !== this.previousTextScaling && !this.isEmfTextScaled) {
	                this.pdfStreamWriter.setTextScaling(textScaling);
	                this.previousTextScaling = textScaling;
	            }
	            var height = (format == null || format.lineSpacing === 0) ? font.height : format.lineSpacing + font.height;
	            var subScript = (format != null && format.subSuperScript === PdfSubSuperScript.SubScript);
	            var shift = 0;
	            shift = (subScript) ? height - (font.height + font.metrics.getDescent(format)) : (height - font.metrics.getAscent(format));
	            this.shift = shift;
	            this.pdfStreamWriter.startNextLine(layoutRectangle.x, layoutRectangle.y - shift);
	            this.pdfStreamWriter.setLeading(+height);
	            var resultHeight = 0;
	            var remainingString = '';
	            for (var i = 0; i < result.lines.length; i++) {
	                resultHeight += result.lineHeight;
	                if ((layoutRectangle.y + resultHeight) > this.clientSize.height) {
	                    this.startCutIndex = i;
	                    break;
	                }
	            }
	            for (var j = this.startCutIndex; (j < result.lines.length && j >= 0); j++) {
	                remainingString += result.lines[j].text;
	            }
	            var bounds = new RectangleF(layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height);
	            this.drawLayoutResult(result, font, format, layoutRectangle);
	            this.underlineStrikeoutText(pen, brush, result, font, bounds, format);
	            this.isEmfPlus = false;
	            this.isUseFontSize = false;
	            if (this.startCutIndex !== -1) {
	                var page = this.getNextPage();
	                page.graphics.drawString(remainingString, font, pen, brush, layoutRectangle.x, 0, layoutRectangle.width, 0, format);
	            }
	        }
	        else {
	            throw new Error('ArgumentNullException:result');
	        }
	    };
	    /**
	     * Gets the `next page`.
	     * @private
	     */
	    PdfGraphics.prototype.getNextPage = function () {
	        var section = this.currentPage.section;
	        var nextPage = null;
	        var index = section.indexOf(this.currentPage);
	        if (index === section.count - 1) {
	            nextPage = section.add();
	        }
	        else {
	            nextPage = section.getPages()[index + 1];
	        }
	        return nextPage;
	    };
	    PdfGraphics.prototype.setClip = function (rectangle, mode) {
	        if (typeof mode === 'undefined') {
	            this.setClip(rectangle, PdfFillMode.Winding);
	        }
	        else {
	            this.pdfStreamWriter.appendRectangle(rectangle);
	            this.pdfStreamWriter.clipPath((mode === PdfFillMode.Alternate));
	        }
	    };
	    /**
	     * Applies all the `text settings`.
	     * @private
	     */
	    PdfGraphics.prototype.applyStringSettings = function (font, pen, brush, format, bounds) {
	        if (brush instanceof PdfTilingBrush) {
	            this.bCSInitialized = false;
	            brush.graphics.colorSpace = this.colorSpace;
	        }
	        else if ((brush instanceof PdfGradientBrush)) {
	            this.bCSInitialized = false;
	            brush.colorSpace = this.colorSpace;
	        }
	        var tm = this.getTextRenderingMode(pen, brush, format);
	        this.stateControl(pen, brush, font, format);
	        this.pdfStreamWriter.beginText();
	        if ((tm) !== this.previousTextRenderingMode) {
	            this.pdfStreamWriter.setTextRenderingMode(tm);
	            this.previousTextRenderingMode = tm;
	        }
	        // Set character spacing.
	        var cs = (format != null) ? format.characterSpacing : 0;
	        if (cs !== this.previousCharacterSpacing && !this.isEmfTextScaled) {
	            this.pdfStreamWriter.setCharacterSpacing(cs);
	            this.previousCharacterSpacing = cs;
	        }
	        // Set word spacing.
	        // NOTE: it works only if the space code is equal to 32 (0x20).
	        var ws = (format != null) ? format.wordSpacing : 0;
	        if (ws !== this.previousWordSpacing) {
	            this.pdfStreamWriter.setWordSpacing(ws);
	            this.previousWordSpacing = ws;
	        }
	    };
	    /**
	     * Calculates `shift value` if the text is vertically aligned.
	     * @private
	     */
	    PdfGraphics.prototype.getTextVerticalAlignShift = function (textHeight, boundsHeight, format) {
	        var shift = 0;
	        if (boundsHeight >= 0 && format != null && format.lineAlignment !== PdfVerticalAlignment.Top) {
	            switch (format.lineAlignment) {
	                case PdfVerticalAlignment.Middle:
	                    shift = (boundsHeight - textHeight) / 2;
	                    break;
	                case PdfVerticalAlignment.Bottom:
	                    shift = boundsHeight - textHeight;
	                    break;
	            }
	        }
	        return shift;
	    };
	    /* tslint:disable */
	    /**
	     * `Draws layout result`.
	     * @private
	     */
	    PdfGraphics.prototype.drawLayoutResult = function (result, font, format, layoutRectangle) {
	        var vAlignShift = this.getTextVerticalAlignShift(result.actualSize.height, layoutRectangle.height, format);
	        if (vAlignShift !== 0) {
	            this.pdfStreamWriter.startNextLine(0, vAlignShift);
	        }
	        var ttfFont = font;
	        var unicode = (ttfFont != null && ttfFont.isUnicode);
	        (ttfFont != null && ttfFont.isEmbedFont);
	        var lines = result.lines;
	        for (var i = 0, len = lines.length; (i < len && i !== this.startCutIndex); i++) {
	            var lineInfo = lines[i];
	            lineInfo.text;
	            var lineWidth = lineInfo.width;
	            var hAlignShift = this.getHorizontalAlignShift(lineWidth, layoutRectangle.width, format);
	            var lineIndent = this.getLineIndent(lineInfo, format, layoutRectangle, (i === 0));
	            hAlignShift += (!this.rightToLeft(format)) ? lineIndent : 0;
	            if (hAlignShift !== 0 && !this.isEmfTextScaled) {
	                this.pdfStreamWriter.startNextLine(hAlignShift, 0);
	            }
	            if (unicode) {
	                this.drawUnicodeLine(lineInfo, layoutRectangle, font, format);
	            }
	            else {
	                this.drawAsciiLine(lineInfo, layoutRectangle, font, format);
	            }
	            if (hAlignShift !== 0 && !this.isEmfTextScaled) {
	                this.pdfStreamWriter.startNextLine(-hAlignShift, 0);
	            }
	            if (this.isOverloadWithPosition && lines.length > 1) {
	                this.pdfStreamWriter.startNextLine(-(layoutRectangle.x), 0);
	                layoutRectangle.x = 0;
	                layoutRectangle.width = this.clientSize.width;
	                this.isOverloadWithPosition = false;
	                this.isPointOverload = true;
	            }
	        }
	        this.getResources.getResources().requireProcedureSet(this.procedureSets.text);
	        if (vAlignShift !== 0) {
	            this.pdfStreamWriter.startNextLine(0, -(vAlignShift - result.lineHeight));
	        }
	        this.pdfStreamWriter.endText();
	    };
	    /**
	     * `Draws Ascii line`.
	     * @private
	     */
	    PdfGraphics.prototype.drawAsciiLine = function (lineInfo, layoutRectangle, font, format) {
	        this.justifyLine(lineInfo, layoutRectangle.width, format);
	        var value = '';
	        if (lineInfo.text.indexOf('(') !== -1 || lineInfo.text.indexOf(')') !== -1) {
	            for (var i = 0; i < lineInfo.text.length; i++) {
	                if (lineInfo.text[i] === '(') {
	                    value += '\\\(';
	                }
	                else if (lineInfo.text[i] === ')') {
	                    value += '\\\)';
	                }
	                else {
	                    value += lineInfo.text[i];
	                }
	            }
	        }
	        if (value === '') {
	            value = lineInfo.text;
	        }
	        var line = '(' + value + ')';
	        this.pdfStreamWriter.showNextLineText(new PdfString(line));
	    };
	    /**
	     * Draws unicode line.
	     * @private
	     */
	    PdfGraphics.prototype.drawUnicodeLine = function (lineInfo, layoutRectangle, font, format) {
	        var line = lineInfo.text;
	        lineInfo.width;
	        var rtl = (format !== null && typeof format !== 'undefined' && format.rightToLeft);
	        var useWordSpace = (format !== null && typeof format !== 'undefined' && (format.wordSpacing !== 0 || format.alignment === PdfTextAlignment.Justify));
	        var ttfFont = font;
	        var wordSpacing = this.justifyLine(lineInfo, layoutRectangle.width, format);
	        var rtlRender = new RtlRenderer();
	        if (rtl || (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.None)) {
	            var blocks = null;
	            var rightAlign = (format !== null && typeof format !== 'undefined' && format.alignment === PdfTextAlignment.Right);
	            if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.None) {
	                /* tslint:disable-next-line:max-line-length */
	                blocks = rtlRender.layout(line, ttfFont, (format.textDirection === PdfTextDirection.RightToLeft) ? true : false, useWordSpace, format);
	            }
	            else {
	                blocks = rtlRender.layout(line, ttfFont, rightAlign, useWordSpace, format);
	            }
	            var words = null;
	            if (blocks.length > 1) {
	                if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.None) {
	                    /* tslint:disable-next-line:max-line-length */
	                    words = rtlRender.splitLayout(line, ttfFont, (format.textDirection === PdfTextDirection.RightToLeft) ? true : false, useWordSpace, format);
	                }
	                else {
	                    words = rtlRender.splitLayout(line, ttfFont, rightAlign, useWordSpace, format);
	                }
	            }
	            else {
	                words = [line];
	            }
	            this.drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);
	        }
	        else {
	            if (useWordSpace) {
	                var result = this.breakUnicodeLine(line, ttfFont, null);
	                var blocks = result.tokens;
	                var words = result.words;
	                this.drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);
	            }
	            else {
	                var token = this.convertToUnicode(line, ttfFont);
	                var value = this.getUnicodeString(token);
	                this.streamWriter.showNextLineText(value);
	            }
	        }
	    };
	    /**
	     * Draws array of unicode tokens.
	     */
	    /* tslint:disable */
	    PdfGraphics.prototype.drawUnicodeBlocks = function (blocks, words, font, format, wordSpacing) {
	        /* tslint:enable */
	        if (blocks == null) {
	            throw new Error('Argument Null Exception : blocks');
	        }
	        if (words == null) {
	            throw new Error('Argument Null Exception : words');
	        }
	        if (font == null) {
	            throw new Error('Argument Null Exception : font');
	        }
	        this.streamWriter.startNextLine();
	        var x = 0;
	        var xShift = 0;
	        var firstLineIndent = 0;
	        var paragraphIndent = 0;
	        try {
	            if (format !== null && typeof format !== 'undefined') {
	                firstLineIndent = format.firstLineIndent;
	                paragraphIndent = format.paragraphIndent;
	                format.firstLineIndent = 0;
	                format.paragraphIndent = 0;
	            }
	            var spaceWidth = font.getCharWidth(StringTokenizer.whiteSpace, format) + wordSpacing;
	            var characterSpacing = (format != null) ? format.characterSpacing : 0;
	            var wordSpace = (format !== null && typeof format !== 'undefined' && wordSpacing === 0) ? format.wordSpacing : 0;
	            spaceWidth += characterSpacing + wordSpace;
	            for (var i = 0; i < blocks.length; i++) {
	                var token = blocks[i];
	                var word = words[i];
	                var tokenWidth = 0;
	                if (x !== 0) {
	                    this.streamWriter.startNextLine(x, 0);
	                }
	                if (word.length > 0) {
	                    tokenWidth += /*Utils.Round(*/ font.measureString(word, format).width /*)*/;
	                    tokenWidth += characterSpacing;
	                    var val = this.getUnicodeString(token);
	                    this.streamWriter.showText(val);
	                }
	                if (i !== blocks.length - 1) {
	                    x = tokenWidth + spaceWidth;
	                    xShift += x;
	                }
	            }
	            // Rolback current line position.
	            if (xShift > 0) {
	                this.streamWriter.startNextLine(-xShift, 0);
	            }
	        }
	        finally {
	            if (format !== null && typeof format !== 'undefined') {
	                format.firstLineIndent = firstLineIndent;
	                format.paragraphIndent = paragraphIndent;
	            }
	        }
	    };
	    /**
	     * Breakes the unicode line to the words and converts symbols to glyphs.
	     */
	    PdfGraphics.prototype.breakUnicodeLine = function (line, ttfFont, words) {
	        if (line === null) {
	            throw new Error('Argument Null Exception : line');
	        }
	        words = line.split(null);
	        var tokens = [];
	        for (var i = 0; i < words.length; i++) {
	            // Reconvert string according to unicode standard.
	            var word = words[i];
	            var token = this.convertToUnicode(word, ttfFont);
	            tokens[i] = token;
	        }
	        return { tokens: tokens, words: words };
	    };
	    /**
	     * Creates PdfString from the unicode text.
	     */
	    PdfGraphics.prototype.getUnicodeString = function (token) {
	        if (token === null) {
	            throw new Error('Argument Null Exception : token');
	        }
	        var val = new PdfString(token);
	        val.converted = true;
	        val.encode = InternalEnum.ForceEncoding.Ascii;
	        return val;
	    };
	    /**
	     * Converts to unicode format.
	     */
	    PdfGraphics.prototype.convertToUnicode = function (text, ttfFont) {
	        var token = null;
	        if (text == null) {
	            throw new Error('Argument Null Exception : text');
	        }
	        if (ttfFont == null) {
	            throw new Error('Argument Null Exception : ttfFont');
	        }
	        if (ttfFont.fontInternal instanceof UnicodeTrueTypeFont) {
	            var ttfReader = ttfFont.fontInternal.ttfReader;
	            ttfFont.setSymbols(text);
	            token = ttfReader.convertString(text);
	            var bytes = PdfString.toUnicodeArray(token, false);
	            token = PdfString.byteToString(bytes);
	        }
	        return token;
	    };
	    /**
	     * `Justifies` the line if needed.
	     * @private
	     */
	    PdfGraphics.prototype.justifyLine = function (lineInfo, boundsWidth, format) {
	        var line = lineInfo.text;
	        var lineWidth = lineInfo.width;
	        var shouldJustify = this.shouldJustify(lineInfo, boundsWidth, format);
	        var hasWordSpacing = (format != null && format.wordSpacing !== 0);
	        var symbols = StringTokenizer.spaces;
	        var whitespacesCount = StringTokenizer.getCharsCount(line, symbols);
	        var wordSpace = 0;
	        if (shouldJustify) {
	            // Correct line width.
	            if (hasWordSpacing) {
	                lineWidth -= (whitespacesCount * format.wordSpacing);
	            }
	            var difference = boundsWidth - lineWidth;
	            wordSpace = difference / whitespacesCount;
	            this.pdfStreamWriter.setWordSpacing(wordSpace);
	        }
	        else {
	            // If there is justifying, but the line shouldn't be justified, restore default word spacing.
	            if (hasWordSpacing) {
	                this.pdfStreamWriter.setWordSpacing(format.wordSpacing);
	            }
	            else {
	                this.pdfStreamWriter.setWordSpacing(0);
	            }
	        }
	        return wordSpace;
	    };
	    /**
	     * `Reset` or reinitialize the current graphic value.
	     * @private
	     */
	    PdfGraphics.prototype.reset = function (size) {
	        this.canvasSize = size;
	        this.streamWriter.clear();
	        this.initialize();
	        this.initializeCoordinates();
	    };
	    /**
	     * Checks whether the line should be `justified`.
	     * @private
	     */
	    PdfGraphics.prototype.shouldJustify = function (lineInfo, boundsWidth, format) {
	        var line = lineInfo.text;
	        var lineWidth = lineInfo.width;
	        var justifyStyle = (format != null && format.alignment === PdfTextAlignment.Justify);
	        var goodWidth = (boundsWidth >= 0 && lineWidth < boundsWidth);
	        var symbols = StringTokenizer.spaces;
	        var whitespacesCount = StringTokenizer.getCharsCount(line, symbols);
	        var hasSpaces = (whitespacesCount > 0 && line[0] !== StringTokenizer.whiteSpace);
	        var goodLineBreakStyle = ((lineInfo.lineType & LineType.LayoutBreak) > 0);
	        /* tslint:disable */
	        var shouldJustify = (justifyStyle && goodWidth && hasSpaces && (goodLineBreakStyle || format.alignment === PdfTextAlignment.Justify)); /* tslint:enable */
	        return shouldJustify;
	    };
	    /* tslint:disable */
	    /**
	     * Emulates `Underline, Strikeout` of the text if needed.
	     * @private
	     */
	    PdfGraphics.prototype.underlineStrikeoutText = function (pen, brush, result, font, layoutRectangle, format) {
	        if (font.underline || font.strikeout) {
	            // Calculate line width.
	            var linePen = this.createUnderlineStikeoutPen(pen, brush, font, format);
	            if (linePen != null) {
	                // Approximate line positions.
	                var vShift = this.getTextVerticalAlignShift(result.actualSize.height, layoutRectangle.height, format);
	                var underlineYOffset = 0;
	                underlineYOffset = layoutRectangle.y + vShift + font.metrics.getAscent(format) + 1.5 * linePen.width;
	                var strikeoutYOffset = layoutRectangle.y + vShift + font.metrics.getHeight(format) / 2 + 1.5 * linePen.width;
	                var lines = result.lines;
	                // Run through the text and draw lines.
	                for (var i = 0, len = result.lineCount; i < len; i++) {
	                    var lineInfo = lines[i];
	                    lineInfo.text;
	                    var lineWidth = lineInfo.width;
	                    var hShift = this.getHorizontalAlignShift(lineWidth, layoutRectangle.width, format);
	                    var lineIndent = this.getLineIndent(lineInfo, format, layoutRectangle, (i === 0));
	                    hShift += (!this.rightToLeft(format)) ? lineIndent : 0;
	                    var x1 = layoutRectangle.x + hShift;
	                    /* tslint:disable */
	                    var x2 = (!this.shouldJustify(lineInfo, layoutRectangle.width, format)) ? x1 + lineWidth - lineIndent : x1 + layoutRectangle.width - lineIndent;
	                    /* tslint:enable */
	                    if (font.underline) {
	                        var y = underlineYOffset;
	                        this.drawLine(linePen, x1, y, x2, y);
	                        underlineYOffset += result.lineHeight;
	                    }
	                    if (font.strikeout) {
	                        var y = strikeoutYOffset;
	                        this.drawLine(linePen, x1, y, x2, y);
	                        strikeoutYOffset += result.lineHeight;
	                    }
	                    if (this.isPointOverload && lines.length > 1) {
	                        layoutRectangle.x = 0;
	                        layoutRectangle.width = this.clientSize.width;
	                    }
	                }
	                this.isPointOverload = false;
	            }
	        }
	    };
	    /**
	     * `Creates a pen` for drawing lines in the text.
	     * @private
	     */
	    PdfGraphics.prototype.createUnderlineStikeoutPen = function (pen, brush, font, format) {
	        // Calculate line width.
	        var lineWidth = font.metrics.getSize(format) / 20;
	        var linePen = null;
	        // Create a pen fo the lines.
	        if (pen != null) {
	            linePen = new PdfPen(pen.color, lineWidth);
	        }
	        else if (brush != null) {
	            linePen = new PdfPen(brush, lineWidth);
	        }
	        return linePen;
	    };
	    /**
	     * Return `text rendering mode`.
	     * @private
	     */
	    PdfGraphics.prototype.getTextRenderingMode = function (pen, brush, format) {
	        var tm = TextRenderingMode.None;
	        if (pen != null && brush != null) {
	            tm = TextRenderingMode.FillStroke;
	        }
	        else if (pen != null) {
	            tm = TextRenderingMode.Stroke;
	        }
	        else {
	            tm = TextRenderingMode.Fill;
	        }
	        if (format != null && format.clipPath) {
	            tm |= TextRenderingMode.ClipFlag;
	        }
	        return tm;
	    };
	    /**
	     * Returns `line indent` for the line.
	     * @private
	     */
	    PdfGraphics.prototype.getLineIndent = function (lineInfo, format, layoutBounds, firstLine) {
	        var lineIndent = 0;
	        var firstParagraphLine = ((lineInfo.lineType & LineType.FirstParagraphLine) > 0);
	        if (format != null && firstParagraphLine) {
	            lineIndent = (firstLine) ? format.firstLineIndent : format.paragraphIndent;
	            lineIndent = (layoutBounds.width > 0) ? Math.min(layoutBounds.width, lineIndent) : lineIndent;
	        }
	        return lineIndent;
	    };
	    /**
	     * Calculates shift value if the line is `horizontaly aligned`.
	     * @private
	     */
	    PdfGraphics.prototype.getHorizontalAlignShift = function (lineWidth, boundsWidth, format) {
	        var shift = 0;
	        if (boundsWidth >= 0 && format != null && format.alignment !== PdfTextAlignment.Left) {
	            switch (format.alignment) {
	                case PdfTextAlignment.Center:
	                    shift = (boundsWidth - lineWidth) / 2;
	                    break;
	                case PdfTextAlignment.Right:
	                    shift = boundsWidth - lineWidth;
	                    break;
	            }
	        }
	        return shift;
	    };
	    /**
	     * Gets or sets the value that indicates `text direction` mode.
	     * @private
	     */
	    PdfGraphics.prototype.rightToLeft = function (format) {
	        var rtl = (format !== null && typeof format !== 'undefined' && format.rightToLeft);
	        if (format !== null && typeof format !== 'undefined') {
	            if (format.textDirection !== PdfTextDirection.None && typeof format.textDirection !== 'undefined') {
	                rtl = true;
	            }
	        }
	        return rtl;
	    };
	    PdfGraphics.prototype.stateControl = function (pen, brush, font, format) {
	        if (typeof format === 'undefined') {
	            this.stateControl(pen, brush, font, null);
	        }
	        else {
	            if (brush instanceof PdfGradientBrush) {
	                this.bCSInitialized = false;
	                brush.colorSpace = this.colorSpace;
	            }
	            if (brush instanceof PdfTilingBrush) {
	                this.bCSInitialized = false;
	                brush.graphics.colorSpace = this.colorSpace;
	            }
	            var saveState = false;
	            if (brush !== null) {
	                if (typeof this.pageLayer !== 'undefined' && this.pageLayer != null) {
	                    if (this.colorSpaceChanged === false) {
	                        this.lastDocumentCS = this.pageLayer.page.document.colorSpace;
	                        this.lastGraphicsCS = this.pageLayer.page.graphics.colorSpace;
	                        this.colorSpace = this.pageLayer.page.document.colorSpace;
	                        this.currentColorSpace = this.pageLayer.page.document.colorSpace;
	                        this.colorSpaceChanged = true;
	                    }
	                }
	                this.initCurrentColorSpace(this.currentColorSpace);
	            }
	            else if (pen != null) {
	                if (typeof this.pageLayer !== 'undefined' && this.pageLayer != null) {
	                    /* tslint:disable */
	                    this.colorSpace = this.pageLayer.page.document.colorSpace;
	                    this.currentColorSpace = this.pageLayer.page.document.colorSpace;
	                }
	                this.initCurrentColorSpace(this.currentColorSpace);
	            }
	            this.penControl(pen, saveState);
	            this.brushControl(brush, saveState);
	            this.fontControl(font, format, saveState);
	        }
	    };
	    /**
	     * Initializes the `current color space`.
	     * @private
	     */
	    PdfGraphics.prototype.initCurrentColorSpace = function (colorspace) {
	        this.getResources.getResources();
	        if (!this.bCSInitialized) {
	            if (this.currentColorSpace != PdfColorSpace.GrayScale) {
	                this.pdfStreamWriter.setColorSpace('Device' + this.currentColorSpaces[this.currentColorSpace], true);
	                this.pdfStreamWriter.setColorSpace('Device' + this.currentColorSpaces[this.currentColorSpace], false);
	                this.bCSInitialized = true;
	            }
	            else {
	                this.pdfStreamWriter.setColorSpace('DeviceGray', true);
	                this.pdfStreamWriter.setColorSpace('DeviceGray', false);
	                this.bCSInitialized = true;
	            }
	        }
	    };
	    /**
	     * Controls the `pen state`.
	     * @private
	     */
	    PdfGraphics.prototype.penControl = function (pen, saveState) {
	        if (pen != null) {
	            this.currentPen = pen;
	            /* tslint:disable */
	            pen.monitorChanges(this.currentPen, this.pdfStreamWriter, this.getResources, saveState, this.colorSpace, this.matrix.clone());
	            /* tslint:enable */
	            this.currentPen = pen.clone();
	        }
	    };
	    /**
	     * Controls the `brush state`.
	     * @private
	     */
	    PdfGraphics.prototype.brushControl = function (brush, saveState) {
	        if (brush != null && typeof brush !== 'undefined') {
	            var b = brush.clone();
	            var lgb = b;
	            if (lgb !== null && typeof lgb !== 'undefined' && !(brush instanceof PdfSolidBrush) && !(brush instanceof PdfTilingBrush)) {
	                var m = lgb.matrix;
	                var matrix = this.matrix.clone();
	                if ((m != null)) {
	                    m.multiply(matrix);
	                    matrix = m;
	                }
	                lgb.matrix = matrix;
	            }
	            this.currentBrush = lgb;
	            /* tslint:disable */
	            b.monitorChanges(this.currentBrush, this.pdfStreamWriter, this.getResources, saveState, this.colorSpace);
	            /* tslint:enable */
	            this.currentBrush = brush;
	            brush = null;
	        }
	    };
	    /**
	     * Saves the font and other `font settings`.
	     * @private
	     */
	    PdfGraphics.prototype.fontControl = function (font, format, saveState) {
	        if (font != null) {
	            var curSubSuper = (format != null) ? format.subSuperScript : PdfSubSuperScript.None;
	            /* tslint:disable */
	            var prevSubSuper = (this.currentStringFormat != null) ? this.currentStringFormat.subSuperScript : PdfSubSuperScript.None; /* tslint:enable */
	            if (saveState || font !== this.currentFont || curSubSuper !== prevSubSuper) {
	                var resources = this.getResources.getResources();
	                this.currentFont = font;
	                this.currentStringFormat = format;
	                var size = font.metrics.getSize(format);
	                /* tslint:disable */
	                this.isEmfTextScaled = false;
	                var fontName = resources.getName(font);
	                this.pdfStreamWriter.setFont(font, fontName, size);
	            }
	        }
	    };
	    PdfGraphics.prototype.setTransparency = function (arg1, arg2, arg3) {
	        if (typeof arg2 === 'undefined') {
	            this.istransparencySet = true;
	            this.setTransparency(arg1, arg1, PdfBlendMode.Normal);
	        }
	        else if (typeof arg2 === 'number' && typeof arg3 === 'undefined') {
	            this.setTransparency(arg1, arg2, PdfBlendMode.Normal);
	        }
	        else {
	            if (this.trasparencies == null) {
	                this.trasparencies = new TemporaryDictionary();
	            }
	            var transp = null;
	            var td = new TransparencyData(arg1, arg2, arg3);
	            if (this.trasparencies.containsKey(td)) {
	                transp = this.trasparencies.getValue(td);
	            }
	            if (transp == null) {
	                transp = new PdfTransparency(arg1, arg2, arg3);
	                this.trasparencies.setValue(td, transp);
	            }
	            var resources = this.getResources.getResources();
	            var name_3 = resources.getName(transp);
	            var sw = this.streamWriter;
	            sw.setGraphicsState(name_3);
	        }
	    };
	    PdfGraphics.prototype.clipTranslateMargins = function (x, y, left, top, right, bottom) {
	        if (x instanceof RectangleF && typeof y === 'undefined') {
	            this.clipBounds = x;
	            this.pdfStreamWriter.writeComment('Clip margins.');
	            this.pdfStreamWriter.appendRectangle(x);
	            this.pdfStreamWriter.closePath();
	            this.pdfStreamWriter.clipPath(false);
	            this.pdfStreamWriter.writeComment('Translate co-ordinate system.');
	            this.translateTransform(x.x, x.y);
	        }
	        else if (typeof x === 'number') {
	            var clipArea = new RectangleF(left, top, this.size.width - left - right, this.size.height - top - bottom);
	            this.clipBounds = clipArea;
	            this.pdfStreamWriter.writeComment("Clip margins.");
	            this.pdfStreamWriter.appendRectangle(clipArea);
	            this.pdfStreamWriter.closePath();
	            this.pdfStreamWriter.clipPath(false);
	            this.pdfStreamWriter.writeComment("Translate co-ordinate system.");
	            this.translateTransform(x, y);
	        }
	    };
	    /**
	     * `Updates y` co-ordinate.
	     * @private
	     */
	    PdfGraphics.prototype.updateY = function (y) {
	        return -y;
	    };
	    /**
	     * Used to `translate the transformation`.
	     * ```typescript
	     * // create a new PDF document
	     * let document : PdfDocument = new PdfDocument();
	     * // create a new page
	     * let page1 : PdfPage = document.pages.add();
	     * // set pen
	     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
	     * //
	     * // set translate transform
	     * page1.graphics.translateTransform(100, 100);
	     * //
	     * // draw the rectangle after applying translate transform
	     * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
	     * // save the document.
	     * document.save('output.pdf');
	     * // destroy the document
	     * document.destroy();
	     * ```
	     * @param offsetX The x-coordinate of the translation.
	     * @param offsetY The y-coordinate of the translation.
	     */
	    PdfGraphics.prototype.translateTransform = function (offsetX, offsetY) {
	        var matrix = new PdfTransformationMatrix();
	        this.getTranslateTransform(offsetX, offsetY, matrix);
	        this.pdfStreamWriter.modifyCtm(matrix);
	        this.matrix.multiply(matrix);
	    };
	    /**
	     * `Translates` coordinates of the input matrix.
	     * @private
	     */
	    PdfGraphics.prototype.getTranslateTransform = function (x, y, input) {
	        input.translate(x, this.updateY(y));
	        return input;
	    };
	    /* tslint:disable */
	    /**
	     * Applies the specified `scaling operation` to the transformation matrix of this Graphics by prepending it to the object's transformation matrix.
	     * ```typescript
	     * // create a new PDF document
	     * let document : PdfDocument = new PdfDocument();
	     * // create a new page
	     * let page1 : PdfPage = document.pages.add();
	     * // create pen
	     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
	     * //
	     * // apply scaling trasformation
	     * page1.graphics.scaleTransform(1.5, 2);
	     * //
	     * // draw the rectangle after applying scaling transform
	     * page1.graphics.drawRectangle(pen, new RectangleF({x : 100, y : 100}, {width : 100, height : 50}));
	     * // save the document.
	     * document.save('output.pdf');
	     * // destroy the document
	     * document.destroy();
	     * ```
	     * @param scaleX Scale factor in the x direction.
	     * @param scaleY Scale factor in the y direction.
	     */
	    /* tslint:enable */
	    PdfGraphics.prototype.scaleTransform = function (scaleX, scaleY) {
	        var matrix = new PdfTransformationMatrix();
	        this.getScaleTransform(scaleX, scaleY, matrix);
	        this.pdfStreamWriter.modifyCtm(matrix);
	        this.matrix.multiply(matrix);
	    };
	    /**
	     * `Scales` coordinates of the input matrix.
	     * @private
	     */
	    PdfGraphics.prototype.getScaleTransform = function (x, y, input) {
	        if (input == null) {
	            input = new PdfTransformationMatrix();
	        }
	        input.scale(x, y);
	        return input;
	    };
	    /**
	     * Applies the specified `rotation` to the transformation matrix of this Graphics.
	     * ```typescript
	     * // create a new PDF document
	     * let document : PdfDocument = new PdfDocument();
	     * // create a new page
	     * let page1 : PdfPage = document.pages.add();
	     * // create pen
	     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
	     * //
	     * // set RotateTransform with 25 degree of angle
	     * page1.graphics.rotateTransform(25);
	     * //
	     * // draw the rectangle after RotateTransformation
	     * page1.graphics.drawRectangle(pen, new RectangleF({x : 100, y : 100}, {width : 100, height : 50}));
	     * // save the document.
	     * document.save('output.pdf');
	     * // destroy the document
	     * document.destroy();
	     * ```
	     * @param angle Angle of rotation in degrees.
	     */
	    PdfGraphics.prototype.rotateTransform = function (angle) {
	        var matrix = new PdfTransformationMatrix();
	        this.getRotateTransform(angle, matrix);
	        this.pdfStreamWriter.modifyCtm(matrix);
	        this.matrix.multiply(matrix);
	    };
	    /**
	     * `Initializes coordinate system`.
	     * @private
	     */
	    PdfGraphics.prototype.initializeCoordinates = function () {
	        // Matrix equation: TM(T-1)=M', where T=[1 0 0 -1 0 h]
	        this.pdfStreamWriter.writeComment('Change co-ordinate system to left/top.');
	        // Translate co-ordinates only, don't flip.
	        if (this.mediaBoxUpperRightBound !== -(this.size.height)) {
	            if (this.cropBox == null) {
	                if (this.mediaBoxUpperRightBound === this.size.height || this.mediaBoxUpperRightBound === 0) {
	                    this.translateTransform(0, this.updateY(this.size.height));
	                }
	                else {
	                    this.translateTransform(0, this.updateY(this.mediaBoxUpperRightBound));
	                }
	            }
	        }
	    };
	    /**
	     * `Rotates` coordinates of the input matrix.
	     * @private
	     */
	    PdfGraphics.prototype.getRotateTransform = function (angle, input) {
	        if (input == null || typeof input === 'undefined') {
	            input = new PdfTransformationMatrix();
	        }
	        input.rotate(this.updateY(angle));
	        return input;
	    };
	    /**
	     * `Saves` the current state of this Graphics and identifies the saved state with a GraphicsState.
	     * ```typescript
	     * // create a new PDF document
	     * let document : PdfDocument = new PdfDocument();
	     * // create a new page
	     * let page1 : PdfPage = document.pages.add();
	     * // create pen
	     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
	     * //
	     * // save the graphics state
	     * let state1 : PdfGraphicsState = page1.graphics.save();
	     * //
	     * page1.graphics.scaleTransform(1.5, 2);
	     * // draw the rectangle
	     * page1.graphics.drawRectangle(pen, new RectangleF({x : 100, y : 100}, {width : 100, height : 50}));
	     * // restore the graphics state
	     * page1.graphics.restore(state1);
	     * // save the document.
	     * document.save('output.pdf');
	     * // destroy the document
	     * document.destroy();
	     * ```
	     */
	    PdfGraphics.prototype.save = function () {
	        var state = new PdfGraphicsState(this, this.matrix.clone());
	        state.brush = this.currentBrush;
	        state.pen = this.currentPen;
	        state.font = this.currentFont;
	        state.colorSpace = this.currentColorSpace;
	        state.characterSpacing = this.previousCharacterSpacing;
	        state.wordSpacing = this.previousWordSpacing;
	        state.textScaling = this.previousTextScaling;
	        state.textRenderingMode = this.previousTextRenderingMode;
	        this.graphicsState.push(state);
	        this.pdfStreamWriter.saveGraphicsState();
	        return state;
	    };
	    PdfGraphics.prototype.restore = function (state) {
	        if (typeof state === 'undefined') {
	            if (this.graphicsState.length > 0) {
	                this.doRestoreState();
	            }
	        }
	        else {
	            if (this.graphicsState.indexOf(state) !== -1) {
	                for (;;) {
	                    if (this.graphicsState.length === 0) {
	                        break;
	                    }
	                    var popState = this.doRestoreState();
	                    if (popState === state) {
	                        break;
	                    }
	                }
	            }
	        }
	    };
	    /**
	     * `Restores graphics state`.
	     * @private
	     */
	    PdfGraphics.prototype.doRestoreState = function () {
	        var state = this.graphicsState.pop();
	        this.transformationMatrix = state.matrix;
	        this.currentBrush = state.brush;
	        this.currentPen = state.pen;
	        this.currentFont = state.font;
	        this.currentColorSpace = state.colorSpace;
	        this.previousCharacterSpacing = state.characterSpacing;
	        this.previousWordSpacing = state.wordSpacing;
	        this.previousTextScaling = state.textScaling;
	        this.previousTextRenderingMode = state.textRenderingMode;
	        this.pdfStreamWriter.restoreGraphicsState();
	        return state;
	    };
	    /* tslint:enable */
	    /**
	     * `Draws the specified path`, using its original physical size, at the location specified by a coordinate pair.
	     * ```typescript
	     * // create a new PDF document.
	     * let document : PdfDocument = new PdfDocument();
	     * // add a page to the document.
	     * let page1 : PdfPage = document.pages.add();
	     * //Create new PDF path.
	     * let path : PdfPath = new PdfPath();
	     * //Add line path points.
	     * path.addLine(new PointF(10, 100), new PointF(10, 200));
	     * path.addLine(new PointF(100, 100), new PointF(100, 200));
	     * path.addLine(new PointF(100, 200), new PointF(55, 150));
	     * // set pen
	     * let pen : PdfPen = new PdfPen(new PdfColor(255, 0, 0));
	     * // set brush
	     * let brush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	     * // draw the path
	     * page1.graphics.drawPath(pen, brush, path);
	     * //
	     * // save the document.
	     * document.save('output.pdf');
	     * // destroy the document
	     * document.destroy();
	     * ```
	     * @param pen Color of the text.
	     * @param brush Color of the text.
	     * @param path Draw path.
	     */
	    PdfGraphics.prototype.drawPath = function (pen, brush, path) {
	        if (brush instanceof PdfTilingBrush) {
	            this.bCSInitialized = false;
	            brush.graphics.colorSpace = this.colorSpace;
	        }
	        else if (brush instanceof PdfGradientBrush) {
	            this.bCSInitialized = false;
	            brush.colorSpace = this.colorSpace;
	        }
	        this.stateControl(pen, brush, null);
	        this.buildUpPath(path.pathPoints, path.pathTypes);
	        this.drawPathHelper(pen, brush, path.fillMode, false);
	    };
	    /* tslint:disable-next-line:max-line-length */
	    PdfGraphics.prototype.drawArc = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
	        if (arg2 instanceof RectangleF) {
	            this.drawArc(arg1, arg2.x, arg2.y, arg2.width, arg2.height, arg3, arg4);
	        }
	        else {
	            if ((arg7 !== 0)) {
	                this.stateControl(arg1, null, null);
	                this.constructArcPath(arg2, arg3, (arg2 + arg4), (arg3 + arg5), arg6, arg7);
	                this.drawPathHelper(arg1, null, false);
	            }
	        }
	    };
	    /**
	     * Builds up the path.
	     * @private
	     */
	    PdfGraphics.prototype.buildUpPath = function (arg1, arg2) {
	        var cnt = arg1.length;
	        for (var i = 0; i < cnt; ++i) {
	            var typeValue = 0;
	            var point = arg1[i];
	            switch (((arg2[i] & (PdfGraphics.pathTypesValuesMask)))) {
	                case PathPointType.Start:
	                    this.pdfStreamWriter.beginPath(point.x, point.y);
	                    break;
	                case PathPointType.Bezier3:
	                    var p2 = new PointF(0, 0);
	                    var p3 = new PointF(0, 0);
	                    var result1 = this.getBezierPoints(arg1, arg2, i, p2, p3);
	                    this.pdfStreamWriter.appendBezierSegment(point, result1.p2, result1.p3);
	                    i = result1.i;
	                    break;
	                case PathPointType.Line:
	                    this.pdfStreamWriter.appendLineSegment(point);
	                    break;
	                default:
	                    throw new Error('ArithmeticException - Incorrect path formation.');
	            }
	            typeValue = arg2[i];
	            this.checkFlags(typeValue);
	        }
	    };
	    /**
	     * Gets the bezier points from respective arrays.
	     * @private
	     */
	    /* tslint:disable-next-line:max-line-length */
	    PdfGraphics.prototype.getBezierPoints = function (points, types, i, p2, p3) {
	        ++i;
	        if ((((types[i] & PdfGraphics.pathTypesValuesMask)) === PathPointType.Bezier3)) {
	            p2 = points[i];
	            ++i;
	            if ((((types[i] & PdfGraphics.pathTypesValuesMask)) === PathPointType.Bezier3)) {
	                p3 = points[i];
	            }
	            else {
	                throw new Error('ArgumentException : errorMsg');
	            }
	        }
	        else {
	            throw new Error('ArgumentException : errorMsg');
	        }
	        return { i: i, p2: p2, p3: p3 };
	    };
	    /**
	     * Checks path point type flags.
	     * @private
	     */
	    PdfGraphics.prototype.checkFlags = function (type) {
	        if ((((type & (PathPointType.CloseSubpath))) === PathPointType.CloseSubpath)) {
	            this.pdfStreamWriter.closePath();
	        }
	    };
	    /**
	     * Constructs the arc path using Bezier curves.
	     * @private
	     */
	    PdfGraphics.prototype.constructArcPath = function (x1, y1, x2, y2, startAng, sweepAngle) {
	        var points = this.getBezierArc(x1, y1, x2, y2, startAng, sweepAngle);
	        if ((points.length === 0)) {
	            return;
	        }
	        var pt = [points[0], points[1], points[2], points[3], points[4], points[5], points[6], points[7]];
	        this.pdfStreamWriter.beginPath(pt[0], pt[1]);
	        var i = 0;
	        for (i = 0; i < points.length; i = i + 8) {
	            pt = [points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5], points[i + 6], points[i + 7]];
	            this.pdfStreamWriter.appendBezierSegment(pt[2], pt[3], pt[4], pt[5], pt[6], pt[7]);
	        }
	    };
	    /**
	     * Gets the bezier points for arc constructing.
	     * @private
	     */
	    PdfGraphics.prototype.getBezierArc = function (numX1, numY1, numX2, numY2, s1, e1) {
	        if ((numX1 > numX2)) {
	            var tmp = void 0;
	            tmp = numX1;
	            numX1 = numX2;
	            numX2 = tmp;
	        }
	        if ((numY2 > numY1)) {
	            var tmp = void 0;
	            tmp = numY1;
	            numY1 = numY2;
	            numY2 = tmp;
	        }
	        var fragAngle1;
	        var numFragments;
	        if ((Math.abs(e1) <= 90)) {
	            fragAngle1 = e1;
	            numFragments = 1;
	        }
	        else {
	            numFragments = (Math.ceil((Math.abs(e1) / 90)));
	            fragAngle1 = (e1 / numFragments);
	        }
	        var xcen = ((numX1 + numX2) / 2);
	        var ycen = ((numY1 + numY2) / 2);
	        var rx = ((numX2 - numX1) / 2);
	        var ry = ((numY2 - numY1) / 2);
	        var halfAng = ((fragAngle1 * (Math.PI / 360)));
	        var kappa = (Math.abs(4.0 / 3.0 * (1.0 - Math.cos(halfAng)) / Math.sin(halfAng)));
	        var pointsList = [];
	        for (var i = 0; (i < numFragments); i++) {
	            var thetaValue0 = (((s1 + (i * fragAngle1)) * (Math.PI / 180)));
	            var thetaValue1 = (((s1 + ((i + 1) * fragAngle1)) * (Math.PI / 180)));
	            var cos0 = (Math.cos(thetaValue0));
	            var cos1 = (Math.cos(thetaValue1));
	            var sin0 = (Math.sin(thetaValue0));
	            var sin1 = (Math.sin(thetaValue1));
	            if ((fragAngle1 > 0)) {
	                /* tslint:disable-next-line:max-line-length */
	                pointsList.push((xcen + (rx * cos0)), (ycen - (ry * sin0)), (xcen + (rx * (cos0 - (kappa * sin0)))), (ycen - (ry * (sin0 + (kappa * cos0)))), (xcen + (rx * (cos1 + (kappa * sin1)))), (ycen - (ry * (sin1 - (kappa * cos1)))), (xcen + (rx * cos1)), (ycen - (ry * sin1)));
	            }
	            else {
	                /* tslint:disable-next-line:max-line-length */
	                pointsList.push((xcen + (rx * cos0)), (ycen - (ry * sin0)), (xcen + (rx * (cos0 + (kappa * sin0)))), (ycen - (ry * (sin0 - (kappa * cos0)))), (xcen + (rx * (cos1 - (kappa * sin1)))), (ycen - (ry * (sin1 + (kappa * cos1)))), (xcen + (rx * cos1)), (ycen - (ry * sin1)));
	            }
	        }
	        return pointsList;
	    };
	    // Constants
	    /**
	     * Specifies the mask of `path type values`.
	     * @private
	     */
	    PdfGraphics.pathTypesValuesMask = 0xf;
	    /**
	     * Checks whether the object is `transparencyObject`.
	     * @hidden
	     * @private
	     */
	    PdfGraphics.transparencyObject = false;
	    return PdfGraphics;
	}());
	/**
	 * `GetResourceEventHandler` class is alternate for event handlers and delegates.
	 * @private
	 * @hidden
	 */
	var GetResourceEventHandler = /** @class */ (function () {
	    /**
	     * Initialize instance of `GetResourceEventHandler` class.
	     * Alternate for event handlers and delegates.
	     * @private
	     */
	    function GetResourceEventHandler(sender) {
	        this.sender = sender;
	    }
	    /**
	     * Return the instance of `PdfResources` class.
	     * @private
	     */
	    GetResourceEventHandler.prototype.getResources = function () {
	        return this.sender.getResources();
	    };
	    return GetResourceEventHandler;
	}());
	var PdfGraphicsState = /** @class */ (function () {
	    function PdfGraphicsState(graphics, matrix) {
	        /**
	         * Stores `previous rendering mode`.
	         * @default TextRenderingMode.Fill
	         * @private
	         */
	        this.internalTextRenderingMode = TextRenderingMode.Fill;
	        /**
	         * `Previous character spacing` value or 0.
	         * @default 0.0
	         * @private
	         */
	        this.internalCharacterSpacing = 0.0;
	        /**
	         * `Previous word spacing` value or 0.
	         * @default 0.0
	         * @private
	         */
	        this.internalWordSpacing = 0.0;
	        /**
	         * The previously used `text scaling value`.
	         * @default 100.0
	         * @private
	         */
	        this.internalTextScaling = 100.0;
	        /**
	         * `Current color space`.
	         * @default PdfColorSpace.Rgb
	         * @private
	         */
	        this.pdfColorSpace = PdfColorSpace.Rgb;
	        if (typeof graphics !== 'undefined') {
	            this.pdfGraphics = graphics;
	            this.transformationMatrix = matrix;
	        }
	    }
	    Object.defineProperty(PdfGraphicsState.prototype, "graphics", {
	        // Properties
	        /**
	         * Gets the parent `graphics object`.
	         * @private
	         */
	        get: function () {
	            return this.pdfGraphics;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphicsState.prototype, "matrix", {
	        /**
	         * Gets the `current matrix`.
	         * @private
	         */
	        get: function () {
	            return this.transformationMatrix;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphicsState.prototype, "characterSpacing", {
	        /**
	         * Gets or sets the `current character spacing`.
	         * @private
	         */
	        get: function () {
	            return this.internalCharacterSpacing;
	        },
	        set: function (value) {
	            this.internalCharacterSpacing = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphicsState.prototype, "wordSpacing", {
	        /**
	         * Gets or sets the `word spacing` value.
	         * @private
	         */
	        get: function () {
	            return this.internalWordSpacing;
	        },
	        set: function (value) {
	            this.internalWordSpacing = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphicsState.prototype, "textScaling", {
	        /**
	         * Gets or sets the `text scaling` value.
	         * @private
	         */
	        get: function () {
	            return this.internalTextScaling;
	        },
	        set: function (value) {
	            this.internalTextScaling = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphicsState.prototype, "pen", {
	        /**
	         * Gets or sets the `current pen` object.
	         * @private
	         */
	        get: function () {
	            return this.pdfPen;
	        },
	        set: function (value) {
	            this.pdfPen = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphicsState.prototype, "brush", {
	        /**
	         * Gets or sets the `brush`.
	         * @private
	         */
	        get: function () {
	            return this.pdfBrush;
	        },
	        set: function (value) {
	            this.pdfBrush = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphicsState.prototype, "font", {
	        /**
	         * Gets or sets the `current font` object.
	         * @private
	         */
	        get: function () {
	            return this.pdfFont;
	        },
	        set: function (value) {
	            this.pdfFont = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphicsState.prototype, "colorSpace", {
	        /**
	         * Gets or sets the `current color space` value.
	         * @private
	         */
	        get: function () {
	            return this.pdfColorSpace;
	        },
	        set: function (value) {
	            this.pdfColorSpace = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfGraphicsState.prototype, "textRenderingMode", {
	        /**
	         * Gets or sets the `text rendering mode`.
	         * @private
	         */
	        get: function () {
	            return this.internalTextRenderingMode;
	        },
	        set: function (value) {
	            this.internalTextRenderingMode = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PdfGraphicsState;
	}());
	var TransparencyData = /** @class */ (function () {
	    // Constructors
	    /**
	     * Initializes a new instance of the `TransparencyData` class.
	     * @private
	     */
	    function TransparencyData(alphaPen, alphaBrush, blendMode) {
	        this.alphaPen = alphaPen;
	        this.alphaBrush = alphaBrush;
	        this.blendMode = blendMode;
	    }
	    return TransparencyData;
	}());

	/**
	 * The `PdfPageLayer` used to create layers in PDF document.
	 * @private
	 */
	var PdfPageLayer = /** @class */ (function () {
	    function PdfPageLayer(page, streamClipPageTemplates) {
	        // private bSaved : boolean;
	        /**
	         * Local Variable to store the `color space` of the document.
	         * @private
	         */
	        this.pdfColorSpace = PdfColorSpace.Rgb;
	        /**
	         * Local Variable to set `visibility`.
	         * @default true
	         * @private
	         */
	        this.isVisible = true;
	        /**
	         * Indicates if `Sublayer` is present.
	         * @default false
	         * @private
	         */
	        this.sublayer = false;
	        /**
	         * Local variable to store `length` of the graphics.
	         * @default 0
	         * @private
	         */
	        this.contentLength = 0;
	        /**
	         * Instance for `PdfDictionaryProperties` Class.
	         * @private
	         */
	        this.dictionaryProperties = new DictionaryProperties();
	        if (page === null) {
	            throw new Error('ArgumentNullException:page');
	        }
	        this.pdfPage = page;
	        this.clipPageTemplates = true;
	        if (typeof streamClipPageTemplates === 'undefined') {
	            this.content = new PdfStream();
	        }
	        else if (streamClipPageTemplates instanceof PdfStream || streamClipPageTemplates === null) {
	            if (streamClipPageTemplates === null) {
	                throw new Error('ArgumentNullException:stream');
	            }
	            this.content = streamClipPageTemplates;
	        }
	        else {
	            this.content = new PdfStream();
	            this.clipPageTemplates = streamClipPageTemplates;
	        }
	    }
	    Object.defineProperty(PdfPageLayer.prototype, "colorSpace", {
	        // Properties
	        /**
	         * Get or set the `color space`.
	         * @private
	         */
	        get: function () {
	            return this.pdfColorSpace;
	        },
	        set: function (value) {
	            this.pdfColorSpace = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageLayer.prototype, "page", {
	        /**
	         * Gets parent `page` of the layer.
	         * @private
	         */
	        get: function () {
	            return this.pdfPage;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageLayer.prototype, "layerId", {
	        /**
	         * Gets and Sets the `id of the layer`.
	         * @private
	         */
	        get: function () {
	            return this.layerid;
	        },
	        set: function (value) {
	            this.layerid = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageLayer.prototype, "name", {
	        /**
	         * Gets or sets the `name` of the layer.
	         * @private
	         */
	        get: function () {
	            return this.layerName;
	        },
	        set: function (value) {
	            this.layerName = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageLayer.prototype, "visible", {
	        /**
	         * Gets or sets the `visibility` of the layer.
	         * @private
	         */
	        get: function () {
	            return this.isVisible;
	        },
	        set: function (value) {
	            this.isVisible = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageLayer.prototype, "graphics", {
	        /**
	         * Gets `Graphics` context of the layer, used to draw various graphical content on layer.
	         * @private
	         */
	        get: function () {
	            if ((this.pdfGraphics == null)) {
	                this.initializeGraphics(this.page);
	            }
	            return this.pdfGraphics;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageLayer.prototype, "layers", {
	        /**
	         * Gets the collection of `PdfPageLayer`, this collection handle by the class 'PdfPageLayerCollection'.
	         * @private
	         */
	        get: function () {
	            if (this.layer == null) {
	                this.layer = new PdfPageLayerCollection(this.page);
	                this.layer.sublayer = true;
	                return this.layer;
	            }
	            else {
	                return this.layer;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    // Implementation
	    /**
	     * `Adds` a new PDF Page layer.
	     * @private
	     */
	    PdfPageLayer.prototype.add = function () {
	        var layer = new PdfPageLayer(this.pdfPage);
	        layer.name = '';
	        return layer;
	    };
	    /**
	     * Returns a value indicating the `sign` of a single-precision floating-point number.
	     * @private
	     */
	    PdfPageLayer.prototype.sign = function (number) {
	        if (number === 0) {
	            return 0;
	        }
	        else if (number > 0) {
	            return 1;
	        }
	        else {
	            return -1;
	        }
	    };
	    /**
	     * `Initializes Graphics context` of the layer.
	     * @private
	     */
	    PdfPageLayer.prototype.initializeGraphics = function (page) {
	        var oPage = page;
	        var gr = new GetResourceEventHandler(this.page);
	        this.pdfGraphics = new PdfGraphics(page.size, gr, this.content);
	        this.pdfGraphics.mediaBoxUpperRightBound = 0;
	        if (oPage != null) {
	            var sc = oPage.section.parent;
	            if (sc != null) {
	                this.pdfGraphics.colorSpace = sc.document.colorSpace;
	                this.colorSpace = sc.document.colorSpace;
	            }
	        }
	        // Transform coordinates to the left/top and activate margins.
	        var isSame = (this.sign(page.origin.y) === this.sign(page.origin.x));
	        // if (page != null) {
	        if (page.origin.x >= 0 && page.origin.y >= 0 || !(isSame)) {
	            this.pdfGraphics.initializeCoordinates();
	        }
	        var clipRect = oPage.section.getActualBounds(oPage, true);
	        var margins = oPage.section.pageSettings.margins;
	        if (this.clipPageTemplates) {
	            if (page.origin.x >= 0 && page.origin.y >= 0) {
	                this.pdfGraphics.clipTranslateMargins(clipRect);
	            }
	        }
	        else {
	            this.graphics.clipTranslateMargins(clipRect.x, clipRect.y, margins.left, margins.top, margins.right, margins.bottom);
	        }
	        this.pdfGraphics.setLayer(this);
	        // this.bSaved = false;
	    };
	    Object.defineProperty(PdfPageLayer.prototype, "element", {
	        // IPdfWrapper Members
	        /**
	         * Gets the wrapped `element`.
	         * @private
	         */
	        get: function () {
	            return this.content;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PdfPageLayer;
	}());

	/**
	 * PdfCollection.ts class for EJ2-PDF
	 * The class used to handle the collection of PdF objects.
	 */
	var PdfCollection = /** @class */ (function () {
	    // Constructors
	    /**
	     * Initializes a new instance of the `Collection` class.
	     * @private
	     */
	    function PdfCollection() {
	        //
	    }
	    Object.defineProperty(PdfCollection.prototype, "count", {
	        // Properties
	        /**
	         * Gets the `Count` of stored objects.
	         * @private
	         */
	        get: function () {
	            if (typeof this.collection === 'undefined') {
	                this.collection = [];
	            }
	            return this.collection.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfCollection.prototype, "list", {
	        /**
	         * Gets the `list` of stored objects.
	         * @private
	         */
	        get: function () {
	            if (typeof this.collection === 'undefined') {
	                this.collection = [];
	            }
	            return this.collection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PdfCollection;
	}());

	var __extends$i = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The class provides methods and properties to handle the collections of `PdfPageLayer`.
	 */
	var PdfPageLayerCollection = /** @class */ (function (_super) {
	    __extends$i(PdfPageLayerCollection, _super);
	    function PdfPageLayerCollection(page) {
	        var _this = _super.call(this) || this;
	        /**
	         * Stores the `number of first level layers` in the document.
	         * @default 0
	         * @private
	         */
	        _this.parentLayerCount = 0;
	        /**
	         * Indicates if `Sublayer` is present.
	         * @default false
	         * @private
	         */
	        _this.sublayer = false;
	        /**
	         * Stores the `optional content dictionary`.
	         * @private
	         */
	        _this.optionalContent = new PdfDictionary();
	        if (page instanceof PdfPageBase) {
	            // if (page == null) {
	            //     throw new Error('ArgumentNullException:page');
	            // }
	            _this.page = page;
	            var lPage = page;
	            // if (lPage != null) {
	            _this.parseLayers(lPage);
	            // }
	        }
	        return _this;
	    }
	    PdfPageLayerCollection.prototype.items = function (index, value) {
	        if (typeof index === 'number' && typeof value === 'undefined') {
	            var obj = this.list[index];
	            return obj;
	        }
	        else {
	            if (value == null) {
	                throw new Error('ArgumentNullException: layer');
	            }
	            if (value.page !== this.page) {
	                throw new Error('ArgumentException: The layer belongs to another page');
	            }
	            // // Add/remove the layer.
	            // let layer : PdfPageLayer = this.items(index);
	            // if (layer != null) {
	            //     this.RemoveLayer(layer);
	            // }
	            // this.List[index] = value;
	            // this.InsertLayer(index, value);
	        }
	    };
	    PdfPageLayerCollection.prototype.add = function (firstArgument, secondArgument) {
	        if (typeof firstArgument === 'undefined') {
	            var layer = new PdfPageLayer(this.page);
	            layer.name = '';
	            this.add(layer);
	            return layer;
	        }
	        else if (firstArgument instanceof PdfPageLayer) {
	            // if (layer == null)
	            //     throw new ArgumentNullException("layer");
	            // if (layer.Page != m_page)
	            //     throw new ArgumentException("The layer belongs to another page");
	            var index = this.list.push(firstArgument);
	            // Register layer.
	            this.addLayer(index, firstArgument);
	            return index;
	        }
	        else {
	            return 0;
	        }
	    };
	    /**
	     * Registers `layer` at the page.
	     * @private
	     */
	    PdfPageLayerCollection.prototype.addLayer = function (index, layer) {
	        var reference = new PdfReferenceHolder(layer);
	        this.page.contents.add(reference);
	    };
	    // private RemoveLayer(layer : PdfPageLayer) : void {
	    //     if (layer == null) {
	    //         throw new Error('ArgumentNullException:layer');
	    //     }
	    //     let reference : PdfReferenceHolder = new PdfReferenceHolder(layer);
	    //     if (this.page != null) {
	    //         this.page.Contents.Remove(reference);
	    //     }
	    // }
	    /**
	     * Inserts `PdfPageLayer` into the collection at specified index.
	     * @private
	     */
	    PdfPageLayerCollection.prototype.insert = function (index, layer) {
	        // if (index < 0)
	        //     throw new ArgumentOutOfRangeException("index", "Value can not be less 0");
	        // if (layer == null)
	        //     throw new ArgumentNullException("layer");
	        // if (layer.Page != m_page)
	        //     throw new ArgumentException("The layer belongs to another page");
	        var list = [];
	        var length = this.list.length;
	        for (var i = index; i < length; i++) {
	            list.push(this.list.pop());
	        }
	        this.list.push(layer);
	        for (var i = 0; i < list.length; i++) {
	            this.list.push(list[i]);
	        }
	        // Register layer.
	        this.insertLayer(index, layer);
	    };
	    /**
	     * Registers layer at the page.
	     * @private
	     */
	    PdfPageLayerCollection.prototype.insertLayer = function (index, layer) {
	        if (layer == null) {
	            throw new Error('ArgumentNullException:layer');
	        }
	        var reference = new PdfReferenceHolder(layer);
	        this.page.contents.insert(index, reference);
	    };
	    // tslint:disable
	    /**
	     * `Parses the layers`.
	     * @private
	     */
	    PdfPageLayerCollection.prototype.parseLayers = function (loadedPage) {
	        // if (loadedPage == null) {
	        //     throw new Error('ArgumentNullException:loadedPage');
	        // }
	        var contents = this.page.contents;
	        this.page.getResources();
	        // if (loadedPage instanceof PdfPage) {
	        loadedPage.crossTable;
	        // } else {
	        //     crossTable = (loadedPage as PdfLoadedPage).CrossTable;
	        //     Propertie = PdfCrossTable.Dereference(Resource[DictionaryProperties.Properties]) as PdfDictionary;
	        //     ocproperties = PdfCrossTable.Dereference((loadedPage as PdfLoadedPage).
	        //     Document.Catalog[DictionaryProperties.OCProperties]) as PdfDictionary;
	        // }
	        var saveStream = new PdfStream();
	        var restoreStream = new PdfStream();
	        var saveState = 'q';
	        var restoreState = 'Q';
	        // for (let index : number = 0; index < contents.Items.length; index++) {
	        //     let obj : IPdfPrimitive = contents[index];
	        //     let stream : PdfStream = crossTable.GetObject(obj) as PdfStream;
	        //     if (stream == null)
	        //         throw new PdfDocumentException("Invalid contents array.");
	        //     // if (stream.Compress)
	        //     {
	        //         if (!loadedPage.Imported)
	        //             stream.Decompress();
	        //     }
	        //     byte[] contentId = stream.Data;
	        //     string str = PdfString.ByteToString(contentId);
	        //     if (!loadedPage.Imported && (contents.Count == 1) && ((stream.Data[stream.Data.Length - 2] ==
	        //     RestoreState) || (stream.Data[stream.Data.Length - 1] == RestoreState)))
	        //     {
	        //         byte[] content = stream.Data;
	        //         byte[] data = new byte[content.Length + 4];
	        //         data[0] = SaveState;
	        //         data[1] = NewLine;
	        //         content.CopyTo(data, 2);
	        //         data[data.Length - 2] = NewLine;
	        //         data[data.Length - 1] = RestoreState;
	        //         stream.Data = data;
	        //     }
	        //     if (ocproperties != null)
	        //     {
	        //         if (Propertie != null)
	        //         {
	        //             foreach (KeyValuePair<PdfName, IPdfPrimitive> prop in Propertie.Items)
	        //             {
	        //                 String Key = prop.Key.ToString();
	        //                 PdfReferenceHolder refh = prop.Value as PdfReferenceHolder;
	        //                 PdfDictionary Dict = null;
	        //                 if (refh != null)
	        //                 {
	        //                     Dict = refh.Object as PdfDictionary;
	        //                 }
	        //                 else
	        //                 {
	        //                     Dict = prop.Value as PdfDictionary;
	        //                 }
	        //                 PdfDictionary m_usage = PdfCrossTable.Dereference(Dict[DictionaryProperties.Usage]) as PdfDictionary;
	        //                 if (m_usage != null)
	        //                 {
	        //                     if (str.Contains(Key))
	        //                     {
	        //                         PdfPageLayer layer = new PdfPageLayer(loadedPage, stream);
	        //                         PdfDictionary printoption = PdfCrossTable.Dereference(m_usage[DictionaryProperties.Print])
	        //                         as PdfDictionary;
	        //                         if (printoption != null)
	        //                         {
	        //                             layer.m_printOption = printoption;
	        //                             foreach (KeyValuePair<PdfName, IPdfPrimitive> value in printoption.Items)
	        //                             {
	        //                                 if (value.Key.Value.Equals(DictionaryProperties.PrintState))
	        //                                 {
	        //                                     string printState = (value.Value as PdfName).Value;
	        //                                     if (printState.Equals(DictionaryProperties.OCGON))
	        //                                     {
	        //                                         layer.PrintState = PdfPrintState.AlwaysPrint;
	        //                                         break;
	        //                                     }
	        //                                     else
	        //                                     {
	        //                                         layer.PrintState = PdfPrintState.NeverPrint;
	        //                                         break;
	        //                                     }
	        //                                 }
	        //                             }
	        //                         }
	        //                         PdfString layerName = PdfCrossTable.Dereference(Dict[DictionaryProperties.Name]) as PdfString;
	        //                         layer.Name = layerName.Value;
	        //                         List.add(layer);
	        //                         isLayerAdded = true;
	        //                         if(!str.Contains("EMC"))
	        //                         break;
	        //                     }
	        //                 }
	        //                 else
	        //                 {
	        //                     if (str.Contains(Key))
	        //                     {
	        //                         PdfPageLayer layer = new PdfPageLayer(loadedPage, stream);
	        //                         List.add(layer);
	        //                         if(Dict.ContainsKey(DictionaryProperties.Name))
	        //                         {
	        //                         PdfString layerName = PdfCrossTable.Dereference(Dict[DictionaryProperties.Name]) as PdfString;
	        //                         layer.Name = layerName.Value;
	        //                         }
	        //                         isLayerAdded = true;
	        //                         break;
	        //                     }
	        //                 }
	        //             }
	        //         }
	        //     }
	        //     if (!isLayerAdded)
	        //     {
	        //         PdfPageLayer layer = new PdfPageLayer(loadedPage, stream);
	        //         List.add(layer);
	        //     }
	        //     else
	        //         isLayerAdded = false;
	        // }
	        var saveData = [];
	        saveData.push(saveState);
	        saveStream.data = saveData;
	        contents.insert(0, new PdfReferenceHolder(saveStream));
	        saveData = [];
	        saveData.push(restoreState);
	        restoreStream.data = saveData;
	        contents.insert(contents.count, new PdfReferenceHolder(restoreStream));
	    };
	    /**
	     * Returns `index of` the `PdfPageLayer` in the collection if exists, -1 otherwise.
	     * @private
	     */
	    PdfPageLayerCollection.prototype.indexOf = function (layer) {
	        if (layer == null) {
	            throw new Error('ArgumentNullException: layer');
	        }
	        var index = this.list.indexOf(layer);
	        return index;
	    };
	    return PdfPageLayerCollection;
	}(PdfCollection));

	/**
	 * The abstract base class for all pages,
	 * `PdfPageBase` class provides methods and properties to create PDF pages and its elements.
	 * @private
	 */
	var PdfPageBase = /** @class */ (function () {
	    //constructors
	    /**
	     * Initializes a new instance of the `PdfPageBase` class.
	     * @private
	     */
	    function PdfPageBase(dictionary) {
	        /**
	         * `Index` of the default layer.
	         * @default -1.
	         * @private
	         */
	        this.defLayerIndex = -1;
	        /**
	         * Local variable to store if page `updated`.
	         * @default false.
	         * @private
	         */
	        this.modified = false;
	        /**
	         * Instance of `DictionaryProperties` class.
	         * @hidden
	         * @private
	         */
	        this.dictionaryProperties = new DictionaryProperties();
	        this.pageDictionary = dictionary;
	    }
	    Object.defineProperty(PdfPageBase.prototype, "section", {
	        //Properties
	        /**
	         * Gets the `section` of a page.
	         * @private
	         */
	        get: function () {
	            // if (this.pdfSection === null) {
	            //     throw new Error('PdfException : Page must be added to some section before using.');
	            // }
	            return this.pdfSection;
	        },
	        set: function (value) {
	            this.pdfSection = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageBase.prototype, "dictionary", {
	        /**
	         * Gets the page `dictionary`.
	         * @private
	         */
	        get: function () {
	            return this.pageDictionary;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageBase.prototype, "element", {
	        /**
	         * Gets the wrapped `element`.
	         * @private
	         */
	        get: function () {
	            return this.pageDictionary;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageBase.prototype, "defaultLayer", {
	        /**
	         * Gets the `default layer` of the page (Read only).
	         * @private
	         */
	        get: function () {
	            var layer = this.layers;
	            var index = this.defaultLayerIndex;
	            var returnlayer = layer.items(index);
	            return returnlayer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageBase.prototype, "defaultLayerIndex", {
	        /**
	         * Gets or sets `index of the default layer`.
	         * @private
	         */
	        get: function () {
	            if (this.layerCollection.count === 0 || this.defLayerIndex === -1) {
	                var layer = this.layerCollection.add();
	                this.defLayerIndex = this.layerCollection.indexOf(layer);
	            }
	            return this.defLayerIndex;
	        },
	        /**
	         * Gets or sets` index of the default layer`.
	         * @private
	         */
	        set: function (value) {
	            if (value < 0 || value > this.layers.count - 1) {
	                throw new Error('ArgumentOutOfRangeException : value, Index can not be less 0 and greater Layers.Count - 1');
	            }
	            else {
	                this.defLayerIndex = value;
	                this.modified = true;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageBase.prototype, "layers", {
	        /**
	         * Gets the collection of the page's `layers` (Read only).
	         * @private
	         */
	        get: function () {
	            if (this.layerCollection == null || typeof this.layerCollection === 'undefined') {
	                this.layerCollection = new PdfPageLayerCollection(this);
	            }
	            return this.layerCollection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Return an instance of `PdfResources` class.
	     * @private
	     */
	    PdfPageBase.prototype.getResources = function () {
	        if (this.resources == null) {
	            this.resources = new PdfResources();
	            this.dictionary.items.setValue(this.dictionaryProperties.resources, this.resources);
	        }
	        return this.resources;
	    };
	    Object.defineProperty(PdfPageBase.prototype, "contents", {
	        /**
	         * Gets `array of page's content`.
	         * @private
	         */
	        get: function () {
	            var obj = this.pageDictionary.items.getValue(this.dictionaryProperties.contents);
	            var contents = obj;
	            if (contents == null) {
	                contents = new PdfArray();
	                this.pageDictionary.items.setValue(this.dictionaryProperties.contents, contents);
	            }
	            return contents;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Sets the `resources`.
	     * @private
	     */
	    PdfPageBase.prototype.setResources = function (res) {
	        this.resources = res;
	        this.dictionary.items.setValue(this.dictionaryProperties.resources, this.resources);
	        this.modified = true;
	    };
	    return PdfPageBase;
	}());

	/**
	 * `PdfAnnotationCollection` class represents the collection of 'PdfAnnotation' objects.
	 * @private
	 */
	var PdfAnnotationCollection = /** @class */ (function () {
	    function PdfAnnotationCollection(page) {
	        // Constants
	        /**
	         * `Error` constant message.
	         * @private
	         */
	        this.alreadyExistsAnnotationError = 'This annotatation had been already added to page';
	        /**
	         * `Error` constant message.
	         * @private
	         */
	        this.missingAnnotationException = 'Annotation is not contained in collection.';
	        /**
	         * Specifies the Internal variable to store fields of `PdfDictionaryProperties`.
	         * @private
	         */
	        this.dictionaryProperties = new DictionaryProperties();
	        /**
	         * Array of the `annotations`.
	         * @private
	         */
	        this.internalAnnotations = new PdfArray();
	        /**
	         * privte `list` for the annotations.
	         * @private
	         */
	        this.lists = [];
	        if (typeof page !== 'undefined') {
	            this.page = page;
	        }
	    }
	    Object.defineProperty(PdfAnnotationCollection.prototype, "annotations", {
	        /**
	         * Gets the `PdfAnnotation` object at the specified index. Read-Only.
	         * @private
	         */
	        get: function () {
	            return this.internalAnnotations;
	        },
	        set: function (value) {
	            this.internalAnnotations = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    // Public methods
	    /**
	     * `Adds` a new annotation to the collection.
	     * @private
	     */
	    PdfAnnotationCollection.prototype.add = function (annotation) {
	        // this.SetPrint(annotation);
	        this.doAdd(annotation);
	    };
	    /**
	     * `Adds` a Annotation to collection.
	     * @private
	     */
	    /* tslint:disable */
	    PdfAnnotationCollection.prototype.doAdd = function (annotation) {
	        if (typeof annotation.destination !== 'undefined') {
	            var layout = new PdfStringLayouter();
	            var layoutResult = layout.layout(annotation.text, annotation.font, annotation.stringFormat, new SizeF((annotation.bounds.width), 0), false, new SizeF(0, 0));
	            var lastPosition = annotation.bounds.y;
	            if (layoutResult.lines.length === 1) {
	                var size = annotation.font.measureString(layoutResult.lines[0].text);
	                annotation.bounds = new RectangleF(new PointF(annotation.bounds.x, lastPosition), size);
	                annotation.text = layoutResult.lines[0].text;
	                //Draw Annotation Text.
	                this.page.graphics.drawString(annotation.text, annotation.font, null, annotation.brush, annotation.bounds.x, annotation.bounds.y, annotation.bounds.width, annotation.bounds.height, null);
	                //Add annotation to dictionary.
	                annotation.setPage(this.page);
	                this.setColor(annotation);
	                this.internalAnnotations.add(new PdfReferenceHolder(annotation));
	                this.lists.push(annotation);
	            }
	            else {
	                for (var i = 0; i < layoutResult.lines.length; i++) {
	                    var size = annotation.font.measureString(layoutResult.lines[i].text);
	                    if (i === 0) {
	                        annotation.bounds = new RectangleF(annotation.bounds.x, lastPosition, size.width, size.height);
	                        annotation.text = layoutResult.lines[i].text;
	                        //Draw Annotation Text.
	                        this.page.graphics.drawString(annotation.text, annotation.font, null, annotation.brush, annotation.bounds.x, lastPosition, size.width, size.height, null);
	                        //Add annotation to dictionary.
	                        annotation.setPage(this.page);
	                        this.setColor(annotation);
	                        this.internalAnnotations.add(new PdfReferenceHolder(annotation));
	                        this.lists.push(annotation);
	                        //Update y for drawing next line of the text.
	                        lastPosition += annotation.bounds.height;
	                    }
	                    else {
	                        var annot = annotation.clone();
	                        annot.bounds = new RectangleF(new PointF(annotation.bounds.x, lastPosition), size);
	                        annot.text = layoutResult.lines[i].text;
	                        //Draw Annotation Text.
	                        this.page.graphics.drawString(annot.text, annot.font, null, annot.brush, annot.bounds.x, annot.bounds.y, annot.bounds.width, annot.bounds.height, null);
	                        //Add annotation to dictionary.
	                        annot.setPage(this.page);
	                        this.setColor(annot);
	                        this.internalAnnotations.add(new PdfReferenceHolder(annot));
	                        this.lists.push(annot);
	                        //Update y for drawing next line of the text.
	                        lastPosition += annot.bounds.height;
	                    }
	                }
	            }
	        }
	        else {
	            annotation.setPage(this.page);
	            this.internalAnnotations.add(new PdfReferenceHolder(annotation));
	            return this.lists.push(annotation);
	        }
	    };
	    /* tslint:enable */
	    /**
	     * `Set a color of an annotation`.
	     * @private
	     */
	    PdfAnnotationCollection.prototype.setColor = function (annotation) {
	        var cs = PdfColorSpace.Rgb;
	        var colours = annotation.color.toArray(cs);
	        annotation.dictionary.items.setValue(this.dictionaryProperties.c, colours);
	    };
	    Object.defineProperty(PdfAnnotationCollection.prototype, "element", {
	        // IPdfWrapper Members
	        /**
	         * Gets the `Element` representing this object.
	         * @private
	         */
	        get: function () {
	            return this.internalAnnotations;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PdfAnnotationCollection;
	}());

	var __extends$h = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Provides methods and properties to create pages and its elements.
	 * `PdfPage` class inherited from the `PdfPageBase` class.
	 * ```typescript
	 * // create a new PDF document
	 * let document : PdfDocument = new PdfDocument();
	 * //
	 * // add a new page to the document
	 * let page1 : PdfPage = document.pages.add();
	 * //
	 * // set the font
	 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	 * // create black brush
	 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	 * // draw the text
	 * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
	 * // save the document
	 * document.save('output.pdf');
	 * // destroy the document
	 * document.destroy();
	 * ```
	 */
	var PdfPage = /** @class */ (function (_super) {
	    __extends$h(PdfPage, _super);
	    //constructors
	    /**
	     * Initialize the new instance for `PdfPage` class.
	     * @private
	     */
	    function PdfPage() {
	        var _this = _super.call(this, new PdfDictionary()) || this;
	        /**
	         * Stores the instance of `PdfAnnotationCollection` class.
	         * @hidden
	         * @default null
	         * @private
	         */
	        _this.annotationCollection = null;
	        /**
	         * Stores the instance of `PageBeginSave` event for Page Number Field.
	         * @default null
	         * @private
	         */
	        _this.beginSave = null;
	        _this.initialize();
	        return _this;
	    }
	    Object.defineProperty(PdfPage.prototype, "document", {
	        //Properties
	        /**
	         * Gets current `document`.
	         * @private
	         */
	        get: function () {
	            if (this.section !== null && this.section.parent !== null) {
	                return this.section.parent.document;
	            }
	            else {
	                return null;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPage.prototype, "graphics", {
	        /**
	         * Get the current `graphics`.
	         * ```typescript
	         * // create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * // add a new page to the document
	         * let page1 : PdfPage = document.pages.add();
	         * //
	         * // get graphics
	         * let graphics : PdfGraphics = page1.graphics;
	         * //
	         * // set the font
	         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	         * // create black brush
	         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	         * // draw the text
	         * graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
	         * // save the document
	         * document.save('output.pdf');
	         * // destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            var result = this.defaultLayer.graphics;
	            result.currentPage = this;
	            return result;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPage.prototype, "crossTable", {
	        /**
	         * Gets the `cross table`.
	         * @private
	         */
	        get: function () {
	            if (this.section === null) {
	                throw new Error('PdfDocumentException : Page is not created');
	            }
	            return this.section.parent === null ? this.section.parentDocument.crossTable : this.section.parent.document.crossTable;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPage.prototype, "size", {
	        /**
	         * Gets the size of the PDF page- Read only.
	         * @public
	         */
	        get: function () {
	            return this.section.pageSettings.size;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPage.prototype, "origin", {
	        /**
	         * Gets the `origin` of the page.
	         * @private
	         */
	        get: function () {
	            return this.section.pageSettings.origin;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPage.prototype, "annotations", {
	        /**
	         * Gets a collection of the `annotations` of the page- Read only.
	         * @private
	         */
	        get: function () {
	            if (this.annotationCollection == null) {
	                this.annotationCollection = new PdfAnnotationCollection(this);
	                // if (!this.Dictionary.ContainsKey(this.dictionaryProperties.annots)) {
	                this.dictionary.items.setValue(this.dictionaryProperties.annots, this.annotationCollection.element);
	                // }
	                this.annotationCollection.annotations = this.dictionary.items.getValue(this.dictionaryProperties.annots);
	            }
	            return this.annotationCollection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //Implementation
	    /**
	     * `Initializes` a page.
	     * @private
	     */
	    PdfPage.prototype.initialize = function () {
	        this.dictionary.items.setValue(this.dictionaryProperties.type, new PdfName('Page'));
	        this.dictionary.pageBeginDrawTemplate = new SaveTemplateEventHandler(this);
	    };
	    /**
	     * Sets parent `section` to the page.
	     * @private
	     */
	    PdfPage.prototype.setSection = function (section) {
	        this.section = section;
	        this.dictionary.items.setValue(this.dictionaryProperties.parent, new PdfReferenceHolder(section));
	    };
	    /**
	     * `Resets the progress`.
	     * @private
	     */
	    PdfPage.prototype.resetProgress = function () {
	        this.isProgressOn = false;
	    };
	    /**
	     * Get the page size reduced by page margins and page template dimensions.
	     * ```typescript
	     * // create a new PDF document
	     * let document : PdfDocument = new PdfDocument();
	     * // add a pages to the document
	     * let page1 : PdfPage = document.pages.add();
	     * // create new standard font
	     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	     * // set brush
	     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	     * //
	     * // set the specified point using `getClientSize` method
	     * let point : PointF = new PointF(page1.getClientSize().width - 200, page1.getClientSize().height - 200);
	     * // draw the text
	     * page1.graphics.drawString('Hello World', font, blackBrush, point);
	     * //
	     * // save the document
	     * document.save('output.pdf');
	     * // destroy the document
	     * document.destroy();
	     * ```
	     */
	    PdfPage.prototype.getClientSize = function () {
	        var returnValue = this.section.getActualBounds(this, true);
	        return new SizeF(returnValue.width, returnValue.height);
	    };
	    /**
	     * Helper method to retrive the instance of `PageBeginSave` event for header and footer elements.
	     * @private
	     */
	    PdfPage.prototype.pageBeginSave = function () {
	        var doc = this.document;
	        if (typeof doc !== undefined && doc != null) {
	            this.drawPageTemplates(doc);
	        }
	        if (this.beginSave != null && typeof this.beginSave !== 'undefined') {
	            this.beginSave(this);
	        }
	    };
	    /**
	     * Helper method to draw template elements.
	     * @private
	     */
	    PdfPage.prototype.drawPageTemplates = function (document) {
	        // Draw Background templates.
	        var hasBackTemplates = this.section.containsTemplates(document, this, false);
	        if (hasBackTemplates) {
	            var backLayer = new PdfPageLayer(this, false);
	            this.layers.insert(0, backLayer);
	            this.section.drawTemplates(this, backLayer, document, false);
	            if (backLayer.graphics !== null && typeof backLayer.graphics !== 'undefined') {
	                for (var i = 0; i < backLayer.graphics.automaticFields.automaticFields.length; i++) {
	                    var fieldInfo = backLayer.graphics.automaticFields.automaticFields[i];
	                    fieldInfo.field.performDraw(backLayer.graphics, fieldInfo.location, fieldInfo.scalingX, fieldInfo.scalingY);
	                }
	            }
	        }
	        // Draw Foreground templates.
	        var hasFrontTemplates = this.section.containsTemplates(document, this, true);
	        if (hasFrontTemplates) {
	            var frontLayer = new PdfPageLayer(this, false);
	            this.layers.add(frontLayer);
	            this.section.drawTemplates(this, frontLayer, document, true);
	        }
	    };
	    return PdfPage;
	}(PdfPageBase));

	/**
	 * Provides data for `PageAddedEventHandler` event.
	 * This event raises when adding the new PDF page to the PDF document.
	 */
	var PageAddedEventArgs = /** @class */ (function () {
	    function PageAddedEventArgs(page) {
	        if (typeof page !== 'undefined') {
	            this.pdfPage = page;
	        }
	        else {
	            this.pdfPage = null;
	        }
	    }
	    Object.defineProperty(PageAddedEventArgs.prototype, "page", {
	        /**
	         * Gets the `newly added page`.
	         * @private
	         */
	        get: function () {
	            return this.pdfPage;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PageAddedEventArgs;
	}());

	/**
	 * Represents the `collection of pages in a section`.
	 * @private
	 */
	var PdfSectionPageCollection = /** @class */ (function () {
	    // Constructors
	    /**
	     * Initializes a new instance of the `PdfSectionPageCollection` class.
	     * @private
	     */
	    function PdfSectionPageCollection(section) {
	        //  Fields
	        /**
	         * @hidden
	         * @private
	         */
	        this.pdfSection = null;
	        if (section == null) {
	            throw Error('ArgumentNullException("section")');
	        }
	        this.section = section;
	    }
	    Object.defineProperty(PdfSectionPageCollection.prototype, "section", {
	        // Properties
	        /**
	         * Gets the `PdfPage` at the specified index.
	         * @private
	         */
	        get: function () {
	            return this.pdfSection;
	        },
	        set: function (value) {
	            this.pdfSection = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    // Public Methods
	    /**
	     * `Determines` whether the specified page is within the collection.
	     * @private
	     */
	    PdfSectionPageCollection.prototype.contains = function (page) {
	        return this.section.contains(page);
	    };
	    /**
	     * `Removes` the specified page from collection.
	     * @private
	     */
	    PdfSectionPageCollection.prototype.remove = function (page) {
	        this.section.remove(page);
	    };
	    /**
	     * `Adds` a new page from collection.
	     * @private
	     */
	    PdfSectionPageCollection.prototype.add = function () {
	        return this.section.add();
	    };
	    return PdfSectionPageCollection;
	}());

	// import { PdfStampCollection } from `./../Pages/PdfStampCollection`;
	/**
	 * `PdfDocumentTemplate` class encapsulates a page template for all the pages in the document.
	 * @private
	 */
	var PdfDocumentTemplate = /** @class */ (function () {
	    // Constructors
	    /**
	     * Initializes a new instance of the `PdfDocumentTemplate` class.
	     * @public
	     */
	    function PdfDocumentTemplate() {
	        //
	    }
	    Object.defineProperty(PdfDocumentTemplate.prototype, "left", {
	        // private m_stamps : PdfStampCollection;
	        // Properties
	        /**
	         * `Left` page template object.
	         * @public
	         */
	        get: function () {
	            return this.leftTemplate;
	        },
	        set: function (value) {
	            this.leftTemplate = this.checkElement(value, TemplateType.Left);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentTemplate.prototype, "top", {
	        /**
	         * `Top` page template object.
	         * @public
	         */
	        get: function () {
	            return this.topTemplate;
	        },
	        set: function (value) {
	            this.topTemplate = this.checkElement(value, TemplateType.Top);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentTemplate.prototype, "right", {
	        /**
	         * `Right` page template object.
	         * @public
	         */
	        get: function () {
	            return this.rightTemplate;
	        },
	        set: function (value) {
	            this.rightTemplate = this.checkElement(value, TemplateType.Right);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentTemplate.prototype, "bottom", {
	        /**
	         * `Bottom` page template object.
	         * @public
	         */
	        get: function () {
	            return this.bottomTemplate;
	        },
	        set: function (value) {
	            this.bottomTemplate = this.checkElement(value, TemplateType.Bottom);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentTemplate.prototype, "EvenLeft", {
	        /**
	         * `EvenLeft` page template object.
	         * @public
	         */
	        get: function () {
	            return this.evenLeft;
	        },
	        set: function (value) {
	            this.evenLeft = this.checkElement(value, TemplateType.Left);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentTemplate.prototype, "EvenTop", {
	        /**
	         * `EvenTop` page template object.
	         * @public
	         */
	        get: function () {
	            return this.evenTop;
	        },
	        set: function (value) {
	            this.evenTop = this.checkElement(value, TemplateType.Top);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentTemplate.prototype, "EvenRight", {
	        /**
	         * `EvenRight` page template object.
	         * @public
	         */
	        get: function () {
	            return this.evenRight;
	        },
	        set: function (value) {
	            this.evenRight = this.checkElement(value, TemplateType.Right);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentTemplate.prototype, "EvenBottom", {
	        /**
	         * `EvenBottom` page template object.
	         * @public
	         */
	        get: function () {
	            return this.evenBottom;
	        },
	        set: function (value) {
	            this.evenBottom = this.checkElement(value, TemplateType.Bottom);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentTemplate.prototype, "OddLeft", {
	        /**
	         * `OddLeft` page template object.
	         * @public
	         */
	        get: function () {
	            return this.oddLeft;
	        },
	        set: function (value) {
	            this.oddLeft = this.checkElement(value, TemplateType.Left);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentTemplate.prototype, "OddTop", {
	        /**
	         * `OddTop` page template object.
	         * @public
	         */
	        get: function () {
	            return this.oddTop;
	        },
	        set: function (value) {
	            this.oddTop = this.checkElement(value, TemplateType.Top);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentTemplate.prototype, "OddRight", {
	        /**
	         * `OddRight` page template object.
	         * @public
	         */
	        get: function () {
	            return this.oddRight;
	        },
	        set: function (value) {
	            this.oddRight = this.checkElement(value, TemplateType.Right);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentTemplate.prototype, "OddBottom", {
	        /**
	         * `OddBottom` page template object.
	         * @public
	         */
	        get: function () {
	            return this.oddBottom;
	        },
	        set: function (value) {
	            this.oddBottom = this.checkElement(value, TemplateType.Bottom);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    // Implementation
	    /**
	     * Returns `left` template.
	     * @public
	     */
	    PdfDocumentTemplate.prototype.getLeft = function (page) {
	        if (page == null) {
	            throw new Error('ArgumentNullException:page');
	        }
	        var template = null;
	        // if (page.Document.Pages != null) {
	        var even = this.isEven(page);
	        if (even) {
	            template = (this.EvenLeft != null) ? this.EvenLeft : this.left;
	        }
	        else {
	            template = (this.OddLeft != null) ? this.OddLeft : this.left;
	        }
	        // }
	        return template;
	    };
	    /**
	     * Returns `top` template.
	     * @public
	     */
	    PdfDocumentTemplate.prototype.getTop = function (page) {
	        if (page == null) {
	            throw new Error('ArgumentNullException:page');
	        }
	        var template = null;
	        // if (page.Document.Pages != null) {
	        var even = this.isEven(page);
	        if (even) {
	            template = (this.EvenTop != null) ? this.EvenTop : this.top;
	        }
	        else {
	            template = (this.OddTop != null) ? this.OddTop : this.top;
	        }
	        // }
	        return template;
	    };
	    /**
	     * Returns `right` template.
	     * @public
	     */
	    PdfDocumentTemplate.prototype.getRight = function (page) {
	        if (page == null) {
	            throw new Error('ArgumentNullException:page');
	        }
	        var template = null;
	        // if (page.Document.Pages != null) {
	        var even = this.isEven(page);
	        if (even) {
	            template = (this.EvenRight != null) ? this.EvenRight : this.right;
	        }
	        else {
	            template = (this.OddRight != null) ? this.OddRight : this.right;
	        }
	        // }
	        return template;
	    };
	    /**
	     * Returns `bottom` template.
	     * @public
	     */
	    PdfDocumentTemplate.prototype.getBottom = function (page) {
	        if (page == null) {
	            throw new Error('ArgumentNullException:page');
	        }
	        var template = null;
	        // if (page.Document.Pages != null) {
	        var even = this.isEven(page);
	        if (even) {
	            template = (this.EvenBottom != null) ? this.EvenBottom : this.bottom;
	        }
	        else {
	            template = (this.OddBottom != null) ? this.OddBottom : this.bottom;
	        }
	        // }
	        return template;
	    };
	    /**
	     * Checks whether the page `is even`.
	     * @private
	     */
	    PdfDocumentTemplate.prototype.isEven = function (page) {
	        var pages = page.section.document.pages;
	        var index = 0;
	        if (pages.pageCollectionIndex.containsKey(page)) {
	            index = pages.pageCollectionIndex.getValue(page) + 1;
	        }
	        else {
	            index = pages.indexOf(page) + 1;
	        }
	        var even = ((index % 2) === 0);
	        return even;
	    };
	    /**
	     * Checks a `template element`.
	     * @private
	     */
	    PdfDocumentTemplate.prototype.checkElement = function (templateElement, type) {
	        if (templateElement != null) {
	            if ((typeof templateElement.type !== 'undefined') && (templateElement.type !== TemplateType.None)) {
	                throw new Error('NotSupportedException:Can not reassign the template element. Please, create new one.');
	            }
	            templateElement.type = type;
	        }
	        return templateElement;
	    };
	    return PdfDocumentTemplate;
	}());

	var __extends$g = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Represents a `page template` for all the pages in the section.
	 */
	var PdfSectionTemplate = /** @class */ (function (_super) {
	    __extends$g(PdfSectionTemplate, _super);
	    // Constructors
	    /**
	     * `Creates a new object`.
	     * @private
	     */
	    function PdfSectionTemplate() {
	        var _this = _super.call(this) || this;
	        _this.leftValue = _this.topValue = _this.rightValue = _this.bottomValue = _this.stampValue = true;
	        return _this;
	    }
	    Object.defineProperty(PdfSectionTemplate.prototype, "applyDocumentLeftTemplate", {
	        // Properties
	        /**
	         * Gets or sets value indicating whether parent `Left page template should be used or not`.
	         * @private
	         */
	        get: function () {
	            return this.leftValue;
	        },
	        set: function (value) {
	            this.leftValue = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfSectionTemplate.prototype, "applyDocumentTopTemplate", {
	        /**
	         * Gets or sets value indicating whether parent `Top page template should be used or not`.
	         * @private
	         */
	        get: function () {
	            return this.topValue;
	        },
	        set: function (value) {
	            this.topValue = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfSectionTemplate.prototype, "applyDocumentRightTemplate", {
	        /**
	         * Gets or sets value indicating whether parent `Right page template should be used or not`.
	         * @private
	         */
	        get: function () {
	            return this.rightValue;
	        },
	        set: function (value) {
	            this.rightValue = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfSectionTemplate.prototype, "applyDocumentBottomTemplate", {
	        /**
	         * Gets or sets value indicating whether parent `Bottom page template should be used or not`.
	         * @private
	         */
	        get: function () {
	            return this.bottomValue;
	        },
	        set: function (value) {
	            this.bottomValue = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfSectionTemplate.prototype, "applyDocumentStamps", {
	        /**
	         * Gets or sets value indicating whether the `stamp value` is true or not.
	         * @private
	         */
	        get: function () {
	            return this.stampValue;
	        },
	        set: function (value) {
	            this.stampValue = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PdfSectionTemplate;
	}(PdfDocumentTemplate));

	/**
	 * Represents a `section` entity. A section it's a set of the pages with similar page settings.
	 */
	var PdfSection = /** @class */ (function () {
	    function PdfSection(document, pageSettings) {
	        //Fields
	        //public PageAdded() : PageAddedEventArgs.PageAddedEventHandler = new PageAddedEventArgs.PageAddedEventHandler(Object,args)
	        /**
	         * @hidden
	         * @private
	         */
	        this.pageAdded = new PageAddedEventArgs();
	        /**
	         * @hidden
	         * @private
	         */
	        this.pdfPages = [];
	        /**
	         * @hidden
	         * @private
	         */
	        this.dictionaryProperties = new DictionaryProperties();
	        this.pdfDocument = document;
	        if (typeof pageSettings === 'undefined') {
	            this.settings = document.pageSettings.clone();
	            this.initialSettings = this.settings.clone();
	        }
	        else {
	            this.settings = pageSettings.clone();
	            this.initialSettings = this.settings.clone();
	        }
	        this.initialize();
	    }
	    Object.defineProperty(PdfSection.prototype, "parent", {
	        //Property
	        /**
	         * Gets or sets the `parent`.
	         * @private
	         */
	        get: function () {
	            return this.sectionCollection;
	        },
	        set: function (value) {
	            this.sectionCollection = value;
	            this.section.items.setValue(this.dictionaryProperties.parent, new PdfReferenceHolder(value));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfSection.prototype, "parentDocument", {
	        /**
	         * Gets the `parent document`.
	         * @private
	         */
	        get: function () {
	            return this.pdfDocument;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfSection.prototype, "pageSettings", {
	        /**
	         * Gets or sets the `page settings` of the section.
	         * @private
	         */
	        get: function () {
	            return this.settings;
	        },
	        set: function (value) {
	            if (value != null) {
	                this.settings = value;
	            }
	            else {
	                throw Error('Value can not be null.');
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfSection.prototype, "element", {
	        /**
	         * Gets the wrapped `element`.
	         * @private
	         */
	        get: function () {
	            return this.section;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfSection.prototype, "count", {
	        /**
	         * Gets the `count` of the pages in the section.
	         * @private
	         */
	        get: function () {
	            return this.pagesReferences.count;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfSection.prototype, "template", {
	        /**
	         * Gets or sets a `template` for the pages in the section.
	         * @private
	         */
	        get: function () {
	            if (this.pageTemplate == null) {
	                this.pageTemplate = new PdfSectionTemplate();
	            }
	            return this.pageTemplate;
	        },
	        set: function (value) {
	            this.pageTemplate = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfSection.prototype, "document", {
	        /**
	         * Gets the `document`.
	         * @private
	         */
	        get: function () {
	            return this.sectionCollection.document;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfSection.prototype, "pages", {
	        /**
	         * Gets the collection of `pages` in a section (Read only)
	         * @private
	         */
	        get: function () {
	            if (this.pagesCollection == null || typeof this.pagesCollection === 'undefined') {
	                this.pagesCollection = new PdfSectionPageCollection(this);
	            }
	            return this.pagesCollection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //methods
	    /**
	     * `Return the page collection` of current section.
	     * @private
	     */
	    PdfSection.prototype.getPages = function () {
	        return this.pdfPages;
	    };
	    /**
	     * `Translates` point into native coordinates of the page.
	     * @private
	     */
	    PdfSection.prototype.pointToNativePdf = function (page, point) {
	        var bounds = this.getActualBounds(page, true);
	        point.x += bounds.x;
	        point.y = this.pageSettings.height - (point.y);
	        return point;
	    };
	    /**
	     * Sets the page setting of the current section.
	     * @public
	     * @param settings Instance of `PdfPageSettings`
	     */
	    PdfSection.prototype.setPageSettings = function (settings) {
	        this.settings = settings;
	        this.state.orientation = settings.orientation;
	        this.state.rotate = settings.rotate;
	        this.state.size = settings.size;
	        this.state.origin = settings.origin;
	    };
	    /**
	     * `Initializes` the object.
	     * @private
	     */
	    PdfSection.prototype.initialize = function () {
	        this.pagesReferences = new PdfArray();
	        this.section = new PdfDictionary();
	        this.state = new PageSettingsState(this.pdfDocument);
	        this.section.sectionBeginSave = new SaveSectionEventHandler(this, this.state);
	        this.pageCount = new PdfNumber(0);
	        this.section.items.setValue(this.dictionaryProperties.count, this.pageCount);
	        this.section.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.pages));
	        this.section.items.setValue(this.dictionaryProperties.kids, this.pagesReferences);
	    };
	    /**
	     * Checks whether any template should be printed on this layer.
	     * @private
	     * @param document The parent document.
	     * @param page The parent page.
	     * @param foreground Layer z-order.
	     * @returns True - if some content should be printed on the layer, False otherwise.
	     */
	    PdfSection.prototype.containsTemplates = function (document, page, foreground) {
	        var documentHeaders = this.getDocumentTemplates(document, page, foreground);
	        var sectionTemplates = this.getSectionTemplates(page, foreground);
	        return (documentHeaders.length > 0 || sectionTemplates.length > 0);
	    };
	    /**
	     * Returns array of the document templates.
	     * @private
	     * @param document The parent document.
	     * @param page The parent page.
	     * @param headers If true - return headers/footers, if false - return simple templates.
	     * @param foreground If true - return foreground templates, if false - return background templates.
	     * @returns Returns array of the document templates.
	     */
	    /* tslint:disable */
	    PdfSection.prototype.getDocumentTemplates = function (document, page, foreground) {
	        var templates = [];
	        if (this.template.applyDocumentTopTemplate && document.template.getTop(page) != null) {
	            if ((!(document.template.getTop(page).foreground || foreground)) || (document.template.getTop(page).foreground && foreground)) {
	                templates.push(document.template.getTop(page));
	            }
	        }
	        if (this.template.applyDocumentBottomTemplate && document.template.getBottom(page) != null) {
	            if ((!(document.template.getBottom(page).foreground || foreground)) || (document.template.getBottom(page).foreground && foreground)) {
	                templates.push(document.template.getBottom(page));
	            }
	        }
	        if (this.template.applyDocumentLeftTemplate && document.template.getLeft(page) != null) {
	            if ((!(document.template.getLeft(page).foreground || foreground)) || (document.template.getLeft(page).foreground && foreground)) {
	                templates.push(document.template.getLeft(page));
	            }
	        }
	        if (this.template.applyDocumentRightTemplate && document.template.getRight(page) != null) {
	            if ((!(document.template.getRight(page).foreground || foreground)) || (document.template.getRight(page).foreground && foreground)) {
	                templates.push(document.template.getRight(page));
	            }
	        }
	        return templates;
	    };
	    /**
	     * Returns array of the section templates.
	     * @private
	     * @param page The parent page.
	     * @param foreground If true - return foreground templates, if false - return background templates.
	     * @returns Returns array of the section templates.
	     */
	    /* tslint:disable */
	    PdfSection.prototype.getSectionTemplates = function (page, foreground) {
	        var templates = [];
	        if (this.template.getTop(page) != null) {
	            var pageTemplate = this.template.getTop(page);
	            if ((!(pageTemplate.foreground || foreground)) || (pageTemplate.foreground && foreground)) {
	                templates.push(pageTemplate);
	            }
	        }
	        if (this.template.getBottom(page) != null) {
	            var pageTemplate = this.template.getBottom(page);
	            if ((!(pageTemplate.foreground || foreground)) || (pageTemplate.foreground && foreground)) {
	                templates.push(pageTemplate);
	            }
	        }
	        if (this.template.getLeft(page) != null) {
	            var pageTemplate = this.template.getLeft(page);
	            if ((!(pageTemplate.foreground || foreground)) || (pageTemplate.foreground && foreground)) {
	                templates.push(pageTemplate);
	            }
	        }
	        if (this.template.getRight(page) != null) {
	            var pageTemplate = this.template.getRight(page);
	            if ((!(pageTemplate.foreground || foreground)) || (pageTemplate.foreground && foreground)) {
	                templates.push(pageTemplate);
	            }
	        }
	        return templates;
	    };
	    /* tslint:enable */
	    /**
	     * `Adds` the specified page.
	     * @private
	     */
	    PdfSection.prototype.add = function (page) {
	        if (typeof page === 'undefined') {
	            var page_1 = new PdfPage();
	            this.add(page_1);
	            return page_1;
	        }
	        else {
	            var r = this.checkPresence(page);
	            this.pdfPages.push(page);
	            this.pagesReferences.add(r);
	            page.setSection(this);
	            page.resetProgress();
	            this.pageAddedMethod(page);
	        }
	    };
	    /**
	     * `Checks the presence`.
	     * @private
	     */
	    PdfSection.prototype.checkPresence = function (page) {
	        var rh = new PdfReferenceHolder(page);
	        var contains = false;
	        var sc = this.parent;
	        for (var index = 0; index < sc.section.length; index++) {
	            var section = sc.section[index];
	            contains = contains || section.contains(page);
	        }
	        return rh;
	    };
	    /**
	     * `Determines` whether the page in within the section.
	     * @private
	     */
	    PdfSection.prototype.contains = function (page) {
	        var index = this.indexOf(page);
	        return (0 <= index);
	    };
	    /**
	     * Get the `index of` the page.
	     * @private
	     */
	    PdfSection.prototype.indexOf = function (page) {
	        for (var index = 0; index < this.pdfPages.length; index++) {
	            if (this.pdfPages[index] === page) {
	                return this.pdfPages.indexOf(page);
	            }
	        }
	        var r = new PdfReferenceHolder(page);
	        return this.pagesReferences.indexOf(r);
	    };
	    /**
	     * Call two event's methods.
	     * @hidden
	     * @private
	     */
	    PdfSection.prototype.pageAddedMethod = function (page) {
	        //Create event's arguments
	        var args = new PageAddedEventArgs(page);
	        this.onPageAdded(args);
	        var parent = this.parent;
	        parent.document.pages.onPageAdded(args);
	        this.pageCount.intValue = this.count;
	    };
	    /**
	     * Called when the page has been added.
	     * @hidden
	     * @private
	     */
	    PdfSection.prototype.onPageAdded = function (args) {
	        //
	    };
	    PdfSection.prototype.getActualBounds = function (arg1, arg2, arg3) {
	        if (arg1 instanceof PdfPage && typeof arg2 === 'boolean') {
	            var result = void 0;
	            var document_1 = this.parent.document;
	            result = this.getActualBounds(document_1, arg1, arg2);
	            return result;
	        }
	        else {
	            arg1 = arg1;
	            arg2 = arg2;
	            arg3 = arg3;
	            var bounds = new RectangleF(0, 0, 0, 0);
	            bounds.height = (arg3) ? this.pageSettings.size.height : this.pageSettings.getActualSize().height;
	            bounds.width = (arg3) ? this.pageSettings.size.width : this.pageSettings.getActualSize().width;
	            var left = this.getLeftIndentWidth(arg1, arg2, arg3);
	            var top_1 = this.getTopIndentHeight(arg1, arg2, arg3);
	            var right = this.getRightIndentWidth(arg1, arg2, arg3);
	            var bottom = this.getBottomIndentHeight(arg1, arg2, arg3);
	            bounds.x += left;
	            bounds.y += top_1;
	            bounds.width -= (left + right);
	            bounds.height -= (top_1 + bottom);
	            return bounds;
	        }
	    };
	    /**
	     * Calculates width of the `left indent`.
	     * @private
	     */
	    PdfSection.prototype.getLeftIndentWidth = function (document, page, includeMargins) {
	        if (document == null) {
	            throw new Error('ArgumentNullException:document');
	        }
	        if (page == null) {
	            throw new Error('ArgumentNullException:page');
	        }
	        var value = (includeMargins) ? this.pageSettings.margins.left : 0;
	        var templateWidth = (this.template.getLeft(page) != null) ? this.template.getLeft(page).width : 0;
	        var docTemplateWidth = (document.template.getLeft(page) != null) ? document.template.getLeft(page).width : 0;
	        value += (this.template.applyDocumentLeftTemplate) ? Math.max(templateWidth, docTemplateWidth) : templateWidth;
	        return value;
	    };
	    /**
	     * Calculates `Height` of the top indent.
	     * @private
	     */
	    PdfSection.prototype.getTopIndentHeight = function (document, page, includeMargins) {
	        if (document == null) {
	            throw new Error('ArgumentNullException:document');
	        }
	        if (page == null) {
	            throw new Error('ArgumentNullException:page');
	        }
	        var value = (includeMargins) ? this.pageSettings.margins.top : 0;
	        var templateHeight = (this.template.getTop(page) != null) ? this.template.getTop(page).height : 0;
	        var docTemplateHeight = (document.template.getTop(page) != null) ? document.template.getTop(page).height : 0;
	        value += (this.template.applyDocumentTopTemplate) ? Math.max(templateHeight, docTemplateHeight) : templateHeight;
	        return value;
	    };
	    /**
	     * Calculates `width` of the right indent.
	     * @private
	     */
	    PdfSection.prototype.getRightIndentWidth = function (document, page, includeMargins) {
	        if (document == null) {
	            throw new Error('ArgumentNullException:document');
	        }
	        if (page == null) {
	            throw new Error('ArgumentNullException:page');
	        }
	        var value = (includeMargins) ? this.pageSettings.margins.right : 0;
	        var templateWidth = (this.template.getRight(page) != null) ? this.template.getRight(page).width : 0;
	        var docTemplateWidth = (document.template.getRight(page) != null) ? document.template.getRight(page).width : 0;
	        value += (this.template.applyDocumentRightTemplate) ? Math.max(templateWidth, docTemplateWidth) : templateWidth;
	        return value;
	    };
	    /**
	     * Calculates `Height` of the bottom indent.
	     * @private
	     */
	    PdfSection.prototype.getBottomIndentHeight = function (document, page, includeMargins) {
	        if (document == null) {
	            throw new Error('ArgumentNullException:document');
	        }
	        if (page == null) {
	            throw new Error('ArgumentNullException:page');
	        }
	        var value = (includeMargins) ? this.pageSettings.margins.bottom : 0;
	        var templateHeight = (this.template.getBottom(page) != null) ? this.template.getBottom(page).height : 0;
	        var docTemplateHeight = (document.template.getBottom(page) != null) ? document.template.getBottom(page).height : 0;
	        value += (this.template.applyDocumentBottomTemplate) ? Math.max(templateHeight, docTemplateHeight) : templateHeight;
	        return value;
	    };
	    /**
	     * `Removes` the page from the section.
	     * @private
	     */
	    PdfSection.prototype.remove = function (page) {
	        if (page == null) {
	            throw Error('ArgumentNullException("page")');
	        }
	        var index = this.pdfPages.indexOf(page);
	        this.pagesReferences.removeAt(index);
	        var temproaryPages = [];
	        for (var j = 0; j < index; j++) {
	            temproaryPages.push(this.pdfPages[j]);
	        }
	        for (var j = index + 1; j < this.pdfPages.length; j++) {
	            temproaryPages.push(this.pdfPages[j]);
	        }
	        this.pdfPages = temproaryPages;
	    };
	    /**
	     * In fills dictionary by the data from `Page settings`.
	     * @private
	     */
	    PdfSection.prototype.applyPageSettings = function (container, parentSettings, state) {
	        var bounds = new RectangleF(state.origin, state.size);
	        container.items.setValue(this.dictionaryProperties.mediaBox, PdfArray.fromRectangle(bounds));
	        var rotate = 0;
	        rotate = PdfSectionCollection.rotateFactor * state.rotate;
	        var angle = new PdfNumber(rotate);
	        container.items.setValue(this.dictionaryProperties.rotate, angle);
	    };
	    /**
	     * Catches the Save event of the dictionary.
	     * @hidden
	     * @private
	     */
	    PdfSection.prototype.beginSave = function (state, writer) {
	        var doc = writer.document;
	        this.applyPageSettings(this.section, doc.pageSettings, state);
	    };
	    /**
	     * Draws page templates on the page.
	     * @private
	     */
	    PdfSection.prototype.drawTemplates = function (page, layer, document, foreground) {
	        var documentHeaders = this.getDocumentTemplates(document, page, foreground);
	        var sectionHeaders = this.getSectionTemplates(page, foreground);
	        this.drawTemplatesHelper(layer, document, documentHeaders);
	        this.drawTemplatesHelper(layer, document, sectionHeaders);
	    };
	    /**
	     * Draws page templates on the page.
	     * @private
	     */
	    PdfSection.prototype.drawTemplatesHelper = function (layer, document, templates) {
	        if (templates != null && templates.length > 0) {
	            var len = templates.length;
	            for (var i = 0; i < len; i++) {
	                var template = templates[i];
	                template.draw(layer, document);
	            }
	        }
	    };
	    return PdfSection;
	}());
	var PageSettingsState = /** @class */ (function () {
	    //Public Constructor
	    /**
	     * New instance to store the `PageSettings`.
	     * @private
	     */
	    function PageSettingsState(document) {
	        this.pageOrientation = document.pageSettings.orientation;
	        this.pageRotate = document.pageSettings.rotate;
	        this.pageSize = document.pageSettings.size;
	        this.pageOrigin = document.pageSettings.origin;
	    }
	    Object.defineProperty(PageSettingsState.prototype, "orientation", {
	        //public Properties
	        /**
	         * @hidden
	         * @private
	         */
	        get: function () {
	            return this.pageOrientation;
	        },
	        set: function (value) {
	            this.pageOrientation = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PageSettingsState.prototype, "rotate", {
	        /**
	         * @hidden
	         * @private
	         */
	        get: function () {
	            return this.pageRotate;
	        },
	        set: function (value) {
	            this.pageRotate = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PageSettingsState.prototype, "size", {
	        /**
	         * @hidden
	         * @private
	         */
	        get: function () {
	            return this.pageSize;
	        },
	        set: function (value) {
	            this.pageSize = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PageSettingsState.prototype, "origin", {
	        /**
	         * @hidden
	         * @private
	         */
	        get: function () {
	            return this.pageOrigin;
	        },
	        set: function (value) {
	            this.pageOrigin = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PageSettingsState;
	}());

	/**
	 * Represents the `collection of the sections`.
	 * @private
	 */
	var PdfSectionCollection = /** @class */ (function () {
	    //constructor
	    /**
	     * Initializes a new instance of the `PdfSectionCollection` class.
	     * @private
	     */
	    function PdfSectionCollection(document) {
	        /**
	         * @hidden
	         * @private
	         */
	        this.sections = [];
	        /**
	         * @hidden
	         * @private
	         */
	        this.dictionaryProperties = new DictionaryProperties();
	        // if (document === null) {
	        //     throw new Error('ArgumentNullException : document');
	        // }
	        this.pdfDocument = document.clone();
	        this.initialize();
	    }
	    Object.defineProperty(PdfSectionCollection.prototype, "section", {
	        //Properties
	        /**
	         * Gets the `Section` collection.
	         */
	        get: function () {
	            return this.sections;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfSectionCollection.prototype, "document", {
	        /**
	         * Gets a parent `document`.
	         * @private
	         */
	        get: function () {
	            return this.pdfDocument;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfSectionCollection.prototype, "count", {
	        /**
	         * Gets the `number of sections` in a document.
	         * @private
	         */
	        get: function () {
	            return this.sections.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfSectionCollection.prototype, "element", {
	        /**
	         * Gets the wrapped `element`.
	         * @private
	         */
	        get: function () {
	            return this.pages;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //Methods
	    /**
	     * `Initializes the object`.
	     * @private
	     */
	    PdfSectionCollection.prototype.initialize = function () {
	        this.sectionCount = new PdfNumber(0);
	        this.sectionCollection = new PdfArray();
	        this.pages = new PdfDictionary();
	        this.pages.beginSave = new SaveSectionCollectionEventHandler(this);
	        this.pages.items.setValue(this.dictionaryProperties.type, new PdfName('Pages'));
	        this.pages.items.setValue(this.dictionaryProperties.kids, this.sectionCollection);
	        this.pages.items.setValue(this.dictionaryProperties.count, this.sectionCount);
	        this.pages.items.setValue(this.dictionaryProperties.resources, new PdfDictionary());
	        this.setPageSettings(this.pages, this.pdfDocument.pageSettings);
	    };
	    /**
	     * Initializes a new instance of the `PdfSectionCollection` class.
	     * @private
	     */
	    PdfSectionCollection.prototype.pdfSectionCollection = function (index) {
	        if (index < 0 || index >= this.count) {
	            throw new Error('IndexOutOfRangeException()');
	        }
	        return this.sections[index];
	    };
	    /**
	     * In fills dictionary by the data from `Page settings`.
	     * @private
	     */
	    PdfSectionCollection.prototype.setPageSettings = function (container, pageSettings) {
	        // if (container === null) {
	        //     throw new Error('ArgumentNullException : container');
	        // }
	        // if (pageSettings === null) {
	        //     throw new Error('ArgumentNullException : pageSettings');
	        // }
	        var bounds = new RectangleF(new PointF(), pageSettings.size);
	        container.items.setValue(this.dictionaryProperties.mediaBox, PdfArray.fromRectangle(bounds));
	    };
	    /**
	     * `Adds` the specified section.
	     * @private
	     */
	    PdfSectionCollection.prototype.add = function (section) {
	        if (typeof section === 'undefined') {
	            var section_1 = new PdfSection(this.pdfDocument);
	            this.add(section_1);
	            return section_1;
	        }
	        else {
	            // if (section === null) {
	            //     throw new Error('ArgumentNullException : section');
	            // }
	            var r = this.checkSection(section);
	            this.sections.push(section);
	            section.parent = this;
	            this.sectionCollection.add(r);
	            return this.sections.indexOf(section);
	        }
	    };
	    /**
	     * `Checks` if the section is within the collection.
	     * @private
	     */
	    PdfSectionCollection.prototype.checkSection = function (section) {
	        var r = new PdfReferenceHolder(section);
	        this.sectionCollection.contains(r);
	        // if (contains) {
	        //     throw new Error('ArgumentException : The object can not be added twice to the collection,section');
	        // }
	        return r;
	    };
	    /**
	     * Catches the Save event of the dictionary to `count the pages`.
	     * @private
	     */
	    PdfSectionCollection.prototype.countPages = function () {
	        var count = 0;
	        this.sections.forEach(function (n) { return (count += n.count); });
	        return count;
	    };
	    /**
	     * Catches the Save event of the dictionary to `count the pages`.
	     * @hidden
	     * @private
	     */
	    PdfSectionCollection.prototype.beginSave = function () {
	        this.sectionCount.intValue = this.countPages();
	    };
	    //Fields
	    /**
	     * Rotate factor for page `rotation`.
	     * @default 90
	     * @private
	     */
	    PdfSectionCollection.rotateFactor = 90;
	    return PdfSectionCollection;
	}());

	/**
	 * Represents a virtual collection of all the pages in the document.
	 * @private
	 */
	var PdfDocumentPageCollection = /** @class */ (function () {
	    //constructor
	    /**
	     * Initializes a new instance of the `PdfPageCollection` class.
	     * @private
	     */
	    function PdfDocumentPageCollection(document) {
	        /**
	         * It holds the page collection with the `index`.
	         * @private
	         */
	        this.pdfPageCollectionIndex = new Dictionary();
	        this.document = document;
	    }
	    Object.defineProperty(PdfDocumentPageCollection.prototype, "count", {
	        //Property
	        /**
	         * Gets the total `number of the pages`.
	         * @private
	         */
	        get: function () {
	            return this.countPages();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocumentPageCollection.prototype, "pageCollectionIndex", {
	        /**
	         * Gets a `page index` from the document.
	         * @private
	         */
	        get: function () {
	            return this.pdfPageCollectionIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PdfDocumentPageCollection.prototype.add = function (page) {
	        if (typeof page === 'undefined') {
	            var page_1 = new PdfPage();
	            this.add(page_1);
	            return page_1;
	        }
	        else {
	            var section = this.getLastSection();
	            section.add(page);
	        }
	    };
	    /**
	     * Returns `last section` in the document.
	     * @private
	     */
	    PdfDocumentPageCollection.prototype.getLastSection = function () {
	        var sc = this.document.sections;
	        if (sc.section.length === 0) {
	            sc.add();
	        }
	        var section = sc.section[sc.section.length - 1];
	        return section;
	    };
	    /**
	     * Called when `new page has been added`.
	     * @private
	     */
	    PdfDocumentPageCollection.prototype.onPageAdded = function (args) {
	        // if (PageAdded !== null)
	        // {
	        //     PageAdded(this, args);
	        // }
	    };
	    /**
	     * Gets the `total number of pages`.
	     * @private
	     */
	    PdfDocumentPageCollection.prototype.countPages = function () {
	        var sc = this.document.sections;
	        var count = 0;
	        for (var index = 0; index < sc.section.length; index++) {
	            count += sc.section[index].count;
	        }
	        return count;
	    };
	    /**
	     * Gets the `page object` from page index.
	     * @private
	     */
	    PdfDocumentPageCollection.prototype.getPageByIndex = function (index) {
	        return this.getPage(index);
	    };
	    /**
	     * Gets a page by its `index` in the document.
	     * @private
	     */
	    PdfDocumentPageCollection.prototype.getPage = function (index) {
	        if ((index < 0) || (index >= this.count)) {
	            throw Error('ArgumentOutOfRangeException("index", "Value can not be less 0")');
	        }
	        var page = null;
	        var sectionStartIndex = 0;
	        var sectionCount = 0;
	        var pageIndex = 0;
	        var length = this.document.sections.count;
	        for (var i = 0; i < length; i++) {
	            var section = this.document.sections.section[i];
	            sectionCount = section.count;
	            pageIndex = index - sectionStartIndex;
	            // We found a section containing the page.
	            if ((index >= sectionStartIndex && pageIndex < sectionCount)) {
	                page = section.getPages()[pageIndex];
	                break;
	            }
	            sectionStartIndex += sectionCount;
	        }
	        return page;
	    };
	    /**
	     * Gets the `index of` the page in the document.
	     * @private
	     */
	    PdfDocumentPageCollection.prototype.indexOf = function (page) {
	        var index = -1;
	        if (page == null) {
	            throw new Error('ArgumentNullException: page');
	        }
	        else {
	            var numPages = 0;
	            for (var i = 0, len = this.document.sections.count; i < len; i++) {
	                var section = this.document.sections.pdfSectionCollection(i);
	                index = section.indexOf(page);
	                if (index >= 0) {
	                    index += numPages;
	                    break;
	                }
	                else {
	                    index = -1;
	                }
	                numPages += section.count;
	            }
	        }
	        return index;
	    };
	    /**
	     * `Removes` the specified page.
	     * @private
	     */
	    PdfDocumentPageCollection.prototype.remove = function (page) {
	        if (page == null) {
	            throw Error('ArgumentNullException("page")');
	        }
	        var section = null;
	        for (var i = 0, len_1 = this.document.sections.count; i < len_1; i++) {
	            section = this.document.sections.pdfSectionCollection(i);
	            if (section.pages.contains(page)) {
	                section.pages.remove(page);
	                break;
	            }
	        }
	        return section;
	    };
	    return PdfDocumentPageCollection;
	}());

	/**
	 * PdfCacheCollection.ts class for EJ2-PDF
	 */
	/**
	 * `Collection of the cached objects`.
	 * @private
	 */
	var PdfCacheCollection = /** @class */ (function () {
	    // Constructors
	    /**
	     * Initializes a new instance of the `PdfCacheCollection` class.
	     * @private
	     */
	    function PdfCacheCollection() {
	        this.referenceObjects = [];
	        this.pdfFontCollection = new Dictionary();
	    }
	    // Public methods
	    /**
	     * `Searches` for the similar cached object. If is not found - adds the object to the cache.
	     * @private
	     */
	    PdfCacheCollection.prototype.search = function (obj) {
	        var result = null;
	        var group = this.getGroup(obj);
	        if (group == null) {
	            group = this.createNewGroup();
	        }
	        else if (group.length > 0) {
	            result = group[0];
	        }
	        group.push(obj);
	        return result;
	    };
	    // Implementation
	    /**
	     * `Creates` a new group.
	     * @private
	     */
	    PdfCacheCollection.prototype.createNewGroup = function () {
	        var group = [];
	        this.referenceObjects.push(group);
	        return group;
	    };
	    /**
	     * `Find and Return` a group.
	     * @private
	     */
	    PdfCacheCollection.prototype.getGroup = function (result) {
	        var group = null;
	        if (result !== null) {
	            var len = this.referenceObjects.length;
	            for (var i = 0; i < len; i++) {
	                if (this.referenceObjects.length > 0) {
	                    var tGroup = this.referenceObjects[i];
	                    if (tGroup.length > 0) {
	                        var representative = tGroup[0];
	                        if (result.equalsTo(representative)) {
	                            group = tGroup;
	                            break;
	                        }
	                    }
	                    else {
	                        this.removeGroup(tGroup);
	                    }
	                }
	                len = this.referenceObjects.length;
	            }
	        }
	        return group;
	    };
	    /**
	     * Remove a group from the storage.
	     */
	    PdfCacheCollection.prototype.removeGroup = function (group) {
	        if (group !== null) {
	            var index = this.referenceObjects.indexOf(group);
	            this.referenceObjects.slice(index, index + 1);
	        }
	    };
	    PdfCacheCollection.prototype.destroy = function () {
	        this.pdfFontCollection = undefined;
	        this.referenceObjects = undefined;
	    };
	    return PdfCacheCollection;
	}());

	var __extends$f = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Represents a PDF document and can be used to create a new PDF document from the scratch.
	 * ```typescript
	 * // create a new PDF document
	 * let document : PdfDocument = new PdfDocument();
	 * // add a new page to the document
	 * let page1 : PdfPage = document.pages.add();
	 * // set the font
	 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	 * // create black brush
	 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	 * // draw the text
	 * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
	 * // save the document
	 * document.save('output.pdf');
	 * // destroy the document
	 * document.destroy();
	 * ```
	 */
	var PdfDocument = /** @class */ (function (_super) {
	    __extends$f(PdfDocument, _super);
	    function PdfDocument(isMerging) {
	        var _this = _super.call(this) || this;
	        /**
	         * Default `margin` value.
	         * @default 40.0
	         * @private
	         */
	        _this.defaultMargin = 40.0;
	        /**
	         * Internal variable to store instance of `StreamWriter` classes..
	         * @default null
	         * @private
	         */
	        _this.streamWriter = null;
	        _this.document = _this;
	        var isMerge = false;
	        if (typeof isMerging === 'undefined') {
	            PdfDocument.cacheCollection = new PdfCacheCollection();
	            isMerge = false;
	        }
	        else {
	            isMerge = isMerging;
	        }
	        var objects = new PdfMainObjectCollection();
	        _this.setMainObjectCollection(objects);
	        var crossTable = new PdfCrossTable();
	        crossTable.isMerging = isMerge;
	        crossTable.document = _this;
	        _this.setCrossTable(crossTable);
	        var catalog = new PdfCatalog();
	        _this.setCatalog(catalog);
	        objects.add(catalog);
	        catalog.position = -1;
	        _this.sectionCollection = new PdfSectionCollection(_this);
	        _this.documentPageCollection = new PdfDocumentPageCollection(_this);
	        catalog.pages = _this.sectionCollection;
	        return _this;
	    }
	    Object.defineProperty(PdfDocument, "defaultFont", {
	        //Properties
	        /**
	         * Gets the `default font`. It is used for complex objects when font is not explicitly defined.
	         * @private
	         */
	        get: function () {
	            if (this.defaultStandardFont == null) {
	                this.defaultStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 8);
	            }
	            return this.defaultStandardFont;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocument.prototype, "sections", {
	        /**
	         * Gets the collection of the `sections` in the document.
	         * @private
	         */
	        get: function () {
	            return this.sectionCollection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocument.prototype, "pageSettings", {
	        /**
	         * Gets the document's page setting.
	         * @public
	         */
	        get: function () {
	            if (this.settings == null) {
	                this.settings = new PdfPageSettings(this.defaultMargin);
	            }
	            return this.settings;
	        },
	        /**
	         * Sets the document's page setting.
	         * ```typescript
	         * // create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         *
	         * // sets the right margin of the page
	         * document.pageSettings.margins.right = 0;
	         * // set the page size.
	         * document.pageSettings.size = new SizeF(500, 500);
	         * // change the page orientation to landscape
	         * document.pageSettings.orientation = PdfPageOrientation.Landscape;
	         * // apply 90 degree rotation on the page
	         * document.pageSettings.rotate = PdfPageRotateAngle.RotateAngle90;
	         *
	         * // add a pages to the document
	         * let page1 : PdfPage = document.pages.add();
	         * // set font
	         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	         * // set brush
	         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	         * // set the specified Point
	         * let point : PointF = new PointF(page1.getClientSize().width - 200, page1.getClientSize().height - 200);
	         * // draw the text
	         * page1.graphics.drawString('Hello World', font, blackBrush, point);
	         * // save the document
	         * document.save('output.pdf');
	         * // destroy the document
	         * document.destroy();
	         * ```
	         */
	        set: function (value) {
	            this.settings = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocument.prototype, "pages", {
	        /**
	         * Represents the collection of pages in the PDF document.
	         * ```typescript
	         * // create a new PDF document
	         * let document : PdfDocument = new PdfDocument();
	         * //
	         * // get the collection of pages in the document
	         * let pageCollection : PdfDocumentPageCollection  = document.pages;
	         * //
	         * // add pages
	         * let page1 : PdfPage = pageCollection.add();
	         * // save the document
	         * document.save('output.pdf');
	         * // destroy the document
	         * document.destroy();
	         * ```
	         */
	        get: function () {
	            return this.documentPageCollection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocument, "cache", {
	        /**
	         * Gets collection of the `cached objects`.
	         * @private
	         */
	        get: function () {
	            if (typeof PdfDocument.cacheCollection === 'undefined' || PdfDocument.cacheCollection == null) {
	                return new PdfCacheCollection();
	            }
	            return PdfDocument.cacheCollection;
	        },
	        /**
	         * Sets collection of the `cached objects`.
	         * @private
	         */
	        set: function (value) {
	            this.cacheCollection = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocument, "enableCache", {
	        /**
	         * Gets the value of enable cache.
	         * @private
	         */
	        get: function () {
	            return this.isCacheEnabled;
	        },
	        /**
	         * Sets thie value of enable cache.
	         * @private
	         */
	        set: function (value) {
	            this.isCacheEnabled = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocument.prototype, "colorSpace", {
	        /* tslint:disable */
	        /**
	         * Gets or sets the `color space` of the document. This property can be used to create PDF document in RGB, Gray scale or CMYK color spaces.
	         * @private
	         */
	        get: function () {
	            if ((this.pdfColorSpace === PdfColorSpace.Rgb) || ((this.pdfColorSpace === PdfColorSpace.Cmyk)
	                || (this.pdfColorSpace === PdfColorSpace.GrayScale))) {
	                return this.pdfColorSpace;
	            }
	            else {
	                return PdfColorSpace.Rgb;
	            }
	        },
	        set: function (value) {
	            if ((value === PdfColorSpace.Rgb) || ((value === PdfColorSpace.Cmyk) ||
	                (value === PdfColorSpace.GrayScale))) {
	                this.pdfColorSpace = value;
	            }
	            else {
	                this.pdfColorSpace = PdfColorSpace.Rgb;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfDocument.prototype, "template", {
	        /* tslint:enable */
	        /**
	         * Gets or sets a `template` to all pages in the document.
	         * @private
	         */
	        get: function () {
	            if (this.pageTemplate == null) {
	                this.pageTemplate = new PdfDocumentTemplate();
	            }
	            return this.pageTemplate;
	        },
	        set: function (value) {
	            this.pageTemplate = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PdfDocument.prototype.docSave = function (stream, arg2, arg3) {
	        this.checkPagesPresence();
	        if (stream === null) {
	            throw new Error('ArgumentNullException : stream');
	        }
	        this.streamWriter = stream;
	        var writer = new PdfWriter(stream);
	        writer.document = this;
	        if (typeof arg2 === 'boolean' && typeof arg3 === 'undefined') {
	            return this.crossTable.save(writer);
	        }
	        else {
	            this.crossTable.save(writer, arg2);
	        }
	    };
	    /**
	     * Checks the pages `presence`.
	     * @private
	     */
	    PdfDocument.prototype.checkPagesPresence = function () {
	        if (this.pages.count === 0) {
	            this.pages.add();
	        }
	    };
	    /**
	     * disposes the current instance of `PdfDocument` class.
	     * ```typescript
	     * // create a new PDF document
	     * let document : PdfDocument = new PdfDocument();
	     * // add a new page to the document
	     * let page1 : PdfPage = document.pages.add();
	     * // set the font
	     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	     * // create black brush
	     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	     * // draw the text
	     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
	     * // save the document
	     * document.save('output.pdf');
	     * // destroy the document
	     * document.destroy();
	     * ```
	     */
	    PdfDocument.prototype.destroy = function () {
	        this.catalog = undefined;
	        this.colorSpace = undefined;
	        this.currentSavingObj = undefined;
	        this.documentPageCollection = undefined;
	        this.isStreamCopied = undefined;
	        this.pageSettings = undefined;
	        this.pageTemplate = undefined;
	        this.pdfColorSpace = undefined;
	        this.sectionCollection = undefined;
	        PdfDocument.cache.destroy();
	        this.crossTable.pdfObjects.destroy();
	        PdfDocument.cache = undefined;
	        this.streamWriter.destroy();
	    };
	    /**
	     * `Font` used in complex objects to draw strings and text when it is not defined explicitly.
	     * @default null
	     * @private
	     */
	    PdfDocument.defaultStandardFont = null;
	    /**
	     * Indicates whether enable cache or not
	     * @default true
	     * @private
	     */
	    PdfDocument.isCacheEnabled = true;
	    return PdfDocument;
	}(PdfDocumentBase));

	/**
	 * PdfStandardFontMetricsFactory.ts class for EJ2-PDF
	 */
	/**
	 * @private
	 * `Factory of the standard fonts metrics`.
	 */
	var PdfStandardFontMetricsFactory = /** @class */ (function () {
	    function PdfStandardFontMetricsFactory() {
	    }
	    /**
	     * Returns `metrics` of the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.getMetrics = function (fontFamily, fontStyle, size) {
	        var metrics = null;
	        switch (fontFamily) {
	            case PdfFontFamily.Helvetica:
	                metrics = this.getHelveticaMetrics(fontFamily, fontStyle, size);
	                break;
	            case PdfFontFamily.Courier:
	                metrics = this.getCourierMetrics(fontFamily, fontStyle, size);
	                break;
	            case PdfFontFamily.TimesRoman:
	                metrics = this.getTimesMetrics(fontFamily, fontStyle, size);
	                break;
	            case PdfFontFamily.Symbol:
	                metrics = this.getSymbolMetrics(fontFamily, fontStyle, size);
	                break;
	            case PdfFontFamily.ZapfDingbats:
	                metrics = this.getZapfDingbatsMetrics(fontFamily, fontStyle, size);
	                break;
	            default:
	                metrics = this.getHelveticaMetrics(PdfFontFamily.Helvetica, fontStyle, size);
	                break;
	        }
	        metrics.name = fontFamily.toString();
	        metrics.subScriptSizeFactor = this.subSuperScriptFactor;
	        metrics.superscriptSizeFactor = this.subSuperScriptFactor;
	        return metrics;
	    };
	    // Implementation
	    /**
	     * Creates `Helvetica font metrics`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.getHelveticaMetrics = function (fontFamily, fontStyle, size) {
	        var metrics = new PdfFontMetrics();
	        if ((fontStyle & PdfFontStyle.Bold) > 0 && (fontStyle & PdfFontStyle.Italic) > 0) {
	            metrics.ascent = this.helveticaBoldItalicAscent;
	            metrics.descent = this.helveticaBoldItalicDescent;
	            metrics.postScriptName = this.helveticaBoldItalicName;
	            metrics.size = size;
	            metrics.widthTable = new StandardWidthTable(this.arialBoldWidth);
	            metrics.height = metrics.ascent - metrics.descent;
	        }
	        else if ((fontStyle & PdfFontStyle.Bold) > 0) {
	            metrics.ascent = this.helveticaBoldAscent;
	            metrics.descent = this.helveticaBoldDescent;
	            metrics.postScriptName = this.helveticaBoldName;
	            metrics.size = size;
	            metrics.widthTable = new StandardWidthTable(this.arialBoldWidth);
	            metrics.height = metrics.ascent - metrics.descent;
	        }
	        else if ((fontStyle & PdfFontStyle.Italic) > 0) {
	            metrics.ascent = this.helveticaItalicAscent;
	            metrics.descent = this.helveticaItalicDescent;
	            metrics.postScriptName = this.helveticaItalicName;
	            metrics.size = size;
	            metrics.widthTable = new StandardWidthTable(this.arialWidth);
	            metrics.height = metrics.ascent - metrics.descent;
	        }
	        else {
	            metrics.ascent = this.helveticaAscent;
	            metrics.descent = this.helveticaDescent;
	            metrics.postScriptName = this.helveticaName;
	            metrics.size = size;
	            metrics.widthTable = new StandardWidthTable(this.arialWidth);
	            metrics.height = metrics.ascent - metrics.descent;
	        }
	        return metrics;
	    };
	    /**
	     * Creates `Courier font metrics`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.getCourierMetrics = function (fontFamily, fontStyle, size) {
	        var metrics = new PdfFontMetrics();
	        if ((fontStyle & PdfFontStyle.Bold) > 0 && (fontStyle & PdfFontStyle.Italic) > 0) {
	            metrics.ascent = this.courierBoldItalicAscent;
	            metrics.descent = this.courierBoldItalicDescent;
	            metrics.postScriptName = this.courierBoldItalicName;
	            metrics.size = size;
	            metrics.widthTable = new StandardWidthTable(this.fixedWidth);
	            metrics.height = metrics.ascent - metrics.descent;
	        }
	        else if ((fontStyle & PdfFontStyle.Bold) > 0) {
	            metrics.ascent = this.courierBoldAscent;
	            metrics.descent = this.courierBoldDescent;
	            metrics.postScriptName = this.courierBoldName;
	            metrics.size = size;
	            metrics.widthTable = new StandardWidthTable(this.fixedWidth);
	            metrics.height = metrics.ascent - metrics.descent;
	        }
	        else if ((fontStyle & PdfFontStyle.Italic) > 0) {
	            metrics.ascent = this.courierItalicAscent;
	            metrics.descent = this.courierItalicDescent;
	            metrics.postScriptName = this.courierItalicName;
	            metrics.size = size;
	            metrics.widthTable = new StandardWidthTable(this.fixedWidth);
	            metrics.height = metrics.ascent - metrics.descent;
	        }
	        else {
	            metrics.ascent = this.courierAscent;
	            metrics.descent = this.courierDescent;
	            metrics.postScriptName = this.courierName;
	            metrics.size = size;
	            metrics.widthTable = new StandardWidthTable(this.fixedWidth);
	            metrics.height = metrics.ascent - metrics.descent;
	        }
	        return metrics;
	    };
	    /**
	     * Creates `Times font metrics`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.getTimesMetrics = function (fontFamily, fontStyle, size) {
	        var metrics = new PdfFontMetrics();
	        if ((fontStyle & PdfFontStyle.Bold) > 0 && (fontStyle & PdfFontStyle.Italic) > 0) {
	            metrics.ascent = this.timesBoldItalicAscent;
	            metrics.descent = this.timesBoldItalicDescent;
	            metrics.postScriptName = this.timesBoldItalicName;
	            metrics.size = size;
	            metrics.widthTable = new StandardWidthTable(this.timesRomanBoldItalicWidths);
	            metrics.height = metrics.ascent - metrics.descent;
	        }
	        else if ((fontStyle & PdfFontStyle.Bold) > 0) {
	            metrics.ascent = this.timesBoldAscent;
	            metrics.descent = this.timesBoldDescent;
	            metrics.postScriptName = this.timesBoldName;
	            metrics.size = size;
	            metrics.widthTable = new StandardWidthTable(this.timesRomanBoldWidth);
	            metrics.height = metrics.ascent - metrics.descent;
	        }
	        else if ((fontStyle & PdfFontStyle.Italic) > 0) {
	            metrics.ascent = this.timesItalicAscent;
	            metrics.descent = this.timesItalicDescent;
	            metrics.postScriptName = this.timesItalicName;
	            metrics.size = size;
	            metrics.widthTable = new StandardWidthTable(this.timesRomanItalicWidth);
	            metrics.height = metrics.ascent - metrics.descent;
	        }
	        else {
	            metrics.ascent = this.timesAscent;
	            metrics.descent = this.timesDescent;
	            metrics.postScriptName = this.timesName;
	            metrics.size = size;
	            metrics.widthTable = new StandardWidthTable(this.timesRomanWidth);
	            metrics.height = metrics.ascent - metrics.descent;
	        }
	        return metrics;
	    };
	    /**
	     * Creates `Symbol font metrics`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.getSymbolMetrics = function (fontFamily, fontStyle, size) {
	        var metrics = new PdfFontMetrics();
	        metrics.ascent = this.symbolAscent;
	        metrics.descent = this.symbolDescent;
	        metrics.postScriptName = this.symbolName;
	        metrics.size = size;
	        metrics.widthTable = new StandardWidthTable(this.symbolWidth);
	        metrics.height = metrics.ascent - metrics.descent;
	        return metrics;
	    };
	    /**
	     * Creates `ZapfDingbats font metrics`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.getZapfDingbatsMetrics = function (fontFamily, fontStyle, size) {
	        var metrics = new PdfFontMetrics();
	        metrics.ascent = this.zapfDingbatsAscent;
	        metrics.descent = this.zapfDingbatsDescent;
	        metrics.postScriptName = this.zapfDingbatsName;
	        metrics.size = size;
	        metrics.widthTable = new StandardWidthTable(this.zapfDingbatsWidth);
	        metrics.height = metrics.ascent - metrics.descent;
	        return metrics;
	    };
	    /**
	     * `Multiplier` os subscript superscript.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.subSuperScriptFactor = 1.52;
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.helveticaAscent = 931;
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.helveticaDescent = -225;
	    /**
	     * `Font type`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.helveticaName = 'Helvetica';
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.helveticaBoldAscent = 962;
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.helveticaBoldDescent = -228;
	    /**
	     * `Font type`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.helveticaBoldName = 'Helvetica-Bold';
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.helveticaItalicAscent = 931;
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.helveticaItalicDescent = -225;
	    /**
	     * `Font type`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.helveticaItalicName = 'Helvetica-Oblique';
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.helveticaBoldItalicAscent = 962;
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.helveticaBoldItalicDescent = -228;
	    /**
	     * `Font type`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.helveticaBoldItalicName = 'Helvetica-BoldOblique';
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.courierAscent = 805;
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.courierDescent = -250;
	    /**
	     * `Font type`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.courierName = 'Courier';
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.courierBoldAscent = 801;
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.courierBoldDescent = -250;
	    /**
	     * `Font type`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.courierBoldName = 'Courier-Bold';
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.courierItalicAscent = 805;
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.courierItalicDescent = -250;
	    /**
	     * `Font type`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.courierItalicName = 'Courier-Oblique';
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.courierBoldItalicAscent = 801;
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.courierBoldItalicDescent = -250;
	    /**
	     * `Font type`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.courierBoldItalicName = 'Courier-BoldOblique';
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesAscent = 898;
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesDescent = -218;
	    /**
	     * `Font type`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesName = 'Times-Roman';
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesBoldAscent = 935;
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesBoldDescent = -218;
	    /**
	     * `Font type`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesBoldName = 'Times-Bold';
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesItalicAscent = 883;
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesItalicDescent = -217;
	    /**
	     * `Font type`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesItalicName = 'Times-Italic';
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesBoldItalicAscent = 921;
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesBoldItalicDescent = -218;
	    /**
	     * `Font type`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesBoldItalicName = 'Times-BoldItalic';
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.symbolAscent = 1010;
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.symbolDescent = -293;
	    /**
	     * `Font type`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.symbolName = 'Symbol';
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.zapfDingbatsAscent = 820;
	    /**
	     * `Ascender` value for the font.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.zapfDingbatsDescent = -143;
	    /**
	     * `Font type`.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.zapfDingbatsName = 'ZapfDingbats';
	    /**
	     * `Arial` widths table.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.arialWidth = [
	        278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333,
	        278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584,
	        584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833,
	        722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278,
	        469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833,
	        556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334,
	        584, 0, 556, 0, 222, 556, 333, 1000, 556, 556, 333, 1000, 667, 333, 1000, 0,
	        611, 0, 0, 222, 222, 333, 333, 350, 556, 1000, 333, 1000, 500, 333, 944, 0,
	        500, 667, 0, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 0,
	        737, 333, 400, 584, 333, 333, 333, 556, 537, 278, 333, 333, 365, 556, 834, 834,
	        834, 611, 667, 667, 667, 667, 667, 667, 1000, 722, 667, 667, 667, 667, 278, 278,
	        278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667,
	        667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278,
	        278, 278, 556, 556, 556, 556, 556, 556, 556, 584, 611, 556, 556, 556, 556, 500,
	        556, 500
	    ];
	    /**
	     * `Arial bold` widths table.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.arialBoldWidth = [
	        278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333,
	        278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584,
	        584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833,
	        722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333,
	        584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889,
	        611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389,
	        584, 0, 556, 0, 278, 556, 500, 1000, 556, 556, 333, 1000, 667, 333, 1000, 0,
	        611, 0, 0, 278, 278, 500, 500, 350, 556, 1000, 333, 1000, 556, 333, 944, 0,
	        500, 667, 0, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 0,
	        737, 333, 400, 584, 333, 333, 333, 611, 556, 278, 333, 333, 365, 556, 834, 834,
	        834, 611, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 278, 278,
	        278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667,
	        667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278,
	        278, 278, 611, 611, 611, 611, 611, 611, 611, 584, 611, 611, 611, 611, 611, 556,
	        611, 556
	    ];
	    /**
	     * `Fixed` widths table.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.fixedWidth = [
	        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
	        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
	        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
	        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
	        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
	        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
	        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
	        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
	        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
	        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
	        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
	        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
	        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
	        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600
	    ];
	    /**
	     * `Times` widths table.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesRomanWidth = [
	        250, 333, 408, 500, 500, 833, 778, 180, 333, 333, 500, 564, 250, 333,
	        250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 278, 278, 564, 564,
	        564, 444, 921, 722, 667, 667, 722, 611, 556, 722, 722, 333, 389, 722, 611, 889,
	        722, 722, 556, 722, 667, 556, 611, 722, 722, 944, 722, 722, 611, 333, 278, 333,
	        469, 500, 333, 444, 500, 444, 500, 444, 333, 500, 500, 278, 278, 500, 278, 778,
	        500, 500, 500, 500, 333, 389, 278, 500, 500, 722, 500, 500, 444, 480, 200, 480,
	        541, 0, 500, 0, 333, 500, 444, 1000, 500, 500, 333, 1000, 556, 333, 889, 0,
	        611, 0, 0, 333, 333, 444, 444, 350, 500, 1000, 333, 980, 389, 333, 722, 0,
	        444, 722, 0, 333, 500, 500, 500, 500, 200, 500, 333, 760, 276, 500, 564, 0,
	        760, 333, 400, 564, 300, 300, 333, 500, 453, 250, 333, 300, 310, 500, 750, 750,
	        750, 444, 722, 722, 722, 722, 722, 722, 889, 667, 611, 611, 611, 611, 333, 333,
	        333, 333, 722, 722, 722, 722, 722, 722, 722, 564, 722, 722, 722, 722, 722, 722,
	        556, 500, 444, 444, 444, 444, 444, 444, 667, 444, 444, 444, 444, 444, 278, 278,
	        278, 278, 500, 500, 500, 500, 500, 500, 500, 564, 500, 500, 500, 500, 500, 500,
	        500, 500
	    ];
	    /**
	     * `Times bold` widths table.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesRomanBoldWidth = [
	        250, 333, 555, 500, 500, 1000, 833, 278, 333, 333, 500, 570, 250, 333,
	        250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 570, 570,
	        570, 500, 930, 722, 667, 722, 722, 667, 611, 778, 778, 389, 500, 778, 667, 944,
	        722, 778, 611, 778, 722, 556, 667, 722, 722, 1000, 722, 722, 667, 333, 278, 333,
	        581, 500, 333, 500, 556, 444, 556, 444, 333, 500, 556, 278, 333, 556, 278, 833,
	        556, 500, 556, 556, 444, 389, 333, 556, 500, 722, 500, 500, 444, 394, 220, 394,
	        520, 0, 500, 0, 333, 500, 500, 1000, 500, 500, 333, 1000, 556, 333, 1000, 0,
	        667, 0, 0, 333, 333, 500, 500, 350, 500, 1000, 333, 1000, 389, 333, 722, 0,
	        444, 722, 0, 333, 500, 500, 500, 500, 220, 500, 333, 747, 300, 500, 570, 0,
	        747, 333, 400, 570, 300, 300, 333, 556, 540, 250, 333, 300, 330, 500, 750, 750,
	        750, 500, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 389, 389,
	        389, 389, 722, 722, 778, 778, 778, 778, 778, 570, 778, 722, 722, 722, 722, 722,
	        611, 556, 500, 500, 500, 500, 500, 500, 722, 444, 444, 444, 444, 444, 278, 278,
	        278, 278, 500, 556, 500, 500, 500, 500, 500, 570, 500, 556, 556, 556, 556, 500,
	        556, 500
	    ];
	    /**
	     * `Times italic` widths table.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesRomanItalicWidth = [
	        250, 333, 420, 500, 500, 833, 778, 214, 333, 333, 500, 675, 250, 333,
	        250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 675, 675,
	        675, 500, 920, 611, 611, 667, 722, 611, 611, 722, 722, 333, 444, 667, 556, 833,
	        667, 722, 611, 722, 611, 500, 556, 722, 611, 833, 611, 556, 556, 389, 278, 389,
	        422, 500, 333, 500, 500, 444, 500, 444, 278, 500, 500, 278, 278, 444, 278, 722,
	        500, 500, 500, 500, 389, 389, 278, 500, 444, 667, 444, 444, 389, 400, 275, 400,
	        541, 0, 500, 0, 333, 500, 556, 889, 500, 500, 333, 1000, 500, 333, 944, 0,
	        556, 0, 0, 333, 333, 556, 556, 350, 500, 889, 333, 980, 389, 333, 667, 0,
	        389, 556, 0, 389, 500, 500, 500, 500, 275, 500, 333, 760, 276, 500, 675, 0,
	        760, 333, 400, 675, 300, 300, 333, 500, 523, 250, 333, 300, 310, 500, 750, 750,
	        750, 500, 611, 611, 611, 611, 611, 611, 889, 667, 611, 611, 611, 611, 333, 333,
	        333, 333, 722, 667, 722, 722, 722, 722, 722, 675, 722, 722, 722, 722, 722, 556,
	        611, 500, 500, 500, 500, 500, 500, 500, 667, 444, 444, 444, 444, 444, 278, 278,
	        278, 278, 500, 500, 500, 500, 500, 500, 500, 675, 500, 500, 500, 500, 500, 444,
	        500, 444
	    ];
	    /**
	     * `Times bold italic` widths table.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.timesRomanBoldItalicWidths = [
	        250, 389, 555, 500, 500, 833, 778, 278, 333, 333, 500, 570, 250, 333,
	        250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 570, 570,
	        570, 500, 832, 667, 667, 667, 722, 667, 667, 722, 778, 389, 500, 667, 611, 889,
	        722, 722, 611, 722, 667, 556, 611, 722, 667, 889, 667, 611, 611, 333, 278, 333,
	        570, 500, 333, 500, 500, 444, 500, 444, 333, 500, 556, 278, 278, 500, 278, 778,
	        556, 500, 500, 500, 389, 389, 278, 556, 444, 667, 500, 444, 389, 348, 220, 348,
	        570, 0, 500, 0, 333, 500, 500, 1000, 500, 500, 333, 1000, 556, 333, 944, 0,
	        611, 0, 0, 333, 333, 500, 500, 350, 500, 1000, 333, 1000, 389, 333, 722, 0,
	        389, 611, 0, 389, 500, 500, 500, 500, 220, 500, 333, 747, 266, 500, 606, 0,
	        747, 333, 400, 570, 300, 300, 333, 576, 500, 250, 333, 300, 300, 500, 750, 750,
	        750, 500, 667, 667, 667, 667, 667, 667, 944, 667, 667, 667, 667, 667, 389, 389,
	        389, 389, 722, 722, 722, 722, 722, 722, 722, 570, 722, 722, 722, 722, 722, 611,
	        611, 500, 500, 500, 500, 500, 500, 500, 722, 444, 444, 444, 444, 444, 278, 278,
	        278, 278, 500, 556, 500, 500, 500, 500, 500, 570, 500, 556, 556, 556, 556, 444,
	        500, 444
	    ];
	    /**
	     * `Symbol` widths table.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.symbolWidth = [
	        250, 333, 713, 500, 549, 833, 778, 439, 333, 333, 500, 549, 250, 549,
	        250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 278, 278,
	        549, 549, 549, 444, 549, 722, 667, 722, 612, 611, 763, 603, 722, 333,
	        631, 722, 686, 889, 722, 722, 768, 741, 556, 592, 611, 690, 439, 768,
	        645, 795, 611, 333, 863, 333, 658, 500, 500, 631, 549, 549, 494, 439,
	        521, 411, 603, 329, 603, 549, 549, 576, 521, 549, 549, 521, 549, 603,
	        439, 576, 713, 686, 493, 686, 494, 480, 200, 480, 549, 750, 620, 247,
	        549, 167, 713, 500, 753, 753, 753, 753, 1042, 987, 603, 987, 603, 400,
	        549, 411, 549, 549, 713, 494, 460, 549, 549, 549, 549, 1000, 603, 1000,
	        658, 823, 686, 795, 987, 768, 768, 823, 768, 768, 713, 713, 713, 713,
	        713, 713, 713, 768, 713, 790, 790, 890, 823, 549, 250, 713, 603, 603,
	        1042, 987, 603, 987, 603, 494, 329, 790, 790, 786, 713, 384, 384, 384,
	        384, 384, 384, 494, 494, 494, 494, 329, 274, 686, 686, 686, 384, 384,
	        384, 384, 384, 384, 494, 494, 494, -1
	    ];
	    /**
	     * `Zip dingbats` widths table.
	     * @private
	     */
	    PdfStandardFontMetricsFactory.zapfDingbatsWidth = [
	        278, 974, 961, 974, 980, 719, 789, 790, 791, 690, 960, 939, 549, 855,
	        911, 933, 911, 945, 974, 755, 846, 762, 761, 571, 677, 763, 760, 759,
	        754, 494, 552, 537, 577, 692, 786, 788, 788, 790, 793, 794, 816, 823,
	        789, 841, 823, 833, 816, 831, 923, 744, 723, 749, 790, 792, 695, 776,
	        768, 792, 759, 707, 708, 682, 701, 826, 815, 789, 789, 707, 687, 696,
	        689, 786, 787, 713, 791, 785, 791, 873, 761, 762, 762, 759, 759, 892,
	        892, 788, 784, 438, 138, 277, 415, 392, 392, 668, 668, 390, 390, 317,
	        317, 276, 276, 509, 509, 410, 410, 234, 234, 334, 334, 732, 544, 544,
	        910, 667, 760, 760, 776, 595, 694, 626, 788, 788, 788, 788, 788, 788,
	        788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788,
	        788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788,
	        788, 788, 788, 788, 788, 788, 894, 838, 1016, 458, 748, 924, 748, 918,
	        927, 928, 928, 834, 873, 828, 924, 924, 917, 930, 931, 463, 883, 836,
	        836, 867, 867, 696, 696, 874, 874, 760, 946, 771, 865, 771, 888, 967,
	        888, 831, 873, 927, 970, 918
	    ];
	    return PdfStandardFontMetricsFactory;
	}());

	var __extends$e = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Represents one of the 14 standard fonts.
	 * It's used to create a standard PDF font to draw the text in to the PDF.
	 * ```typescript
	 * // create a new PDF document
	 * let document : PdfDocument = new PdfDocument();
	 * // add a new page to the document
	 * let page1 : PdfPage = document.pages.add();
	 * //
	 * // create new standard font
	 * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
	 * //
	 * // create black brush
	 * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
	 * // draw the text
	 * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
	 * // save the document
	 * document.save('output.pdf');
	 * // destroy the document
	 * document.destroy();
	 * ```
	 */
	var PdfStandardFont = /** @class */ (function (_super) {
	    __extends$e(PdfStandardFont, _super);
	    function PdfStandardFont(fontFamilyPrototype, size, style) {
	        var _this = _super.call(this, size, (typeof style === 'undefined') ? ((fontFamilyPrototype instanceof PdfStandardFont) ? fontFamilyPrototype.style : PdfFontStyle.Regular) : style) || this;
	        /**
	         * Gets `ascent` of the font.
	         * @private
	         */
	        _this.dictionaryProperties = new DictionaryProperties();
	        /**
	         * Gets `encodings` for internal class use.
	         * @hidden
	         * @private
	         */
	        _this.encodings = ['Unknown', 'StandardEncoding', 'MacRomanEncoding', 'MacExpertEncoding',
	            'WinAnsiEncoding', 'PDFDocEncoding', 'IdentityH'];
	        if (typeof fontFamilyPrototype === 'undefined') {
	            _this.pdfFontFamily = PdfFontFamily.Helvetica;
	        }
	        else if ((fontFamilyPrototype instanceof PdfStandardFont)) {
	            _this.pdfFontFamily = fontFamilyPrototype.fontFamily;
	        }
	        else {
	            _this.pdfFontFamily = fontFamilyPrototype;
	        }
	        _this.checkStyle();
	        _this.initializeInternals();
	        return _this;
	    }
	    Object.defineProperty(PdfStandardFont.prototype, "fontFamily", {
	        /* tslint:enable */
	        //Properties
	        /**
	         * Gets the `FontFamily`.
	         * @private
	         */
	        get: function () {
	            return this.pdfFontFamily;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //methods
	    /**
	     * Checks font `style` of the font.
	     * @private
	     */
	    PdfStandardFont.prototype.checkStyle = function () {
	        if (this.fontFamily === PdfFontFamily.Symbol || this.fontFamily === PdfFontFamily.ZapfDingbats) {
	            var style = this.style;
	            style &= ~(PdfFontStyle.Bold | PdfFontStyle.Italic);
	            this.setStyle(style);
	        }
	    };
	    /**
	     * Returns `width` of the line.
	     * @public
	     */
	    PdfStandardFont.prototype.getLineWidth = function (line, format) {
	        if (line == null) {
	            throw new Error('ArgumentNullException:line');
	        }
	        var width = 0;
	        this.name;
	        line = PdfStandardFont.convert(line);
	        for (var i = 0, len = line.length; i < len; i++) {
	            var ch = line[i];
	            var charWidth = this.getCharWidthInternal(ch, format);
	            width += charWidth;
	        }
	        var size = this.metrics.getSize(format);
	        width *= (PdfFont.charSizeMultiplier * size);
	        width = this.applyFormatSettings(line, format, width);
	        return width;
	    };
	    /**
	     * Checks whether fonts are `equals`.
	     * @private
	     */
	    PdfStandardFont.prototype.equalsToFont = function (font) {
	        var equal = false;
	        var stFont = font;
	        if (stFont != null) {
	            var fontFamilyEqual = (this.fontFamily === stFont.fontFamily);
	            var lineReducer = (~(PdfFontStyle.Underline | PdfFontStyle.Strikeout));
	            var styleEqual = (this.style & lineReducer) === (stFont.style & lineReducer);
	            equal = (fontFamilyEqual && styleEqual);
	        }
	        return equal;
	    };
	    /**
	     * `Initializes` font internals..
	     * @private
	     */
	    PdfStandardFont.prototype.initializeInternals = function () {
	        // if (PdfDocument.EnableCache) {
	        PdfDocument.cache.search(this);
	        // }
	        var internals = null;
	        // if (equalFont == null) {
	        // Create font metrics.
	        var metrics = PdfStandardFontMetricsFactory.getMetrics(this.pdfFontFamily, this.style, this.size);
	        this.metrics = metrics;
	        internals = this.createInternals();
	        this.setInternals(internals);
	    };
	    /**
	     * `Creates` font`s dictionary.
	     * @private
	     */
	    PdfStandardFont.prototype.createInternals = function () {
	        var dictionary = new PdfDictionary();
	        dictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.font));
	        dictionary.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.type1));
	        dictionary.items.setValue(this.dictionaryProperties.baseFont, new PdfName(this.metrics.postScriptName));
	        if (this.fontFamily !== PdfFontFamily.Symbol && this.fontFamily !== PdfFontFamily.ZapfDingbats) {
	            var encoding = this.encodings[FontEncoding.WinAnsiEncoding];
	            dictionary.items.setValue(this.dictionaryProperties.encoding, new PdfName(encoding));
	        }
	        return dictionary;
	    };
	    /**
	     * Returns `width` of the char. This methods doesn`t takes into consideration font`s size.
	     * @private
	     */
	    PdfStandardFont.prototype.getCharWidthInternal = function (charCode, format) {
	        var width = 0;
	        var code = 0;
	        code = charCode.charCodeAt(0);
	        if (this.name === '0' || this.name === '1' || this.name === '2' ||
	            this.name === '3' || this.name === '4') {
	            code = code - PdfStandardFont.charOffset;
	        }
	        code = (code >= 0 && code !== 128) ? code : 0;
	        var metrics = this.metrics;
	        var widthTable = metrics.widthTable;
	        width = widthTable.items(code);
	        return width;
	    };
	    /**
	     * `Converts` the specified text.
	     * @private
	     */
	    PdfStandardFont.convert = function (text) {
	        return text;
	    };
	    //Constants
	    /**
	     * First character `position`.
	     * @private
	     */
	    PdfStandardFont.charOffset = 32;
	    return PdfStandardFont;
	}(PdfFont));

	/**
	 * PdfPageTemplateElement.ts class for EJ2-Pdf
	 */
	/**
	 * Describes a `page template` object that can be used as header/footer, watermark or stamp.
	 */
	var PdfPageTemplateElement = /** @class */ (function () {
	    /* tslint:disable */
	    function PdfPageTemplateElement(arg1, arg2, arg3, arg4, arg5) {
	        if (arg1 instanceof RectangleF && typeof arg2 === 'undefined') {
	            this.InitiateBounds(arg1.x, arg1.y, arg1.width, arg1.height, null);
	        }
	        else if (arg1 instanceof RectangleF && arg2 instanceof PdfPage && typeof arg3 === 'undefined') {
	            this.InitiateBounds(arg1.x, arg1.y, arg1.width, arg1.height, arg2);
	        }
	        else if (arg1 instanceof PointF && arg2 instanceof SizeF && typeof arg3 === 'undefined') {
	            this.InitiateBounds(arg1.x, arg1.y, arg2.width, arg2.height, null);
	        }
	        else if (arg1 instanceof PointF && arg2 instanceof SizeF && arg3 instanceof PdfPage && typeof arg4 === 'undefined') {
	            this.InitiateBounds(arg1.x, arg1.y, arg2.width, arg2.height, arg3);
	        }
	        else if (arg1 instanceof SizeF && typeof arg2 === 'undefined') {
	            this.InitiateBounds(0, 0, arg1.width, arg1.height, null);
	        }
	        else if (typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'undefined') {
	            this.InitiateBounds(0, 0, arg1, arg2, null);
	        }
	        else if (typeof arg1 === 'number' && typeof arg2 === 'number' && arg3 instanceof PdfPage && typeof arg4 === 'undefined') {
	            this.InitiateBounds(0, 0, arg1, arg2, arg3);
	        }
	        else if (typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number' && typeof arg4 === 'number' && typeof arg5 === 'undefined') {
	            this.InitiateBounds(arg1, arg2, arg3, arg4, null);
	        }
	        else {
	            this.InitiateBounds(arg1, arg2, arg3, arg4, null);
	            // this.graphics.colorSpace = this.page.document.colorSpace;
	        }
	        /* tslint:enable */
	    }
	    Object.defineProperty(PdfPageTemplateElement.prototype, "dock", {
	        // Properties
	        /**
	         * Gets or sets the `dock style` of the page template element.
	         * @private
	         */
	        get: function () {
	            return this.dockStyle;
	        },
	        set: function (value) {
	            // if (this.dockStyle !== value && this.Type === TemplateType.None) {
	            this.dockStyle = value;
	            // Reset alignment.
	            this.resetAlignment();
	            // }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageTemplateElement.prototype, "alignment", {
	        /**
	         * Gets or sets `alignment` of the page template element.
	         * @private
	         */
	        get: function () {
	            return this.alignmentStyle;
	        },
	        set: function (value) {
	            // if (this.alignmentStyle !== value) {
	            this.setAlignment(value);
	            // }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageTemplateElement.prototype, "foreground", {
	        /**
	         * Indicates whether the page template is located `in front of the page layers or behind of it`.
	         * @private
	         */
	        get: function () {
	            return this.isForeground;
	        },
	        set: function (value) {
	            // if (this.foreground !== value) {
	            this.isForeground = value;
	            // }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageTemplateElement.prototype, "background", {
	        /**
	         * Indicates whether the page template is located `behind of the page layers or in front of it`.
	         * @private
	         */
	        get: function () {
	            return !this.isForeground;
	        },
	        set: function (value) {
	            this.isForeground = !value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageTemplateElement.prototype, "location", {
	        /**
	         * Gets or sets `location` of the page template element.
	         * @private
	         */
	        get: function () {
	            return this.currentLocation;
	        },
	        set: function (value) {
	            if (this.type === TemplateType.None) {
	                this.currentLocation = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageTemplateElement.prototype, "x", {
	        /**
	         * Gets or sets `X` co-ordinate of the template element on the page.
	         * @private
	         */
	        get: function () {
	            var value = (typeof this.currentLocation !== 'undefined') ? this.currentLocation.x : 0;
	            return value;
	        },
	        set: function (value) {
	            if (this.type === TemplateType.None) {
	                this.currentLocation.x = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageTemplateElement.prototype, "y", {
	        /**
	         * Gets or sets `Y` co-ordinate of the template element on the page.
	         * @private
	         */
	        get: function () {
	            var value = (typeof this.currentLocation !== 'undefined') ? this.currentLocation.y : 0;
	            return value;
	        },
	        set: function (value) {
	            if (this.type === TemplateType.None) {
	                this.currentLocation.y = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageTemplateElement.prototype, "size", {
	        /**
	         * Gets or sets `size` of the page template element.
	         * @private
	         */
	        get: function () {
	            return this.template.size;
	        },
	        set: function (value) {
	            if (this.type === TemplateType.None) {
	                this.template.reset(value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageTemplateElement.prototype, "width", {
	        /**
	         * Gets or sets `width` of the page template element.
	         * @private
	         */
	        get: function () {
	            return this.template.width;
	        },
	        set: function (value) {
	            if (this.template.width !== value && this.type === TemplateType.None) {
	                var size = this.template.size;
	                size.width = value;
	                this.template.reset(size);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageTemplateElement.prototype, "height", {
	        /**
	         * Gets or sets `height` of the page template element.
	         * @private
	         */
	        get: function () {
	            return this.template.height;
	        },
	        set: function (value) {
	            if (this.template.height !== value && this.type === TemplateType.None) {
	                var size = this.template.size;
	                size.height = value;
	                this.template.reset(size);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageTemplateElement.prototype, "graphics", {
	        /**
	         * Gets `graphics` context of the page template element.
	         * @private
	         */
	        get: function () {
	            return this.template.graphics;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageTemplateElement.prototype, "template", {
	        /**
	         * Gets Pdf `template` object.
	         * @private
	         */
	        get: function () {
	            // if (typeof this.pdfTemplate === 'undefined' || this.pdfTemplate == null) {
	            //     this.pdfTemplate = new PdfTemplate(this.size);
	            // }
	            return this.pdfTemplate;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageTemplateElement.prototype, "type", {
	        /**
	         * Gets or sets `type` of the usage of this page template.
	         * @private
	         */
	        get: function () {
	            return this.templateType;
	        },
	        set: function (value) {
	            this.updateDocking(value);
	            this.templateType = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PdfPageTemplateElement.prototype, "bounds", {
	        /**
	         * Gets or sets `bounds` of the page template.
	         * @public
	         */
	        get: function () {
	            return new RectangleF(new PointF(this.x, this.y), this.size);
	        },
	        set: function (value) {
	            if (this.type === TemplateType.None) {
	                this.location = new PointF(value.x, value.y);
	                this.size = new SizeF(value.width, value.height);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * `Initialize Bounds` Initialize the bounds value of the template.
	     * @private
	     */
	    PdfPageTemplateElement.prototype.InitiateBounds = function (arg1, arg2, arg3, arg4, arg5) {
	        this.x = arg1;
	        this.y = arg2;
	        this.pdfTemplate = new PdfTemplate(arg3, arg4);
	        // this.graphics.colorSpace = this.page.document.colorSpace;
	    };
	    /**
	     * `Updates Dock` property if template is used as header/footer.
	     * @private
	     */
	    PdfPageTemplateElement.prototype.updateDocking = function (type) {
	        if (type !== TemplateType.None) {
	            switch (type) {
	                case TemplateType.Top:
	                    this.dock = PdfDockStyle.Top;
	                    break;
	                case TemplateType.Bottom:
	                    this.dock = PdfDockStyle.Bottom;
	                    break;
	                case TemplateType.Left:
	                    this.dock = PdfDockStyle.Left;
	                    break;
	                case TemplateType.Right:
	                    this.dock = PdfDockStyle.Right;
	                    break;
	            }
	            this.resetAlignment();
	        }
	    };
	    /**
	     * `Resets alignment` of the template.
	     * @private
	     */
	    PdfPageTemplateElement.prototype.resetAlignment = function () {
	        this.alignment = PdfAlignmentStyle.None;
	    };
	    /**
	     * `Sets alignment` of the template.
	     * @private
	     */
	    PdfPageTemplateElement.prototype.setAlignment = function (alignment) {
	        if (this.dock === PdfDockStyle.None) {
	            this.alignmentStyle = alignment;
	        }
	        else {
	            // Template is docked and alignment has been changed.
	            var canBeSet = false;
	            switch (this.dock) {
	                case PdfDockStyle.Left:
	                    canBeSet = (alignment === PdfAlignmentStyle.TopLeft || alignment === PdfAlignmentStyle.MiddleLeft ||
	                        alignment === PdfAlignmentStyle.BottomLeft || alignment === PdfAlignmentStyle.None);
	                    break;
	                case PdfDockStyle.Top:
	                    canBeSet = (alignment === PdfAlignmentStyle.TopLeft || alignment === PdfAlignmentStyle.TopCenter ||
	                        alignment === PdfAlignmentStyle.TopRight || alignment === PdfAlignmentStyle.None);
	                    break;
	                case PdfDockStyle.Right:
	                    canBeSet = (alignment === PdfAlignmentStyle.TopRight || alignment === PdfAlignmentStyle.MiddleRight ||
	                        alignment === PdfAlignmentStyle.BottomRight || alignment === PdfAlignmentStyle.None);
	                    break;
	                case PdfDockStyle.Bottom:
	                    canBeSet = (alignment === PdfAlignmentStyle.BottomLeft || alignment === PdfAlignmentStyle.BottomCenter
	                        || alignment === PdfAlignmentStyle.BottomRight || alignment === PdfAlignmentStyle.None);
	                    break;
	                case PdfDockStyle.Fill:
	                    canBeSet = (alignment === PdfAlignmentStyle.MiddleCenter || alignment === PdfAlignmentStyle.None);
	                    break;
	            }
	            if (canBeSet) {
	                this.alignmentStyle = alignment;
	            }
	        }
	    };
	    /**
	     * Draws the template.
	     * @private
	     */
	    PdfPageTemplateElement.prototype.draw = function (layer, document) {
	        var page = layer.page;
	        var bounds = this.calculateBounds(page, document);
	        if (bounds.x === -0) {
	            bounds.x = 0;
	        }
	        layer.graphics.drawPdfTemplate(this.template, new PointF(bounds.x, bounds.y), new SizeF(bounds.width, bounds.height));
	    };
	    /**
	     * Calculates bounds of the page template.
	     * @private
	     */
	    PdfPageTemplateElement.prototype.calculateBounds = function (page, document) {
	        var result = this.bounds;
	        if (this.alignmentStyle !== PdfAlignmentStyle.None) {
	            result = this.getAlignmentBounds(page, document);
	        }
	        else if (this.dockStyle !== PdfDockStyle.None) {
	            result = this.getDockBounds(page, document);
	        }
	        return result;
	    };
	    /**
	     * Calculates bounds according to the alignment.
	     * @private
	     */
	    PdfPageTemplateElement.prototype.getAlignmentBounds = function (page, document) {
	        var result = this.bounds;
	        if (this.type === TemplateType.None) {
	            result = this.getSimpleAlignmentBounds(page, document);
	        }
	        else {
	            result = this.getTemplateAlignmentBounds(page, document);
	        }
	        return result;
	    };
	    /**
	     * Calculates bounds according to the alignment.
	     * @private
	     */
	    PdfPageTemplateElement.prototype.getSimpleAlignmentBounds = function (page, document) {
	        var bounds = this.bounds;
	        var pdfSection = page.section;
	        var actualBounds = pdfSection.getActualBounds(document, page, false);
	        var x = this.x;
	        var y = this.y;
	        switch (this.alignmentStyle) {
	            case PdfAlignmentStyle.TopLeft:
	                x = 0;
	                y = 0;
	                break;
	            case PdfAlignmentStyle.TopCenter:
	                x = (actualBounds.width - this.width) / 2;
	                y = 0;
	                break;
	            case PdfAlignmentStyle.TopRight:
	                x = actualBounds.width - this.width;
	                y = 0;
	                break;
	            case PdfAlignmentStyle.MiddleLeft:
	                x = 0;
	                y = (actualBounds.height - this.height) / 2;
	                break;
	            case PdfAlignmentStyle.MiddleCenter:
	                x = (actualBounds.width - this.width) / 2;
	                y = (actualBounds.height - this.height) / 2;
	                break;
	            case PdfAlignmentStyle.MiddleRight:
	                x = actualBounds.width - this.width;
	                y = (actualBounds.height - this.height) / 2;
	                break;
	            case PdfAlignmentStyle.BottomLeft:
	                x = 0;
	                y = actualBounds.height - this.height;
	                break;
	            case PdfAlignmentStyle.BottomCenter:
	                x = (actualBounds.width - this.width) / 2;
	                y = actualBounds.height - this.height;
	                break;
	            case PdfAlignmentStyle.BottomRight:
	                x = actualBounds.width - this.width;
	                y = actualBounds.height - this.height;
	                break;
	        }
	        bounds.x = x;
	        bounds.y = y;
	        return bounds;
	    };
	    /**
	     * Calculates bounds according to the alignment.
	     * @private
	     */
	    PdfPageTemplateElement.prototype.getTemplateAlignmentBounds = function (page, document) {
	        var result = this.bounds;
	        var section = page.section;
	        var actualBounds = section.getActualBounds(document, page, false);
	        var x = this.x;
	        var y = this.y;
	        switch (this.alignmentStyle) {
	            case PdfAlignmentStyle.TopLeft:
	                if (this.type === TemplateType.Left) {
	                    x = -actualBounds.x;
	                    y = 0;
	                }
	                else if (this.type === TemplateType.Top) {
	                    x = -actualBounds.x;
	                    y = -actualBounds.y;
	                }
	                break;
	            case PdfAlignmentStyle.TopCenter:
	                x = (actualBounds.width - this.width) / 2;
	                y = -actualBounds.y;
	                break;
	            case PdfAlignmentStyle.TopRight:
	                if (this.type === TemplateType.Right) {
	                    x = actualBounds.width + section.getRightIndentWidth(document, page, false) - this.width;
	                    y = 0;
	                }
	                else if (this.type === TemplateType.Top) {
	                    x = actualBounds.width + section.getRightIndentWidth(document, page, false) - this.width;
	                    y = -actualBounds.y;
	                }
	                break;
	            case PdfAlignmentStyle.MiddleLeft:
	                x = -actualBounds.x;
	                y = (actualBounds.height - this.height) / 2;
	                break;
	            case PdfAlignmentStyle.MiddleCenter:
	                x = (actualBounds.width - this.width) / 2;
	                y = (actualBounds.height - this.height) / 2;
	                break;
	            case PdfAlignmentStyle.MiddleRight:
	                x = actualBounds.width + section.getRightIndentWidth(document, page, false) - this.width;
	                y = (actualBounds.height - this.height) / 2;
	                break;
	            case PdfAlignmentStyle.BottomLeft:
	                if (this.type === TemplateType.Left) {
	                    x = -actualBounds.x;
	                    y = actualBounds.height - this.height;
	                }
	                else if (this.type === TemplateType.Bottom) {
	                    x = -actualBounds.x;
	                    y = actualBounds.height + section.getBottomIndentHeight(document, page, false) - this.height;
	                }
	                break;
	            case PdfAlignmentStyle.BottomCenter:
	                x = (actualBounds.width - this.width) / 2;
	                y = actualBounds.height + section.getBottomIndentHeight(document, page, false) - this.height;
	                break;
	            case PdfAlignmentStyle.BottomRight:
	                if (this.type === TemplateType.Right) {
	                    x = actualBounds.width + section.getRightIndentWidth(document, page, false) - this.width;
	                    y = actualBounds.height - this.height;
	                }
	                else if (this.type === TemplateType.Bottom) {
	                    x = actualBounds.width + section.getRightIndentWidth(document, page, false) - this.width;
	                    y = actualBounds.height + section.getBottomIndentHeight(document, page, false) - this.height;
	                }
	                break;
	        }
	        result.x = x;
	        result.y = y;
	        return result;
	    };
	    /**
	     * Calculates bounds according to the docking.
	     * @private
	     */
	    PdfPageTemplateElement.prototype.getDockBounds = function (page, document) {
	        var result = this.bounds;
	        if (this.type === TemplateType.None) {
	            result = this.getSimpleDockBounds(page, document);
	        }
	        else {
	            result = this.getTemplateDockBounds(page, document);
	        }
	        return result;
	    };
	    /**
	     * Calculates bounds according to the docking.
	     * @private
	     */
	    PdfPageTemplateElement.prototype.getSimpleDockBounds = function (page, document) {
	        var result = this.bounds;
	        var section = page.section;
	        var actualBounds = section.getActualBounds(document, page, false);
	        var x = this.x;
	        var y = this.y;
	        var width = this.width;
	        var height = this.height;
	        switch (this.dockStyle) {
	            case PdfDockStyle.Left:
	                x = 0;
	                y = 0;
	                width = this.width;
	                height = actualBounds.height;
	                break;
	            case PdfDockStyle.Top:
	                x = 0;
	                y = 0;
	                width = actualBounds.width;
	                height = this.height;
	                break;
	            case PdfDockStyle.Right:
	                x = actualBounds.width - this.width;
	                y = 0;
	                width = this.width;
	                height = actualBounds.height;
	                break;
	            case PdfDockStyle.Bottom:
	                x = 0;
	                y = actualBounds.height - this.height;
	                width = actualBounds.width;
	                height = this.height;
	                break;
	            case PdfDockStyle.Fill:
	                x = 0;
	                x = 0;
	                width = actualBounds.width;
	                height = actualBounds.height;
	                break;
	        }
	        result = new RectangleF(x, y, width, height);
	        return result;
	    };
	    /**
	     * Calculates template bounds basing on docking if template is a page template.
	     * @private
	     */
	    PdfPageTemplateElement.prototype.getTemplateDockBounds = function (page, document) {
	        var result = this.bounds;
	        var section = page.section;
	        var actualBounds = section.getActualBounds(document, page, false);
	        var actualSize = section.pageSettings.getActualSize();
	        var x = this.x;
	        var y = this.y;
	        var width = this.width;
	        var height = this.height;
	        switch (this.dockStyle) {
	            case PdfDockStyle.Left:
	                x = -actualBounds.x;
	                y = 0;
	                width = this.width;
	                height = actualBounds.height;
	                break;
	            case PdfDockStyle.Top:
	                x = -actualBounds.x;
	                y = -actualBounds.y;
	                width = actualSize.width;
	                height = this.height;
	                if (actualBounds.height < 0) {
	                    y = -actualBounds.y + actualSize.height;
	                }
	                break;
	            case PdfDockStyle.Right:
	                x = actualBounds.width + section.getRightIndentWidth(document, page, false) - this.width;
	                y = 0;
	                width = this.width;
	                height = actualBounds.height;
	                break;
	            case PdfDockStyle.Bottom:
	                x = -actualBounds.x;
	                y = actualBounds.height + section.getBottomIndentHeight(document, page, false) - this.height;
	                width = actualSize.width;
	                height = this.height;
	                if (actualBounds.height < 0) {
	                    y -= actualSize.height;
	                }
	                break;
	            case PdfDockStyle.Fill:
	                x = 0;
	                x = 0;
	                width = actualBounds.width;
	                height = actualBounds.height;
	                break;
	        }
	        result = new RectangleF(x, y, width, height);
	        return result;
	    };
	    return PdfPageTemplateElement;
	}());

	var ExportUtils = /** @class */ (function () {
	    /**
	     * Constructor for chart and accumulation annotation
	     *
	     * @param control
	     */
	    function ExportUtils(control) {
	        this.control = control;
	    }
	    /**
	     * To print the accumulation and chart elements.
	     *
	     * @param elements
	     */
	    ExportUtils.prototype.print = function (elements) {
	        this.printWindow = window.open('', 'print', 'height=' + window.outerHeight + ',width=' + window.outerWidth + ',tabbar=no');
	        this.printWindow.moveTo(0, 0);
	        this.printWindow.resizeTo(screen.availWidth, screen.availHeight);
	        var argsData = {
	            cancel: false, htmlContent: this.getHTMLContent(elements), name: beforePrint
	        };
	        this.control.trigger(beforePrint, argsData);
	        if (!argsData.cancel) {
	            print(argsData.htmlContent, this.printWindow);
	        }
	    };
	    /**
	     * To get the html string of the chart and accumulation
	     *
	     * @param elements
	     * @private
	     */
	    ExportUtils.prototype.getHTMLContent = function (elements) {
	        var div = createElement('div');
	        if (elements) {
	            if (elements instanceof Array) {
	                for (var j = 0; j < elements.length; j++) {
	                    var value = elements[j];
	                    div.appendChild(getElement(value).cloneNode(true));
	                }
	            }
	            else if (elements instanceof Element) {
	                div.appendChild(elements.cloneNode(true));
	            }
	            else {
	                div.appendChild(getElement(elements).cloneNode(true));
	            }
	        }
	        else {
	            div.appendChild(this.control.element.cloneNode(true));
	        }
	        for (var index = 0; index < div.children.length; index++) {
	            var backgroundColor = (this.control.theme.indexOf('Dark') > -1 || this.control.theme === 'HighContrast') ? 'rgba(0, 0, 0, 1)' : 'rgba(255, 255, 255, 1)';
	            var svg = div.children[index];
	            for (var childIndex = 0; childIndex < svg.children.length; childIndex++) {
	                var actualBackgroundColor = void 0;
	                var isSVG = false;
	                if (svg.id.indexOf('_stockChart_svg') > -1) {
	                    actualBackgroundColor = svg.children[0].getAttribute('fill');
	                    isSVG = true;
	                }
	                else if (svg.children[childIndex].id.indexOf('_svg') > -1) {
	                    actualBackgroundColor = svg.children[childIndex].children[0].getAttribute('fill');
	                    isSVG = true;
	                }
	                if (isSVG) {
	                    actualBackgroundColor = actualBackgroundColor === 'transparent' ? backgroundColor : actualBackgroundColor;
	                    svg.children[childIndex].children[0].setAttribute('fill', actualBackgroundColor);
	                }
	            }
	            div[index] = svg;
	        }
	        return div;
	    };
	    /**
	     * To export the file as image/svg format.
	     *
	     * @param type
	     * @param fileName
	     */
	    ExportUtils.prototype.export = function (type, fileName, orientation, controls, width, height, isVertical, header, footer, exportToMultiplePage) {
	        var _this = this;
	        var controlValue = this.getControlsValue(controls, isVertical, (exportToMultiplePage && type === 'PDF'), type);
	        var canvasElements = [];
	        var controlWidth = [];
	        var controlHeight = [];
	        var isDownload = !(Browser.userAgent.toString().indexOf('HeadlessChrome') > -1);
	        orientation = isNullOrUndefined(orientation) ? PdfPageOrientation.Landscape : orientation;
	        var _loop_1 = function (i) {
	            controlWidth.push(width ? width : controlValue[i].width);
	            controlHeight.push(height ? height : controlValue[i].height);
	            var element = controls[i].svgObject;
	            var isCanvas = controls[i].enableCanvas;
	            var image = void 0;
	            if (!isCanvas) {
	                element = createElement('canvas', {
	                    id: 'ej2-canvas',
	                    attrs: {
	                        'width': controlWidth[i].toString(),
	                        'height': controlHeight[i].toString()
	                    }
	                });
	            }
	            var svgData = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' +
	                controlValue[i].svg.outerHTML +
	                '</svg>';
	            var url = window.URL.createObjectURL(new Blob(type === 'SVG' ? [svgData] :
	                [(new XMLSerializer()).serializeToString(controlValue[i].svg)], { type: 'image/svg+xml' }));
	            if (type === 'SVG') {
	                if (Browser.info.name === 'msie') {
	                    var svg = new Blob([(new XMLSerializer()).serializeToString(controlValue[i].svg)], { type: 'application/octet-stream' });
	                    window.navigator.msSaveOrOpenBlob(svg, fileName + '.' + type.toLocaleLowerCase());
	                }
	                else {
	                    this_1.triggerDownload(fileName, type, url, isDownload);
	                }
	            }
	            else if (Browser.info.name === 'msie') {
	                var canvas = element;
	                if (!isCanvas) {
	                    canvas = this_1.createCanvas();
	                }
	                image = canvas.toDataURL();
	                canvasElements.push(element);
	                if (type === 'PDF') {
	                    if (canvasElements.length === controlValue.length) {
	                        this_1.exportPdf(canvasElements, orientation, controlWidth, controlHeight, isDownload, fileName, header, footer);
	                    }
	                }
	                else {
	                    this_1.doexport(type, image, fileName);
	                }
	            }
	            else {
	                var image_1 = new Image();
	                var ctx_1 = element.getContext('2d');
	                image_1.onload = (function () {
	                    ctx_1.drawImage(image_1, 0, 0);
	                    window.URL.revokeObjectURL(url);
	                    canvasElements.push(element);
	                    if (type === 'PDF') {
	                        if (canvasElements.length === controlValue.length) {
	                            _this.exportPdf(canvasElements, orientation, controlWidth, controlHeight, isDownload, fileName, header, footer);
	                        }
	                    }
	                    else {
	                        if (window.navigator.msSaveOrOpenBlob) {
	                            window.navigator.msSaveOrOpenBlob(element.toBlob(null), fileName + '.' + type.toLocaleLowerCase());
	                        }
	                        else {
	                            _this.triggerDownload(fileName, type, element.toDataURL('image/' + type.toLowerCase()), isDownload);
	                        }
	                    }
	                });
	                image_1.src = url;
	            }
	            if (!isCanvas) {
	                removeElement(document.getElementById(controls[i].element.id + '_canvas'));
	            }
	        };
	        var this_1 = this;
	        for (var i = 0; i < controlValue.length; i++) {
	            _loop_1(i);
	        }
	    };
	    /**
	     * To get data url for charts.
	     *
	     * @param chart
	     */
	    ExportUtils.prototype.getDataUrl = function (chart) {
	        var controlValue = this.getControlsValue([chart]);
	        var element = this.control.svgObject;
	        var isCanvas = this.control.enableCanvas;
	        if (!isCanvas) {
	            element = createElement('canvas', {
	                id: 'ej2-canvas',
	                attrs: {
	                    'width': controlValue[0].width.toString(),
	                    'height': controlValue[0].height.toString()
	                }
	            });
	        }
	        var url = window.URL.createObjectURL(new Blob([(new XMLSerializer()).serializeToString(controlValue[0].svg)], { type: 'image/svg+xml' }));
	        if (Browser.info.name === 'msie') {
	            var canvas = element;
	            if (!isCanvas) {
	                canvas = this.createCanvas();
	            }
	            var argsData = {
	                name: afterExport, cancel: false, dataUrl: element.toDataURL('image/png')
	            };
	            chart.trigger(afterExport, argsData);
	            return { element: canvas, dataUrl: canvas.toDataURL() };
	        }
	        else {
	            var image_2 = new Image();
	            var ctx_2 = element.getContext('2d');
	            image_2.onload = (function () {
	                ctx_2.drawImage(image_2, 0, 0);
	                window.URL.revokeObjectURL(url);
	                var argsData = {
	                    name: afterExport, cancel: false, dataUrl: element.toDataURL('image/png')
	                };
	                chart.trigger(afterExport, argsData);
	                return argsData.dataUrl;
	            });
	            image_2.src = url;
	            return { element: element, blobUrl: url };
	        }
	    };
	    /**
	     * To trigger the download element.
	     *
	     * @param fileName
	     * @param type
	     * @param url
	     */
	    ExportUtils.prototype.triggerDownload = function (fileName, type, url, isDownload) {
	        createElement('a', {
	            attrs: {
	                'download': fileName + '.' + type.toLocaleLowerCase(),
	                'href': url
	            }
	        }).dispatchEvent(new MouseEvent(isDownload ? 'click' : 'move', {
	            view: window,
	            bubbles: false,
	            cancelable: true
	        }));
	    };
	    /**
	     * To get the maximum size value
	     *
	     * @param controls
	     * @param name
	     */
	    // eslint-disable-next-line max-len
	    ExportUtils.prototype.getControlsValue = function (controls, isVertical, isMultiPages, type) {
	        var width = 0;
	        var height = 0;
	        var svgObject = new SvgRenderer('').createSvg({
	            id: 'Svg_Export_Element',
	            width: 200, height: 200
	        });
	        var controlValues = [];
	        var backgroundColor;
	        for (var i = 0; i < controls.length; i++) {
	            var control = controls[i];
	            var isCanvas = control.enableCanvas;
	            var svg = control.svgObject.cloneNode(true);
	            var groupEle = control.renderer.createGroup({
	                style: (isNullOrUndefined(isVertical) || isVertical) ? 'transform: translateY(' + height + 'px)' :
	                    'transform: translateX(' + width + 'px)'
	            });
	            backgroundColor = svg.childNodes[0] ? svg.childNodes[0].getAttribute('fill') : 'transparent';
	            if (backgroundColor === 'transparent') {
	                if (control.theme.indexOf('Dark') > -1 || control.theme === 'HighContrast') {
	                    backgroundColor = 'rgba(0, 0, 0, 1)';
	                }
	                else {
	                    backgroundColor = 'rgba(255, 255, 255, 1)';
	                }
	            }
	            if (!isCanvas) {
	                if (control.getModuleName() === 'stockChart') {
	                    svg.childNodes[0].firstChild.setAttribute('fill', backgroundColor);
	                    for (var index = 1; index < svg.childNodes.length; index++) {
	                        svg.childNodes[index].childNodes[0].setAttribute('fill', backgroundColor);
	                    }
	                }
	                else if (type === 'SVG') {
	                    svg.childNodes[0].setAttribute('fill', backgroundColor);
	                }
	                groupEle.appendChild(svg);
	            }
	            var top_1 = 0;
	            var left = 0;
	            if (control.stockLegendModule && control.legendSettings.visible) {
	                if (control.legendSettings.position === 'Bottom' || control.legendSettings.position === 'Top'
	                    || control.legendSettings.position === 'Auto') {
	                    top_1 += control.stockLegendModule.legendBounds.height;
	                }
	                else if (control.legendSettings.position === 'Left' || control.legendSettings.position === 'Right') {
	                    left += control.stockLegendModule.legendBounds.width;
	                }
	            }
	            width = (isNullOrUndefined(isVertical) || isVertical) ? Math.max(control.availableSize.width + left, width) :
	                width + control.availableSize.width + left;
	            height = (isNullOrUndefined(isVertical) || isVertical) ? height + control.availableSize.height + top_1 :
	                Math.max(control.availableSize.height + top_1, height);
	            if (!isCanvas) {
	                svgObject.appendChild(groupEle);
	            }
	            if (isMultiPages || i === controls.length - 1) {
	                if ((!isMultiPages && !(this.control.enableCanvas)) || (isMultiPages && !isCanvas)) {
	                    svgObject.setAttribute('width', width + '');
	                    svgObject.setAttribute('height', height + '');
	                    svgObject.setAttribute('style', 'background-color: ' + backgroundColor + ';');
	                }
	                controlValues.push({
	                    'width': width,
	                    'height': height,
	                    'svg': svgObject
	                });
	            }
	            if (isMultiPages && (i < controls.length)) {
	                width = 0;
	                height = 0;
	                svgObject = new SvgRenderer('').createSvg({
	                    id: 'Svg_Export_Element',
	                    width: 200, height: 200
	                });
	            }
	        }
	        return controlValues;
	    };
	    ExportUtils.prototype.createCanvas = function () {
	        var chart = this.control;
	        this.canvasRender(true, chart);
	        var canvas = chart.svgObject;
	        this.canvasRender(false, chart);
	        return canvas;
	    };
	    /**
	     * To convert svg chart into canvas chart to fix export issue in IE
	     * We cant export svg to other formats in IE
	     *
	     * @param enableCanvas
	     * @param chart
	     * @param enableCanvas
	     * @param chart
	     */
	    ExportUtils.prototype.canvasRender = function (enableCanvas, chart) {
	        chart.enableCanvas = enableCanvas;
	        chart['preRender']();
	        chart['render']();
	    };
	    // eslint-disable-next-line max-len
	    ExportUtils.prototype.exportPdf = function (element, orientation, width, height, isDownload, fileName, header, footer) {
	        var document = new PdfDocument();
	        var margin = document.pageSettings.margins;
	        var pdfDefaultWidth = document.pageSettings.width;
	        var pdfDefaultHeight = document.pageSettings.height;
	        for (var i = 0; element.length > i; i++) {
	            var imageString = element[i].toDataURL('image/jpeg').replace('image/jpeg', 'image/octet-stream');
	            document.pageSettings.orientation = orientation;
	            var exactWidth = (pdfDefaultWidth < width[i]) ? (width[i] + margin.left + margin.right) : pdfDefaultWidth;
	            var exactHeight = (pdfDefaultHeight < height[i]) ? (height[i] + margin.top + margin.bottom) : pdfDefaultHeight;
	            if (header !== undefined) {
	                var font = new PdfStandardFont(1, header.fontSize || 15);
	                var pdfHeader = new PdfPageTemplateElement(exactWidth, 40);
	                pdfHeader.graphics.drawString(header.content + '', font, null, new PdfSolidBrush(new PdfColor(0, 0, 0)), header.x, header.y, null);
	                document.template.top = pdfHeader;
	            }
	            if (footer !== undefined) {
	                var font = new PdfStandardFont(1, footer.fontSize || 15);
	                var pdfFooter = new PdfPageTemplateElement(exactWidth, 40);
	                pdfFooter.graphics.drawString(footer.content + '', font, null, new PdfSolidBrush(new PdfColor(0, 0, 0)), footer.x, footer.y, null);
	                document.template.bottom = pdfFooter;
	            }
	            document.pageSettings.size = new SizeF(exactWidth, exactHeight);
	            imageString = imageString.slice(imageString.indexOf(',') + 1);
	            document.pages.add().graphics.drawImage(new PdfBitmap(imageString), 0, 0, width[i], height[i]);
	        }
	        if (isDownload) {
	            document.save(fileName + '.pdf');
	            document.destroy();
	        }
	    };
	    ExportUtils.prototype.doexport = function (type, image, fileName) {
	        var images = [];
	        var fileType = type || 'JPG';
	        images = [image];
	        this.exportImage(images, fileName, fileType, image);
	    };
	    ExportUtils.prototype.exportImage = function (images, fileName, fileType, image) {
	        var buffers = [];
	        var length = (!(images instanceof HTMLElement)) ? images.length : 0;
	        for (var g = 0; g < length; g++) {
	            image = images[g];
	            image = image.replace(/^data:[a-z]*;,/, '');
	            var image1 = image.split(',');
	            var byteString = atob(image1[1]);
	            var buffer = new ArrayBuffer(byteString.length);
	            var intArray = new Uint8Array(buffer);
	            for (var i = 0; i < byteString.length; i++) {
	                intArray[i] = byteString.charCodeAt(i);
	            }
	            buffers.push(buffer);
	        }
	        for (var j = 0; j < buffers.length; j++) {
	            var b = new Blob([buffers[j]], { type: 'application/octet-stream' });
	            if (Browser.info.name === 'msie') {
	                window.navigator.msSaveOrOpenBlob(b, fileName + '.' + fileType.toLocaleLowerCase());
	            }
	        }
	    };
	    return ExportUtils;
	}());

	var __extends$d = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	/**
	 * Configures the RangeColorSetting in the chart.
	 */
	var RangeColorSetting = /** @class */ (function (_super) {
	    __extends$d(RangeColorSetting, _super);
	    function RangeColorSetting() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate([
	        Property()
	    ], RangeColorSetting.prototype, "start", void 0);
	    __decorate([
	        Property()
	    ], RangeColorSetting.prototype, "end", void 0);
	    __decorate([
	        Property([])
	    ], RangeColorSetting.prototype, "colors", void 0);
	    __decorate([
	        Property('')
	    ], RangeColorSetting.prototype, "label", void 0);
	    return RangeColorSetting;
	}(ChildProperty));
	/**
	 * Configures the crosshair in the chart.
	 */
	var CrosshairSettings = /** @class */ (function (_super) {
	    __extends$d(CrosshairSettings, _super);
	    function CrosshairSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate([
	        Property(false)
	    ], CrosshairSettings.prototype, "enable", void 0);
	    __decorate([
	        Property('')
	    ], CrosshairSettings.prototype, "dashArray", void 0);
	    __decorate([
	        Complex({ color: null, width: 1 }, Border)
	    ], CrosshairSettings.prototype, "line", void 0);
	    __decorate([
	        Property('Both')
	    ], CrosshairSettings.prototype, "lineType", void 0);
	    __decorate([
	        Property('')
	    ], CrosshairSettings.prototype, "verticalLineColor", void 0);
	    __decorate([
	        Property('')
	    ], CrosshairSettings.prototype, "horizontalLineColor", void 0);
	    __decorate([
	        Property(1)
	    ], CrosshairSettings.prototype, "opacity", void 0);
	    return CrosshairSettings;
	}(ChildProperty));
	/**
	 * Configures the zooming behavior for the chart.
	 */
	var ZoomSettings = /** @class */ (function (_super) {
	    __extends$d(ZoomSettings, _super);
	    function ZoomSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate([
	        Property(false)
	    ], ZoomSettings.prototype, "enableSelectionZooming", void 0);
	    __decorate([
	        Property(false)
	    ], ZoomSettings.prototype, "enablePinchZooming", void 0);
	    __decorate([
	        Property(false)
	    ], ZoomSettings.prototype, "showToolbar", void 0);
	    __decorate([
	        Property(false)
	    ], ZoomSettings.prototype, "enableMouseWheelZooming", void 0);
	    __decorate([
	        Property(true)
	    ], ZoomSettings.prototype, "enableDeferredZooming", void 0);
	    __decorate([
	        Property('XY')
	    ], ZoomSettings.prototype, "mode", void 0);
	    __decorate([
	        Property(['Zoom', 'ZoomIn', 'ZoomOut', 'Pan', 'Reset'])
	    ], ZoomSettings.prototype, "toolbarItems", void 0);
	    __decorate([
	        Property(false)
	    ], ZoomSettings.prototype, "enablePan", void 0);
	    __decorate([
	        Property(false)
	    ], ZoomSettings.prototype, "enableScrollbar", void 0);
	    return ZoomSettings;
	}(ChildProperty));
	/**
	 * Configures the borders in the chart title.
	 */
	var titleBorder = /** @class */ (function (_super) {
	    __extends$d(titleBorder, _super);
	    function titleBorder() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate([
	        Property('transparent')
	    ], titleBorder.prototype, "color", void 0);
	    __decorate([
	        Property(0)
	    ], titleBorder.prototype, "width", void 0);
	    __decorate([
	        Property(0.8)
	    ], titleBorder.prototype, "cornerRadius", void 0);
	    return titleBorder;
	}(ChildProperty));
	var titleSettings = /** @class */ (function (_super) {
	    __extends$d(titleSettings, _super);
	    function titleSettings() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    __decorate([
	        Property('Normal')
	    ], titleSettings.prototype, "fontStyle", void 0);
	    __decorate([
	        Property('15px')
	    ], titleSettings.prototype, "size", void 0);
	    __decorate([
	        Property('500')
	    ], titleSettings.prototype, "fontWeight", void 0);
	    __decorate([
	        Property('')
	    ], titleSettings.prototype, "color", void 0);
	    __decorate([
	        Property('Center')
	    ], titleSettings.prototype, "textAlignment", void 0);
	    __decorate([
	        Property('Segoe UI')
	    ], titleSettings.prototype, "fontFamily", void 0);
	    __decorate([
	        Property(1)
	    ], titleSettings.prototype, "opacity", void 0);
	    __decorate([
	        Property('Wrap')
	    ], titleSettings.prototype, "textOverflow", void 0);
	    __decorate([
	        Property('Top')
	    ], titleSettings.prototype, "position", void 0);
	    __decorate([
	        Property(0)
	    ], titleSettings.prototype, "x", void 0);
	    __decorate([
	        Property(0)
	    ], titleSettings.prototype, "y", void 0);
	    __decorate([
	        Property('transparent')
	    ], titleSettings.prototype, "background", void 0);
	    __decorate([
	        Complex({}, titleBorder)
	    ], titleSettings.prototype, "border", void 0);
	    return titleSettings;
	}(ChildProperty));
	/**
	 * Represents the Chart control.
	 * ```html
	 * <div id="chart"/>
	 * <script>
	 *   var chartObj = new Chart({ isResponsive : true });
	 *   chartObj.appendTo("#chart");
	 * </script>
	 * ```
	 *
	 * @public
	 */
	var Chart = /** @class */ (function (_super) {
	    __extends$d(Chart, _super);
	    /**
	     * Constructor for creating the widget
	     *
	     * @hidden
	     */
	    function Chart(options, element) {
	        var _this = _super.call(this, options, element) || this;
	        /** @private */
	        _this.rotatedDataLabelCollections = [];
	        /** @public */
	        _this.animated = false;
	        /** @private */
	        _this.isPointMouseDown = false;
	        /** @private */
	        _this.isScrolling = false;
	        /** @private */
	        _this.checkResize = 0;
	        /** @private */
	        _this.visible = 0;
	        /** @private */
	        _this.clickCount = 0;
	        /** @private */
	        _this.maxPointCount = 0;
	        /** @private */
	        _this.singleClickTimer = 0;
	        /** @private */
	        _this.chartAreaType = 'Cartesian';
	        /** @private */
	        _this.isRtlEnabled = false;
	        /** @private */
	        _this.scaleX = 1;
	        /** @private */
	        _this.scaleY = 1;
	        _this.isCrosshair = true;
	        _this.chartid = 57723;
	        /** @private */
	        _this.isLegendClicked = false;
	        _this.isZoomed = false;
	        _this.previousTargetId = '';
	        _this.currentPointIndex = 0;
	        _this.currentSeriesIndex = 0;
	        _this.currentLegendIndex = 0;
	        _this.previousPageX = null;
	        _this.previousPageY = null;
	        _this.allowPan = false;
	        setValue('mergePersistData', _this.mergePersistChartData, _this);
	        return _this;
	    }
	    /**
	     * To manage persist chart data
	     */
	    Chart.prototype.mergePersistChartData = function () {
	        var data = window.localStorage.getItem(this.getModuleName() + this.element.id);
	        if (!(isNullOrUndefined(data) || (data === ''))) {
	            var dataObj = JSON.parse(data);
	            var keys = Object.keys(dataObj);
	            this.isProtectedOnChange = true;
	            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
	                var key = keys_1[_i];
	                if ((typeof this[key] === 'object') && !isNullOrUndefined(this[key])) {
	                    extend(this[key], dataObj[key]);
	                }
	                else {
	                    this[key] = dataObj[key];
	                }
	            }
	            this.isProtectedOnChange = false;
	        }
	    };
	    /**
	     *
	     * @param elementId
	     * Return the proper ID when the special character exist in the ID
	     */
	    Chart.prototype.isIdHasSpecialCharacter = function (elementId) {
	        var regex = /^[A-Za-z ]+$/;
	        var numberRegex = /^[0-9 ]+$/;
	        var childElementId = '';
	        if (!regex.test(elementId)) {
	            var start = 0;
	            if (numberRegex.test(elementId[0])) {
	                childElementId += ('\\3' + elementId[0]);
	                start = 1;
	            }
	            for (var i = start; i < elementId.length; i++) {
	                if (!regex.test(elementId[i]) && elementId.indexOf('-') === -1 &&
	                    elementId.indexOf('_') === -1 && elementId.indexOf('\\') === -1 && !numberRegex.test(elementId[i])) {
	                    childElementId += ('\\' + elementId[i]);
	                }
	                else {
	                    childElementId += elementId[i];
	                }
	            }
	            return childElementId;
	        }
	        else {
	            return elementId;
	        }
	    };
	    /**
	     * Initialize the event handler.
	     */
	    Chart.prototype.preRender = function () {
	        this.element.id = this.isIdHasSpecialCharacter(this.element.id);
	        // It is used for checking blazor framework or not.
	        var blazor = 'Blazor';
	        this.isBlazor = window[blazor];
	        this.allowServerDataBinding = false;
	        this.markerIndex = 0;
	        this.unWireEvents();
	        this.initPrivateVariable();
	        this.setCulture();
	        this.wireEvents();
	        if (this.stockChart) {
	            if (this.stockChart.tooltip.header === null) {
	                this.tooltip.header = '<b>${point.x}</b>';
	            }
	            if (this.stockChart.tooltip.format === null) {
	                this.tooltip.format = 'High : <b>${point.high}</b><br/>Low :' +
	                    ' <b>${point.low}</b><br/>Open : <b>${point.open}</b><br/>Close : <b>${point.close}</b>';
	            }
	        }
	        this.element.setAttribute('dir', this.enableRtl ? 'rtl' : '');
	    };
	    Chart.prototype.initPrivateVariable = function () {
	        this.animateSeries = true;
	        this.delayRedraw = false;
	        this.dragY = null;
	        this.horizontalAxes = [];
	        this.verticalAxes = [];
	        this.refreshAxis();
	        this.refreshDefinition(this.rows);
	        this.refreshDefinition(this.columns);
	        if (this.tooltipModule) {
	            this.tooltipModule.previousPoints = [];
	        }
	        this.element.setAttribute('role', 'region');
	        this.element.setAttribute('tabindex', '0');
	        this.element.setAttribute('aria-label', this.description || this.title + '. Syncfusion interactive chart.');
	        if (!(this.element.classList.contains("e-chart-focused"))) {
	            this.element.setAttribute('class', this.element.getAttribute('class') + ' e-chart-focused');
	        }
	        if (this.element.id === '') {
	            var collection = document.getElementsByClassName('e-chart').length;
	            this.element.id = 'chart_' + this.chartid + '_' + collection;
	        }
	        //seperate ID to differentiate chart and stock chart
	        this.svgId = this.stockChart ? this.stockChart.element.id + '_stockChart_chart' :
	            this.element.id + (this.enableCanvas ? '_canvas' : '_svg');
	    };
	    /**
	     * To Initialize the control rendering.
	     */
	    Chart.prototype.render = function () {
	        var _this = this;
	        this.svgRenderer = new SvgRenderer(this.element.id);
	        var loadEventData = {
	            chart: this.isBlazor ? {} : this, theme: this.theme, name: load, cancel: false
	        };
	        if (!this.stockChart) {
	            /**
	             * Load event for the chart will be triggered only chart componet, if this is stock chart, load event did not triggered.
	             */
	            this.trigger(load, loadEventData, function () {
	                if (!loadEventData.cancel) {
	                    _this.cartesianChartRendering(loadEventData);
	                }
	            });
	        }
	        else {
	            // The fix is specific for nextjs app, as window is set as not defined for server side application like nextjs.
	            this.isRtlEnabled = (window.getComputedStyle(document.querySelector('body')).direction === 'rtl');
	            this.cartesianChartRendering(loadEventData);
	        }
	        this.applyZoomkit();
	    };
	    Chart.prototype.cartesianChartRendering = function (beforeRenderData) {
	        this.theme = this.isBlazor ? beforeRenderData.theme : this.theme;
	        this.setTheme();
	        this.createChartSvg();
	        this.markerRender = new Marker(this);
	        this.calculateAreaType();
	        this.calculateVisibleSeries();
	        this.initTechnicalIndicators();
	        this.initTrendLines();
	        this.calculateVisibleAxis();
	        this.processData();
	        this.renderComplete();
	        this.mouseMoveEvent();
	        this.allowServerDataBinding = true;
	    };
	    /**
	     * Gets the localized label by locale keyword.
	     *
	     * @param  {string} key key
	     * @returns {string} localized label
	     */
	    Chart.prototype.getLocalizedLabel = function (key) {
	        return this.localeObject.getConstant(key);
	    };
	    /**
	     * Animate the series bounds.
	     *
	     * @private
	     */
	    Chart.prototype.animate = function (duration) {
	        this.redraw = true;
	        this.animated = true; //used to set duration as 1000 for animation at default 300
	        this.duration = duration ? duration : 1000;
	    };
	    /**
	     * Refresh the chart bounds.
	     *
	     * @private
	     */
	    Chart.prototype.refreshBound = function () {
	        this.rotatedDataLabelCollections = [];
	        if (this.legendModule && this.legendSettings.visible) {
	            this.legendModule.getLegendOptions(this.visibleSeries, this);
	        }
	        /**
	         * I264230, EJ2-36761
	         * Issue: Tooltip doesnot appears after zooming and hovering on same point
	         * Root cause: While performing zoom, previous points in tooltip restore.
	         * Fix: previous points set to empty array
	         */
	        if (this.tooltip.enable && this.tooltipModule) {
	            this.tooltipModule.previousPoints = [];
	        }
	        this.calculateStackValues();
	        this.calculateBounds();
	        //this prevents the initial rendering of stock chart
	        if (this.stockChart && !this.stockChart.rangeFound) {
	            if (this.stockChart.enablePeriodSelector || this.stockChart.enableSelector) {
	                return null;
	            }
	        }
	        this.renderElements();
	        removeElement('chartmeasuretext');
	        this.removeSelection();
	        if (this.markerRender) {
	            this.markerRender.mergeXvalues(this.visibleSeries);
	        }
	    };
	    /**
	     * To calcualte the stack values
	     */
	    Chart.prototype.calculateStackValues = function () {
	        var series;
	        var isCalculateStacking = false;
	        for (var i = 0, len = this.visibleSeries.length; i < len; i++) {
	            series = this.visibleSeries[i];
	            series.position = series.rectCount = undefined;
	            if (((series.type.indexOf('Stacking') !== -1) || (series.drawType.indexOf('Stacking') !== -1
	                && this.chartAreaType === 'PolarRadar')) && !isCalculateStacking) {
	                series.calculateStackedValue(series.type.indexOf('100') > -1, this);
	                isCalculateStacking = true;
	            }
	        }
	    };
	    Chart.prototype.removeSelection = function () {
	        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
	            var series = _a[_i];
	            if (series.visible) {
	                for (var _b = 0, _c = series.points; _b < _c.length; _b++) {
	                    var point = _c[_b];
	                    point.isSelect = false;
	                }
	            }
	        }
	        if (getElement(this.element.id + '_ej2_drag_multi_group')) {
	            if (this.selectionMode.indexOf('Drag') > -1) {
	                this.selectionModule.filterArray = [];
	            }
	            removeElement(this.element.id + '_ej2_drag_multi_group');
	            this.selectionModule.calculateDragSelectedElements(this, new Rect(0, 0, 0, 0), true);
	        }
	        else if (getElement(this.element.id + '_ej2_drag_group')) {
	            if (this.selectionMode !== 'Lasso') {
	                this.selectionModule.filterArray = [];
	            }
	            removeElement(this.element.id + '_ej2_drag_group');
	            this.selectionModule.calculateDragSelectedElements(this, new Rect(0, 0, 0, 0), true);
	        }
	    };
	    Chart.prototype.renderElements = function () {
	        this.renderBorder();
	        this.renderTitle();
	        this.renderAreaBorder();
	        this.renderSeriesElements(this.renderAxes());
	        this.renderLegend();
	        this.applyZoomkit();
	        this.performSelection();
	        this.setSecondaryElementPosition();
	        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
	            var value = _a[_i];
	            updateBlazorTemplate(this.element.id + '_DataLabel', 'Template', value.marker.dataLabel);
	        }
	        this.renderAnnotation();
	    };
	    /**
	     * To render the legend
	     *
	     * @private
	     */
	    Chart.prototype.renderAxes = function () {
	        this.yAxisElements = this.renderer.createGroup({ id: this.element.id + 'yAxisCollection' });
	        var axisElement;
	        if (this.rows.length > 0 && this.columns.length > 0) {
	            axisElement = this.chartAxisLayoutPanel.renderAxes();
	        }
	        if (this.stripLineModule) {
	            this.stripLineModule.renderStripLine(this, 'Behind', this.axisCollections);
	        }
	        return axisElement;
	    };
	    /**
	     * To render the legend
	     */
	    Chart.prototype.renderLegend = function () {
	        if (this.legendModule && this.legendModule.legendCollections.length && this.legendSettings.visible) {
	            this.legendModule.calTotalPage = true;
	            var borderWidth = this.legendSettings.border.width;
	            var bounds = this.legendModule.legendBounds;
	            var rect = new Rect(bounds.x, bounds.y, bounds.width, bounds.height);
	            if (this.enableCanvas) {
	                rect = new Rect(rect.x - borderWidth / 2, rect.y - borderWidth / 2, rect.width + borderWidth, rect.height + borderWidth);
	                this.renderer.canvasClip(rect);
	            }
	            this.legendModule.renderLegend(this, this.legendSettings, bounds);
	            if (this.enableCanvas) {
	                this.renderer.canvasRestore();
	            }
	        }
	        if (!this.redraw) {
	            if (!this.stockChart) {
	                this.element.appendChild(this.svgObject);
	            }
	            else {
	                if (!getElement(this.stockChart.chartObject.id)) {
	                    this.stockChart.mainObject.appendChild(this.svgObject);
	                }
	            }
	        }
	    };
	    /**
	     * To set the left and top position for data label template for center aligned chart
	     */
	    Chart.prototype.setSecondaryElementPosition = function () {
	        var element = getElement(this.element.id + '_Secondary_Element');
	        if (!element) {
	            return;
	        }
	        var rect = this.element.getBoundingClientRect();
	        var svgRect = getElement(this.svgId).getBoundingClientRect();
	        element.style.left = Math.max(svgRect.left - rect.left, 0) + 'px';
	        element.style.top = Math.max(svgRect.top - rect.top, 0) + 'px';
	    };
	    Chart.prototype.initializeModuleElements = function () {
	        this.dataLabelCollections = [];
	        var elementId = this.element.id;
	        if (this.series.length) {
	            this.seriesElements = this.svgRenderer.createGroup({ id: elementId + 'SeriesCollection' });
	        }
	        if (this.indicators.length) {
	            this.indicatorElements = this.renderer.createGroup({ id: elementId + 'IndicatorCollection' });
	        }
	        if (this.hasTrendlines()) {
	            this.trendLineElements = this.renderer.createGroup({ id: elementId + 'TrendLineCollection' });
	        }
	        this.dataLabelElements = this.renderer.createGroup({ id: elementId + 'DataLabelCollection' });
	    };
	    Chart.prototype.hasTrendlines = function () {
	        var isTrendline;
	        for (var _i = 0, _a = this.series; _i < _a.length; _i++) {
	            var series = _a[_i];
	            isTrendline = series.trendlines.length ? true : false;
	            if (isTrendline) {
	                break;
	            }
	        }
	        return isTrendline;
	    };
	    Chart.prototype.renderSeriesElements = function (axisElement) {
	        // Initialize the series elements values
	        this.initializeModuleElements();
	        var elementId = this.element.id;
	        if (this.element.tagName !== 'g') {
	            var tooltipDiv = redrawElement(this.redraw, elementId + '_Secondary_Element') ||
	                this.createElement('div');
	            tooltipDiv.id = elementId + '_Secondary_Element';
	            tooltipDiv.style.cssText = 'position: relative';
	            appendChildElement(false, this.element, tooltipDiv, this.redraw);
	        }
	        // For canvas
	        if (this.enableCanvas) {
	            var tooltipdiv = document.getElementById(elementId + '_Secondary_Element');
	            tooltipdiv = !tooltipdiv ? this.createElement('div', { id: elementId + '_Secondary_Element',
	                attrs: { 'style': 'position: relative; left:0px; top:0px' } }) : tooltipdiv;
	            var svg = this.svgRenderer.createSvg({
	                id: elementId + '_tooltip_svg',
	                width: this.availableSize.width,
	                height: this.availableSize.height
	            });
	            svg.style.cssText = 'position: absolute; pointer-events: none';
	            tooltipdiv.appendChild(svg);
	        }
	        // For userInteraction
	        if (this.tooltip.enable) {
	            appendChildElement(this.enableCanvas, this.svgObject, this.renderer.createGroup({ id: elementId + '_UserInteraction', style: 'pointer-events:none;' }), this.redraw);
	        }
	        if (this.rows.length > 0 && this.columns.length > 0) {
	            this.initializeIndicator();
	            this.initializeTrendLine();
	            this.renderSeries();
	            // Trendline is append to DOM after the series
	            if (this.trendLineElements) {
	                appendChildElement(this.enableCanvas, this.svgObject, this.trendLineElements, this.redraw);
	            }
	            this.appendElementsAfterSeries(axisElement);
	        }
	    };
	    /**
	     * @private
	     */
	    Chart.prototype.renderSeries = function () {
	        var visibility;
	        if (this.enableCanvas) {
	            // To clip the series rect for canvas
	            this.renderer.canvasClip(this.chartAxisLayoutPanel.seriesClipRect);
	        }
	        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
	            var item = _a[_i];
	            if (item.category === 'TrendLine') {
	                visibility = this.series[item.sourceIndex].trendlines[item.index].visible;
	            }
	            else {
	                visibility = item.visible;
	            }
	            if (visibility) {
	                this.visible++;
	                findClipRect(item, this.enableCanvas);
	                if (this.enableCanvas) {
	                    // To render scatter and bubble series in canvas
	                    this.renderCanvasSeries(item);
	                }
	                item.renderSeries(this);
	            }
	        }
	        if (this.enableCanvas) {
	            this.renderer.canvasRestore();
	        }
	        this.visible = 0;
	        var options = {
	            'id': this.element.id + '_ChartAreaClipRect_',
	            'x': this.chartAxisLayoutPanel.seriesClipRect.x,
	            'y': this.chartAxisLayoutPanel.seriesClipRect.y,
	            'width': this.chartAxisLayoutPanel.seriesClipRect.width,
	            'height': this.chartAxisLayoutPanel.seriesClipRect.height,
	            'fill': 'transparent',
	            'stroke-width': 1,
	            'stroke': 'Gray'
	        };
	        if (!this.seriesElements) {
	            return;
	        }
	        var clipRectElement;
	        if (this.chartAreaType === 'PolarRadar') {
	            clipRectElement = appendClipElement(this.redraw, options, this.renderer, 'drawCircularClipPath');
	        }
	        else {
	            clipRectElement = appendClipElement(this.redraw, options, this.renderer);
	        }
	        if (!this.enableCanvas) {
	            this.seriesElements.appendChild(clipRectElement);
	        }
	        var seriesSvg = document.getElementById(this.element.id + '_series_svg');
	        if (seriesSvg) {
	            appendChildElement(false, seriesSvg, this.seriesElements, this.redraw);
	        }
	        else {
	            appendChildElement(this.enableCanvas, this.svgObject, this.seriesElements, this.redraw);
	        }
	    };
	    Chart.prototype.renderCanvasSeries = function (item) {
	        var svgElement;
	        // eslint-disable-next-line prefer-const
	        svgElement = (this.enableCanvas) ?
	            svgElement : this.svgObject;
	        (this.enableCanvas) ?
	            false : this.enableCanvas;
	    };
	    Chart.prototype.initializeIndicator = function () {
	        for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {
	            var indicator = _a[_i];
	            if (this[firstToLowerCase(indicator.type) + 'IndicatorModule']) {
	                this[firstToLowerCase(indicator.type) + 'IndicatorModule'].createIndicatorElements(this, indicator, indicator.index);
	            }
	        }
	        if (this.indicatorElements) {
	            appendChildElement(this.enableCanvas, this.svgObject, this.indicatorElements, this.redraw);
	        }
	    };
	    Chart.prototype.initializeTrendLine = function () {
	        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
	            var series = _a[_i];
	            if (series.trendlines.length) {
	                this.trendLineModule.getTrendLineElements(series, this);
	            }
	        }
	    };
	    Chart.prototype.appendElementsAfterSeries = function (axisElement) {
	        if (this.chartAreaType === 'PolarRadar') {
	            appendChildElement(this.enableCanvas, this.svgObject, this.yAxisElements, this.redraw);
	        }
	        appendChildElement(this.enableCanvas, this.svgObject, axisElement, this.redraw);
	        if ((this.zoomModule && this.zoomSettings.enableScrollbar && this.scrollElement.childElementCount) ||
	            (this.scrollElement && this.scrollElement.childElementCount)) {
	            appendChildElement(false, getElement(this.element.id + '_Secondary_Element'), this.scrollElement, this.redraw);
	        }
	        if (this.stripLineModule) {
	            this.stripLineModule.renderStripLine(this, 'Over', this.axisCollections);
	        }
	        if (!this.tooltip.enable) {
	            appendChildElement(this.enableCanvas, this.svgObject, this.renderer.createGroup({ id: this.element.id + '_UserInteraction', style: 'pointer-events:none;' }), this.redraw);
	        }
	        if (this.stockChart) {
	            this.stockChart.calculateStockEvents();
	        }
	    };
	    Chart.prototype.applyZoomkit = function () {
	        /**
	         * Issue: Zoomkit not visible after performing refresh()
	         * Fix: this method called without checking `zoomModule.isZoomed`
	         */
	        if (this.chartAreaType === 'PolarRadar') {
	            return;
	        }
	        if (!this.redraw && this.zoomModule && (!this.zoomSettings.enablePan || this.zoomModule.performedUI || this.zoomSettings.showToolbar)) {
	            this.zoomModule.applyZoomToolkit(this, this.axisCollections);
	        }
	    };
	    /**
	     * Render annotation perform here
	     *
	     * @private
	     */
	    Chart.prototype.renderAnnotation = function () {
	        if (this.annotationModule) {
	            //for stock chart, stock chart's id is added to render the annotations
	            this.annotationModule.renderAnnotations(getElement((this.stockChart ? this.stockChart.element.id : this.element.id) + '_Secondary_Element'));
	        }
	    };
	    Chart.prototype.performSelection = function () {
	        var selectedDataIndexes = [];
	        if (this.selectionModule) {
	            selectedDataIndexes = extend([], this.selectionModule.selectedDataIndexes, null, true);
	            this.selectionModule.invokeSelection(this);
	        }
	        if (this.highlightModule) {
	            this.highlightModule.invokeHighlight(this);
	        }
	        if (selectedDataIndexes.length > 0) {
	            this.selectionModule.selectedDataIndexes = selectedDataIndexes;
	            this.selectionModule.redrawSelection(this, this.selectionMode);
	        }
	    };
	    Chart.prototype.processData = function (render) {
	        if (render === void 0) { render = true; }
	        this.visibleSeriesCount = 0;
	        var check = true;
	        var prevPointCount = 0;
	        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
	            var series = _a[_i];
	            if (!series.visible && !this.legendSettings.visible) {
	                this.visibleSeriesCount++;
	                continue;
	            }
	            if (series.category !== 'Indicator' && series.category !== 'TrendLine') {
	                this.initializeDataModule(series);
	            }
	        }
	        for (var _b = 0, _c = this.indicators; _b < _c.length; _b++) {
	            var indicator = _c[_b];
	            if (indicator.dataSource) {
	                var techIndicator = indicator;
	                this.initializeDataModule(techIndicator);
	                check = false;
	            }
	        }
	        if (render && (!this.visibleSeries.length || this.visibleSeriesCount === this.visibleSeries.length && check)) {
	            this.refreshBound();
	            this.trigger('loaded', { chart: this.isBlazor ? {} : this });
	        }
	        if (!this.stockChart && this.visibleSeries.length > 0) {
	            for (var _d = 0, _e = this.visibleSeries; _d < _e.length; _d++) {
	                var series = _e[_d];
	                if (!isNullOrUndefined(series.points)) {
	                    this.maxPointCount = Math.max(prevPointCount, series.points.length);
	                    prevPointCount = series.points.length;
	                }
	            }
	        }
	    };
	    Chart.prototype.initializeDataModule = function (series) {
	        series.xData = [];
	        series.yData = [];
	        var dataSource;
	        var isAngular = 'isAngular';
	        if (this[isAngular]) {
	            dataSource = Object.keys(series.dataSource).length ? series.dataSource : this.dataSource;
	        }
	        else {
	            dataSource = series.dataSource || this.dataSource;
	        }
	        series.dataModule = new Data(dataSource, series.query);
	        series.points = [];
	        series.refreshDataManager(this);
	    };
	    Chart.prototype.calculateBounds = function () {
	        var margin = this.margin;
	        // Title Height;
	        var titleHeight = 0;
	        var subTitleHeight = 0;
	        var padding = this.titleStyle.position === 'Top' || (this.titleStyle.position === 'Bottom' && !this.legendSettings.visible) ? 15 : 5;
	        var left = margin.left + this.border.width;
	        var width = this.availableSize.width - left - margin.right - this.border.width;
	        var elementSpacing = 0;
	        this.titleCollection = [];
	        this.subTitleCollection = [];
	        if (this.title) {
	            this.titleCollection = getTitle(this.title, this.titleStyle, width, this.themeStyle.chartTitleFont);
	            titleHeight = (measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont).height * this.titleCollection.length) + padding;
	            if (this.subTitle) {
	                this.subTitleCollection = getTitle(this.subTitle, this.subTitleStyle, width, this.themeStyle.chartSubTitleFont);
	                subTitleHeight = (measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont).height * this.subTitleCollection.length) +
	                    padding;
	            }
	        }
	        else if (this.legendSettings.position !== 'Top' && this.border.width) {
	            elementSpacing = 10;
	        }
	        var top = margin.top + elementSpacing + this.border.width + this.chartArea.border.width * 0.5;
	        var height = this.availableSize.height - top - this.border.width - margin.bottom;
	        var marginTotal = subTitleHeight + titleHeight + this.titleStyle.border.width + this.subTitleStyle.border.width;
	        switch (this.titleStyle.position) {
	            case 'Top':
	                top += marginTotal;
	                height -= marginTotal;
	                break;
	            case 'Bottom':
	                height -= marginTotal;
	                break;
	            case 'Left':
	                left += marginTotal;
	                width -= marginTotal;
	                break;
	            case 'Right':
	                left -= (this.titleStyle.border.width + this.subTitleStyle.border.width);
	                width -= marginTotal;
	                break;
	        }
	        if (this.stockChart && this.stockChart.legendSettings.visible && this.stockChart.stockLegendModule) {
	            if (this.stockChart.legendSettings.position === 'Top') {
	                top += this.stockChart.stockLegendModule.legendBounds.height;
	            }
	            else if (this.stockChart.legendSettings.position === 'Left') {
	                left += this.stockChart.stockLegendModule.legendBounds.width;
	            }
	        }
	        this.initialClipRect = new Rect(left, top, width, height);
	        if (this.legendModule && this.legendSettings.visible) {
	            this.legendModule.calculateLegendBounds(this.initialClipRect, this.availableSize, null);
	        }
	        this.chartAxisLayoutPanel.measureAxis(this.initialClipRect);
	    };
	    /**
	     * Handles the print method for chart control.
	     */
	    Chart.prototype.print = function (id) {
	        var exportChart = new ExportUtils(this);
	        var width = this.width;
	        if (this.getModuleName() == 'chart' && parseInt(this.width) >= 80 && this.width.indexOf('%') > -1) {
	            this.width = '80%';
	            this.dataBind();
	        }
	        exportChart.print(id);
	        if (this.getModuleName() == 'chart' && parseInt(this.width) >= 80 && this.width.indexOf('%') > -1) {
	            this.width = width;
	            this.dataBind();
	        }
	    };
	    /**
	     * Defines the trendline initialization
	     */
	    Chart.prototype.initTrendLines = function () {
	        this.isProtectedOnChange = true;
	        for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
	            var series = _a[_i];
	            var trendIndex = 0;
	            for (var _b = 0, _c = series.trendlines; _b < _c.length; _b++) {
	                var trendline = _c[_b];
	                var trendLine = trendline;
	                if (this.trendLineModule) {
	                    trendLine.index = trendIndex;
	                    trendLine.sourceIndex = series.index;
	                    this.trendLineModule.initSeriesCollection(trendLine, this);
	                    if (trendLine.targetSeries) {
	                        trendLine.targetSeries.xAxisName = series.xAxisName;
	                        trendLine.targetSeries.yAxisName = series.yAxisName;
	                        this.visibleSeries.push(trendLine.targetSeries);
	                    }
	                }
	                trendIndex++;
	            }
	        }
	        this.isProtectedOnChange = false;
	    };
	    Chart.prototype.calculateAreaType = function () {
	        var series = this.series[0];
	        this.chartArea.border.width = this.stockChart ? 0 : this.chartArea.border.width;
	        if (series) {
	            this.requireInvertedAxis = ((series.type.indexOf('Bar') !== -1) && !this.isTransposed) ||
	                ((series.type.indexOf('Bar') === -1) && this.isTransposed && this.chartAreaType !== 'PolarRadar');
	        }
	        this.chartAxisLayoutPanel = this.chartAreaType === 'PolarRadar' ? (this.polarSeriesModule || this.radarSeriesModule)
	            : new CartesianAxisLayoutPanel(this);
	    };
	    /**
	     * Calculate the visible axis
	     *
	     * @private
	     */
	    Chart.prototype.calculateVisibleAxis = function () {
	        var axis;
	        var axes = [this.primaryXAxis, this.primaryYAxis];
	        axes = this.chartAreaType === 'Cartesian' ? axes.concat(this.axes) : axes;
	        if (this.paretoSeriesModule && this.series[0].type === 'Pareto') {
	            axes = axes.concat(this.paretoSeriesModule.paretoAxes);
	        }
	        this.axisCollections = [];
	        if (this.zoomModule) {
	            this.zoomModule.isPanning = this.zoomModule.isAxisZoomed(axes) && this.zoomSettings.enablePan;
	            this.svgObject.setAttribute('cursor', this.zoomModule.isPanning ? 'pointer' : 'auto');
	            if (this.scrollBarModule) {
	                this.scrollBarModule.axes = axes;
	            }
	        }
	        if (this.scrollSettingEnabled) {
	            if (this.scrollBarModule) {
	                this.scrollBarModule.axes = axes;
	            }
	        }
	        for (var i = 0, len = axes.length; i < len; i++) {
	            axis = axes[i];
	            axis.series = [];
	            axis.labels = [];
	            axis.indexLabels = {};
	            axis.orientation = (i == 0) ? (this.requireInvertedAxis ? 'Vertical' : 'Horizontal') :
	                (i == 1) ? (this.requireInvertedAxis ? 'Horizontal' : 'Vertical') : axis.orientation;
	            for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
	                var series = _a[_i];
	                this.initAxis(series, axis, true);
	                if (series.category == 'Pareto' && series.type == 'Line' && series.yAxis) {
	                    series.yAxis.internalVisibility = series.paretoOptions.showAxis;
	                }
	            }
	            for (var _b = 0, _c = this.indicators; _b < _c.length; _b++) {
	                var indicator = _c[_b];
	                this.initAxis(indicator, axis, false);
	            }
	            if (this.scrollBarModule && !axis.zoomingScrollBar) {
	                this.scrollBarModule.injectTo(axis, this);
	            }
	            if (axis.orientation != null) {
	                this.axisCollections.push(axis);
	            }
	        }
	        if (this.rows.length > 0 && this.columns.length > 0) {
	            this.chartAxisLayoutPanel.measure();
	        }
	    };
	    Chart.prototype.initAxis = function (series, axis, isSeries) {
	        if (series.xAxisName === axis.name || (series.xAxisName == null && axis.name === 'primaryXAxis')) {
	            axis.orientation = this.requireInvertedAxis ? 'Vertical' : 'Horizontal';
	            series.xAxis = axis;
	            if (isSeries) {
	                axis.series.push(series);
	            }
	        }
	        else if (series.yAxisName === axis.name || (series.yAxisName == null && axis.name === 'primaryYAxis')) {
	            axis.orientation = this.requireInvertedAxis ? 'Horizontal' : 'Vertical';
	            series.yAxis = axis;
	            if (isSeries) {
	                axis.series.push(series);
	            }
	        }
	    };
	    Chart.prototype.initTechnicalIndicators = function () {
	        var i = 0;
	        for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {
	            var indicator = _a[_i];
	            var techIndicator = indicator;
	            var type = firstToLowerCase(techIndicator.type);
	            if (this[type + 'IndicatorModule']) {
	                techIndicator.index = i;
	                this[type + 'IndicatorModule'].initSeriesCollection(techIndicator, this);
	                for (var _b = 0, _c = techIndicator.targetSeries; _b < _c.length; _b++) {
	                    var targetSeries = _c[_b];
	                    if (indicator.seriesName || indicator.dataSource) {
	                        this.visibleSeries.push(targetSeries);
	                    }
	                }
	            }
	            i++;
	        }
	    };
	    /** @private */
	    Chart.prototype.refreshTechnicalIndicator = function (series) {
	        if (this.indicators.length) {
	            var targetIndicator = null;
	            if (series instanceof Series && series.category !== 'Indicator') {
	                for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {
	                    var indicator = _a[_i];
	                    if (indicator.seriesName === series.name && !indicator.dataSource) {
	                        targetIndicator = indicator;
	                        targetIndicator.setDataSource(series, this);
	                    }
	                }
	            }
	            else if (series instanceof TechnicalIndicator) {
	                targetIndicator = series;
	                targetIndicator.setDataSource(series instanceof Series ? series : null, this);
	            }
	        }
	    };
	    Chart.prototype.calculateVisibleSeries = function () {
	        var series;
	        this.visibleSeries = [];
	        var colors = this.palettes.length ? this.palettes : getSeriesColor(this.theme);
	        var count = colors.length;
	        var seriesCollection = this.series.sort(function (a, b) { return a.zOrder - b.zOrder; });
	        for (var i = 0, len = seriesCollection.length; i < len; i++) {
	            series = seriesCollection[i];
	            // for y axis label issue during chart navigation
	            series.category = seriesCollection[0].type === 'Pareto' ? 'Pareto' : 'Series';
	            series.index = i;
	            series.interior = series.fill || colors[i % count];
	            if (!series.marker.shape && (series.marker.visible || series.type === 'Scatter' || series.drawType === 'Scatter')) {
	                series.marker.shape = markerShapes[this.markerIndex % 10];
	                this.markerIndex++;
	            }
	            if (this.isSecondaryAxis(series.xAxis)) {
	                series.xAxis.internalVisibility = series.xAxis.series.some(function (value) { return (value.visible); });
	            }
	            if (this.isSecondaryAxis(series.yAxis)) {
	                series.yAxis.internalVisibility = series.yAxis.series.some(function (value) { return (value.visible); });
	            }
	            switch (series.type) {
	                case 'Bar':
	                case 'StackingBar':
	                case 'StackingBar100':
	                    if (seriesCollection[0].type.indexOf('Bar') === -1) {
	                        continue;
	                    }
	                    break;
	                case 'Polar':
	                case 'Radar':
	                    if (this.chartAreaType !== 'PolarRadar') {
	                        continue;
	                    }
	                    if (this.chartAreaType === 'PolarRadar' && ((series.xAxisName === null && series.yAxisName !== null) ||
	                        (series.xAxisName !== null && series.yAxisName === null) ||
	                        (series.xAxisName !== null && series.yAxisName !== null))) {
	                        continue;
	                    }
	                    break;
	                case 'Pareto':
	                    this.visibleSeries.push(series);
	                    this.paretoSeriesModule.initSeries(series, this);
	                    continue;
	                default:
	                    if (this.chartAreaType === 'PolarRadar' || seriesCollection[0].type.indexOf('Bar') > -1) {
	                        continue;
	                    }
	                    break;
	            }
	            this.visibleSeries.push(series);
	            seriesCollection[i] = series;
	        }
	    };
	    Chart.prototype.isSecondaryAxis = function (axis) {
	        return (this.axes.indexOf(axis) > -1);
	    };
	    Chart.prototype.renderTitle = function () {
	        var rect;
	        var margin = this.margin;
	        var elementSpacing = 5;
	        if (this.title) {
	            var getAnchor = getTextAnchor(this.titleStyle.textAlignment, this.enableRtl);
	            var elementSize = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont);
	            rect = new Rect(margin.left, 0, this.availableSize.width - margin.left - margin.right, 0);
	            var borderWidth = this.titleStyle.border.width;
	            var positionY = this.margin.top + ((elementSize.height) * 3 / 4);
	            var positionX = titlePositionX(rect, this.titleStyle || this.themeStyle.chartTitleFont) + borderWidth;
	            var rotation = void 0;
	            var alignment = this.titleStyle.textAlignment;
	            var subtitleSize = measureText(this.subTitle, this.subTitleStyle, this.themeStyle.chartSubTitleFont);
	            switch (this.titleStyle.position) {
	                case 'Top':
	                    positionY += borderWidth * 0.5;
	                    positionX += getAnchor === 'start' ? borderWidth * 0.5 + this.border.width :
	                        getAnchor === 'end' ? ((-borderWidth * 2) - this.border.width) : 0;
	                    break;
	                case 'Bottom':
	                    positionX += getAnchor === 'start' ? (borderWidth * 0.5) + this.border.width :
	                        getAnchor === 'end' ? (-borderWidth * 2) - this.border.width : 0;
	                    positionY = this.availableSize.height - this.margin.bottom - subtitleSize.height - (elementSize.height / 2) -
	                        (borderWidth * 0.5) - (this.subTitleStyle.border.width * 0.5);
	                    break;
	                case 'Left':
	                    positionX = this.margin.left + ((elementSize.height) * 3 / 4) + (borderWidth * 0.5);
	                    positionY = alignment == 'Near' ? margin.bottom + (borderWidth * 0.5) + this.border.width :
	                        alignment == 'Far' ? this.availableSize.height - margin.bottom - (borderWidth * 0.5) - this.border.width : this.availableSize.height / 2;
	                    getAnchor = alignment == 'Near' ? 'end' : alignment == 'Far' ? 'start' : 'middle';
	                    getAnchor = this.enableRtl ? (getAnchor === 'end' ? 'start' : getAnchor === 'start' ? 'end' : getAnchor) : getAnchor;
	                    rotation = 'rotate(' + -90 + ',' + positionX + ',' + positionY + ')';
	                    break;
	                case 'Right':
	                    positionX = this.availableSize.width - this.margin.right - ((elementSize.height) * 3 / 4) - (borderWidth * 0.5);
	                    positionY = alignment == 'Near' ? margin.bottom + (borderWidth * 0.5) + this.border.width :
	                        alignment == 'Far' ? this.availableSize.height - margin.bottom - (borderWidth * 0.5) - this.border.width : this.availableSize.height / 2;
	                    getAnchor = alignment == 'Near' ? 'start' : alignment == 'Far' ? 'end' : 'middle';
	                    getAnchor = this.enableRtl ? (getAnchor === 'end' ? 'start' : getAnchor === 'start' ? 'end' : getAnchor) : getAnchor;
	                    rotation = 'rotate(' + 90 + ',' + positionX + ',' + positionY + ')';
	                    break;
	                case 'Custom':
	                    positionX = this.titleStyle.x;
	                    positionY = this.titleStyle.y;
	                    getAnchor = 'middle';
	                    break;
	            }
	            var borderOptions = {
	                'id': this.element.id + '_ChartTitleBorder',
	                'x': positionX - (getAnchor === 'middle' ? (elementSize.width / 2) + elementSpacing : getAnchor === 'end' ? elementSize.width + elementSpacing : elementSpacing),
	                'y': positionY - elementSize.height + (elementSize.height / 4),
	                'rx': this.titleStyle.border.cornerRadius,
	                'ry': this.titleStyle.border.cornerRadius,
	                'width': elementSize.width + (elementSpacing * 2),
	                'height': elementSize.height * this.titleCollection.length,
	                'fill': this.titleStyle.background,
	                'stroke-width': borderWidth,
	                'stroke': this.titleStyle.border.color,
	                'transform': rotation ? rotation : '',
	                'd': ''
	            };
	            var htmlObject = redrawElement(this.redraw, this.element.id + '_ChartTitleBorder', borderOptions, this.renderer)
	                || this.renderer.drawRectangle(borderOptions);
	            appendChildElement(this.enableCanvas, this.svgObject, htmlObject, this.redraw);
	            var options = new TextOption(this.element.id + '_ChartTitle', positionX, positionY, getAnchor, this.titleCollection, rotation, 'auto');
	            var element = redrawElement(this.redraw, this.element.id + '_ChartTitle', options, this.renderer) ||
	                textElement(this.renderer, options, this.titleStyle, this.titleStyle.color || this.themeStyle.chartTitleFont.color, this.svgObject, null, null, null, null, null, null, null, null, this.enableCanvas, null, this.themeStyle.chartTitleFont);
	            if (element) {
	                element.setAttribute('tabindex', '0');
	                element.setAttribute('class', 'e-chart-focused');
	            }
	            if (this.subTitle) {
	                this.renderSubTitle(options);
	            }
	        }
	    };
	    Chart.prototype.renderSubTitle = function (options) {
	        var maxWidth = 0;
	        var titleWidth = 0;
	        var padding = 10;
	        var alignment = this.titleStyle.textAlignment;
	        for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {
	            var titleText = _a[_i];
	            titleWidth = measureText(titleText, this.titleStyle, this.themeStyle.chartSubTitleFont).width;
	            maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;
	        }
	        var subTitleElementSize = measureText(this.subTitleCollection.reduce(function (a, b) { return (a.length > b.length ? a : b); }), this.subTitleStyle, this.themeStyle.chartSubTitleFont);
	        var getAnchor = getTextAnchor(this.subTitleStyle.textAlignment, this.enableRtl);
	        var rect = new Rect(alignment === 'Center' ? (options.x - maxWidth * 0.5) : alignment === 'Far' ? options.x - maxWidth : options.x, 0, maxWidth, 0);
	        if (this.titleStyle.position === 'Left') {
	            rect.x = alignment === 'Center' ? (options.x - maxWidth * 0.5) : alignment == 'Far' ? this.margin.left + ((subTitleElementSize.height) * 3 / 4) : (options.x - maxWidth);
	        }
	        var elementSize = measureText(this.title, this.titleStyle, this.themeStyle.chartTitleFont);
	        var positionY = options.y * options.text.length + subTitleElementSize.height + (padding / 2) + this.titleStyle.border.width + (this.subTitleStyle.border.width * 0.5);
	        if (this.titleStyle.position === 'Bottom') {
	            positionY = options.y * options.text.length + (padding / 2) + (elementSize.height / 2) + (subTitleElementSize.height / 2);
	        }
	        var borderOptions = {
	            'id': this.element.id + '_ChartSubTitleBorder',
	            'x': titlePositionX(rect, this.subTitleStyle) - (getAnchor === 'middle' ? (subTitleElementSize.width / 2) + padding / 2 : getAnchor === 'end' ? subTitleElementSize.width + padding / 2 : padding / 2),
	            'y': positionY - subTitleElementSize.height + (subTitleElementSize.height / 4),
	            'rx': this.subTitleStyle.border.cornerRadius,
	            'ry': this.subTitleStyle.border.cornerRadius,
	            'width': subTitleElementSize.width + padding,
	            'height': subTitleElementSize.height * this.subTitleCollection.length,
	            'fill': this.subTitleStyle.background,
	            'stroke-width': this.subTitleStyle.border.width,
	            'stroke': this.subTitleStyle.border.color,
	            'transform': options.transform,
	            'd': ''
	        };
	        var htmlObject = redrawElement(this.redraw, this.element.id + '_ChartSubTitleBorder', borderOptions, this.renderer)
	            || this.renderer.drawRectangle(borderOptions);
	        appendChildElement(this.enableCanvas, this.svgObject, htmlObject, this.redraw);
	        var subTitleOptions = new TextOption(this.element.id + '_ChartSubTitle', titlePositionX(rect, this.subTitleStyle), positionY, getTextAnchor(this.subTitleStyle.textAlignment, this.enableRtl), this.subTitleCollection, options.transform, 'auto');
	        redrawElement(this.redraw, this.element.id + '_ChartSubTitle', subTitleOptions, this.renderer) ||
	            textElement(this.renderer, subTitleOptions, this.subTitleStyle, this.subTitleStyle.color || this.themeStyle.chartSubTitleFont.color, this.svgObject, null, null, null, null, null, null, null, null, this.enableCanvas, null, this.themeStyle.chartSubTitleFont);
	    };
	    Chart.prototype.renderBorder = function () {
	        var x = 0;
	        var y = 0;
	        var width = this.border.width;
	        var backGroundImage = this.backgroundImage;
	        var fillColor = backGroundImage ? 'transparent' : (this.background || this.themeStyle.background);
	        if (this.stockChart && this.stockChart.legendSettings.visible && this.stockChart.stockLegendModule) {
	            if (this.stockChart.legendSettings.position === 'Top') {
	                y += this.stockChart.stockLegendModule.legendBounds.height;
	            }
	            else if (this.stockChart.legendSettings.position === 'Left') {
	                x += this.stockChart.stockLegendModule.legendBounds.width;
	            }
	        }
	        var rect = new RectOption(this.element.id + '_ChartBorder', fillColor, this.border, 1, new Rect(width * 0.5 + x, width * 0.5 + y, this.availableSize.width - width, this.availableSize.height - width));
	        this.htmlObject = redrawElement(this.redraw, this.element.id + '_ChartBorder', rect, this.renderer)
	            || this.renderer.drawRectangle(rect);
	        this.htmlObject.setAttribute('aria-hidden', 'true');
	        appendChildElement(this.enableCanvas, this.svgObject, this.htmlObject, this.redraw);
	        // to draw back ground image for chart
	        if (backGroundImage) {
	            var image = new ImageOption(this.availableSize.height - width, this.availableSize.width - width, backGroundImage, 0, 0, this.element.id + '_ChartBackground', 'visible', 'none');
	            this.htmlObject = redrawElement(this.redraw, this.element.id + '_ChartBackground', image, this.renderer)
	                || this.renderer.drawImage(image);
	            appendChildElement(this.enableCanvas, this.svgObject, this.htmlObject, this.redraw);
	        }
	    };
	    /**
	     * @private
	     */
	    Chart.prototype.renderAreaBorder = function () {
	        if (this.chartAreaType === 'PolarRadar') {
	            return null;
	        }
	        else {
	            var element = getElement(this.element.id + '_ChartAreaBorder');
	            var previousRect = element ?
	                new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')) : null;
	            var rect = new RectOption(this.element.id + '_ChartAreaBorder', this.chartArea.background, { width: this.chartArea.border.width, color: this.chartArea.border.color || this.themeStyle.areaBorder }, this.chartArea.opacity, this.chartAxisLayoutPanel.seriesClipRect);
	            this.htmlObject = this.renderer.drawRectangle(rect);
	            this.htmlObject.setAttribute('aria-hidden', 'true');
	            appendChildElement(this.enableCanvas, this.svgObject, this.htmlObject, this.redraw, true, 'x', 'y', null, null, true, true, previousRect);
	            this.htmlObject = null;
	        }
	        // to draw back ground image for chart area
	        var backGroundImage = this.chartArea.backgroundImage;
	        if (backGroundImage) {
	            var width = this.chartArea.border.width;
	            var image = new ImageOption(this.initialClipRect.height - width, this.initialClipRect.width - width, backGroundImage, this.initialClipRect.x, this.initialClipRect.y, this.element.id + '_ChartAreaBackground', 'visible', 'none');
	            this.htmlObject = this.renderer.drawImage(image);
	            appendChildElement(this.enableCanvas, this.svgObject, this.htmlObject, this.redraw, true, 'x', 'y', null, null, true, true);
	        }
	    };
	    /**
	     * To add series for the chart
	     *
	     * @param {SeriesModel[]} seriesCollection - Defines the series collection to be added in chart.
	     * @returns {void}.
	     */
	    Chart.prototype.addSeries = function (seriesCollection) {
	        for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
	            var series = seriesCollection_1[_i];
	            series = new Series(this, 'series', series);
	            this.series.push(series);
	        }
	        this.refresh();
	    };
	    /**
	     * To Remove series for the chart
	     *
	     * @param {number} index - Defines the series index to be remove in chart series
	     * @returns {void}
	     */
	    Chart.prototype.removeSeries = function (index) {
	        this.redraw = false; //fix for remove svg not working when use animatemethod.
	        if (this.visibleSeries[index]) {
	            this.visibleSeries[index].xAxis.orientation = null;
	            this.visibleSeries[index].yAxis.orientation = null;
	        }
	        for (var i = 0; i < this.axes.length; i++) {
	            if (this.axes[i].orientation === null) {
	                this.axes.splice(i, 1);
	            }
	        }
	        this.series.splice(index, 1);
	        this.refresh();
	    };
	    /**
	     * To Clear all series for the chart
	     *
	     * @returns {void}.
	     */
	    Chart.prototype.clearSeries = function () {
	        this.series = [];
	        this.refresh();
	    };
	    /**
	     * To add secondary axis for the chart
	     *
	     * @param {AxisModel[]} axisCollection - Defines the axis collection to be added in chart.
	     * @returns {void}.
	     */
	    Chart.prototype.addAxes = function (axisCollection) {
	        for (var _i = 0, axisCollection_1 = axisCollection; _i < axisCollection_1.length; _i++) {
	            var axis = axisCollection_1[_i];
	            axis = new Axis(this, 'axes', axis);
	            if (this.isBlazor) {
	                axis.interval = isNaN(axis.interval) ? null : axis.interval;
	                axis.desiredIntervals = isNaN(axis.desiredIntervals) ? null : axis.desiredIntervals;
	            }
	            this.axes.push(axis);
	        }
	        this.refresh();
	    };
	    /**
	     * To remove secondary axis for the chart
	     *
	     * @param {number} index - Defines the axis collection to be removed in chart.
	     * @returns {void}
	     */
	    Chart.prototype.removeAxis = function (index) {
	        this.redraw = false;
	        this.axes.splice(index, 1);
	        this.refresh();
	    };
	    /**
	     * To destroy the widget
	     *
	     * @function destroy
	     * @returns {void}.
	     * @member of Chart
	     */
	    Chart.prototype.destroy = function () {
	        if (this.scrollBarModule) {
	            this.scrollBarModule.destroy();
	        }
	        if (this.markerRender) {
	            this.markerRender.removeEventListener();
	            this.markerRender = null;
	        }
	        this.horizontalAxes = [];
	        this.verticalAxes = [];
	        this.visibleSeries = [];
	        this.axisCollections = [];
	        this.rotatedDataLabelCollections = [];
	        this.seriesElements = null;
	        this.chartAxisLayoutPanel = null;
	        this.dataLabelCollections = null;
	        this.dataLabelElements = null;
	        this.yAxisElements = null;
	        var element = document.getElementById(this.element.id + 'Keyboard_chart_focus');
	        if (element) {
	            element.remove();
	        }
	        var highlightElement = document.getElementById(this.element.id + '_ej2_chart_highlight');
	        if (highlightElement) {
	            highlightElement.remove();
	        }
	        removeElement('chartmeasuretext');
	        /**
	         * To fix react timeout destroy issue.
	         */
	        if (this.element) {
	            this.unWireEvents();
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            if (this.isReact) {
	                this.clearTemplate();
	            }
	            _super.prototype.destroy.call(this);
	            if (!this.enableCanvas) {
	                this.removeSvg();
	                this.svgObject = null;
	            }
	        }
	    };
	    /**
	     * Get component name
	     */
	    Chart.prototype.getModuleName = function () {
	        return 'chart';
	    };
	    /**
	     * Get the properties to be maintained in the persisted state.
	     *
	     * @private
	     */
	    Chart.prototype.getPersistData = function () {
	        var keyEntity = ['loaded', 'animationComplete', 'primaryXAxis', 'primaryYAxis'];
	        return this.addOnPersist(keyEntity);
	    };
	    /**
	     * Method to create SVG element.
	     */
	    Chart.prototype.createChartSvg = function () {
	        this.removeSvg();
	        createSvg(this);
	    };
	    /**
	     * Method to bind events for chart
	     */
	    Chart.prototype.unWireEvents = function () {
	        var startEvent = Browser.touchStartEvent;
	        var moveEvent = Browser.touchMoveEvent;
	        var stopEvent = Browser.touchEndEvent;
	        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
	        /*! UnBind the Event handler */
	        EventHandler.remove(this.element, startEvent, this.chartOnMouseDown);
	        EventHandler.remove(this.element, moveEvent, this.mouseMove);
	        EventHandler.remove(this.element, stopEvent, this.mouseEnd);
	        EventHandler.remove(this.element, 'click', this.chartOnMouseClick);
	        EventHandler.remove(this.element, 'dblclick', this.chartOnDoubleClick);
	        EventHandler.remove(this.element, 'contextmenu', this.chartRightClick);
	        EventHandler.remove(this.element, cancelEvent, this.mouseLeave);
	        EventHandler.remove(this.element, 'keydown', this.chartKeyDown);
	        EventHandler.remove(document.body, 'keydown', this.documentKeyHandler);
	        EventHandler.remove(this.element, 'keyup', this.chartKeyUp);
	        window.removeEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.resizeBound);
	        /**
	         * To fix memory issue
	         */
	        if (this.touchObject) {
	            this.touchObject.destroy();
	            this.touchObject = null;
	        }
	    };
	    Chart.prototype.wireEvents = function () {
	        /**
	         * To fix react timeout destroy issue.
	         */
	        if (!this.element) {
	            return;
	        }
	        /*! Find the Events type */
	        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
	        /*! Bind the Event handler */
	        EventHandler.add(this.element, Browser.touchStartEvent, this.chartOnMouseDown, this);
	        EventHandler.add(this.element, Browser.touchMoveEvent, this.mouseMove, this);
	        EventHandler.add(this.element, Browser.touchEndEvent, this.mouseEnd, this);
	        EventHandler.add(this.element, 'click', this.chartOnMouseClick, this);
	        EventHandler.add(this.element, 'dblclick', this.chartOnDoubleClick, this);
	        EventHandler.add(this.element, 'contextmenu', this.chartRightClick, this);
	        EventHandler.add(this.element, cancelEvent, this.mouseLeave, this);
	        EventHandler.add(this.element, 'keydown', this.chartKeyDown, this);
	        EventHandler.add(document.body, 'keydown', this.documentKeyHandler, this);
	        EventHandler.add(this.element, 'keyup', this.chartKeyUp, this);
	        this.resizeBound = this.chartResize.bind(this);
	        window.addEventListener((Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.resizeBound);
	        this.longPressBound = this.longPress.bind(this);
	        this.touchObject = new Touch(this.element, { tapHold: this.longPressBound, tapHoldThreshold: 500 });
	        /*! Apply the style for chart */
	        this.setStyle(this.element);
	    };
	    Chart.prototype.chartRightClick = function (event) {
	        if (this.crosshair.enable && this.crosshairModule &&
	            (event.buttons === 2 || event.which === 0 || event.pointerType === 'touch')) {
	            event.preventDefault();
	            event.stopPropagation();
	            return false;
	        }
	        return true;
	    };
	    Chart.prototype.setStyle = function (element) {
	        var zooming = this.zoomSettings;
	        var disableScroll = zooming.enableSelectionZooming || zooming.enablePinchZooming ||
	            this.selectionMode !== 'None' || this.crosshair.enable || this.highlightMode !== 'None';
	        element.style.touchAction = disableScroll ? 'none' : 'element';
	        element.style.msTouchAction = disableScroll ? 'none' : 'element';
	        element.style.msContentZooming = 'none';
	        element.style.msUserSelect = 'none';
	        element.style.webkitUserSelect = 'none';
	        element.style.position = 'relative';
	        element.style.display = 'block';
	        // To fix angular and react tooltip div scrollbar issue
	        element.style.overflow = 'hidden';
	        element.style.height = (element.style.height || (this.height && this.height.indexOf('%') === -1)) ? element.style.height : 'inherit';
	    };
	    /**
	     * Finds the orientation.
	     *
	     * @returns {boolean}
	     * @private
	     */
	    Chart.prototype.isOrientation = function () {
	        return ('orientation' in window && 'onorientationchange' in window);
	    };
	    /**
	     * Handles the long press on chart.
	     *
	     * @returns {boolean} false
	     * @private
	     */
	    Chart.prototype.longPress = function (e) {
	        this.mouseX = (e && e.originalEvent.changedTouches) ? (e.originalEvent.changedTouches[0].clientX) : 0;
	        this.mouseY = (e && e.originalEvent.changedTouches) ? (e.originalEvent.changedTouches[0].clientY) : 0;
	        this.startMove = true;
	        this.allowPan = this.stockChart ? false : this.allowPan;
	        this.setMouseXY(this.mouseX, this.mouseY);
	        this.notify('tapHold', e);
	        return false;
	    };
	    /**
	     * To find mouse x, y for aligned chart element svg position
	     */
	    Chart.prototype.setMouseXY = function (pageX, pageY) {
	        if (getElement(this.svgId)) {
	            var svgRect = getElement(this.svgId).getBoundingClientRect();
	            var rect = this.element.getBoundingClientRect();
	            this.mouseY = ((pageY - rect.top) - Math.max(svgRect.top - rect.top, 0) / this.scaleX);
	            this.mouseX = ((pageX - rect.left) - Math.max(svgRect.left - rect.left, 0) / this.scaleY);
	            if (this.stockChart) {
	                this.mouseX += this.stockChart.legendSettings.position === 'Left' ? this.stockChart.stockLegendModule.legendBounds.width : 0;
	                this.mouseY += this.stockChart.legendSettings.position === 'Top' ? this.stockChart.stockLegendModule.legendBounds.height : 0;
	            }
	        }
	    };
	    /**
	     * Export method for the chart.
	     */
	    Chart.prototype.export = function (type, fileName) {
	        if (this.exportModule) {
	            this.exportModule.export(type, fileName);
	            if (this.afterExport) {
	                this.exportModule.getDataUrl(this);
	            }
	        }
	    };
	    /**
	     * Handles the chart resize.
	     *
	     * @returns {boolean} false
	     * @private
	     */
	    Chart.prototype.chartResize = function () {
	        var _this = this;
	        this.animateSeries = false;
	        var arg = {
	            chart: this.isBlazor ? {} : this,
	            name: resized,
	            currentSize: new Size(0, 0),
	            previousSize: new Size(this.availableSize.width, this.availableSize.height)
	        };
	        var beforeResizeArgs = { name: 'beforeResize', cancelResizedEvent: false };
	        if (this.resizeTo) {
	            clearTimeout(this.resizeTo);
	        }
	        this.trigger(beforeResize, beforeResizeArgs);
	        if (!beforeResizeArgs.cancelResizedEvent) {
	            this.resizeTo = +setTimeout(function () {
	                if (_this.isDestroyed || _this.stockChart) {
	                    clearTimeout(_this.resizeTo);
	                    return;
	                }
	                _this.createChartSvg();
	                arg.currentSize = _this.availableSize;
	                _this.trigger(resized, arg);
	                _this.refreshAxis();
	                _this.refreshBound();
	                _this.trigger('loaded', { chart: _this.isBlazor ? {} : _this });
	            }, 500);
	        }
	        return false;
	    };
	    /**
	     * Handles the mouse move.
	     *
	     * @returns {boolean} false
	     * @private
	     */
	    Chart.prototype.mouseMove = function (e) {
	        var pageX;
	        var pageY;
	        var touchArg;
	        if (this.allowPan) {
	            return false;
	        }
	        if (e.type === 'touchmove') {
	            this.isTouch = true;
	            touchArg = e;
	            pageX = touchArg.changedTouches[0].clientX;
	            pageY = touchArg.changedTouches[0].clientY;
	        }
	        else {
	            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2' || this.isTouch;
	            pageX = e.clientX;
	            pageY = e.clientY;
	        }
	        this.previousPageX = pageX;
	        this.previousPageY = pageY;
	        if (getElement(this.svgId)) {
	            this.setMouseXY(pageX, pageY);
	            this.chartOnMouseMove(e);
	        }
	        return false;
	    };
	    /**
	     * Handles the mouse leave.
	     *
	     * @returns {boolean} false
	     * @private
	     */
	    Chart.prototype.mouseLeave = function (e) {
	        var pageX;
	        var pageY;
	        var touchArg;
	        if (this.stockChart && this.stockChart.onPanning) {
	            return false;
	        }
	        if (e.type === 'touchleave') {
	            this.isTouch = true;
	            touchArg = e;
	            pageX = touchArg.changedTouches[0].clientX;
	            pageY = touchArg.changedTouches[0].clientY;
	        }
	        else {
	            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';
	            pageX = e.clientX;
	            pageY = e.clientY;
	        }
	        this.previousPageX = null;
	        this.previousPageY = null;
	        this.setMouseXY(pageX, pageY);
	        this.chartOnMouseLeave(e);
	        return false;
	    };
	    /**
	     * Handles the mouse leave on chart.
	     *
	     * @returns {boolean} false
	     * @private
	     */
	    Chart.prototype.chartOnMouseLeave = function (e) {
	        var element = e.target;
	        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
	        this.trigger(chartMouseLeave, { target: element.id, x: this.mouseX, y: this.mouseY });
	        removeElement(this.element.id + '_EJ2_AxisLabel_Tooltip');
	        this.isChartDrag = this.isPointMouseDown = false;
	        this.notify(cancelEvent, e);
	        return false;
	    };
	    /**
	     * Handles the mouse double click on chart.
	     *
	     * @returns {boolean} false
	     * @private
	     */
	    Chart.prototype.chartOnDoubleClick = function (e) {
	        var element = e.target;
	        this.trigger(chartDoubleClick, { target: element.id, x: this.mouseX, y: this.mouseY });
	        return false;
	    };
	    /**
	     * Handles the keyboard onkeydown on chart.
	     *
	     * @returns {boolean} false
	     * @private
	     */
	    Chart.prototype.chartKeyDown = function (e) {
	        var actionKey = '';
	        if ((this.isZoomed && e.code === 'Tab') || e.code === 'Space') {
	            e.preventDefault();
	        }
	        if (this.tooltip.enable && ((e.code === 'Tab' && this.previousTargetId.indexOf('Series') > -1) || e.code === 'Escape')) {
	            actionKey = 'ESC';
	        }
	        if (this.highlightMode !== 'None' && e.code === 'Tab' && this.previousTargetId.indexOf('_chart_legend_') > -1) {
	            if (this.highlightModule) {
	                this.highlightModule.removeLegendHighlightStyles();
	            }
	        }
	        if (e.ctrlKey && (e.key === '+' || e.code === 'Equal' || e.key === '-' || e.code === 'Minus')) {
	            e.preventDefault();
	            this.isZoomed = this.zoomModule && (this.zoomSettings.enableDeferredZooming || this.zoomSettings.enableSelectionZooming ||
	                this.zoomSettings.enablePinchZooming || this.zoomSettings.enableMouseWheelZooming);
	            //this.tooltipModule.fadeOut(this.element);
	            actionKey = this.isZoomed ? e.code : '';
	        }
	        else if (e['keyCode'] === 82 && this.isZoomed) { // KeyCode 82 (R) for reseting
	            e.preventDefault();
	            this.isZoomed = false;
	            actionKey = 'R';
	        }
	        else if (e.code.indexOf('Arrow') > -1) {
	            e.preventDefault();
	            actionKey = this.isZoomed ? e.code : '';
	        }
	        if (e.ctrlKey && (e.key === 'p')) {
	            e.preventDefault();
	            actionKey = 'CtrlP';
	        }
	        if (actionKey !== '')
	            this.chartKeyboardNavigations(e, e.target.id, actionKey);
	        return false;
	    };
	    /**
	     * Handles the keyboard onkeydown on chart.
	     *
	     * @returns {boolean} false
	     * @private
	     */
	    Chart.prototype.chartKeyUp = function (e) {
	        var actionKey = '';
	        var targetId = e.target['id'];
	        var groupElement;
	        var markerGroup;
	        var targetElement = e.target;
	        var titleElement = getElement(this.element.id + '_ChartTitle');
	        var seriesElement = getElement(this.element.id + 'SeriesCollection');
	        var legendElement = getElement(this.element.id + '_chart_legend_translate_g');
	        var pagingElement = getElement(this.element.id + '_chart_legend_pageup');
	        if (titleElement) {
	            titleElement.setAttribute('class', 'e-chart-focused');
	        }
	        if (seriesElement && seriesElement.firstElementChild && seriesElement.firstElementChild.children[1]) {
	            var firstChild = seriesElement.firstElementChild.children[1];
	            var className = firstChild.getAttribute('class');
	            if (className && className.indexOf('e-chart-focused') === -1) {
	                className = className + ' e-chart-focused';
	            }
	            else if (!className) {
	                className = 'e-chart-focused';
	            }
	            firstChild.setAttribute('class', className);
	        }
	        if (legendElement) {
	            var firstChild = legendElement.firstElementChild;
	            var className = firstChild.getAttribute('class');
	            if (className && className.indexOf('e-chart-focused') === -1) {
	                className = className + ' e-chart-focused';
	            }
	            else if (!className) {
	                className = 'e-chart-focused';
	            }
	            firstChild.setAttribute('class', className);
	        }
	        if (pagingElement) {
	            pagingElement.setAttribute('class', 'e-chart-focused');
	        }
	        if (e.code === 'Tab') {
	            if (this.previousTargetId !== '') {
	                if ((this.previousTargetId.indexOf('_Series_') > -1 && targetId.indexOf('_Series_') === -1)) {
	                    groupElement = getElement(this.element.id + 'SeriesCollection');
	                    var previousElement = this.previousTargetId.indexOf('_Symbol') > -1 ?
	                        getElement(this.element.id + 'SymbolGroup' + this.currentSeriesIndex).children[this.currentPointIndex + 1] :
	                        (this.previousTargetId.indexOf('_Point_') > -1 ?
	                            groupElement.children[this.currentSeriesIndex].children[this.currentPointIndex + 1] :
	                            groupElement.children[this.currentSeriesIndex]);
	                    this.setTabIndex(previousElement, groupElement.firstElementChild);
	                    this.currentPointIndex = 0;
	                    this.currentSeriesIndex = 0;
	                }
	                else if (this.previousTargetId.indexOf('_chart_legend_page') > -1 && targetId.indexOf('_chart_legend_page') === -1
	                    && targetId.indexOf('_chart_legend_g_') === -1) {
	                    this.setTabIndex(e.target, getElement(this.element.id + '_chart_legend_pageup'));
	                }
	                else if (this.previousTargetId.indexOf('_chart_legend_g_') > -1 && targetId.indexOf('_chart_legend_g_') === -1) {
	                    groupElement = getElement(this.element.id + '_chart_legend_translate_g');
	                    this.setTabIndex(groupElement.children[this.currentLegendIndex], groupElement.firstElementChild);
	                }
	            }
	            this.previousTargetId = targetId;
	            if (targetId.indexOf('SeriesGroup') > -1) {
	                this.currentSeriesIndex = +targetId.split('SeriesGroup')[1];
	                targetElement.removeAttribute('tabindex');
	                targetElement.blur();
	                if (targetElement.children[1].id.indexOf('_Point_') === -1) {
	                    markerGroup = getElement(this.element.id + 'SymbolGroup' + targetId.split('SeriesGroup')[1]);
	                }
	                targetId = this.focusChild((markerGroup != null ? markerGroup.children[1] : targetElement.children[1]));
	            }
	            actionKey = this.highlightMode !== 'None' || this.tooltip.enable ? 'Tab' : '';
	        }
	        else if (e.code.indexOf('Arrow') > -1) {
	            e.preventDefault();
	            this.previousTargetId = targetId;
	            if (targetId.indexOf('_chart_legend_page') > -1) {
	                if (e.code === 'ArrowLeft') {
	                    getElement(this.element.id + '_chart_legend_pagedown').removeAttribute('tabindex');
	                    this.focusChild(getElement(this.element.id + '_chart_legend_pageup'));
	                }
	                else if (e.code === 'ArrowRight') {
	                    getElement(this.element.id + '_chart_legend_pageup').removeAttribute('tabindex');
	                    this.focusChild(getElement(this.element.id + '_chart_legend_pagedown'));
	                }
	            }
	            else if ((targetId.indexOf('_chart_legend_') > -1)) {
	                var legendElement_1 = targetElement.parentElement.children;
	                legendElement_1[this.currentLegendIndex].removeAttribute('tabindex');
	                this.currentLegendIndex += (e.code === 'ArrowUp' || e.code === 'ArrowRight') ? +1 : -1;
	                this.currentLegendIndex = this.getActualIndex(this.currentLegendIndex, legendElement_1.length);
	                var currentLegend = legendElement_1[this.currentLegendIndex];
	                this.focusChild(currentLegend);
	                targetId = currentLegend.children[1].id;
	                actionKey = this.highlightMode !== 'None' ? 'ArrowMove' : '';
	            }
	            else if (targetId.indexOf('_Series_') > -1) {
	                groupElement = targetElement.parentElement.parentElement;
	                var currentPoint = e.target;
	                targetElement.removeAttribute('tabindex');
	                targetElement.blur();
	                if (e.code === 'ArrowRight' || e.code === 'ArrowLeft') {
	                    var seriesIndexes = [];
	                    for (var i = 0; i < groupElement.children.length; i++) {
	                        if (groupElement.children[i].id.indexOf('SeriesGroup') > -1) {
	                            seriesIndexes.push(+groupElement.children[i].id.split('SeriesGroup')[1]);
	                        }
	                    }
	                    this.currentSeriesIndex = seriesIndexes.indexOf(this.currentSeriesIndex) + (e.code === 'ArrowRight' ? 1 : -1);
	                    this.currentSeriesIndex = seriesIndexes[this.getActualIndex(this.currentSeriesIndex, seriesIndexes.length)];
	                }
	                else {
	                    this.currentPointIndex += e.code === 'ArrowUp' ? 1 : -1;
	                }
	                if (targetId.indexOf('_Symbol') > -1) {
	                    this.currentPointIndex = this.getActualIndex(this.currentPointIndex, getElement(this.element.id + 'SymbolGroup' + this.currentSeriesIndex).childElementCount - 1);
	                    currentPoint = getElement(this.element.id + '_Series_' + this.currentSeriesIndex + '_Point_' +
	                        this.currentPointIndex + '_Symbol');
	                }
	                else if (targetId.indexOf('_Point_') > -1) {
	                    this.currentPointIndex = this.getActualIndex(this.currentPointIndex, getElement(this.element.id + 'SeriesGroup' + this.currentSeriesIndex).childElementCount - 1);
	                    currentPoint = getElement(this.element.id + '_Series_' + this.currentSeriesIndex + '_Point_' +
	                        this.currentPointIndex);
	                }
	                targetId = this.focusChild(currentPoint);
	                actionKey = this.tooltip.enable || this.highlightMode !== 'None' ? 'ArrowMove' : '';
	            }
	        }
	        else if ((e.code === 'Enter' || e.code === 'Space') && ((targetId.indexOf('_chart_legend_') > -1) ||
	            (targetId.indexOf('_Point_') > -1))) {
	            targetId = (targetId.indexOf('_chart_legend_page') > -1) ? targetId : ((targetId.indexOf('_chart_legend_') > -1) ?
	                targetElement.children[1].id : targetId);
	            actionKey = 'Enter';
	        }
	        if (actionKey !== '') {
	            this.chartKeyboardNavigations(e, targetId, actionKey);
	        }
	        return false;
	    };
	    Chart.prototype.setTabIndex = function (previousElement, currentElement) {
	        if (previousElement) {
	            previousElement.removeAttribute('tabindex');
	        }
	        if (currentElement) {
	            currentElement.setAttribute('tabindex', '0');
	        }
	    };
	    Chart.prototype.getActualIndex = function (index, totalLength) {
	        return index > totalLength - 1 ? 0 : (index < 0 ? totalLength - 1 : index);
	    };
	    Chart.prototype.focusChild = function (element) {
	        element.setAttribute('tabindex', '0');
	        var className = element.getAttribute('class');
	        element.setAttribute('tabindex', '0');
	        if (className && className.indexOf('e-chart-focused') === -1) {
	            className = 'e-chart-focused ' + className;
	        }
	        else if (!className) {
	            className = 'e-chart-focused';
	        }
	        element.setAttribute('class', className);
	        element.focus();
	        return element.id;
	    };
	    /**
	     * Handles the document onkey.
	     *
	     * @private
	     */
	    Chart.prototype.documentKeyHandler = function (e) {
	        // 74 - J
	        if (e.altKey && e.keyCode === 74 && !isNullOrUndefined(this.element)) {
	            this.element.focus();
	        }
	    };
	    Chart.prototype.chartKeyboardNavigations = function (e, targetId, actionKey) {
	        this.isLegendClicked = false;
	        switch (actionKey) {
	            case 'Tab':
	            case 'ArrowMove':
	                if (this.highlightModule) {
	                    this.highlightModule.removeLegendHighlightStyles();
	                }
	                if (targetId.indexOf('_Point_') > -1) {
	                    var seriesIndex = +(targetId.split('_Series_')[1].split('_Point_')[0]);
	                    var pointIndex = +(targetId.split('_Series_')[1].replace('_Symbol', '').split('_Point_')[1]);
	                    var pointRegion = this.visibleSeries[seriesIndex].points[pointIndex].symbolLocations[0];
	                    this.mouseX = pointRegion.x + this.initialClipRect.x;
	                    this.mouseY = pointRegion.y + this.initialClipRect.y;
	                    if (this.highlightModule) {
	                        this.highlightModule.highlightChart(document.getElementById(targetId), 'mousemove');
	                        this.highlightModule.completeSelection(document.getElementById(targetId), 'mousemove');
	                    }
	                    if (this.tooltipModule) {
	                        this.tooltipModule.tooltip();
	                    }
	                }
	                if (this.highlightModule && this.highlightMode !== 'None') {
	                    targetId = targetId.indexOf('_chart_legend_g_') > -1 ? document.getElementById(targetId).firstChild['id'] : targetId;
	                    var legendID = this.element.id + '_chart_legend';
	                    var legendItemsId = [legendID + '_text_', legendID + '_shape_marker_',
	                        legendID + '_shape_'];
	                    for (var i = 0; i < legendItemsId.length; i++) {
	                        var id = legendItemsId[i];
	                        if (targetId.indexOf(id) > -1) {
	                            document.getElementById(targetId).setAttribute('class', '');
	                            this.highlightModule.legendSelection(this, parseInt(targetId.split(id)[1], 10), document.getElementById(targetId), 'mousemove');
	                            break;
	                        }
	                    }
	                }
	                break;
	            case 'Enter':
	            case 'Space':
	                if (targetId.indexOf('_chart_legend_') > -1) {
	                    this.isLegendClicked = true;
	                    this.legendModule.click(e);
	                    this.focusChild(document.getElementById(targetId).parentElement);
	                }
	                else {
	                    this.selectionModule.calculateSelectedElements(document.getElementById(targetId), 'click');
	                }
	                break;
	            case 'CtrlP':
	                this.print();
	                break;
	            case 'ESC':
	                this.tooltipModule.removeTooltip(1);
	                break;
	            case 'Equal':
	            case 'Minus':
	                this.zoomModule.isZoomed = this.zoomModule.performedUI = true;
	                this.zoomModule.isPanning = this.isChartDrag = false;
	                if (actionKey === 'Equal') {
	                    this.zoomModule.toolkit.zoomInOutCalculation(1, this, this.axisCollections, this.zoomSettings.mode);
	                }
	                else {
	                    this.zoomModule.toolkit.zoomInOutCalculation(-1, this, this.axisCollections, this.zoomSettings.mode);
	                }
	                this.zoomModule.performZoomRedraw(this);
	                this.element.focus();
	                break;
	            case 'ArrowUp':
	            case 'ArrowDown':
	            case 'ArrowLeft':
	            case 'ArrowRight':
	                var yArrowPadding = actionKey === 'ArrowUp' ? 10 : (actionKey === 'ArrowDown' ? -10 : 0);
	                var xArrowPadding = actionKey === 'ArrowLeft' ? -10 : (actionKey === 'ArrowRight' ? 10 : 0);
	                this.zoomModule.isPanning = this.isChartDrag = true;
	                this.zoomModule.doPan(this, this.axisCollections, xArrowPadding, yArrowPadding);
	                this.zoomModule.performZoomRedraw(this);
	                this.element.focus();
	                break;
	            case 'R':
	                this.zoomModule.toolkit.reset(e);
	                break;
	        }
	    };
	    /**
	     * Handles the mouse click on chart.
	     *
	     * @returns {boolean} false
	     * @private
	     */
	    Chart.prototype.chartOnMouseClick = function (e) {
	        var _this = this;
	        var element = e.target;
	        var chart = this;
	        this.clickCount++;
	        var timeInterval = 400;
	        if (this.clickCount === 1) {
	            this.singleClickTimer = +setTimeout(function () {
	                chart.clickCount = 0;
	                chart.trigger(chartMouseClick, { target: element.id, x: chart.mouseX, y: chart.mouseY });
	            }, timeInterval);
	        }
	        else if (this.clickCount === 2 && !this.pointDoubleClick) {
	            clearTimeout(this.singleClickTimer);
	            this.clickCount = 0;
	        }
	        var isAngular = 'isAngular';
	        if (this[isAngular]) {
	            var observers = 'observers';
	            timeInterval = this.pointDoubleClick[observers].length > 0 ? 400 : 0;
	        }
	        else {
	            timeInterval = this.pointDoubleClick ? 400 : 0;
	        }
	        if (this.clickCount === 1 && this.pointClick) {
	            this.singleClickTimer = +setTimeout(function () {
	                _this.clickCount = 0;
	                _this.triggerPointEvent(pointClick, e);
	            }, timeInterval);
	        }
	        else if (this.clickCount === 2 && this.pointDoubleClick) {
	            clearTimeout(this.singleClickTimer);
	            this.clickCount = 0;
	            this.triggerPointEvent(pointDoubleClick, e);
	        }
	        if (this.axisLabelClick) {
	            this.triggerAxisLabelClickEvent(axisLabelClick, e);
	        }
	        this.notify('click', e);
	        return false;
	    };
	    Chart.prototype.triggerPointEvent = function (event, e) {
	        var evt = e;
	        var data = new ChartData(this);
	        var pointData = data.getData();
	        if (pointData.series && pointData.point) {
	            this.trigger(event, {
	                series: this.isBlazor ? {} : pointData.series,
	                point: pointData.point,
	                seriesIndex: pointData.series.index, pointIndex: pointData.point.index,
	                x: this.mouseX, y: this.mouseY, pageX: evt.pageX, pageY: evt.pageY
	            });
	        }
	    };
	    Chart.prototype.triggerAxisLabelClickEvent = function (event, e) {
	        var targetElement = e.target;
	        var clickEvt = e;
	        if (targetElement.id.indexOf('_AxisLabel_') !== -1) {
	            var index = targetElement.id.split('_AxisLabel_');
	            var axisIndex = +index[0].slice(-1);
	            var labelIndex = +index[1];
	            var currentAxis = this.axisCollections[axisIndex];
	            if (currentAxis.visible && (axisIndex === 0 || axisIndex === 1)) {
	                this.trigger(event, {
	                    chart: this,
	                    axis: currentAxis,
	                    text: currentAxis.visibleLabels[labelIndex].text,
	                    labelID: targetElement.id,
	                    index: labelIndex,
	                    location: new ChartLocation(clickEvt.pageX, clickEvt.pageY),
	                    value: currentAxis.visibleLabels[labelIndex].value
	                });
	            }
	        }
	    };
	    /**
	     * Handles the mouse move on chart.
	     *
	     * @returns {boolean} false
	     * @private
	     */
	    Chart.prototype.chartOnMouseMove = function (e) {
	        var element = e.target;
	        this.trigger(chartMouseMove, { target: element.id, x: this.mouseX, y: this.mouseY });
	        if (this.pointMove) {
	            this.triggerPointEvent(pointMove, e);
	        }
	        // Tooltip for chart series.
	        if (!this.isTouch) {
	            this.titleTooltip(e, this.mouseX, this.mouseY);
	            this.axisTooltip(e, this.mouseX, this.mouseY);
	        }
	        if (this.dataEditingModule) {
	            this.dataEditingModule.pointMouseMove(e);
	        }
	        this.notify(Browser.touchMoveEvent, e);
	        this.isTouch = false;
	        return false;
	    };
	    Chart.prototype.titleTooltip = function (event, x, y, isTouch) {
	        var targetId = event.target.id;
	        var id = (targetId === (this.element.id + '_ChartTitle') || targetId === (this.element.id + '_ChartSubTitle') ||
	            targetId.indexOf('_AxisTitle') > -1 || targetId.indexOf('_legend_title') > -1);
	        var index = 0;
	        if (targetId.indexOf('_AxisTitle') > -1) {
	            index = parseInt(((targetId.replace(this.element.id, '')).replace('AxisLabel_', '')).split('_')[2], 10);
	        }
	        if (id && (event.target.textContent.indexOf('...') > -1)) {
	            var title = (targetId === (this.element.id + '_ChartTitle')) ? this.title :
	                targetId.indexOf('_AxisTitle') > -1 ? this.axisCollections[index].title :
	                    targetId.indexOf('_ChartSubTitle') > -1 ? this.subTitle : this.legendSettings.title;
	            showTooltip(title, x, y, this.element.offsetWidth, this.element.id + '_EJ2_Title_Tooltip', getElement(this.element.id + '_Secondary_Element'), isTouch);
	        }
	        else {
	            removeElement(this.element.id + '_EJ2_Title_Tooltip');
	        }
	    };
	    Chart.prototype.axisTooltip = function (event, x, y, isTouch) {
	        var targetId = event.target.id;
	        if (((targetId.indexOf('AxisLabel') > -1) || targetId.indexOf('Axis_MultiLevelLabel') > -1) &&
	            (event.target.textContent.indexOf('...') > -1)) {
	            var isTitleOrLegendEnabled = (this.legendSettings.visible || this.primaryXAxis.title === '');
	            showTooltip(this.findAxisLabel(targetId), x, y, this.element.offsetWidth, this.element.id + '_EJ2_AxisLabel_Tooltip', getElement(this.element.id + '_Secondary_Element'), isTouch, isTitleOrLegendEnabled);
	        }
	        else {
	            removeElement(this.element.id + '_EJ2_AxisLabel_Tooltip');
	        }
	    };
	    Chart.prototype.findAxisLabel = function (text) {
	        var texts;
	        if (text.indexOf('AxisLabel') > -1) {
	            texts = ((text.replace(this.element.id, '')).replace('AxisLabel_', '')).split('_');
	            return this.axisCollections[parseInt(texts[0], 10)].visibleLabels[parseInt(texts[1], 10)].originalText;
	        }
	        else {
	            texts = ((text.replace(this.element.id, '')).replace('Axis_MultiLevelLabel_Level_', '').replace('Text_', '')).split('_');
	            return (this.axisCollections[parseInt(texts[0], 10)].multiLevelLabels[parseInt(texts[1], 10)]
	                .categories[parseInt(texts[2], 10)].text);
	        }
	    };
	    /**
	     * Handles the mouse down on chart.
	     *
	     * @returns {boolean} false
	     * @private
	     */
	    Chart.prototype.chartOnMouseDown = function (e) {
	        var pageX;
	        var pageY;
	        var target;
	        var touchArg;
	        var offset = Browser.isDevice ? 20 : 30;
	        var rect = this.element.getBoundingClientRect();
	        var element = e.target;
	        if (this.stockChart && this.stockChart.zoomSettings.enablePan) {
	            this.allowPan = true;
	        }
	        this.trigger(chartMouseDown, { target: element.id, x: this.mouseX, y: this.mouseY });
	        if (e.type === 'touchstart') {
	            this.isTouch = true;
	            touchArg = e;
	            pageX = touchArg.changedTouches[0].clientX;
	            pageY = touchArg.changedTouches[0].clientY;
	            target = touchArg.target;
	        }
	        else {
	            this.isTouch = e.pointerType === 'touch';
	            pageX = e.clientX;
	            pageY = e.clientY;
	            target = e.target;
	        }
	        var svgRect = getElement(this.svgId).getBoundingClientRect();
	        this.mouseDownX = this.previousMouseMoveX = (pageX - rect.left) - Math.max(svgRect.left - rect.left, 0);
	        this.mouseDownY = this.previousMouseMoveY = (pageY - rect.top) - Math.max(svgRect.top - rect.top, 0);
	        if (this.isTouch) {
	            this.isDoubleTap = (new Date().getTime() < this.threshold && target.id.indexOf(this.element.id + '_Zooming_') === -1 &&
	                (this.mouseDownX - offset >= this.mouseX || this.mouseDownX + offset >= this.mouseX) &&
	                (this.mouseDownY - offset >= this.mouseY || this.mouseDownY + offset >= this.mouseY) &&
	                (this.mouseX - offset >= this.mouseDownX || this.mouseX + offset >= this.mouseDownX) &&
	                (this.mouseY - offset >= this.mouseDownY || this.mouseY + offset >= this.mouseDownY));
	        }
	        if (this.dataEditingModule) {
	            this.dataEditingModule.pointMouseDown();
	        }
	        this.notify(Browser.touchStartEvent, e);
	        return false;
	    };
	    /**
	     * Handles the mouse up.
	     *
	     * @returns {boolean} false
	     * @private
	     */
	    Chart.prototype.mouseEnd = function (e) {
	        var pageY;
	        var pageX;
	        var touchArg;
	        if (e.type === 'touchend') {
	            touchArg = e;
	            pageX = touchArg.changedTouches[0].clientX;
	            this.isTouch = true;
	            pageY = touchArg.changedTouches[0].clientY;
	        }
	        else {
	            pageY = e.clientY;
	            pageX = e.clientX;
	            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';
	        }
	        this.setMouseXY(pageX, pageY);
	        this.chartOnMouseUp(e);
	        return false;
	    };
	    /**
	     * Handles the mouse up.
	     *
	     * @returns {boolean}
	     * @private
	     */
	    Chart.prototype.chartOnMouseUp = function (e) {
	        var element = e.target;
	        this.trigger(chartMouseUp, { target: element.id, x: this.mouseX, y: this.mouseY });
	        this.isChartDrag = false;
	        this.allowPan = false;
	        if (this.isTouch) {
	            this.titleTooltip(e, this.mouseX, this.mouseY, this.isTouch);
	            this.axisTooltip(e, this.mouseX, this.mouseY, this.isTouch);
	            this.threshold = new Date().getTime() + 300;
	        }
	        if (this.dataEditingModule) {
	            this.dataEditingModule.pointMouseUp();
	        }
	        if (!this.enableCanvas && this.seriesElements) {
	            this.seriesElements.removeAttribute('clip-path');
	        }
	        this.notify(Browser.touchEndEvent, e);
	        return false;
	    };
	    /**
	     * Method to set culture for chart
	     */
	    Chart.prototype.setCulture = function () {
	        this.intl = new Internationalization();
	        this.setLocaleConstants();
	        this.localeObject = new L10n(this.getModuleName(), this.defaultLocalConstants, this.locale);
	    };
	    /**
	     * Method to set the annotation content dynamically for chart.
	     */
	    Chart.prototype.setAnnotationValue = function (annotationIndex, content) {
	        var parentNode = getElement(this.element.id + '_Annotation_Collections');
	        var annotation = this.annotations[annotationIndex];
	        var element;
	        if (content !== null) {
	            annotation.content = content;
	            if (parentNode) {
	                removeElement(this.element.id + '_Annotation_' + annotationIndex);
	                element = this.createElement('div');
	                this.annotationModule.processAnnotation(annotation, annotationIndex, element);
	                parentNode.appendChild(element.children[0]);
	            }
	            else {
	                this.annotationModule.renderAnnotations(getElement(this.element.id + '_Secondary_Element'));
	            }
	        }
	    };
	    /**
	     * Method to set locale constants
	     */
	    Chart.prototype.setLocaleConstants = function () {
	        this.defaultLocalConstants = {
	            ZoomIn: 'Zoom in',
	            Zoom: 'Zoom',
	            ZoomOut: 'Zoom out',
	            Pan: 'Pan',
	            Reset: 'Reset',
	            ResetZoom: 'Reset Zoom'
	        };
	    };
	    /**
	     * Theming for chart
	     */
	    Chart.prototype.setTheme = function () {
	        /*! Set theme */
	        this.themeStyle = getThemeColor(this.theme, this.enableCanvas);
	        if (!(document.getElementById(this.element.id + 'Keyboard_chart_focus'))) {
	            var style = document.createElement('style');
	            style.setAttribute('id', this.element.id + 'Keyboard_chart_focus');
	            style.innerText = '.e-chart-focused:focus, path[class*=_ej2_chart_selection_series]:focus,' +
	                'path[id*=_Point_]:focus, text[id*=_ChartTitle]:focus {outline: none } .e-chart-focused:focus-visible, path[class*=_ej2_chart_selection_series]:focus-visible,' +
	                'path[id*=_Point_]:focus-visible, text[id*=_ChartTitle]:focus-visible {outline: 1.5px ' + this.themeStyle.tabColor + ' solid}';
	            document.body.appendChild(style);
	        }
	    };
	    /**
	     * To provide the array of modules needed for control rendering
	     *
	     * @returns {ModuleDeclaration[]}
	     * @private
	     */
	    /* eslint-disable  */
	    Chart.prototype.requiredModules = function () {
	        var _this = this;
	        var modules = [];
	        var series = this.series;
	        var enableAnnotation = false;
	        var moduleName;
	        var errorBarVisible = false;
	        var isPointDrag = false;
	        var dataLabelEnable = false;
	        var zooming = this.zoomSettings;
	        this.chartAreaType = (series.length > 0 && (series[0].type === 'Polar' || series[0].type === 'Radar')) ? 'PolarRadar' : 'Cartesian';
	        if (this.tooltip.enable) {
	            modules.push({
	                member: 'Tooltip',
	                args: [this]
	            });
	        }
	        series.map(function (value) {
	            _this.isLegend = (_this.legendSettings.visible && ((value.name !== '') || !!_this.isLegend));
	            moduleName = value.type.indexOf('100') !== -1 ? value.type.replace('100', '') + 'Series' : value.type + 'Series';
	            errorBarVisible = value.errorBar.visible || errorBarVisible;
	            dataLabelEnable = value.marker.dataLabel.visible || dataLabelEnable || (value.type == 'Pareto' && value.paretoOptions.marker.dataLabel.visible);
	            isPointDrag = value.dragSettings.enable || isPointDrag;
	            if (!modules.some(function (currentModule) {
	                return currentModule.member === moduleName;
	            })) {
	                modules.push({
	                    member: moduleName,
	                    args: [_this, series]
	                });
	            }
	            if (_this.chartAreaType === 'PolarRadar') {
	                modules.push({
	                    member: value.drawType + 'Series',
	                    args: [_this, series]
	                });
	            }
	            if (value.type === 'Pareto') {
	                modules.push({
	                    member: 'ColumnSeries',
	                    args: [_this, series]
	                });
	                modules.push({
	                    member: 'LineSeries',
	                    args: [_this, series]
	                });
	            }
	        });
	        this.findIndicatorModules(modules);
	        this.findTrendLineModules(modules);
	        modules = this.findAxisModule(modules);
	        enableAnnotation = this.annotations.some(function (value) {
	            return (value.content !== null);
	        });
	        if (errorBarVisible) {
	            modules.push({
	                member: 'ErrorBar',
	                args: [this, series]
	            });
	        }
	        if (this.isLegend) {
	            modules.push({
	                member: 'Legend',
	                args: [this]
	            });
	        }
	        if (this.enableExport || this.allowExport) {
	            modules.push({
	                member: 'Export',
	                args: [this]
	            });
	        }
	        if (this.chartAreaType !== 'PolarRadar' && this.crosshair.enable) {
	            modules.push({
	                member: 'Crosshair',
	                args: [this]
	            });
	        }
	        if (this.chartAreaType !== 'PolarRadar' && !this.scrollSettingEnabled && (zooming.enableSelectionZooming
	            || zooming.enableMouseWheelZooming || zooming.enablePinchZooming || zooming.enablePan || zooming.enableScrollbar || zooming.showToolbar)) {
	            modules.push({
	                member: 'Zoom',
	                args: [this, this.zoomSettings]
	            });
	            if (zooming.enableScrollbar) {
	                modules.push({
	                    member: 'ScrollBar',
	                    args: [this]
	                });
	            }
	        }
	        if (this.selectionMode !== 'None' && !(this.chartAreaType === 'PolarRadar' &&
	            this.selectionMode.indexOf('Drag') > -1)) {
	            modules.push({
	                member: 'Selection',
	                args: [this]
	            });
	        }
	        if (this.highlightMode !== 'None' || this.legendSettings.enableHighlight) {
	            modules.push({
	                member: 'Highlight',
	                args: [this]
	            });
	        }
	        if (dataLabelEnable) {
	            modules.push({
	                member: 'DataLabel',
	                args: [this, series]
	            });
	        }
	        if (isPointDrag) {
	            modules.push({
	                member: 'DataEditing',
	                args: [this]
	            });
	        }
	        if (enableAnnotation) {
	            modules.push({
	                member: 'Annotation',
	                args: [this]
	            });
	        }
	        return modules;
	    };
	    Chart.prototype.findAxisModule = function (modules) {
	        var axisCollections = [];
	        axisCollections.push(this.primaryXAxis);
	        axisCollections.push(this.primaryYAxis);
	        axisCollections = axisCollections.concat(this.axes);
	        var datetimeEnabled = false;
	        var categoryEnabled = false;
	        var logarithmicEnabled = false;
	        var striplineEnabled = false;
	        var dateTimeCategoryEnabled = false;
	        var multiLevelEnabled = false;
	        for (var _i = 0, axisCollections_1 = axisCollections; _i < axisCollections_1.length; _i++) {
	            var axis = axisCollections_1[_i];
	            datetimeEnabled = axis.valueType === 'DateTime' || datetimeEnabled;
	            categoryEnabled = axis.valueType === 'Category' || categoryEnabled;
	            logarithmicEnabled = axis.valueType === 'Logarithmic' || logarithmicEnabled;
	            dateTimeCategoryEnabled = axis.valueType === 'DateTimeCategory' || dateTimeCategoryEnabled;
	            striplineEnabled = this.findStriplineVisibility(axis.stripLines) || striplineEnabled;
	            multiLevelEnabled = axis.multiLevelLabels.length > 0 || multiLevelEnabled;
	            this.scrollSettingEnabled = axis.scrollbarSettings.enable ? true : this.scrollSettingEnabled;
	        }
	        if (datetimeEnabled) {
	            modules.push({
	                member: 'DateTime',
	                args: [this]
	            });
	        }
	        if (categoryEnabled) {
	            modules.push({
	                member: 'Category',
	                args: [this]
	            });
	        }
	        if (logarithmicEnabled) {
	            modules.push({
	                member: 'Logarithmic',
	                args: [this]
	            });
	        }
	        if (striplineEnabled) {
	            modules.push({
	                member: 'StripLine',
	                args: [this]
	            });
	        }
	        if (multiLevelEnabled) {
	            modules.push({
	                member: 'MultiLevelLabel',
	                args: [this]
	            });
	        }
	        if (dateTimeCategoryEnabled) {
	            modules.push({
	                member: 'DateTimeCategory',
	                args: [this]
	            });
	        }
	        if (this.scrollSettingEnabled) {
	            modules.push({
	                member: 'ScrollBar',
	                args: [this]
	            });
	        }
	        return modules;
	    };
	    Chart.prototype.findIndicatorModules = function (modules) {
	        var macdEnable;
	        var bandEnable;
	        var indicators = this.indicators;
	        if (this.indicators.length) {
	            modules.push({
	                member: 'LineSeries',
	                args: [this]
	            });
	            indicators.map(function (indicator) {
	                macdEnable = macdEnable || indicator.type === 'Macd';
	                bandEnable = bandEnable || indicator.type === 'BollingerBands';
	            });
	            if (macdEnable) {
	                modules.push({
	                    member: 'ColumnSeries',
	                    args: [this]
	                });
	            }
	            if (bandEnable) {
	                modules.push({
	                    member: 'RangeAreaSeries',
	                    args: [this]
	                });
	            }
	            if (bandEnable) {
	                modules.push({
	                    member: 'SplineRangeAreaSeries',
	                    args: [this]
	                });
	            }
	            for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {
	                var indicator = _a[_i];
	                modules.push({
	                    member: indicator.type + 'Indicator',
	                    args: [this]
	                });
	            }
	        }
	    };
	    Chart.prototype.findTrendLineModules = function (modules) {
	        var isLine;
	        var isSpline;
	        var _loop_1 = function (series) {
	            var markerEnable;
	            series.trendlines.map(function (trendline) {
	                markerEnable = markerEnable || trendline.marker.visible;
	                isLine = isLine || (trendline.type === 'Linear' || trendline.type === 'MovingAverage') ? true : false;
	                isSpline = isSpline || !isLine ? true : false;
	            });
	            if (markerEnable) {
	                modules.push({
	                    member: 'Marker',
	                    args: [this_1, series]
	                });
	            }
	        };
	        var this_1 = this;
	        for (var _i = 0, _a = this.series; _i < _a.length; _i++) {
	            var series = _a[_i];
	            _loop_1(series);
	        }
	        if (isLine || isSpline) {
	            modules.push({
	                member: 'TrendLine',
	                args: [this]
	            });
	        }
	        if (isLine) {
	            modules.push({
	                member: 'LineSeries',
	                args: [this]
	            });
	        }
	        if (isSpline) {
	            modules.push({
	                member: 'SplineSeries',
	                args: [this]
	            });
	        }
	    };
	    Chart.prototype.findStriplineVisibility = function (striplines) {
	        var visible = false;
	        for (var _i = 0, striplines_1 = striplines; _i < striplines_1.length; _i++) {
	            var stripline = striplines_1[_i];
	            if (stripline.visible) {
	                visible = true;
	                break;
	            }
	        }
	        return visible;
	    };
	    /**
	     * To Remove the SVG.
	     * @return {boolean}
	     * @private
	     */
	    Chart.prototype.removeSvg = function () {
	        if (this.redraw) {
	            return null;
	        }
	        blazorTemplatesReset(this);
	        if (this.enableCanvas && this.svgObject && this.svgObject.tagName === 'CANVAS') {
	            this.renderer.clearRect(new Rect(0, 0, this.availableSize.width, this.availableSize.height));
	            if (this.svgObject.parentNode) {
	                remove(this.svgObject);
	            }
	            return null;
	        }
	        removeElement(this.element.id + '_Secondary_Element');
	        if (this.isReact) {
	            this.clearTemplate();
	        }
	        var removeLength = 0;
	        if (this.zoomModule && this.zoomModule.pinchTarget) {
	            this.zoomModule.pinchTarget.id = '';
	            this.zoomModule.pinchTarget.setAttribute('opacity', '0');
	            this.svgObject.appendChild(this.zoomModule.pinchTarget);
	            removeLength = 1;
	        }
	        // Fix for blazor resize issue
	        if (!isNullOrUndefined(this.resizeTo)) {
	            if (this.resizeTo !== this.checkResize && this.isBlazor && this.element.childElementCount) {
	                var containerCollection = document.querySelectorAll('.e-chart');
	                for (var index = 0; index < containerCollection.length; index++) {
	                    var container = containerCollection[index];
	                    while (container.firstChild) {
	                        remove(container.firstChild);
	                    }
	                }
	            }
	            this.checkResize = this.resizeTo;
	        }
	        if (this.svgObject) {
	            while (this.svgObject.childNodes.length > removeLength) {
	                this.svgObject.removeChild(this.svgObject.firstChild);
	            }
	            if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode && !(this.stockChart)) {
	                remove(this.svgObject);
	            }
	        }
	    };
	    Chart.prototype.refreshDefinition = function (definitions) {
	        for (var _i = 0, definitions_1 = definitions; _i < definitions_1.length; _i++) {
	            var item = definitions_1[_i];
	            item.axes = [];
	        }
	    };
	    /**
	     * Refresh the axis default value.
	     *
	     * @returns {boolean}
	     * @private
	     */
	    Chart.prototype.refreshAxis = function () {
	        var axis = this.primaryXAxis;
	        axis.rect = new Rect(undefined, undefined, 0, 0);
	        axis = this.primaryYAxis;
	        axis.isStack100 = false;
	        axis.rect = new Rect(undefined, undefined, 0, 0);
	        for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
	            var item = _a[_i];
	            axis = item;
	            axis.rect = new Rect(undefined, undefined, 0, 0);
	            axis.isStack100 = false;
	        }
	        if (this.paretoSeriesModule && this.series[0].type === 'Pareto') {
	            for (var _b = 0, _c = this.paretoSeriesModule.paretoAxes; _b < _c.length; _b++) {
	                var item = _c[_b];
	                axis = item;
	                axis.rect = new Rect(undefined, undefined, 0, 0);
	                axis.isStack100 = false;
	            }
	        }
	    };
	    Chart.prototype.axisChange = function (axis) {
	        if (!axis.name && !axis.valueType) {
	            return false;
	        }
	        this.refreshDefinition(this.columns);
	        this.refreshDefinition(this.rows);
	        this.calculateVisibleAxis();
	        this.processData();
	        return true;
	    };
	    /**
	     * Get visible series by index
	     */
	    Chart.prototype.getVisibleSeries = function (visibleSeries, index) {
	        for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
	            var series = visibleSeries_1[_i];
	            if (index === series.index) {
	                return series;
	            }
	        }
	        return null;
	    };
	    /**
	     * Fix for live data update flicker issue
	     */
	    Chart.prototype.refreshLiveData = function () {
	        this.calculateVisibleSeries();
	        this.initTechnicalIndicators();
	        this.initTrendLines();
	        this.refreshDefinition(this.columns);
	        this.refreshDefinition(this.rows);
	        this.calculateVisibleAxis();
	        this.processData(false);
	        if (!this.isBlazor) {
	            this.enableCanvas ? this.createChartSvg() : this.removeSvg();
	            this.refreshAxis();
	            this.refreshBound();
	            this.trigger('loaded', { chart: this.isBlazor ? {} : this });
	        }
	    };
	    /**
	     * To remove style element
	     */
	    Chart.prototype.removeStyles = function () {
	        removeElement(this.element.id + '_ej2_chart_selection');
	        removeElement(this.element.id + '_ej2_chart_highlight');
	    };
	    /**
	     * To trigger the manual mouse move event for live chart tooltip
	     */
	    Chart.prototype.mouseMoveEvent = function () {
	        if (this.tooltip.enable && this.previousPageX !== null && this.previousPageY !== null) {
	            var mousemove = document.createEvent('MouseEvent');
	            mousemove.initMouseEvent('mousemove', true, false, window, 1, 100, 100, this.previousPageX, this.previousPageY, false, false, false, false, 0, null);
	            this.element.dispatchEvent(mousemove);
	        }
	    };
	    /**
	     * Displays a tooltip for the data points.
	     *
	     * @param {object} x - Specifies the x value of the point or x coordinate.
	     * @param {number} y - Specifies the x value of the point or y coordinate.
	     * @param {boolean} isPoint - Specifies whether x and y are data point or chart coordinates.
	     * @returns {void}
	     */
	    Chart.prototype.showTooltip = function (x, y, isPoint) {
	        if (isPoint === void 0) { isPoint = false; }
	        if (isPoint) {
	            for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {
	                var series = _a[_i];
	                for (var _b = 0, _c = series.points; _b < _c.length; _b++) {
	                    var point = _c[_b];
	                    var pointX = series.xAxis.valueType == 'DateTime' ? point.xValue : point.x;
	                    var xValue = x;
	                    if (series.xAxis.valueType == 'DateTime') {
	                        xValue = new Date(xValue).getTime();
	                    }
	                    if (x == pointX && y === point.yValue) {
	                        this.mouseX = point.regions[0].x + this.chartAxisLayoutPanel.seriesClipRect.x;
	                        this.mouseY = point.regions[0].y + this.chartAxisLayoutPanel.seriesClipRect.y;
	                        this.tooltipModule.tooltip();
	                        this.markerRender.mouseMoveHandler();
	                        break;
	                    }
	                }
	            }
	        }
	        else {
	            this.mouseX = x;
	            this.mouseY = y;
	            this.tooltipModule.mouseMoveHandler();
	            this.markerRender.mouseMoveHandler();
	        }
	    };
	    /**
	     * Hides a tooltip in the chart.
	     *
	     * @returns {void}
	     */
	    Chart.prototype.hideTooltip = function () {
	        this.tooltipModule.removeTooltip(Browser.isDevice ? 2000 : 1000);
	    };
	    /**
	     * Displays a crosshair for the chart.
	     *
	     * @param {object} x - Specifies the x value of the point or x coordinate.
	     * @param {number} y - Specifies the x value of the point or y coordinate.
	     * @returns {void}
	     */
	    Chart.prototype.showCrosshair = function (x, y) {
	        this.mouseX = x;
	        this.mouseY = y;
	        this.isCrosshair = false;
	        if (withInBounds(this.mouseX, this.mouseY, this.chartAxisLayoutPanel.seriesClipRect)) {
	            this.crosshairModule.crosshair();
	        }
	        else {
	            this.hideCrosshair();
	        }
	        this.isCrosshair = true;
	    };
	    /**
	     * Hides a tooltip in the chart.
	     *
	     * @returns {void}
	     */
	    Chart.prototype.hideCrosshair = function () {
	        this.crosshairModule.removeCrosshair(Browser.isDevice ? 2000 : 1000);
	    };
	    /**
	     * Called internally if any of the property value changed.
	     * @private
	     */
	    // tslint:disable-next-line:max-func-body-length
	    Chart.prototype.onPropertyChanged = function (newProp, oldProp) {
	        var renderer = false;
	        var refreshBounds = false;
	        this.animateSeries = false;
	        var axis;
	        if (!this.delayRedraw) {
	            for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
	                var prop = _a[_i];
	                switch (prop) {
	                    case 'primaryXAxis':
	                        axis = newProp.primaryXAxis;
	                        refreshBounds = this.axisChange(axis);
	                        if (newProp.primaryXAxis.edgeLabelPlacement) {
	                            renderer = true;
	                        }
	                        if (!newProp.primaryXAxis.crosshairTooltip) {
	                            refreshBounds = true;
	                        }
	                        if (!isNullOrUndefined(axis.isInversed) || !isNullOrUndefined(axis.opposedPosition)) {
	                            this.primaryXAxis.setIsInversedAndOpposedPosition();
	                        }
	                        break;
	                    case 'primaryYAxis':
	                        axis = newProp.primaryYAxis;
	                        refreshBounds = this.axisChange(axis);
	                        if (newProp.primaryYAxis.edgeLabelPlacement) {
	                            renderer = true;
	                        }
	                        if (!newProp.primaryYAxis.crosshairTooltip) {
	                            refreshBounds = true;
	                        }
	                        if (!isNullOrUndefined(axis.isInversed) || !isNullOrUndefined(axis.opposedPosition)) {
	                            this.primaryYAxis.setIsInversedAndOpposedPosition();
	                        }
	                        break;
	                    case 'axes':
	                        for (var _b = 0, _c = Object.keys(newProp.axes); _b < _c.length; _b++) {
	                            var index = _c[_b];
	                            axis = newProp.axes[index];
	                            refreshBounds = refreshBounds || this.axisChange(axis);
	                            if (!axis.crosshairTooltip) {
	                                refreshBounds = true;
	                            }
	                            if (!isNullOrUndefined(axis.isInversed) || !isNullOrUndefined(axis.opposedPosition)) {
	                                this.axes[index].setIsInversedAndOpposedPosition();
	                            }
	                        }
	                        break;
	                    case 'height':
	                    case 'width':
	                        this.createChartSvg();
	                        refreshBounds = true;
	                        break;
	                    case 'subTitle':
	                    case 'title':
	                        refreshBounds = true;
	                        break;
	                    case 'titleStyle':
	                        if (newProp.titleStyle && (newProp.titleStyle.size || newProp.titleStyle.textOverflow)) {
	                            refreshBounds = true;
	                        }
	                        else {
	                            renderer = true;
	                        }
	                        break;
	                    case 'subTitleStyle':
	                        if (newProp.subTitleStyle && (newProp.subTitleStyle.size || newProp.subTitleStyle.textOverflow)) {
	                            refreshBounds = true;
	                        }
	                        else {
	                            renderer = true;
	                        }
	                        break;
	                    case 'border':
	                        renderer = true;
	                        break;
	                    case 'dataSource':
	                        this.processData(false);
	                        refreshBounds = true;
	                        break;
	                    case 'enableCanvas':
	                        this.refresh();
	                        break;
	                    case 'series':
	                        var len = this.series.length;
	                        var seriesRefresh = false;
	                        var series = void 0;
	                        var blazorProp = void 0;
	                        for (var i = 0; i < len; i++) {
	                            series = newProp.series[i];
	                            // I264774 blazor series visible property binding not working issue fixed.
	                            if (this.isBlazor && series && ((series.visible !== oldProp.series[i].visible) || series.isClosed ||
	                                series.marker || series.emptyPointSettings || series.type || series.boxPlotMode || series.showMean)) {
	                                blazorProp = true;
	                            }
	                            if (series && (series.dataSource || series.query || series.errorBar || series.xName ||
	                                series.yName || series.size || series.high || series.low || series.open || series.close || series.trendlines ||
	                                series.fill || series.name || series.marker || series.width || series.binInterval || blazorProp)) {
	                                extend(this.getVisibleSeries(this.visibleSeries, i), series, null, true);
	                                seriesRefresh = true;
	                            }
	                        }
	                        if (this.availableSize && this.element) {
	                            this.element.style.height = (!this.element.style.height || this.element.style.height == 'inherit') ? (this.availableSize.height + 'px') : this.element.style.height;
	                        }
	                        if (seriesRefresh) {
	                            this.calculateVisibleSeries();
	                            this.initTechnicalIndicators();
	                            this.initTrendLines();
	                            this.refreshDefinition(this.columns);
	                            this.refreshDefinition(this.rows);
	                            this.calculateVisibleAxis();
	                            this.processData(false);
	                            refreshBounds = true;
	                        }
	                        break;
	                    case 'indicators':
	                        refreshBounds = true;
	                        break;
	                    case 'zoomSettings':
	                        if (newProp.zoomSettings.enableScrollbar || oldProp.zoomSettings.enableScrollbar) {
	                            refreshBounds = true;
	                        }
	                        renderer = true;
	                        break;
	                    case 'background':
	                        renderer = true;
	                        break;
	                    case 'chartArea':
	                        if (newProp.chartArea.border && newProp.chartArea.border.width) {
	                            refreshBounds = true;
	                        }
	                        renderer = true;
	                        break;
	                    case 'legendSettings':
	                        if (!newProp.legendSettings.background || !newProp.legendSettings.opacity) {
	                            refreshBounds = true;
	                        }
	                        renderer = true;
	                        break;
	                    case 'palettes':
	                        this.calculateVisibleSeries();
	                        renderer = true;
	                        break;
	                    case 'selectedDataIndexes':
	                        if (this.selectionModule) {
	                            this.selectionModule.currentMode = this.selectionMode;
	                            this.selectionModule.selectedDataIndexes = this.selectedDataIndexes;
	                            this.selectionModule.styleId = this.element.id + '_ej2_chart_selection';
	                            this.selectionModule.redrawSelection(this, oldProp.selectionMode, true);
	                        }
	                        else if (this.highlightModule) {
	                            this.highlightModule.currentMode = this.highlightMode;
	                            this.highlightModule.highlightDataIndexes = this.selectedDataIndexes;
	                            this.highlightModule.styleId = this.element.id + '_ej2_chart_highlight';
	                            this.highlightModule.redrawSelection(this, oldProp.selectionMode, true);
	                        }
	                        break;
	                    case 'selectionMode':
	                        if (this.selectionModule && newProp.selectionMode && newProp.selectionMode.indexOf('Drag') === -1) {
	                            this.selectionModule.currentMode = this.selectionMode;
	                            this.selectionModule.styleId = this.element.id + '_ej2_chart_selection';
	                            this.selectionModule.redrawSelection(this, oldProp.selectionMode, true);
	                        }
	                        break;
	                    case 'isMultiSelect':
	                        if (this.selectionModule && !newProp.isMultiSelect && this.selectionModule.selectedDataIndexes.length > 1) {
	                            this.selectionModule.currentMode = this.selectionMode;
	                            this.selectionModule.styleId = this.element.id + '_ej2_chart_selection';
	                            this.selectionModule.redrawSelection(this, oldProp.selectionMode);
	                        }
	                        break;
	                    case 'highlightMode':
	                    case 'selectionPattern':
	                    case 'highlightPattern':
	                        this.removeStyles();
	                        renderer = true;
	                        break;
	                    case 'theme':
	                        this.animateSeries = true;
	                        break;
	                    case 'enableRtl':
	                    case 'locale':
	                    case 'currencyCode':
	                        if (this.isBlazor) {
	                            this.setCulture();
	                            renderer = true;
	                        }
	                        else {
	                            this.refresh();
	                        }
	                        break;
	                    case 'tooltip':
	                        if (this.tooltipModule) { // To check the tooltip enable is true.
	                            this.tooltipModule.previousPoints = [];
	                            if (this.tooltip.template) {
	                                this.tooltipModule.template = this.tooltip.template;
	                            }
	                        }
	                        break;
	                }
	            }
	            if (!refreshBounds && renderer) {
	                this.rotatedDataLabelCollections = [];
	                this.removeSvg();
	                this.renderElements();
	                this.trigger('loaded', { chart: this.isBlazor ? {} : this });
	            }
	            if (refreshBounds) {
	                this.enableCanvas ? this.createChartSvg() : this.removeSvg();
	                if (this.isReact) {
	                    this.clearTemplate();
	                }
	                this.dragY = null;
	                this.refreshAxis();
	                this.refreshBound();
	                this.trigger('loaded', { chart: this.isBlazor ? {} : this });
	                this.redraw = false;
	                this.animated = false;
	            }
	        }
	    };
	    __decorate([
	        Property(null)
	    ], Chart.prototype, "width", void 0);
	    __decorate([
	        Property(null)
	    ], Chart.prototype, "height", void 0);
	    __decorate([
	        Property('')
	    ], Chart.prototype, "title", void 0);
	    __decorate([
	        Property('')
	    ], Chart.prototype, "dataSource", void 0);
	    __decorate([
	        Complex({ fontFamily: null, size: "16px", fontStyle: 'Normal', fontWeight: '600', color: null }, titleSettings)
	    ], Chart.prototype, "titleStyle", void 0);
	    __decorate([
	        Property('')
	    ], Chart.prototype, "subTitle", void 0);
	    __decorate([
	        Complex({ fontFamily: null, size: "14px", fontStyle: 'Normal', fontWeight: '400', color: null }, titleSettings)
	    ], Chart.prototype, "subTitleStyle", void 0);
	    __decorate([
	        Complex({}, Margin)
	    ], Chart.prototype, "margin", void 0);
	    __decorate([
	        Complex({ color: '#DDDDDD', width: 0 }, Border)
	    ], Chart.prototype, "border", void 0);
	    __decorate([
	        Property(null)
	    ], Chart.prototype, "background", void 0);
	    __decorate([
	        Complex({ border: { color: null, width: 0.5 }, background: 'transparent' }, ChartArea)
	    ], Chart.prototype, "chartArea", void 0);
	    __decorate([
	        Complex({ name: 'primaryXAxis' }, Axis)
	    ], Chart.prototype, "primaryXAxis", void 0);
	    __decorate([
	        Complex({ name: 'primaryYAxis' }, Axis)
	    ], Chart.prototype, "primaryYAxis", void 0);
	    __decorate([
	        Collection([{}], Row)
	    ], Chart.prototype, "rows", void 0);
	    __decorate([
	        Collection([{}], Column)
	    ], Chart.prototype, "columns", void 0);
	    __decorate([
	        Collection([{}], Axis)
	    ], Chart.prototype, "axes", void 0);
	    __decorate([
	        Collection([{}], Series)
	    ], Chart.prototype, "series", void 0);
	    __decorate([
	        Collection([{}], ChartAnnotationSettings)
	    ], Chart.prototype, "annotations", void 0);
	    __decorate([
	        Property([])
	    ], Chart.prototype, "palettes", void 0);
	    __decorate([
	        Property('Material')
	    ], Chart.prototype, "theme", void 0);
	    __decorate([
	        Complex({}, TooltipSettings)
	    ], Chart.prototype, "tooltip", void 0);
	    __decorate([
	        Complex({}, CrosshairSettings)
	    ], Chart.prototype, "crosshair", void 0);
	    __decorate([
	        Complex({}, LegendSettings)
	    ], Chart.prototype, "legendSettings", void 0);
	    __decorate([
	        Collection([{}], RangeColorSetting)
	    ], Chart.prototype, "rangeColorSettings", void 0);
	    __decorate([
	        Complex({}, ZoomSettings)
	    ], Chart.prototype, "zoomSettings", void 0);
	    __decorate([
	        Property('')
	    ], Chart.prototype, "highlightColor", void 0);
	    __decorate([
	        Property('None')
	    ], Chart.prototype, "selectionMode", void 0);
	    __decorate([
	        Property('None')
	    ], Chart.prototype, "highlightMode", void 0);
	    __decorate([
	        Property('None')
	    ], Chart.prototype, "selectionPattern", void 0);
	    __decorate([
	        Property('None')
	    ], Chart.prototype, "highlightPattern", void 0);
	    __decorate([
	        Property(false)
	    ], Chart.prototype, "isMultiSelect", void 0);
	    __decorate([
	        Property(false)
	    ], Chart.prototype, "allowMultiSelection", void 0);
	    __decorate([
	        Property(true)
	    ], Chart.prototype, "enableExport", void 0);
	    __decorate([
	        Property(false)
	    ], Chart.prototype, "allowExport", void 0);
	    __decorate([
	        Collection([], Indexes)
	    ], Chart.prototype, "selectedDataIndexes", void 0);
	    __decorate([
	        Property(false)
	    ], Chart.prototype, "useGroupingSeparator", void 0);
	    __decorate([
	        Property(false)
	    ], Chart.prototype, "enableAutoIntervalOnBothAxis", void 0);
	    __decorate([
	        Property(false)
	    ], Chart.prototype, "isTransposed", void 0);
	    __decorate([
	        Property(false)
	    ], Chart.prototype, "enableCanvas", void 0);
	    __decorate([
	        Property(null)
	    ], Chart.prototype, "backgroundImage", void 0);
	    __decorate([
	        Collection([], TechnicalIndicator)
	    ], Chart.prototype, "indicators", void 0);
	    __decorate([
	        Property(true)
	    ], Chart.prototype, "enableAnimation", void 0);
	    __decorate([
	        Property(null)
	    ], Chart.prototype, "description", void 0);
	    __decorate([
	        Property(1)
	    ], Chart.prototype, "tabIndex", void 0);
	    __decorate([
	        Property(true)
	    ], Chart.prototype, "enableSideBySidePlacement", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "resized", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "beforeResize", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "annotationRender", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "beforePrint", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "loaded", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "beforeExport", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "afterExport", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "load", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "animationComplete", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "legendRender", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "textRender", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "pointRender", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "seriesRender", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "axisLabelRender", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "axisLabelClick", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "axisRangeCalculated", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "axisMultiLabelRender", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "legendClick", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "multiLevelLabelClick", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "tooltipRender", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "sharedTooltipRender", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "chartMouseMove", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "chartMouseClick", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "chartDoubleClick", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "pointClick", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "pointDoubleClick", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "pointMove", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "chartMouseLeave", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "chartMouseDown", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "chartMouseUp", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "dragComplete", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "selectionComplete", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "zoomComplete", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "onZooming", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "scrollStart", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "scrollEnd", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "scrollChanged", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "dragStart", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "drag", void 0);
	    __decorate([
	        Event()
	    ], Chart.prototype, "dragEnd", void 0);
	    __decorate([
	        Property('USD')
	    ], Chart.prototype, "currencyCode", void 0);
	    Chart = __decorate([
	        NotifyPropertyChanges
	    ], Chart);
	    return Chart;
	}(Component));

	var __extends$c = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Common axis classes
	 *
	 * @private
	 */
	var NiceInterval = /** @class */ (function (_super) {
	    __extends$c(NiceInterval, _super);
	    function NiceInterval() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * Method to calculate numeric datetime interval.
	     */
	    NiceInterval.prototype.calculateDateTimeNiceInterval = function (axis, size, start, end, isChart) {
	        if (isChart === void 0) { isChart = true; }
	        var oneDay = 24 * 60 * 60 * 1000;
	        var startDate = new Date(start);
	        var endDate = new Date(end);
	        //var axisInterval ;
	        var totalDays = (Math.abs((startDate.getTime() - endDate.getTime()) / (oneDay)));
	        var interval;
	        axis.actualIntervalType = axis.intervalType;
	        var type = axis.intervalType;
	        switch (type) {
	            case 'Years':
	                interval = this.calculateNumericNiceInterval(axis, totalDays / 365, size);
	                break;
	            case 'Quarter':
	                interval = this.calculateNumericNiceInterval(axis, (totalDays / 365) * 4, size);
	                break;
	            case 'Months':
	                interval = this.calculateNumericNiceInterval(axis, totalDays / 30, size);
	                break;
	            case 'Weeks':
	                interval = this.calculateNumericNiceInterval(axis, totalDays / 7, size);
	                break;
	            case 'Days':
	                interval = this.calculateNumericNiceInterval(axis, totalDays, size);
	                break;
	            case 'Hours':
	                interval = this.calculateNumericNiceInterval(axis, totalDays * 24, size);
	                break;
	            case 'Minutes':
	                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60, size);
	                break;
	            case 'Seconds':
	                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60 * 60, size);
	                break;
	            case 'Auto':
	                interval = this.calculateNumericNiceInterval(axis, totalDays / 365, size);
	                if (interval >= 1) {
	                    axis.actualIntervalType = 'Years';
	                    return interval;
	                }
	                interval = this.calculateNumericNiceInterval(axis, totalDays / 30, size);
	                if (interval >= 1) {
	                    axis.actualIntervalType = 'Months';
	                    return interval;
	                }
	                interval = this.calculateNumericNiceInterval(axis, totalDays / 7, size);
	                if (interval >= 1 && !isChart) {
	                    axis.actualIntervalType = 'Weeks';
	                    return interval;
	                }
	                interval = this.calculateNumericNiceInterval(axis, totalDays, size);
	                if (interval >= 1) {
	                    axis.actualIntervalType = 'Days';
	                    return interval;
	                }
	                interval = this.calculateNumericNiceInterval(axis, totalDays * 24, size);
	                if (interval >= 1) {
	                    axis.actualIntervalType = 'Hours';
	                    return interval;
	                }
	                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60, size);
	                if (interval >= 1) {
	                    axis.actualIntervalType = 'Minutes';
	                    return interval;
	                }
	                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60 * 60, size);
	                axis.actualIntervalType = 'Seconds';
	                return interval;
	        }
	        return interval;
	    };
	    /**
	     * To get the skeleton for the DateTime axis.
	     *
	     * @returns {string} skeleton format
	     * @private
	     */
	    NiceInterval.prototype.getSkeleton = function (axis, currentValue, previousValue, isBlazor) {
	        var skeleton;
	        var intervalType = axis.actualIntervalType;
	        if (axis.skeleton) {
	            return axis.skeleton;
	        }
	        if (intervalType === 'Years') {
	            if (isBlazor) {
	                skeleton = axis.isChart ? (axis.valueType === 'DateTime' ? 'y' : 'y') : 'y';
	            }
	            else {
	                skeleton = axis.isChart ? ((axis.valueType === 'DateTime' && axis.isIntervalInDecimal) ? 'y' : 'yMMM') : 'y';
	            }
	        }
	        else if (intervalType === 'Quarter') {
	            skeleton = isBlazor ? 'y' : 'yMMM';
	        }
	        else if (intervalType === 'Months') {
	            if (isBlazor) {
	                skeleton = axis.isChart ? 'm' : 'm';
	            }
	            else {
	                skeleton = axis.isChart ? 'MMMd' : 'MMM';
	            }
	        }
	        else if (intervalType === 'Weeks') {
	            skeleton = isBlazor ? 'm' : 'MEd';
	        }
	        else if (intervalType === 'Days') {
	            if (isBlazor) {
	                skeleton = 'd';
	            }
	            else {
	                skeleton = axis.isChart ? (axis.valueType === 'DateTime' ? 'MMMd' : 'yMd') : 'MMMd';
	            }
	        }
	        else if (intervalType === 'Hours') {
	            if (isBlazor) {
	                skeleton = 't';
	            }
	            else {
	                skeleton = axis.isChart ? (axis.valueType === 'DateTime' ? 'Hm' : 'EHm') : 'h';
	            }
	        }
	        else if (intervalType === 'Minutes') {
	            if (isBlazor) {
	                skeleton = 'T';
	            }
	            else {
	                skeleton = axis.isChart ? 'Hms' : 'hm';
	            }
	        }
	        else {
	            if (isBlazor) {
	                skeleton = 'T';
	            }
	            else {
	                skeleton = axis.isChart ? 'Hms' : 'hms';
	            }
	        }
	        return skeleton;
	    };
	    /**
	     * Find label format for axis
	     *
	     * @param {Axis} axis axis
	     * @param {number} currentValue currentValue
	     * @param {number} previousValue previousValue
	     * @private
	     */
	    NiceInterval.prototype.findCustomFormats = function (axis, currentValue, previousValue) {
	        var labelFormat = axis.labelFormat ? axis.labelFormat : '';
	        if (axis.isChart && !axis.skeleton && axis.actualIntervalType === 'Months' && !labelFormat) {
	            labelFormat = axis.valueType === 'DateTime' ? 'MMM yyyy' : 'yMMM';
	        }
	        return labelFormat;
	    };
	    return NiceInterval;
	}(Double));

	var __extends$b = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `DateTime` module is used to render datetime axis.
	 */
	var DateTime = /** @class */ (function (_super) {
	    __extends$b(DateTime, _super);
	    /**
	     * Constructor for the dateTime module.
	     *
	     * @private
	     */
	    function DateTime(chart) {
	        return _super.call(this, chart) || this;
	    }
	    /**
	     * The function to calculate the range and labels for the axis.
	     *
	     * @returns {void}
	     */
	    DateTime.prototype.calculateRangeAndInterval = function (size, axis) {
	        this.calculateRange(axis);
	        this.getActualRange(axis, size);
	        this.applyRangePadding(axis, size);
	        this.calculateVisibleLabels(axis, this.chart);
	    };
	    /**
	     * Actual Range for the axis.
	     *
	     * @private
	     */
	    DateTime.prototype.getActualRange = function (axis, size) {
	        var option = {
	            skeleton: 'full',
	            type: 'dateTime'
	        };
	        var dateParser = this.chart.intl.getDateParser(option);
	        var dateFormatter = this.chart.intl.getDateFormat(option);
	        // Axis min
	        if ((axis.minimum) !== null) {
	            this.min = this.chart.isBlazor ? Date.parse(axis.minimum.toString()) : Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: axis.minimum }).val))));
	        }
	        else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {
	            this.min = Date.parse(dateParser(dateFormatter(new Date(1970, 1, 1))));
	        }
	        // Axis Max
	        if ((axis.maximum) !== null) {
	            this.max = this.chart.isBlazor ? Date.parse(axis.maximum.toString()) : Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: axis.maximum }).val))));
	        }
	        else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {
	            this.max = Date.parse(dateParser(dateFormatter(new Date(1970, 5, 1))));
	        }
	        if (this.min === this.max) {
	            this.max = this.max + 2592000000;
	            this.min = this.min - 2592000000;
	        }
	        axis.actualRange = {};
	        axis.doubleRange = new DoubleRange(this.min, this.max);
	        var datetimeInterval = this.calculateDateTimeNiceInterval(axis, size, axis.doubleRange.start, axis.doubleRange.end);
	        if (!axis.interval) {
	            axis.actualRange.interval = datetimeInterval;
	        }
	        else {
	            axis.actualRange.interval = axis.interval;
	        }
	        axis.actualRange.min = axis.doubleRange.start;
	        axis.actualRange.max = axis.doubleRange.end;
	    };
	    /**
	     * Apply padding for the range.
	     *
	     * @private
	     */
	    DateTime.prototype.applyRangePadding = function (axis, size) {
	        this.min = (axis.actualRange.min);
	        this.max = (axis.actualRange.max);
	        var minimum;
	        var maximum;
	        var interval = axis.actualRange.interval;
	        if (!setRange(axis)) {
	            var rangePadding = axis.getRangePadding(this.chart);
	            minimum = new Date(this.min);
	            maximum = new Date(this.max);
	            var intervalType = axis.actualIntervalType;
	            if (rangePadding === 'None') {
	                this.min = minimum.getTime();
	                this.max = maximum.getTime();
	            }
	            else if (rangePadding === 'Additional' || rangePadding === 'Round') {
	                switch (intervalType) {
	                    case 'Years':
	                        this.getYear(minimum, maximum, rangePadding, interval);
	                        break;
	                    case 'Months':
	                        this.getMonth(minimum, maximum, rangePadding, interval);
	                        break;
	                    case 'Days':
	                        this.getDay(minimum, maximum, rangePadding, interval);
	                        break;
	                    case 'Hours':
	                        this.getHour(minimum, maximum, rangePadding, interval);
	                        break;
	                    case 'Minutes':
	                        var minute = (minimum.getMinutes() / interval) * interval;
	                        var endMinute = maximum.getMinutes() + (minimum.getMinutes() - minute);
	                        if (rangePadding === 'Round') {
	                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute, 0)).getTime();
	                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute, 59)).getTime();
	                        }
	                        else {
	                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute + (-interval), 0)).getTime();
	                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute + (interval), 0)).getTime();
	                        }
	                        break;
	                    case 'Seconds':
	                        var second = (minimum.getSeconds() / interval) * interval;
	                        var endSecond = maximum.getSeconds() + (minimum.getSeconds() - second);
	                        if (rangePadding === 'Round') {
	                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second, 0)).getTime();
	                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond, 0)).getTime();
	                        }
	                        else {
	                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second + (-interval), 0)).getTime();
	                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond + (interval), 0)).getTime();
	                        }
	                        break;
	                }
	            }
	        }
	        axis.actualRange.min = (axis.minimum != null) ? this.min : this.min;
	        axis.actualRange.max = (axis.maximum != null) ? this.max : this.max;
	        axis.actualRange.delta = (axis.actualRange.max - axis.actualRange.min);
	        axis.doubleRange = new DoubleRange(axis.actualRange.min, axis.actualRange.max);
	        this.calculateVisibleRange(size, axis);
	    };
	    DateTime.prototype.getYear = function (minimum, maximum, rangePadding, interval) {
	        var startYear = minimum.getFullYear();
	        var endYear = maximum.getFullYear();
	        if (rangePadding === 'Additional') {
	            this.min = (new Date(startYear - interval, 1, 1, 0, 0, 0)).getTime();
	            this.max = (new Date(endYear + interval, 1, 1, 0, 0, 0)).getTime();
	        }
	        else {
	            this.min = new Date(startYear, 0, 0, 0, 0, 0).getTime();
	            this.max = new Date(endYear, 11, 30, 23, 59, 59).getTime();
	        }
	    };
	    DateTime.prototype.getMonth = function (minimum, maximum, rangePadding, interval) {
	        var month = minimum.getMonth();
	        var endMonth = maximum.getMonth();
	        if (rangePadding === 'Round') {
	            this.min = (new Date(minimum.getFullYear(), month, 0, 0, 0, 0)).getTime();
	            this.max = (new Date(maximum.getFullYear(), endMonth, new Date(maximum.getFullYear(), maximum.getMonth(), 0).getDate(), 23, 59, 59)).getTime();
	        }
	        else {
	            this.min = (new Date(minimum.getFullYear(), month + (-interval), 1, 0, 0, 0)).getTime();
	            this.max = (new Date(maximum.getFullYear(), endMonth + (interval), endMonth === 2 ? 28 : 30, 0, 0, 0)).getTime();
	        }
	    };
	    DateTime.prototype.getDay = function (minimum, maximum, rangePadding, interval) {
	        var day = minimum.getDate();
	        var endDay = maximum.getDate();
	        if (rangePadding === 'Round') {
	            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), day, 0, 0, 0)).getTime();
	            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), endDay, 23, 59, 59)).getTime();
	        }
	        else {
	            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), day + (-interval), 0, 0, 0)).getTime();
	            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), endDay + (interval), 0, 0, 0)).getTime();
	        }
	    };
	    DateTime.prototype.getHour = function (minimum, maximum, rangePadding, interval) {
	        var hour = (minimum.getHours() / interval) * interval;
	        var endHour = maximum.getHours() + (minimum.getHours() - hour);
	        if (rangePadding === 'Round') {
	            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour, 0, 0)).getTime();
	            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour, 59, 59)).getTime();
	        }
	        else {
	            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour + (-interval), 0, 0)).getTime();
	            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour + (interval), 0, 0)).getTime();
	        }
	    };
	    /**
	     * Calculate visible range for axis.
	     *
	     * @private
	     */
	    DateTime.prototype.calculateVisibleRange = function (size, axis) {
	        axis.visibleRange = {
	            min: axis.actualRange.min,
	            max: axis.actualRange.max,
	            interval: axis.actualRange.interval,
	            delta: axis.actualRange.delta
	        };
	        var isLazyLoad = isNullOrUndefined(axis.zoomingScrollBar) ? false : axis.zoomingScrollBar.isLazyLoad;
	        if ((isZoomSet(axis)) && !isLazyLoad) {
	            axis.calculateVisibleRangeOnZooming(size);
	            axis.visibleRange.interval = (axis.enableAutoIntervalOnZooming) ?
	                this.calculateDateTimeNiceInterval(axis, size, axis.visibleRange.min, axis.visibleRange.max)
	                : axis.visibleRange.interval;
	        }
	        axis.dateTimeInterval = this.increaseDateTimeInterval(axis, axis.visibleRange.min, axis.visibleRange.interval).getTime()
	            - axis.visibleRange.min;
	        axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);
	    };
	    /**
	     * Calculate visible labels for the axis.
	     *
	     * @param {Axis} axis axis
	     * @param {Chart | RangeNavigator} chart chart
	     * @returns {void}
	     * @private
	     */
	    DateTime.prototype.calculateVisibleLabels = function (axis, chart) {
	        axis.visibleLabels = [];
	        var tempInterval = axis.visibleRange.min;
	        var labelStyle;
	        var previousValue;
	        var isBlazor = chart.getModuleName() === 'chart' ? chart.isBlazor : false;
	        var axisLabels = axis.visibleLabels;
	        if (!setRange(axis)) {
	            tempInterval = this.alignRangeStart(axis, tempInterval, axis.visibleRange.interval).getTime();
	        }
	        while (tempInterval <= axis.visibleRange.max) {
	            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));
	            previousValue = axisLabels.length ? axis.visibleLabels[axisLabels.length - 1].value : tempInterval;
	            axis.format = chart.intl.getDateFormat({
	                format: this.findCustomFormats(axis, tempInterval, previousValue) || this.blazorCustomFormat(axis),
	                type: firstToLowerCase(axis.skeletonType),
	                skeleton: this.getSkeleton(axis, tempInterval, previousValue, isBlazor)
	            });
	            axis.startLabel = axis.format(new Date(axis.visibleRange.min));
	            axis.endLabel = axis.format(new Date(axis.visibleRange.max));
	            if (withIn(tempInterval, axis.visibleRange)) {
	                var interval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();
	                if (interval > axis.visibleRange.max) {
	                    axis.endLabel = axis.format(new Date(tempInterval));
	                }
	                triggerLabelRender(chart, tempInterval, axis.format(new Date(tempInterval)), labelStyle, axis);
	            }
	            var actualInterval = tempInterval;
	            tempInterval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();
	            if (actualInterval === tempInterval) {
	                break;
	            }
	        }
	        //tooltip and crosshair formats for 'Months' and 'Days' interval types
	        if ((axis.actualIntervalType === 'Months' || axis.actualIntervalType === 'Days') && axis.isChart) {
	            axis.format = chart.intl.getDateFormat({
	                format: axis.labelFormat || (axis.actualIntervalType === 'Months' && !axis.skeleton ? 'y MMM' : ''),
	                type: firstToLowerCase(axis.skeletonType), skeleton: axis.skeleton || (axis.actualIntervalType === 'Days' ? 'MMMd' : '')
	            });
	        }
	        if (axis.getMaxLabelWidth) {
	            axis.getMaxLabelWidth(this.chart);
	        }
	    };
	    /** @private */
	    DateTime.prototype.blazorCustomFormat = function (axis) {
	        if (this.chart.isBlazor) {
	            return axis.actualIntervalType === 'Years' ? (axis.isIntervalInDecimal ? 'yyyy' : 'MMM y') :
	                (axis.actualIntervalType === 'Days' && !axis.isIntervalInDecimal) ? 'ddd HH tt' : '';
	        }
	        else {
	            return '';
	        }
	    };
	    /** @private */
	    DateTime.prototype.increaseDateTimeInterval = function (axis, value, interval) {
	        var result = new Date(value);
	        if (axis.interval) {
	            axis.isIntervalInDecimal = (interval % 1) === 0;
	            axis.visibleRange.interval = interval;
	        }
	        else {
	            interval = Math.ceil(interval);
	            axis.visibleRange.interval = interval;
	        }
	        var intervalType = axis.actualIntervalType;
	        if (axis.isIntervalInDecimal) {
	            switch (intervalType) {
	                case 'Years':
	                    result.setFullYear(result.getFullYear() + interval);
	                    return result;
	                case 'Quarter':
	                    result.setMonth(result.getMonth() + (3 * interval));
	                    return result;
	                case 'Months':
	                    result.setMonth(result.getMonth() + interval);
	                    return result;
	                case 'Weeks':
	                    result.setDate(result.getDate() + (interval * 7));
	                    return result;
	                case 'Days':
	                    result.setDate(result.getDate() + interval);
	                    return result;
	                case 'Hours':
	                    result.setHours(result.getHours() + interval);
	                    return result;
	                case 'Minutes':
	                    result.setMinutes(result.getMinutes() + interval);
	                    return result;
	                case 'Seconds':
	                    result.setSeconds(result.getSeconds() + interval);
	                    return result;
	            }
	        }
	        else {
	            result = this.getDecimalInterval(result, interval, intervalType);
	        }
	        return result;
	    };
	    DateTime.prototype.alignRangeStart = function (axis, sDate, intervalSize) {
	        var sResult = new Date(sDate);
	        switch (axis.actualIntervalType) {
	            case 'Years':
	                var year = Math.floor(Math.floor(sResult.getFullYear() / intervalSize) * intervalSize);
	                sResult = new Date(year, sResult.getMonth(), sResult.getDate(), 0, 0, 0);
	                return sResult;
	            case 'Months':
	                var month = Math.floor(Math.floor((sResult.getMonth()) / intervalSize) * intervalSize);
	                sResult = new Date(sResult.getFullYear(), month, sResult.getDate(), 0, 0, 0);
	                return sResult;
	            case 'Days':
	                var day = Math.floor(Math.floor((sResult.getDate()) / intervalSize) * intervalSize);
	                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), day, 0, 0, 0);
	                return sResult;
	            case 'Hours':
	                var hour = Math.floor(Math.floor((sResult.getHours()) / intervalSize) * intervalSize);
	                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), hour, 0, 0);
	                return sResult;
	            case 'Minutes':
	                var minutes = Math.floor(Math.floor((sResult.getMinutes()) / intervalSize) * intervalSize);
	                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), minutes, 0, 0);
	                return sResult;
	            case 'Seconds':
	                var seconds = Math.floor(Math.floor((sResult.getSeconds()) / intervalSize) * intervalSize);
	                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), sResult.getMinutes(), seconds, 0);
	                return sResult;
	        }
	        return sResult;
	    };
	    DateTime.prototype.getDecimalInterval = function (result, interval, intervalType) {
	        var roundValue = Math.floor(interval);
	        var decimalValue = interval - roundValue;
	        switch (intervalType) {
	            case 'Years':
	                var month = Math.round(12 * decimalValue);
	                result.setFullYear(result.getFullYear() + roundValue);
	                result.setMonth(result.getMonth() + month);
	                return result;
	            case 'Quarter':
	                result.setMonth(result.getMonth() + (3 * interval));
	                return result;
	            case 'Months':
	                var days = Math.round(30 * decimalValue);
	                result.setMonth(result.getMonth() + roundValue);
	                result.setDate(result.getDate() + days);
	                return result;
	            case 'Weeks':
	                result.setDate(result.getDate() + (interval * 7));
	                return result;
	            case 'Days':
	                var hour = Math.round(24 * decimalValue);
	                result.setDate(result.getDate() + roundValue);
	                result.setHours(result.getHours() + hour);
	                return result;
	            case 'Hours':
	                var min = Math.round(60 * decimalValue);
	                result.setHours(result.getHours() + roundValue);
	                result.setMinutes(result.getMinutes() + min);
	                return result;
	            case 'Minutes':
	                var sec = Math.round(60 * decimalValue);
	                result.setMinutes(result.getMinutes() + roundValue);
	                result.setSeconds(result.getSeconds() + sec);
	                return result;
	            case 'Seconds':
	                var milliSec = Math.round(1000 * decimalValue);
	                result.setSeconds(result.getSeconds() + roundValue);
	                result.setMilliseconds(result.getMilliseconds() + milliSec);
	                return result;
	        }
	        return result;
	    };
	    /**
	     * Get module name
	     */
	    DateTime.prototype.getModuleName = function () {
	        /**
	         * Returns the module name
	         */
	        return 'DateTime';
	    };
	    /**
	     * To destroy the category axis.
	     *
	     * @returns {void}
	     * @private
	     */
	    DateTime.prototype.destroy = function () {
	        /**
	         * Destroy method performed here
	         */
	    };
	    return DateTime;
	}(NiceInterval));

	var __extends$a = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `Category` module is used to render category axis.
	 */
	var Category = /** @class */ (function (_super) {
	    __extends$a(Category, _super);
	    /**
	     * Constructor for the category module.
	     *
	     * @private
	     */
	    function Category(chart) {
	        return _super.call(this, chart) || this;
	    }
	    /**
	     * The function to calculate the range and labels for the axis.
	     *
	     * @returns {void}
	     */
	    Category.prototype.calculateRangeAndInterval = function (size, axis) {
	        this.calculateRange(axis);
	        this.getActualRange(axis, size);
	        this.applyRangePadding(axis, size);
	        this.calculateVisibleLabels(axis);
	    };
	    /**
	     * Actual Range for the axis.
	     *
	     * @private
	     */
	    Category.prototype.getActualRange = function (axis, size) {
	        this.initializeDoubleRange(axis);
	        // axis.doubleRange = new DoubleRange(<number>this.min, <number>this.max);
	        axis.actualRange = {};
	        if (!axis.interval) {
	            axis.actualRange.interval = Math.max(1, Math.floor(axis.doubleRange.delta / getActualDesiredIntervalsCount(size, axis)));
	        }
	        else {
	            axis.actualRange.interval = Math.ceil(axis.interval);
	        }
	        axis.actualRange.min = axis.doubleRange.start;
	        axis.actualRange.max = axis.doubleRange.end;
	        axis.actualRange.delta = axis.doubleRange.delta;
	    };
	    /**
	     * Padding for the axis.
	     *
	     * @private
	     */
	    Category.prototype.applyRangePadding = function (axis, size) {
	        var isColumn;
	        axis.series.forEach(function (element) {
	            if (!isColumn) {
	                isColumn = element.type.indexOf('Column') > -1 && !(axis.zoomFactor < 1 || axis.zoomPosition > 0) && isNullOrUndefined(axis.minimum) && isNullOrUndefined(axis.maximum);
	            }
	        });
	        var ticks = ((axis.labelPlacement === 'BetweenTicks' || isColumn) && !this.chart.stockChart && this.chart.chartAreaType !== 'PolarRadar') ? 0.5 : 0;
	        if (ticks > 0) {
	            axis.actualRange.min -= ticks;
	            axis.actualRange.max += ticks;
	        }
	        else {
	            axis.actualRange.max += axis.actualRange.max ? 0 : 0.5;
	        }
	        axis.doubleRange = new DoubleRange(axis.actualRange.min, axis.actualRange.max);
	        axis.actualRange.delta = axis.doubleRange.delta;
	        this.calculateVisibleRange(size, axis);
	    };
	    /**
	     * Calculate label for the axis.
	     *
	     * @private
	     */
	    Category.prototype.calculateVisibleLabels = function (axis) {
	        /*! Generate axis labels */
	        axis.visibleLabels = [];
	        axis.visibleRange.interval = axis.visibleRange.interval < 1 ? 1 : axis.visibleRange.interval;
	        var tempInterval = Math.ceil(axis.visibleRange.min);
	        var labelStyle;
	        if (axis.zoomFactor < 1 || axis.zoomPosition > 0) {
	            tempInterval = axis.visibleRange.min - (axis.visibleRange.min % axis.visibleRange.interval);
	        }
	        var position;
	        axis.startLabel = axis.labels[Math.round(axis.visibleRange.min)];
	        axis.endLabel = axis.labels[Math.floor(axis.visibleRange.max)];
	        for (; tempInterval <= axis.visibleRange.max; tempInterval += axis.visibleRange.interval) {
	            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));
	            if (withIn(tempInterval, axis.visibleRange) && axis.labels.length > 0) {
	                position = Math.round(tempInterval);
	                triggerLabelRender(this.chart, position, axis.labels[position] ? axis.labels[position].toString() : position.toString(), labelStyle, axis);
	            }
	        }
	        if (axis.getMaxLabelWidth) {
	            axis.getMaxLabelWidth(this.chart);
	        }
	    };
	    /**
	     * Get module name
	     */
	    Category.prototype.getModuleName = function () {
	        /**
	         * Returns the module name
	         */
	        return 'Category';
	    };
	    /**
	     * To destroy the category axis.
	     *
	     * @returns {void}
	     * @private
	     */
	    Category.prototype.destroy = function () {
	        /**
	         * Destroy method performed here
	         */
	    };
	    return Category;
	}(NiceInterval));

	/* eslint-disable no-trailing-spaces */
	/* eslint-disable @typescript-eslint/ban-types */
	/* eslint-disable jsdoc/require-returns */
	/* eslint-disable valid-jsdoc */
	/* eslint-disable jsdoc/require-param */
	/**
	 * Base for line type series.
	 */
	var LineBase = /** @class */ (function () {
	    /** @private */
	    function LineBase(chartModule) {
	        this.chart = chartModule;
	    }
	    /**
	     * To improve the chart performance.
	     *
	     * @returns {void}
	     * @private
	     */
	    LineBase.prototype.enableComplexProperty = function (series) {
	        var tempPoints = [];
	        var tempPoints2 = [];
	        var xVisibleRange = series.xAxis.visibleRange;
	        var yVisibleRange = series.yAxis.visibleRange;
	        var seriesPoints = series.points;
	        var areaBounds = series.clipRect;
	        var xTolerance = Math.abs(xVisibleRange.delta / areaBounds.width);
	        var yTolerance = Math.abs(yVisibleRange.delta / areaBounds.height);
	        var prevXValue = (seriesPoints[0] && seriesPoints[0].xValue > xTolerance) ? 0 : xTolerance;
	        var prevYValue = (seriesPoints[0] && seriesPoints[0].y > yTolerance) ? 0 : yTolerance;
	        var xVal = 0;
	        var yVal = 0;
	        for (var _i = 0, seriesPoints_1 = seriesPoints; _i < seriesPoints_1.length; _i++) {
	            var currentPoint = seriesPoints_1[_i];
	            currentPoint.symbolLocations = [];
	            xVal = currentPoint.xValue ? currentPoint.xValue : xVisibleRange.min;
	            yVal = currentPoint.yValue ? currentPoint.yValue : yVisibleRange.min;
	            if (Math.abs(prevXValue - xVal) >= xTolerance || Math.abs(prevYValue - yVal) >= yTolerance) {
	                tempPoints.push(currentPoint);
	                prevXValue = xVal;
	                prevYValue = yVal;
	            }
	        }
	        var tempPoint;
	        for (var i = 0; i < tempPoints.length; i++) {
	            tempPoint = tempPoints[i];
	            if (isNullOrUndefined(tempPoint.x) || (series.category === 'Indicator' && (isNaN(tempPoint.xValue) || isNaN(tempPoint.yValue)))) {
	                continue;
	            }
	            else {
	                tempPoints2.push(tempPoint);
	            }
	        }
	        return tempPoints2;
	    };
	    /**
	     * To generate the line path direction.
	     *
	     * @param {Points} firstPoint firstPoint
	     * @param {Points} secondPoint secondPoint
	     * @param {Series} series series
	     * @param {boolean} isInverted isInverted
	     * @param {Function} getPointLocation getPointLocation
	     * @param {string} startPoint startPoint
	     */
	    LineBase.prototype.getLineDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation, startPoint) {
	        var direction = '';
	        if (firstPoint != null) {
	            var point1 = getPointLocation(firstPoint.xValue, firstPoint.yValue, series.xAxis, series.yAxis, isInverted, series);
	            var point2 = getPointLocation(secondPoint.xValue, secondPoint.yValue, series.xAxis, series.yAxis, isInverted, series);
	            direction = startPoint + ' ' + (point1.x) + ' ' + (point1.y) + ' ' +
	                'L' + ' ' + (point2.x) + ' ' + (point2.y) + ' ';
	        }
	        return direction;
	    };
	    /**
	     * To append the line path.
	     *
	     * @returns {void}
	     * @private
	     */
	    LineBase.prototype.appendLinePath = function (options, series, clipRect) {
	        var element = getElement(options.id);
	        var chart = series.chart;
	        var previousDirection = element ? element.getAttribute('d') : null;
	        var htmlObject = series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));
	        if (htmlObject) {
	            htmlObject.setAttribute('clip-path', clipRect);
	        }
	        series.pathElement = htmlObject;
	        if (!series.chart.enableCanvas) {
	            series.seriesElement.appendChild(htmlObject);
	        }
	        series.isRectSeries = false;
	        pathAnimation(element, options.d, series.chart.redraw, previousDirection, chart.duration);
	    };
	    /**
	     * To render the marker for the series.
	     *
	     * @returns {void}
	     * @private
	     */
	    LineBase.prototype.renderMarker = function (series) {
	        if (series.marker && series.marker.visible) {
	            series.chart.markerRender.render(series);
	        }
	    };
	    /**
	     * To do the progressive animation.
	     *
	     * @returns {void}
	     * @private
	     */
	    LineBase.prototype.doProgressiveAnimation = function (series, option) {
	        var animation = new Animation$1({});
	        var path = series.pathElement;
	        var strokeDashArray = path.getAttribute('stroke-dasharray');
	        var pathLength = series.pathElement.getTotalLength();
	        var currentTime;
	        path.style.visibility = 'hidden';
	        animation.animate(path, {
	            duration: (option.duration === 0 && animationMode === 'Enable') ? 1000 : option.duration,
	            delay: option.delay,
	            progress: function (args) {
	                if (args.timeStamp >= args.delay) {
	                    path.style.visibility = 'visible';
	                    currentTime = Math.abs(Math.round(((args.timeStamp - args.delay) * pathLength) / args.duration));
	                    path.setAttribute('stroke-dasharray', currentTime + ',' + pathLength);
	                }
	            },
	            end: function () {
	                path.setAttribute('stroke-dasharray', strokeDashArray);
	                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });
	            }
	        });
	    };
	    /**
	     * To store the symbol location and region.
	     *
	     * @param {Points} point point
	     * @param {Series} series series
	     * @param {boolean} isInverted isInverted
	     * @param {Function} getLocation getLocation
	     */
	    LineBase.prototype.storePointLocation = function (point, series, isInverted, getLocation) {
	        var markerWidth = (series.marker && series.marker.width) ? series.marker.width : 0;
	        var markerHeight = (series.marker && series.marker.height) ? series.marker.height : 0;
	        point.symbolLocations.push(getLocation(point.xValue, point.yValue, series.xAxis, series.yAxis, isInverted, series));
	        point.regions.push(new Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));
	    };
	    /**
	     * To find point with in the visible range
	     *
	     * @param {Points} point point
	     * @param {Axis} yAxis yAxis
	     * @private
	     */
	    LineBase.prototype.withinYRange = function (point, yAxis) {
	        return point.yValue >= yAxis.visibleRange.min && point.yValue <= yAxis.visibleRange.max;
	    };
	    /**
	     * To get first and last visible points
	     *
	     * @private
	     */
	    LineBase.prototype.getFirstLastVisiblePoint = function (points) {
	        var first = null;
	        var last = null;
	        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
	            var point = points_1[_i];
	            if (first === null && point.visible) {
	                first = last = point;
	            }
	            last = point.visible ? point : last;
	        }
	        return { first: first ? first : points[0], last: last ? last : points[points.length - 1] };
	    };
	    /**
	     * To Generate the area series border path direction from area series main direction path.
	     *
	     *  @param {string} direction direction
	     *
	     * */
	    LineBase.prototype.getBorderDirection = function (direction) {
	        var coordinates = direction.split(' ');
	        if (coordinates.length > 3 && !(this.chart.stackingAreaSeriesModule) && !(this.chart.stackingStepAreaSeriesModule)) {
	            coordinates.splice(coordinates.length - 4, 3);
	        }
	        else if (this.chart.stackingAreaSeriesModule || this.chart.stackingStepAreaSeriesModule) {
	            coordinates.splice(coordinates.length / 2 + 1, coordinates.length / 2 + 1);
	            if (coordinates[coordinates.length - 1] === 'L') {
	                coordinates.splice(coordinates.length - 1, 1);
	            }
	        }
	        return coordinates.join(' ');
	    };
	    /**
	     * To remove empty point directions from series direction of area types.
	     *
	     *  @param {string} borderDirection direction
	     *
	     * */
	    LineBase.prototype.removeEmptyPointsBorder = function (borderDirection) {
	        var startIndex = 0;
	        var coordinates = borderDirection.split(' ');
	        // eslint-disable-next-line @typescript-eslint/tslint/config
	        var point;
	        do {
	            point = coordinates.indexOf('M', startIndex);
	            if (point > -1) {
	                coordinates.splice(point + 1, 3);
	                startIndex = point + 1;
	                if (point - 6 > 0) {
	                    coordinates.splice(point - 6, 6);
	                    startIndex -= 6;
	                }
	            }
	        } while (point !== -1);
	        return coordinates.join(' ');
	    };
	    /**
	     * To do the linear animation.
	     *
	     * @returns {void}
	     * @private
	     */
	    LineBase.prototype.doLinearAnimation = function (series, animation) {
	        var clipRect = series.clipRectElement.childNodes[0].childNodes[0];
	        var duration = series.chart.animated ? series.chart.duration : animation.duration;
	        var effect = getAnimationFunction('Linear');
	        var elementHeight = +clipRect.getAttribute('height');
	        var elementWidth = +clipRect.getAttribute('width');
	        var xCenter = +clipRect.getAttribute('x');
	        var yCenter = series.chart.requireInvertedAxis ? +clipRect.getAttribute('height') + +clipRect.getAttribute('y') :
	            +clipRect.getAttribute('y');
	        var value;
	        clipRect.style.visibility = 'hidden';
	        new Animation$1({}).animate(clipRect, {
	            duration: (duration === 0 && animationMode === 'Enable') ? 1000 : duration,
	            delay: animation.delay,
	            progress: function (args) {
	                if (args.timeStamp >= args.delay) {
	                    clipRect.style.visibility = 'visible';
	                    if (series.chart.requireInvertedAxis) {
	                        value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);
	                        clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter +
	                            ') scale(1,' + (value / elementHeight) + ') translate(' + (-xCenter) + ' ' + (-yCenter) + ')');
	                    }
	                    else {
	                        value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);
	                        clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter +
	                            ') scale(' + (value / elementWidth) + ', 1) translate(' + (-xCenter) + ' ' + (-yCenter) + ')');
	                    }
	                }
	            },
	            end: function () {
	                clipRect.setAttribute('transform', 'translate(0,0)');
	                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });
	            }
	        });
	    };
	    return LineBase;
	}());

	/* eslint-disable @typescript-eslint/tslint/config */
	/* eslint-disable max-len */
	/* eslint-disable valid-jsdoc */
	/* eslint-disable jsdoc/require-returns */
	/* eslint-disable jsdoc/require-param */
	/**
	 * Column Series Base
	 */
	var ColumnBase = /** @class */ (function () {
	    function ColumnBase() {
	    }
	    ColumnBase.prototype.getSideBySideInfo = function (series) {
	        if (series.chart.enableSideBySidePlacement && !series.position) {
	            this.getSideBySidePositions(series);
	        }
	        if (series.columnWidthInPixel) {
	            return new DoubleRange(0, 0);
	        }
	        var position = series.type === 'Histogram' || !series.chart.enableSideBySidePlacement ? 0 : series.position;
	        var rectCount = series.type === 'Histogram' || !series.chart.enableSideBySidePlacement ? 1 : series.rectCount;
	        series.isRectSeries = true;
	        var visibleSeries = series.chart.visibleSeries;
	        var seriesSpacing = series.chart.enableSideBySidePlacement ? series.columnSpacing : 0; // Column Spacing
	        var pointSpacing = (series.columnWidth === null || isNaN(+series.columnWidth)) ? ((series.type === 'Histogram') ? 1 : 0.7) :
	            Math.min(series.columnWidth, 1); // Column width
	        var minimumPointDelta = getMinPointsDelta(series.xAxis, visibleSeries);
	        var width = minimumPointDelta * pointSpacing;
	        var radius;
	        var location = (position) / rectCount - 0.5;
	        var doubleRange = new DoubleRange(location, location + (1 / rectCount));
	        if (!(isNaN(doubleRange.start) || isNaN(doubleRange.end))) {
	            if (series.groupName && series.type.indexOf('Stacking') === -1) {
	                var mainColumnWidth_1 = 0.7;
	                series.chart.series.filter(function (series) { if (series.columnWidth > mainColumnWidth_1) {
	                    mainColumnWidth_1 = series.columnWidth;
	                } });
	                var mainWidth = minimumPointDelta * mainColumnWidth_1;
	                var mainDoubleRange = new DoubleRange(doubleRange.start * mainWidth, doubleRange.end * mainWidth);
	                var difference = ((mainDoubleRange.delta) - (doubleRange.end * width - doubleRange.start * width)) / 2;
	                doubleRange = new DoubleRange(mainDoubleRange.start + difference, mainDoubleRange.end - difference);
	            }
	            else {
	                doubleRange = new DoubleRange(doubleRange.start * width, doubleRange.end * width);
	            }
	            radius = seriesSpacing * doubleRange.delta;
	            doubleRange = new DoubleRange(doubleRange.start + radius / 2, doubleRange.end - radius / 2);
	        }
	        return doubleRange;
	    };
	    /**
	     * To get the rect values.
	     *
	     * @returns {Rect} rect region values
	     * @private
	     */
	    ColumnBase.prototype.getRectangle = function (x1, y1, x2, y2, series) {
	        var point1 = getPoint(x1, y1, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);
	        var point2 = getPoint(x2, y2, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);
	        return new Rect(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y), Math.abs(point2.x - point1.x), Math.abs(point2.y - point1.y));
	    };
	    /**
	     * To draw the cylindrical shape for points.
	     *
	     * @returns {void}
	     * @private
	     */
	    ColumnBase.prototype.drawCylinder = function (options, element, cylinderSeriesOption, rect, series) {
	        var width = rect.width;
	        var height = rect.height;
	        if (series.chart.enableCanvas) {
	            var ctx = series.chart.canvasRender.ctx;
	            var canvasCtx = ctx;
	            ctx.save();
	            var gradientColor = colorNameToHex(options.fill);
	            var x = rect.x + series.clipRect.x;
	            var y = rect.y + series.clipRect.y;
	            var arc = 2 * Math.PI + 0.1;
	            var rx = void 0, ry = void 0, cx1 = void 0, cx2 = void 0, cy1 = void 0, cy2 = void 0, x1 = void 0, x2 = void 0, y1 = void 0, y2 = void 0, cx = void 0, cy = void 0, xl = void 0, yl = void 0, xPos = void 0, yPos = void 0, step = void 0, rxt = void 0, ryt = void 0;
	            var gx1 = 0;
	            var gx2 = 0;
	            var gy1 = 0;
	            var gy2 = 0;
	            var ini = 0;
	            ctx.fillStyle = applyZLight(gradientColor, 0.9);
	            ctx.lineWidth = 0;
	            ctx.strokeStyle = applyZLight(gradientColor, 0.9);
	            ctx.globalAlpha = options.opacity;
	            if (cylinderSeriesOption.isColumn) {
	                gx1 = x;
	                gx2 = width + x;
	                rx = width / 2;
	                ry = rx / 4;
	                cx2 = cx1 = x + rx;
	                y2 = cy1 = y - ry;
	                x2 = x;
	                x1 = x + width;
	                cy2 = y1 = y + height - ry;
	                step = Math.PI;
	                rxt = -rx;
	                ryt = ry;
	                if (cylinderSeriesOption.stacking) {
	                    if (!cylinderSeriesOption.isLastSeries) {
	                        y2 = cy1 = y + ry;
	                    }
	                }
	            }
	            else {
	                gy2 = height + y;
	                gy1 = y;
	                ry = height / 2;
	                rx = ry / 4;
	                x2 = cx1 = x + rx;
	                x1 = cx2 = x + width + rx;
	                y1 = y + height;
	                y2 = y;
	                cy2 = cy1 = y + ry;
	                ini = Math.PI / 2;
	                step = Math.PI * 1.5;
	                if (cylinderSeriesOption.stacking) {
	                    if (!cylinderSeriesOption.isLastSeries) {
	                        x1 = cx2 = x + width - rx;
	                    }
	                }
	                ry = -ry;
	                rx = -rx;
	                rxt = rx;
	                ryt = -ry;
	            }
	            var color = applyZLight(gradientColor, 0.7);
	            var gradient = ctx.createLinearGradient(gx1, gy1, gx2, gy2);
	            gradient.addColorStop(0, gradientColor);
	            gradient.addColorStop(0.3, color);
	            gradient.addColorStop(0.7, color);
	            gradient.addColorStop(1, gradientColor);
	            for (var j = 1; j <= 4; j++) {
	                var i = 0;
	                if (j < 4) {
	                    ctx.beginPath();
	                }
	                if (j % 2 === 0) {
	                    cx = cx2;
	                    cy = cy2;
	                    xl = x2;
	                    yl = y2;
	                }
	                else {
	                    cx = cx1;
	                    cy = cy1;
	                    xl = x1;
	                    yl = y1;
	                }
	                if (j === 4) {
	                    rx = rxt;
	                    ry = ryt;
	                    ctx.fillStyle = gradient;
	                }
	                if (j > 2) {
	                    i = ini;
	                    arc = step;
	                }
	                for (; i <= arc; i += 0.1) {
	                    xPos = cx - (rx * Math.cos(i));
	                    yPos = cy + (ry * Math.sin(i));
	                    if (i === 0) {
	                        ctx.moveTo(xPos, yPos);
	                    }
	                    else {
	                        ctx.lineTo(xPos, yPos);
	                    }
	                }
	                if (j > 2) {
	                    ctx.lineTo(xl, yl);
	                }
	                if (j !== 3) {
	                    ctx.stroke();
	                    ctx.fill();
	                }
	            }
	            if (options.id.indexOf('Series') >= 0) {
	                ctx.clip();
	                ctx.restore();
	                ctx = canvasCtx;
	            }
	        }
	        else {
	            var chart = series.chart;
	            var x = rect.x;
	            var y = rect.y;
	            var id = options.id;
	            var gradientColor = options.fill;
	            var fillColor = gradientColor;
	            var format = checkColorFormat(gradientColor);
	            if (!format) {
	                gradientColor = colorNameToHex(gradientColor);
	            }
	            var AEx = 0;
	            var AEy = 0;
	            var LX = 0;
	            var LY = 0;
	            var GX = 0;
	            var GY = 0;
	            var X = void 0, Y = void 0, X1 = void 0, Y1 = void 0, X2 = void 0, Y2 = void 0, rx = void 0, ry = void 0;
	            var i = 2;
	            if (cylinderSeriesOption.isColumn) {
	                rx = width / 2;
	                ry = rx / 4;
	                X = X1 = x;
	                Y = ry < y ? y - ry : cylinderSeriesOption.stacking ? y + ry : (y - ry);
	                Y1 = Y;
	                AEx = 2 * rx;
	                LY = ry < y ? height : (height < 2 * ry ? height : cylinderSeriesOption.stacking ? height - (2 * ry) : height);
	                X2 = X;
	                Y2 = ry < y ? Y + height : (height < Y ? height + Y : cylinderSeriesOption.stacking ? height + (y - ry) : height + Y);
	                GX = 100;
	                if (cylinderSeriesOption.stacking) {
	                    if (!cylinderSeriesOption.isLastSeries) {
	                        Y = Y1 = y + ry;
	                        LY = height < rx / 2 ? height : height - rx / 2;
	                    }
	                }
	            }
	            else {
	                ry = height / 2;
	                rx = ry / 4;
	                Y = Y1 = y;
	                X = X1 = Math.abs(x - rx);
	                AEy = 2 * ry;
	                LX = width;
	                X2 = X + width;
	                Y2 = Y;
	                GY = 100;
	                if (cylinderSeriesOption.stacking) {
	                    if (!cylinderSeriesOption.isLastSeries) {
	                        X2 = (X + width - rx * 2);
	                        LX = width - rx * 2;
	                    }
	                }
	            }
	            remove(this.element);
	            while (i--) {
	                options.d = 'M' + X.toString() + ',' + Y.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,0 ' + AEx.toString() + ',' + AEy.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,0 ' + (-1 * AEx).toString() + ',' + (-1 * AEy).toString();
	                options.id = id + '_' + 'Region_' + i;
	                options.fill = applyZLight(gradientColor, 0.9);
	                if (i % 2 === 0 && series.type !== 'StackingBar100' && series.type !== 'StackingBar' && series.type !== 'Bar') {
	                    options.fill = options.fill + '10';
	                }
	                this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));
	                appendChildElement(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);
	                X = X2;
	                Y = Y2;
	            }
	            options.d = 'M' + X1.toString() + ',' + Y1.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,0 ' + AEx.toString() + ',' + AEy.toString() + 'l' + LX.toString() + ' ' + LY.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,1 ' + (-1 * AEx).toString() + ',' + (-1 * AEy).toString() + ' z';
	            options.id = id + '_' + 'Region_2';
	            options.fill = applyZLight(gradientColor, 0.7);
	            var optiong = void 0;
	            if (fillColor.indexOf('url') === -1) {
	                if (!document.getElementById(id)) {
	                    optiong = { 'id': id, x1: '0%', y1: '0%', x2: GX.toString() + '%', y2: GY.toString() + '%' };
	                    var gradientElement = [{ colorStop: '0%', color: gradientColor }, { colorStop: '30%', color: applyZLight(gradientColor, 0.7) }, { colorStop: '70%', color: applyZLight(gradientColor, 0.7) }, { colorStop: '100%', color: gradientColor }];
	                    this.drawGradient(optiong, gradientElement, series);
	                }
	                options.fill = 'url(#' + optiong.id + ')';
	            }
	            this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));
	            appendChildElement(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);
	        }
	    };
	    /**
	     * To get the gradient of each points.
	     *
	     * @returns {void}
	     * @private
	     */
	    ColumnBase.prototype.drawGradient = function (optiong, gradientElement, series) {
	        var chart = series.chart;
	        var defElement = chart.renderer.createDefs();
	        var xmlns = 'http://www.w3.org/2000/svg';
	        var linearGradientElement = document.createElementNS(xmlns, 'linearGradient');
	        linearGradientElement.setAttribute('id', optiong.id);
	        linearGradientElement.setAttribute('x1', optiong.x1);
	        linearGradientElement.setAttribute('y1', optiong.y1);
	        linearGradientElement.setAttribute('x2', optiong.x2);
	        linearGradientElement.setAttribute('y2', optiong.y2);
	        for (var i = 0; i < gradientElement.length; i++) {
	            var stopElement = document.createElementNS(xmlns, 'stop');
	            stopElement.setAttribute('offset', gradientElement[i].colorStop);
	            stopElement.setAttribute('stop-color', gradientElement[i].color);
	            stopElement.setAttribute('stop-opacity', '1');
	            linearGradientElement.appendChild(stopElement);
	        }
	        series.seriesElement.appendChild(defElement);
	        defElement.appendChild(linearGradientElement);
	    };
	    /**
	     * To get the position of each series.
	     *
	     * @returns {void}
	     * @private
	     */
	    ColumnBase.prototype.getSideBySidePositions = function (series) {
	        var chart = series.chart;
	        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {
	            var columnItem = _a[_i];
	            for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {
	                var item = _c[_b];
	                this.findRectPosition(series.findSeriesCollection(columnItem, item, false));
	            }
	        }
	    };
	    ColumnBase.prototype.findRectPosition = function (seriesCollection) {
	        var groupingValues = [];
	        var vSeries = { rectCount: 0, position: null };
	        for (var i = 0; i < seriesCollection.length; i++) {
	            var value = seriesCollection[i];
	            if (value.type.indexOf('Stacking') !== -1 || value.groupName !== '') {
	                var groupName = value.type.indexOf('Stacking') !== -1 ? value.stackingGroup : value.type + value.groupName;
	                if (groupName) {
	                    if (groupingValues[groupName] === undefined) {
	                        value.position = vSeries.rectCount;
	                        groupingValues[groupName] = vSeries.rectCount++;
	                    }
	                    else {
	                        value.position = groupingValues[groupName];
	                    }
	                }
	                else {
	                    if (vSeries.position === null) {
	                        value.position = vSeries.rectCount;
	                        vSeries.position = vSeries.rectCount++;
	                    }
	                    else {
	                        value.position = vSeries.position;
	                    }
	                }
	            }
	            else {
	                value.position = vSeries.rectCount++;
	            }
	        }
	        for (var i = 0; i < seriesCollection.length; i++) {
	            var value = seriesCollection[i];
	            value.rectCount = vSeries.rectCount;
	        }
	    };
	    /**
	     * Updates the symbollocation for points
	     *
	     * @returns {void}
	     * @private
	     */
	    ColumnBase.prototype.updateSymbolLocation = function (point, rect, series) {
	        if (!series.chart.requireInvertedAxis) {
	            this.updateXRegion(point, rect, series);
	        }
	        else {
	            this.updateYRegion(point, rect, series);
	        }
	        if (series.type === 'Histogram') {
	            point.minimum = +point.x - series.histogramValues.binWidth / 2;
	            point.maximum = +point.x + series.histogramValues.binWidth / 2;
	        }
	    };
	    /**
	     * Update the region for the point.
	     *
	     * @returns {void}
	     * @private
	     */
	    ColumnBase.prototype.updateXRegion = function (point, rect, series) {
	        point.symbolLocations.push({
	            x: rect.x + (rect.width) / 2,
	            y: (series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 ||
	                (point.yValue >= 0 === !series.yAxis.isAxisInverse)) ? rect.y : (rect.y + rect.height)
	        });
	        this.getRegion(point, rect, series);
	        if (series.type === 'RangeColumn') {
	            point.symbolLocations.push({
	                x: rect.x + (rect.width) / 2,
	                y: rect.y + rect.height
	            });
	        }
	    };
	    /**
	     * Update the region for the point in bar series.
	     *
	     * @returns {void}
	     * @private
	     */
	    ColumnBase.prototype.updateYRegion = function (point, rect, series) {
	        point.symbolLocations.push({
	            x: (series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 ||
	                (point.yValue >= 0 === !series.yAxis.isAxisInverse)) ? rect.x + rect.width : rect.x,
	            y: rect.y + rect.height / 2
	        });
	        this.getRegion(point, rect, series);
	        if (series.type === 'RangeColumn') {
	            point.symbolLocations.push({
	                x: rect.x,
	                y: rect.y + rect.height / 2
	            });
	        }
	    };
	    /**
	     * To render the marker for the series.
	     *
	     * @returns {void}
	     * @private
	     */
	    ColumnBase.prototype.renderMarker = function (series) {
	        if (series.marker && series.marker.visible) {
	            series.chart.markerRender.render(series);
	        }
	    };
	    /**
	     * To get the marker region when Y value is 0
	     *
	     * @param {Points} point point
	     * @param {rect} rect rect
	     * @param {Series} series series
	     */
	    ColumnBase.prototype.getRegion = function (point, rect, series) {
	        if (point.y === 0) {
	            var markerWidth = (series.marker && series.marker.width) ? series.marker.width : 0;
	            var markerHeight = (series.marker && series.marker.height) ? series.marker.height : 0;
	            point.regions.push(new Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));
	        }
	        else {
	            point.regions.push(rect);
	        }
	    };
	    /**
	     * To trigger the point rendering event.
	     *
	     * @returns {void}
	     * @private
	     */
	    ColumnBase.prototype.triggerEvent = function (series, point, fill, border) {
	        var argsData = {
	            cancel: false, name: pointRender, series: series, point: point,
	            fill: series.setPointColor(point, fill),
	            border: series.setBorderColor(point, border)
	        };
	        series.chart.trigger(pointRender, argsData);
	        point.color = argsData.fill;
	        return argsData;
	    };
	    /**
	     * To draw the rectangle for points.
	     *
	     * @returns {void}
	     * @private
	     */
	    ColumnBase.prototype.drawRectangle = function (series, point, rect, argsData) {
	        var chart = series.chart;
	        var check = chart.requireInvertedAxis ? rect.height : rect.width;
	        if (check <= 0) {
	            return null;
	        }
	        var direction;
	        if (point.y === 0) {
	            // For 0 values corner radius will not calculate
	            direction = this.calculateRoundedRectPath(rect, 0, 0, 0, 0);
	        }
	        else {
	            direction = this.calculateRoundedRectPath(rect, series.cornerRadius.topLeft, series.cornerRadius.topRight, series.cornerRadius.bottomLeft, series.cornerRadius.bottomRight);
	        }
	        var name = series.category === 'Indicator' ? chart.element.id + '_Indicator_' + series.index + '_' + series.name +
	            '_Point_' + point.index : chart.element.id + '_Series_' + series.index + '_Point_' + point.index;
	        var previousElement = redrawElement(chart.redraw, name);
	        var previousDirection = previousElement ? previousElement.getAttribute('d') : '';
	        this.options = new PathOption(name, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.dashArray, (series.columnFacet === 'Cylinder') ? '' : direction);
	        this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));
	        switch (series.seriesType) {
	            case 'XY':
	                this.element.setAttribute('role', 'img');
	                this.element.setAttribute('aria-label', point.x + ':' + point.yValue + ', ' + series.name);
	                break;
	            case 'HighLow':
	                this.element.setAttribute('role', 'img');
	                this.element.setAttribute('aria-label', point.x + ':' + point.high + ', ' + point.low + ', ' + series.name);
	                break;
	        }
	        appendChildElement(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);
	        if (!series.chart.enableCanvas) {
	            pathAnimation(this.element, (series.columnFacet === 'Cylinder') ? '' : direction, chart.redraw, previousDirection, chart.duration);
	        }
	    };
	    /**
	     * To animate the series.
	     *
	     * @returns {void}
	     * @private
	     */
	    ColumnBase.prototype.animate = function (series) {
	        var rectElements = series.seriesElement.childNodes;
	        var count = series.category === 'Indicator' ? 0 : 1;
	        var visiblePoints = getVisiblePoints(series);
	        for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {
	            var point = visiblePoints_1[_i];
	            if (!point.symbolLocations.length && !(series.type === 'BoxAndWhisker' && point.regions.length)) {
	                continue;
	            }
	            if ((series.type === 'Column' || series.type === 'Bar' || series.type === 'StackingColumn' || series.type === 'StackingColumn100' || series.type === 'StackingBar' || series.type === 'StackingBar100') && series.columnFacet === 'Cylinder') {
	                for (var j = 0; j < rectElements.length; j++) {
	                    this.animateRect(rectElements[j], series, point);
	                }
	            }
	            else {
	                this.animateRect(rectElements[count], series, point);
	                count++;
	            }
	        }
	    };
	    /**
	     * To animate the series.
	     *
	     * @returns {void}
	     * @private
	     */
	    ColumnBase.prototype.animateRect = function (element, series, point) {
	        var option = series.animation;
	        var duration = series.chart.animated ? series.chart.duration : option.duration;
	        var effect = getAnimationFunction('Linear');
	        var isPlot = point.yValue < 0;
	        var x;
	        var y;
	        var elementHeight = +point.regions[0].height;
	        var elementWidth = +point.regions[0].width;
	        var centerX;
	        var centerY;
	        if (!series.chart.requireInvertedAxis) {
	            x = +point.regions[0].x;
	            if (series.type.indexOf('Stacking') > -1) {
	                y = (1 - valueToCoefficient(0, series.yAxis)) * (series.yAxis.rect.height);
	                centerX = x;
	                centerY = y;
	            }
	            else {
	                y = +point.regions[0].y;
	                centerY = (series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1) ? y + elementHeight / 2 :
	                    (isPlot !== series.yAxis.isAxisInverse) ? y : y + elementHeight;
	                centerX = isPlot ? x : x + elementWidth;
	            }
	        }
	        else {
	            y = +point.regions[0].y;
	            if (series.type.indexOf('Stacking') > -1) {
	                x = (valueToCoefficient(0, series.yAxis)) * series.yAxis.rect.width;
	                centerX = x;
	                centerY = y;
	            }
	            else {
	                x = +point.regions[0].x;
	                centerY = isPlot ? y : y + elementHeight;
	                centerX = (series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1) ? x + elementWidth / 2 :
	                    (isPlot !== series.yAxis.isAxisInverse) ? x + elementWidth : x;
	            }
	        }
	        var value;
	        if (!isNullOrUndefined(element)) {
	            element.style.visibility = 'hidden';
	            new Animation$1({}).animate(element, {
	                duration: (duration === 0 && animationMode === 'Enable') ? 1000 : duration,
	                delay: option.delay,
	                progress: function (args) {
	                    if (args.timeStamp >= args.delay) {
	                        element.style.visibility = 'visible';
	                        if (!series.chart.requireInvertedAxis) {
	                            elementHeight = elementHeight ? elementHeight : 1;
	                            value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);
	                            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY +
	                                ') scale(1,' + (value / elementHeight) + ') translate(' + (-centerX) + ' ' + (-centerY) + ')');
	                        }
	                        else {
	                            elementWidth = elementWidth ? elementWidth : 1;
	                            value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);
	                            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY +
	                                ') scale(' + (value / elementWidth) + ', 1) translate(' + (-centerX) + ' ' + (-centerY) + ')');
	                        }
	                    }
	                },
	                end: function () {
	                    element.setAttribute('transform', 'translate(0,0)');
	                    var seriesElement = series.seriesElement;
	                    if (element === seriesElement.lastElementChild || point.index === series.points.length - 1 ||
	                        (series.type === 'Waterfall' && element === seriesElement.children[seriesElement.childElementCount - 2])) {
	                        series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });
	                        if (series.type === 'Waterfall') {
	                            var rectElements = seriesElement.childNodes;
	                            for (var i = 0; i < rectElements.length; i++) {
	                                if (rectElements[i].id.indexOf('Connector') !== -1) {
	                                    rectElements[i].style.visibility = 'visible';
	                                    rectElements[i].setAttribute('transform', 'translate(0,0)');
	                                }
	                            }
	                        }
	                    }
	                }
	            });
	        }
	    };
	    /**
	     * To get rounded rect path direction.
	     */
	    ColumnBase.prototype.calculateRoundedRectPath = function (rect, topLeft, topRight, bottomLeft, bottomRight) {
	        return 'M' + ' ' + rect.x + ' ' + (topLeft + rect.y) +
	            ' Q ' + rect.x + ' ' + rect.y + ' ' + (rect.x + topLeft) + ' ' +
	            rect.y + ' ' + 'L' + ' ' + (rect.x + rect.width - topRight) + ' ' + rect.y +
	            ' Q ' + (rect.x + rect.width) + ' ' + rect.y + ' ' +
	            (rect.x + rect.width) + ' ' + (rect.y + topRight) + ' ' + 'L ' +
	            (rect.x + rect.width) + ' ' + (rect.y + rect.height - bottomRight)
	            + ' Q ' + (rect.x + rect.width) + ' ' + (rect.y + rect.height) + ' ' + (rect.x + rect.width - bottomRight) + ' ' +
	            (rect.y + rect.height) + ' ' + 'L ' + (rect.x + bottomLeft) + ' ' + (rect.y + rect.height) + ' Q ' + rect.x + ' ' +
	            (rect.y + rect.height) + ' ' + rect.x + ' ' + (rect.y + rect.height - bottomLeft) + ' ' + 'L' + ' ' + rect.x + ' ' +
	            (topLeft + rect.y) + ' ' + 'Z';
	    };
	    return ColumnBase;
	}());

	var __extends$9 = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `ColumnSeries` Module used to render the column series.
	 */
	var ColumnSeries = /** @class */ (function (_super) {
	    __extends$9(ColumnSeries, _super);
	    function ColumnSeries() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ColumnSeries.prototype.render = function (series) {
	        var sideBySideInfo = this.getSideBySideInfo(series);
	        var origin = Math.max(series.yAxis.visibleRange.min, 0);
	        var argsData;
	        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
	            var pointColumn = _a[_i];
	            pointColumn.symbolLocations = [];
	            pointColumn.regions = [];
	            if (pointColumn.visible && withInRange(series.points[pointColumn.index - 1], pointColumn, series.points[pointColumn.index + 1], series)) {
	                this.rect = this.getRectangle(pointColumn.xValue + sideBySideInfo.start, pointColumn.yValue, pointColumn.xValue + sideBySideInfo.end, origin, series);
	                this.rect.width = series.columnWidthInPixel ? series.columnWidthInPixel : this.rect.width;
	                this.rect.x = series.columnWidthInPixel ? this.rect.x - (((series.columnWidthInPixel / 2) * series.rectCount) -
	                    (series.columnWidthInPixel * series.index)) : this.rect.x;
	                var color = series.category === 'Indicator' ? pointColumn.color : series.interior;
	                argsData = this.triggerEvent(series, pointColumn, color, { width: series.border.width, color: series.border.color });
	                if (!argsData.cancel) {
	                    this.updateSymbolLocation(pointColumn, this.rect, series);
	                    this.drawRectangle(series, pointColumn, this.rect, argsData);
	                    if (series.columnFacet === 'Cylinder') {
	                        var cylinderSeriesOption = {
	                            'isColumn': true,
	                            'stacking': false,
	                            'isLastSeries': true
	                        };
	                        this.drawCylinder(this.options, this.element, cylinderSeriesOption, this.rect, series);
	                    }
	                }
	            }
	        }
	        this.renderMarker(series);
	    };
	    /**
	     * Animates the series.
	     *
	     * @param  {Series} series - Defines the series to animate.
	     * @returns {void}
	     */
	    ColumnSeries.prototype.doAnimation = function (series) {
	        this.animate(series);
	    };
	    /**
	     * Get module name.
	     */
	    ColumnSeries.prototype.getModuleName = function () {
	        return 'ColumnSeries';
	        /**
	         * return the module name
	         */
	    };
	    /**
	     * To destroy the column series.
	     *
	     * @returns {void}
	     * @private
	     */
	    ColumnSeries.prototype.destroy = function () {
	        /**
	         * Destroy method performed here
	         */
	    };
	    return ColumnSeries;
	}(ColumnBase));

	var __extends$8 = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `BarSeries` module is used to render the bar series.
	 */
	var BarSeries = /** @class */ (function (_super) {
	    __extends$8(BarSeries, _super);
	    function BarSeries() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    BarSeries.prototype.render = function (series) {
	        var origin = Math.max(series.yAxis.visibleRange.min, 0);
	        var sideBySideInfo = this.getSideBySideInfo(series);
	        var argsData;
	        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
	            var pointBar = _a[_i];
	            pointBar.symbolLocations = [];
	            pointBar.regions = [];
	            if (pointBar.visible && withInRange(series.points[pointBar.index - 1], pointBar, series.points[pointBar.index + 1], series)) {
	                this.rect = this.getRectangle(pointBar.xValue + sideBySideInfo.start, pointBar.yValue, pointBar.xValue + sideBySideInfo.end, origin, series);
	                this.rect.height = series.columnWidthInPixel ? series.columnWidthInPixel : this.rect.height;
	                this.rect.y = series.columnWidthInPixel ? this.rect.y - (((series.columnWidthInPixel / 2) * series.rectCount) -
	                    (series.columnWidthInPixel * series.index)) : this.rect.y;
	                argsData = this.triggerEvent(series, pointBar, series.interior, { width: series.border.width, color: series.border.color });
	                if (!argsData.cancel) {
	                    this.updateSymbolLocation(pointBar, this.rect, series);
	                    this.drawRectangle(series, pointBar, this.rect, argsData);
	                    if (series.columnFacet === 'Cylinder') {
	                        var cylinderSeriesOption = {
	                            'isColumn': false,
	                            'stacking': false,
	                            'isLastSeries': true
	                        };
	                        this.drawCylinder(this.options, this.element, cylinderSeriesOption, this.rect, series);
	                    }
	                }
	            }
	        }
	        this.renderMarker(series);
	    };
	    /**
	     * Animates the series.
	     *
	     * @param  {Series} series - Defines the series to animate.
	     * @returns {void}
	     */
	    BarSeries.prototype.doAnimation = function (series) {
	        this.animate(series);
	    };
	    /**
	     * To destroy the bar series.
	     *
	     * @returns {void}
	     * @private
	     */
	    BarSeries.prototype.destroy = function () {
	        /**
	         * Destroy method performed here
	         */
	    };
	    /**
	     * Get module name
	     */
	    BarSeries.prototype.getModuleName = function () {
	        return 'BarSeries';
	    };
	    return BarSeries;
	}(ColumnBase));

	var __extends$7 = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `StackingColumnSeries` module used to render the stacking column series.
	 */
	var StackingColumnSeries = /** @class */ (function (_super) {
	    __extends$7(StackingColumnSeries, _super);
	    function StackingColumnSeries() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    StackingColumnSeries.prototype.render = function (series) {
	        series.isRectSeries = true;
	        var sideBySideInfo = this.getSideBySideInfo(series);
	        var argsData;
	        var stackedValue = series.stackedValues;
	        var visiblePoints = getVisiblePoints(series);
	        for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {
	            var point = visiblePoints_1[_i];
	            point.symbolLocations = [];
	            point.regions = [];
	            if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {
	                this.rect = this.getRectangle(point.xValue + sideBySideInfo.start, stackedValue.endValues[point.index], point.xValue + sideBySideInfo.end, stackedValue.startValues[point.index], series);
	                this.rect.width = series.columnWidthInPixel ? series.columnWidthInPixel : this.rect.width;
	                this.rect.x = series.columnWidthInPixel ? this.rect.x - (series.columnWidthInPixel / 2) : this.rect.x;
	                argsData = this.triggerEvent(series, point, series.interior, { width: series.border.width, color: series.border.color });
	                if (!argsData.cancel) {
	                    this.drawRectangle(series, point, this.rect, argsData);
	                    this.updateSymbolLocation(point, this.rect, series);
	                    if (series.columnFacet === 'Cylinder') {
	                        var cylinderSeriesOption = {
	                            'isColumn': true,
	                            'stacking': series.type === 'StackingColumn100',
	                            'isLastSeries': true
	                        };
	                        this.drawCylinder(this.options, this.element, cylinderSeriesOption, this.rect, series);
	                    }
	                }
	            }
	        }
	        this.renderMarker(series);
	    };
	    /**
	     * Animates the series.
	     *
	     * @param  {Series} series - Defines the series to animate.
	     * @returns {void}
	     */
	    StackingColumnSeries.prototype.doAnimation = function (series) {
	        this.animate(series);
	    };
	    /**
	     * To destroy the stacking column.
	     *
	     * @returns {void}
	     * @private
	     */
	    StackingColumnSeries.prototype.destroy = function () {
	        /**
	         * Destroy method performed here
	         */
	    };
	    /**
	     * Get module name.
	     */
	    StackingColumnSeries.prototype.getModuleName = function () {
	        return 'StackingColumnSeries';
	    };
	    return StackingColumnSeries;
	}(ColumnBase));

	var __extends$6 = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * render Line series
	 */
	var SplineBase = /** @class */ (function (_super) {
	    __extends$6(SplineBase, _super);
	    /** @private */
	    function SplineBase(chartModule) {
	        var _this = _super.call(this, chartModule) || this;
	        _this.splinePoints = [];
	        _this.lowSplinePoints = [];
	        return _this;
	    }
	    /**
	     * To find the control points for spline.
	     *
	     * @returns {void}
	     * @private
	     */
	    SplineBase.prototype.findSplinePoint = function (series) {
	        var value;
	        var lowPoints;
	        var realPoints = [];
	        var points = [];
	        var point;
	        var pointIndex = 0;
	        var negativePoint = false;
	        realPoints = this.filterEmptyPoints(series);
	        for (var i = 0; i < realPoints.length; i++) {
	            point = realPoints[i];
	            if (point.x === null || point.x === '') {
	                continue;
	            }
	            else {
	                point.index = pointIndex;
	                pointIndex++;
	                points.push(point);
	            }
	        }
	        var isLow = false;
	        this.splinePoints = this.findSplineCoefficients(points, series, isLow);
	        if (series.type === 'SplineRangeArea') {
	            isLow = !isLow;
	            this.lowSplinePoints = this.findSplineCoefficients(points, series, isLow);
	        }
	        if (points.length > 1) {
	            series.drawPoints = [];
	            series.lowDrawPoints = [];
	            for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
	                var point_1 = points_1[_i];
	                negativePoint = negativePoint ? negativePoint : point_1.yValue < 0;
	                if (point_1.index !== 0) {
	                    var previous = this.getPreviousIndex(points, point_1.index - 1, series);
	                    if (series.type === 'SplineRangeArea') {
	                        points[previous].yValue = points[previous].high > points[previous].low ? points[previous].high : points[previous].low;
	                        point_1.yValue = point_1.high > point_1.low ? point_1.high : point_1.low;
	                    }
	                    value = this.getControlPoints(points[previous], point_1, this.splinePoints[previous], this.splinePoints[point_1.index], series);
	                    series.drawPoints.push(value);
	                    if (series.type === 'SplineRangeArea') {
	                        points[previous].yValue = points[previous].low < points[previous].high ? points[previous].low : points[previous].high;
	                        point_1.yValue = point_1.low < point_1.high ? point_1.low : point_1.high;
	                        lowPoints = this.getControlPoints(points[previous], point_1, this.lowSplinePoints[previous], this.lowSplinePoints[point_1.index], series);
	                        series.lowDrawPoints.push(lowPoints);
	                    }
	                    // fix for Y-Axis of Spline chart not adjusting scale to suit dataSource issue
	                    var delta = series.yMax - series.yMin;
	                    if (point_1.yValue && value.controlPoint1.y && value.controlPoint2.y && delta > 1) {
	                        series.yMin = Math.min(series.yMin, point_1.yValue, value.controlPoint1.y, value.controlPoint2.y);
	                        series.yMax = Math.ceil(Math.max(series.yMax, point_1.yValue, value.controlPoint1.y, value.controlPoint2.y));
	                        series.yMin = series.yAxis.valueType !== 'Logarithmic' ? Math.floor(series.yMin) : series.yMin;
	                    }
	                }
	            }
	            if (!negativePoint && series.yMin < 0) {
	                series.yMin = 0;
	            }
	            if (series.chart.chartAreaType === 'PolarRadar' && series.isClosed) {
	                value = this.getControlPoints({ xValue: points[points.length - 1].xValue, yValue: points[points.length - 1].yValue }, { xValue: points[points.length - 1].xValue + 1, yValue: points[0].yValue }, this.splinePoints[0], this.splinePoints[points[points.length - 1].index], series);
	                series.drawPoints.push(value);
	            }
	        }
	    };
	    SplineBase.prototype.getPreviousIndex = function (points, i, series) {
	        if (series.emptyPointSettings.mode !== 'Drop') {
	            return i;
	        }
	        while (isNullOrUndefined(points[i]) && i > -1) {
	            i = i - 1;
	        }
	        return i;
	    };
	    SplineBase.prototype.getNextIndex = function (points, i, series) {
	        if (series.emptyPointSettings.mode !== 'Drop') {
	            return i;
	        }
	        while (isNullOrUndefined(points[i]) && i < points.length) {
	            i = i + 1;
	        }
	        return i;
	    };
	    SplineBase.prototype.filterEmptyPoints = function (series, seriesPoints) {
	        if (series.emptyPointSettings.mode !== 'Drop' && this.isPointInRange(series.points)) {
	            return seriesPoints ? seriesPoints : series.points;
	        }
	        var points = seriesPoints ? seriesPoints : extend([], series.points, null, true);
	        for (var i = 0; i < points.length; i++) {
	            points[i].index = i;
	            if (points[i].isEmpty) {
	                points[i].symbolLocations = [];
	                points[i].regions = [];
	                points.splice(i, 1);
	                i--;
	            }
	        }
	        return points;
	    };
	    /**
	     * To find points in the range
	     *
	     * @private
	     */
	    SplineBase.prototype.isPointInRange = function (points) {
	        for (var _i = 0, points_2 = points; _i < points_2.length; _i++) {
	            var point = points_2[_i];
	            if (!point.isPointInRange) {
	                return false;
	            }
	        }
	        return true;
	    };
	    /**
	     * To find the natural spline.
	     *
	     * @returns {void}
	     * @private
	     */
	    SplineBase.prototype.findSplineCoefficients = function (points, series, isLow) {
	        var ySpline = [];
	        series.cardinalSplineTension ? series.cardinalSplineTension : 0.5;
	        switch (series.splineType) {
	            case 'Monotonic':
	                ySpline = this.monotonicSplineCoefficients(points, series, isLow);
	                break;
	            case 'Cardinal':
	                ySpline = this.cardinalSplineCofficients(points, series, isLow);
	                break;
	            default:
	                if (series.splineType === 'Clamped') {
	                    ySpline = this.clampedSplineCofficients(points, series, isLow);
	                }
	                else {
	                    // assigning the first and last value as zero
	                    ySpline[0] = 0;
	                    ySpline[points.length - 1] = 0;
	                }
	                ySpline = this.naturalSplineCoefficients(points, series, isLow);
	                break;
	        }
	        return ySpline;
	    };
	    /**
	     *  To find Monotonic Spline Coefficients
	     */
	    SplineBase.prototype.monotonicSplineCoefficients = function (points, series, isLow) {
	        var count = points.length;
	        var ySpline = [];
	        var dx = [];
	        var dy = [];
	        var slope = [];
	        var interPoint;
	        for (var i = 0; i < count - 1; i++) {
	            if (series.type === 'SplineRangeArea') {
	                if (!isLow) {
	                    points[i + 1].yValue = points[i + 1].high > points[i + 1].low ? points[i + 1].high : points[i + 1].low;
	                    points[i].yValue = points[i].high > points[i].low ? points[i].high : points[i].low;
	                }
	                if (isLow) {
	                    points[i + 1].yValue = points[i + 1].low < points[i + 1].high ? points[i + 1].low : points[i + 1].high;
	                    points[i].yValue = points[i].low < points[i].high ? points[i].low : points[i].high;
	                }
	            }
	            dx[i] = points[i + 1].xValue - points[i].xValue;
	            dy[i] = points[i + 1].yValue - points[i].yValue;
	            slope[i] = dy[i] / dx[i];
	        }
	        //interpolant points
	        var slopeLength = slope.length;
	        // to find the first and last co-efficient value
	        ySpline[0] = slope[0];
	        ySpline[count - 1] = slope[slopeLength - 1];
	        //to find the other co-efficient values
	        for (var j = 0; j < dx.length; j++) {
	            if (slopeLength > j + 1) {
	                if (slope[j] * slope[j + 1] <= 0) {
	                    ySpline[j + 1] = 0;
	                }
	                else {
	                    interPoint = dx[j] + dx[j + 1];
	                    ySpline[j + 1] = 3 * interPoint / ((interPoint + dx[j + 1]) / slope[j] + (interPoint + dx[j]) / slope[j + 1]);
	                }
	            }
	        }
	        return ySpline;
	    };
	    /**
	     * To find Cardinal Spline Coefficients
	     */
	    SplineBase.prototype.cardinalSplineCofficients = function (points, series, isLow) {
	        var count = points.length;
	        var ySpline = [];
	        var cardinalSplineTension = series.cardinalSplineTension ? series.cardinalSplineTension : 0.5;
	        cardinalSplineTension = cardinalSplineTension < 0 ? 0 : cardinalSplineTension > 1 ? 1 : cardinalSplineTension;
	        for (var i = 0; i < count; i++) {
	            if (i === 0) {
	                ySpline[i] = (count > 2) ? (cardinalSplineTension * (points[i + 2].xValue - points[i].xValue)) : 0;
	            }
	            else if (i === (count - 1)) {
	                ySpline[i] = (count > 2) ? (cardinalSplineTension * (points[count - 1].xValue - points[count - 3].xValue)) : 0;
	            }
	            else {
	                ySpline[i] = (cardinalSplineTension * (points[i + 1].xValue - points[i - 1].xValue));
	            }
	        }
	        return ySpline;
	    };
	    /**
	     * To find Clamped Spline Coefficients
	     */
	    SplineBase.prototype.clampedSplineCofficients = function (points, series, isLow) {
	        var count = points.length;
	        var ySpline = [];
	        var ySplineDuplicate = [];
	        for (var i = 0; i < count - 1; i++) {
	            if (series.type === 'SplineRangeArea') {
	                if (!isLow) {
	                    points[1].yValue = points[1].high > points[1].low ? points[1].high : points[1].low;
	                    points[0].yValue = points[0].high > points[0].low ? points[0].high : points[0].low;
	                    points[points.length - 1].yValue = points[points.length - 1].high > points[points.length - 1].low ?
	                        points[points.length - 1].high : points[points.length - 1].low;
	                    points[points.length - 2].yValue = points[points.length - 2].high > points[points.length - 2].low ?
	                        points[points.length - 2].high : points[points.length - 2].low;
	                }
	                if (isLow) {
	                    points[1].yValue = points[1].low < points[1].high ? points[1].low : points[1].high;
	                    points[0].yValue = points[0].low < points[0].high ? points[0].low : points[0].high;
	                    points[points.length - 1].yValue = points[points.length - 1].low < points[points.length - 1].high ?
	                        points[points.length - 1].low : points[points.length - 1].high;
	                    points[points.length - 2].yValue = points[points.length - 2].low < points[points.length - 2].high ?
	                        points[points.length - 2].low : points[points.length - 2].high;
	                }
	            }
	            ySpline[0] = (3 * (points[1].yValue - points[0].yValue)) / (points[1].xValue - points[0].xValue) - 3;
	            ySplineDuplicate[0] = 0.5;
	            ySpline[points.length - 1] = (3 * (points[points.length - 1].yValue - points[points.length - 2].yValue)) /
	                (points[points.length - 1].xValue - points[points.length - 2].xValue);
	            ySpline[0] = ySplineDuplicate[0] = Math.abs(ySpline[0]) === Infinity ? 0 : ySpline[0];
	            ySpline[points.length - 1] = ySplineDuplicate[points.length - 1] = Math.abs(ySpline[points.length - 1]) === Infinity ?
	                0 : ySpline[points.length - 1];
	        }
	        return ySpline;
	    };
	    /**
	     * To find Natural Spline Coefficients
	     */
	    SplineBase.prototype.naturalSplineCoefficients = function (points, series, isLow) {
	        var count = points.length;
	        var ySpline = [];
	        var ySplineDuplicate = [];
	        var dy1;
	        var dy2;
	        var coefficient1;
	        var coefficient2;
	        var coefficient3;
	        ySpline[0] = ySplineDuplicate[0] = 0;
	        ySpline[points.length - 1] = 0;
	        for (var i = 1; i < count - 1; i++) {
	            if (series.type === 'SplineRangeArea') {
	                if (!isLow) {
	                    points[i + 1].yValue = points[i + 1].low > points[i + 1].high ? points[i + 1].low : points[i + 1].high;
	                    points[i].yValue = points[i].low > points[i].high ? points[i].low : points[i].high;
	                    points[i - 1].yValue = points[i - 1].low > points[i - 1].high ? points[i - 1].low : points[i - 1].high;
	                }
	                if (isLow) {
	                    points[i + 1].yValue = points[i + 1].high < points[i + 1].low ? points[i + 1].high : points[i + 1].low;
	                    points[i].yValue = points[i].high < points[i].low ? points[i].high : points[i].low;
	                    points[i - 1].yValue = points[i - 1].high < points[i - 1].low ? points[i - 1].high : points[i - 1].low;
	                }
	            }
	            coefficient1 = points[i].xValue - points[i - 1].xValue;
	            coefficient2 = points[i + 1].xValue - points[i - 1].xValue;
	            coefficient3 = points[i + 1].xValue - points[i].xValue;
	            dy1 = points[i + 1].yValue - points[i].yValue || null;
	            dy2 = points[i].yValue - points[i - 1].yValue || null;
	            if (coefficient1 === 0 || coefficient2 === 0 || coefficient3 === 0) {
	                ySpline[i] = 0;
	                ySplineDuplicate[i] = 0;
	            }
	            else {
	                var p = 1 / (coefficient1 * ySpline[i - 1] + 2 * coefficient2);
	                ySpline[i] = -p * coefficient3;
	                ySplineDuplicate[i] = p * (6 * (dy1 / coefficient3 - dy2 / coefficient1) - coefficient1 * ySplineDuplicate[i - 1]);
	            }
	        }
	        for (var k = count - 2; k >= 0; k--) {
	            ySpline[k] = ySpline[k] * ySpline[k + 1] + ySplineDuplicate[k];
	        }
	        return ySpline;
	    };
	    /**
	     * To find the control points for spline.
	     *
	     * @returns {void}
	     * @private
	     */
	    SplineBase.prototype.getControlPoints = function (point1, point2, ySpline1, ySpline2, series) {
	        var controlPoint1;
	        var controlPoint2;
	        var point;
	        var ySplineDuplicate1 = ySpline1;
	        var ySplineDuplicate2 = ySpline2;
	        var xValue1 = point1.xValue;
	        var yValue1 = point1.yValue;
	        var xValue2 = point2.xValue;
	        var yValue2 = point2.yValue;
	        switch (series.splineType) {
	            case 'Cardinal':
	                if (series.xAxis.valueType === 'DateTime') {
	                    ySplineDuplicate1 = ySpline1 / this.dateTimeInterval(series);
	                    ySplineDuplicate2 = ySpline2 / this.dateTimeInterval(series);
	                }
	                controlPoint1 = new ChartLocation(xValue1 + ySpline1 / 3, yValue1 + ySplineDuplicate1 / 3);
	                controlPoint2 = new ChartLocation(xValue2 - ySpline2 / 3, yValue2 - ySplineDuplicate2 / 3);
	                point = new ControlPoints(controlPoint1, controlPoint2);
	                break;
	            case 'Monotonic':
	                var value = (xValue2 - xValue1) / 3;
	                controlPoint1 = new ChartLocation(xValue1 + value, yValue1 + ySpline1 * value);
	                controlPoint2 = new ChartLocation(xValue2 - value, yValue2 - ySpline2 * value);
	                point = new ControlPoints(controlPoint1, controlPoint2);
	                break;
	            default:
	                var one3 = 1 / 3.0;
	                var deltaX2 = (xValue2 - xValue1);
	                deltaX2 = deltaX2 * deltaX2;
	                var y1 = one3 * (((2 * yValue1) + yValue2) - one3 * deltaX2 * (ySpline1 + 0.5 * ySpline2));
	                var y2 = one3 * ((yValue1 + (2 * yValue2)) - one3 * deltaX2 * (0.5 * ySpline1 + ySpline2));
	                controlPoint1 = new ChartLocation((2 * (xValue1) + (xValue2)) * one3, y1);
	                controlPoint2 = new ChartLocation(((xValue1) + 2 * (xValue2)) * one3, y2);
	                point = new ControlPoints(controlPoint1, controlPoint2);
	                break;
	        }
	        return point;
	    };
	    /**
	     * calculate datetime interval in hours
	     */
	    SplineBase.prototype.dateTimeInterval = function (series) {
	        var interval = series.xAxis.actualIntervalType;
	        var intervalInMilliseconds;
	        if (interval === 'Years') {
	            intervalInMilliseconds = 365 * 24 * 60 * 60 * 1000;
	        }
	        else if (interval === 'Months') {
	            intervalInMilliseconds = 30 * 24 * 60 * 60 * 1000;
	        }
	        else if (interval === 'Days') {
	            intervalInMilliseconds = 24 * 60 * 60 * 1000;
	        }
	        else if (interval === 'Hours') {
	            intervalInMilliseconds = 60 * 60 * 1000;
	        }
	        else if (interval === 'Minutes') {
	            intervalInMilliseconds = 60 * 1000;
	        }
	        else if (interval === 'Seconds') {
	            intervalInMilliseconds = 1000;
	        }
	        else {
	            intervalInMilliseconds = 30 * 24 * 60 * 60 * 1000;
	        }
	        return intervalInMilliseconds;
	    };
	    /**
	     * Animates the series.
	     *
	     * @param  {Series} series - Defines the series to animate.
	     * @returns {void}
	     */
	    SplineBase.prototype.doAnimation = function (series) {
	        var option = series.animation;
	        this.doLinearAnimation(series, option);
	    };
	    return SplineBase;
	}(LineBase));

	var __extends$5 = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `SplineSeries` module is used to render the spline series.
	 */
	var SplineSeries = /** @class */ (function (_super) {
	    __extends$5(SplineSeries, _super);
	    function SplineSeries() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * Render the spline series.
	     *
	     * @returns {void}
	     * @private
	     */
	    SplineSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {
	        var firstPoint = null;
	        var direction = '';
	        var startPoint = 'M';
	        var points = [];
	        var tempPoints = series.category === 'TrendLine' ? series.points : this.enableComplexProperty(series);
	        points = this.filterEmptyPoints(series, tempPoints);
	        var previous;
	        var getCoordinate = series.chart.chartAreaType === 'PolarRadar' ? TransformToVisible : getPoint;
	        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
	            var point = points_1[_i];
	            previous = this.getPreviousIndex(points, point.index - 1, series);
	            point.symbolLocations = [];
	            point.regions = [];
	            if (point.visible) {
	                if (withInRange(points[previous], point, points[this.getNextIndex(points, point.index - 1, series)], series)) {
	                    if (firstPoint !== null) {
	                        direction = this.getSplineDirection(series.drawPoints[previous], firstPoint, point, xAxis, yAxis, isInverted, series, startPoint, getCoordinate, direction);
	                        startPoint = 'L';
	                    }
	                    this.storePointLocation(point, series, isInverted, getCoordinate);
	                }
	                firstPoint = point;
	            }
	            else {
	                startPoint = 'M';
	                firstPoint = null;
	                point.symbolLocations = [];
	            }
	        }
	        if ((points.length > 0 && series.drawPoints.length > 0) && series.chart.chartAreaType === 'PolarRadar' && series.isClosed) {
	            var connectPoints = this.getFirstLastVisiblePoint(points);
	            direction = this.getSplineDirection(series.drawPoints[series.drawPoints.length - 1], connectPoints.last, { xValue: connectPoints.first.xValue, yValue: connectPoints.first.yValue }, xAxis, yAxis, isInverted, series, startPoint, getCoordinate, direction);
	            startPoint = 'L';
	        }
	        var name = series.category === 'TrendLine' ? series.chart.element.id + '_Series_' + series.sourceIndex + '_TrendLine_' + series.index :
	            series.chart.element.id + '_Series_' + series.index;
	        var options = new PathOption(name, 'transparent', series.width, series.interior, series.opacity, series.dashArray, direction);
	        this.appendLinePath(options, series, '');
	        this.renderMarker(series);
	    };
	    /**
	     * To find the direct of spline using points.
	     *
	     * @param {ControlPoints} data data
	     * @param {Points} firstPoint firstPoint
	     * @param {Points} point point
	     * @param {Axis} xAxis xAxis
	     * @param {Axis} yAxis yAxis
	     * @param {boolean} isInverted isInverted
	     * @param {Series} series series
	     * @param {string} startPoint startPoint
	     * @param {Function} getCoordinate getCoordinate
	     * @param {string} direction direction
	     */
	    SplineSeries.prototype.getSplineDirection = function (data, firstPoint, point, xAxis, yAxis, isInverted, series, startPoint, getCoordinate, direction) {
	        var controlPoint1 = data.controlPoint1;
	        var controlPoint2 = data.controlPoint2;
	        var pt1 = getCoordinate(firstPoint.xValue, firstPoint.yValue, xAxis, yAxis, isInverted, series);
	        var pt2 = getCoordinate(point.xValue, point.yValue, xAxis, yAxis, isInverted, series);
	        var bpt1 = getCoordinate(controlPoint1.x, controlPoint1.y, xAxis, yAxis, isInverted, series);
	        var bpt2 = getCoordinate(controlPoint2.x, controlPoint2.y, xAxis, yAxis, isInverted, series);
	        return direction.concat((startPoint + ' ' + (pt1.x) + ' ' + (pt1.y) + ' ' + 'C' + ' ' + (bpt1.x) + ' '
	            + (bpt1.y) + ' ' + (bpt2.x) + ' ' + (bpt2.y) + ' ' + (pt2.x) + ' ' + (pt2.y) + ' '));
	    };
	    /**
	     * Get module name.
	     */
	    SplineSeries.prototype.getModuleName = function () {
	        /**
	         * Returns the module name of the series
	         */
	        return 'SplineSeries';
	    };
	    /**
	     * To destroy the spline.
	     *
	     * @returns {void}
	     * @private
	     */
	    SplineSeries.prototype.destroy = function () {
	        /**
	         * Destroy method calling here
	         */
	    };
	    return SplineSeries;
	}(SplineBase));

	var __extends$4 = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Tooltip Module used to render the tooltip for series.
	 */
	var BaseTooltip = /** @class */ (function (_super) {
	    __extends$4(BaseTooltip, _super);
	    /**
	     * Constructor for tooltip module.
	     *
	     * @private
	     */
	    function BaseTooltip(chart) {
	        var _this = _super.call(this, chart) || this;
	        _this.element = _this.chart.element;
	        _this.textStyle = chart.tooltip.textStyle;
	        _this.control = chart;
	        _this.template = chart.tooltip.template;
	        return _this;
	    }
	    BaseTooltip.prototype.getElement = function (id) {
	        return document.getElementById(id);
	    };
	    /**
	     * Renders the tooltip.
	     *
	     * @returns {void}
	     * @private
	     */
	    BaseTooltip.prototype.getTooltipElement = function (isTooltip) {
	        this.inverted = this.chart.requireInvertedAxis;
	        this.header = (this.control.tooltip.header === null) ?
	            ((this.control.tooltip.shared) ? '${point.x}' : '${series.name}')
	            : (this.control.tooltip.header);
	        this.formattedText = [];
	        var tooltipDiv = document.getElementById(this.chart.element.id + '_tooltip');
	        var isStockChart = this.chart.element.id.indexOf('stockChart') > -1;
	        if (!isTooltip && !tooltipDiv || isStockChart) {
	            return this.createElement();
	        }
	        return null;
	    };
	    BaseTooltip.prototype.createElement = function () {
	        var tooltipDiv = document.createElement('div');
	        tooltipDiv.id = this.element.id + '_tooltip';
	        tooltipDiv.className = 'ejSVGTooltip';
	        tooltipDiv.style.pointerEvents = 'none';
	        tooltipDiv.style.position = 'absolute';
	        tooltipDiv.style.zIndex = '1';
	        return tooltipDiv;
	    };
	    BaseTooltip.prototype.pushData = function (data, isFirst, tooltipDiv, isChart) {
	        if (data.series.enableTooltip) {
	            if (isChart) {
	                this.currentPoints.push(data);
	            }
	            else {
	                this.currentPoints.push(data);
	            }
	            this.stopAnimation();
	            if (tooltipDiv && !document.getElementById(tooltipDiv.id)) {
	                if (!this.chart.stockChart) {
	                    document.getElementById(this.element.id + '_Secondary_Element').appendChild(tooltipDiv);
	                }
	                else {
	                    document.getElementById(this.chart.stockChart.element.id + '_Secondary_Element').appendChild(tooltipDiv);
	                }
	            }
	            return true;
	        }
	        return false;
	    };
	    BaseTooltip.prototype.removeHighlight = function () {
	        var item;
	        for (var i = 0, len = this.previousPoints.length; i < len; i++) {
	            item = this.previousPoints[i];
	            if (item.series.isRectSeries) {
	                if (item.series.visible) {
	                    this.highlightPoint(item.series, item.point.index, false);
	                }
	                continue;
	            }
	            item.series;
	        }
	    };
	    BaseTooltip.prototype.highlightPoint = function (series, pointIndex, highlight) {
	        var element = this.getElement(this.element.id + '_Series_' + series.index + '_Point_' + pointIndex);
	        var selectionModule = this.control.accumulationSelectionModule;
	        var isSelectedElement = selectionModule && selectionModule.selectedDataIndexes.length > 0 ? true : false;
	        if (element) {
	            if ((!isSelectedElement || isSelectedElement && element.getAttribute('class')
	                && element.getAttribute('class').indexOf('_ej2_chart_selection_series_') === -1)) {
	                if (this.chart.highlightColor !== '' && !isNullOrUndefined(this.chart.highlightColor)) {
	                    element.setAttribute('fill', (highlight && this.chart.highlightColor !== 'transparent' ? this.chart.highlightColor : series.pointColorMapping !== '' ? (series.points[0]).color : series.points[pointIndex].color || series.interior));
	                }
	                else {
	                    element.setAttribute('opacity', (highlight && this.chart.highlightColor !== 'transparent' ? series.opacity / 2 : series.opacity).toString());
	                }
	            }
	            else {
	                element.setAttribute('opacity', series.opacity.toString());
	            }
	        }
	    };
	    BaseTooltip.prototype.highlightPoints = function () {
	        for (var _i = 0, _a = this.currentPoints; _i < _a.length; _i++) {
	            var item = _a[_i];
	            if (item.series.isRectSeries && item.series.category === 'Series') {
	                this.highlightPoint(item.series, item.point.index, true);
	            }
	        }
	    };
	    // tslint:disable-next-line:max-func-body-length
	    BaseTooltip.prototype.createTooltip = function (chart, isFirst, location, clipLocation, point, shapes, offset, bounds, crosshairEnabled, extraPoints, templatePoint, customTemplate) {
	        if (crosshairEnabled === void 0) { crosshairEnabled = false; }
	        if (extraPoints === void 0) { extraPoints = null; }
	        if (templatePoint === void 0) { templatePoint = null; }
	        var series = this.currentPoints[0].series;
	        var module = chart.tooltipModule || chart.accumulationTooltipModule;
	        if (!module || location === null) { // For the tooltip enable is false.
	            removeElement(this.chart.element.id + '_tooltip');
	            return;
	        }
	        if (isFirst) {
	            this.svgTooltip = new Tooltip$1({
	                opacity: chart.tooltip.opacity ? chart.tooltip.opacity : ((this.chart.theme === 'Material3' || this.chart.theme === 'Material3Dark') ? 1 : 0.75),
	                header: this.headerText,
	                content: this.text,
	                fill: chart.tooltip.fill,
	                border: chart.tooltip.border,
	                enableAnimation: chart.tooltip.enableAnimation,
	                location: location,
	                shared: chart.tooltip.shared,
	                crosshair: crosshairEnabled,
	                shapes: shapes,
	                clipBounds: this.chart.chartAreaType === 'PolarRadar' ? new ChartLocation(0, 0) : clipLocation,
	                areaBounds: bounds,
	                palette: this.findPalette(),
	                template: customTemplate || this.template,
	                data: templatePoint,
	                theme: chart.theme,
	                offset: offset,
	                textStyle: chart.tooltip.textStyle,
	                isNegative: (series.isRectSeries && series.type !== 'Waterfall' && point && point.y < 0),
	                inverted: this.chart.requireInvertedAxis && series.isRectSeries,
	                arrowPadding: this.text.length > 1 || this.chart.stockChart ? 0 : 7,
	                availableSize: chart.availableSize,
	                duration: this.chart.tooltip.duration,
	                isCanvas: this.chart.enableCanvas,
	                isTextWrap: chart.tooltip.enableTextWrap && chart.getModuleName() === 'chart',
	                blazorTemplate: { name: 'Template', parent: this.chart.tooltip },
	                controlInstance: this.chart,
	                enableRTL: chart.enableRtl,
	                controlName: 'Chart',
	                allowHighlight: chart.getModuleName() === 'chart' && !series.marker.allowHighlight,
	                tooltipRender: function () {
	                    module.removeHighlight();
	                    module.highlightPoints();
	                    module.updatePreviousPoint(extraPoints);
	                },
	                animationComplete: function (args) {
	                    if (args.tooltip.fadeOuted) {
	                        module.fadeOut(module.previousPoints);
	                    }
	                }
	            });
	            this.svgTooltip.appendTo(this.getElement(this.element.id + '_tooltip'));
	        }
	        else {
	            if (this.svgTooltip) {
	                this.svgTooltip.location = location;
	                this.svgTooltip.content = this.text;
	                this.svgTooltip.header = this.headerText;
	                this.svgTooltip.offset = offset;
	                this.svgTooltip.palette = this.findPalette();
	                this.svgTooltip.shapes = shapes;
	                this.svgTooltip.data = templatePoint;
	                this.svgTooltip.template = this.template;
	                this.svgTooltip.controlName = 'Chart';
	                this.svgTooltip.crosshair = crosshairEnabled;
	                this.svgTooltip.textStyle = chart.tooltip.textStyle;
	                this.svgTooltip.isNegative = (series.isRectSeries && series.type !== 'Waterfall' && point && point.y < 0);
	                this.svgTooltip.clipBounds = this.chart.chartAreaType === 'PolarRadar' ? new ChartLocation(0, 0) : clipLocation;
	                this.svgTooltip.arrowPadding = this.text.length > 1 || this.chart.stockChart ? 0 : 7;
	                this.svgTooltip.allowHighlight = chart.getModuleName() === 'chart' && !series.marker.allowHighlight;
	                this.svgTooltip.dataBind();
	            }
	        }
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        if (this.chart.isReact) {
	            this.chart.renderReactTemplates();
	        }
	    };
	    BaseTooltip.prototype.findPalette = function () {
	        var colors = [];
	        for (var _i = 0, _a = this.currentPoints; _i < _a.length; _i++) {
	            var data = _a[_i];
	            colors.push(this.findColor(data, data.series));
	        }
	        return colors;
	    };
	    BaseTooltip.prototype.findColor = function (data, series) {
	        if (series.isRectSeries && (series.type === 'Candle' || series.type === 'Hilo' || series.type === 'HiloOpenClose')) {
	            return data.point.color;
	        }
	        else {
	            return (data.point.color && data.point.color !== '#ffffff' ? data.point.color
	                : data.point.interior) ||
	                series.marker.fill || series.interior;
	        }
	    };
	    BaseTooltip.prototype.updatePreviousPoint = function (extraPoints) {
	        if (extraPoints) {
	            this.currentPoints = this.currentPoints.concat(extraPoints);
	        }
	        this.previousPoints = extend([], this.currentPoints, null, true);
	    };
	    BaseTooltip.prototype.fadeOut = function (data) {
	        var svgElement = this.chart.enableCanvas ? this.getElement(this.element.id + '_tooltip_group') :
	            this.getElement(this.element.id + '_tooltip_svg');
	        var isTooltip = (svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0);
	        if (!isTooltip) {
	            this.valueX = null;
	            this.valueY = null;
	            this.currentPoints = [];
	            this.removeHighlight();
	            this.removeHighlightedMarker(data, true);
	            this.svgTooltip = null;
	            this.control.trigger('animationComplete', {});
	        }
	    };
	    /*
	    * @hidden
	    */
	    BaseTooltip.prototype.removeHighlightedMarker = function (data, fadeOut) {
	        if (this.chart.markerRender) {
	            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
	                var item = data_1[_i];
	                removeElement(this.element.id + '_Series_' + item.series.index +
	                    '_Point_' + item.point.index + '_Trackball');
	                this.chart.markerRender.removeHighlightedMarker(item.series, item.point, fadeOut);
	            }
	        }
	        this.previousPoints = [];
	    };
	    // public triggerEvent(point: PointData | AccPointData, isFirst: boolean, textCollection: string, firstText: boolean = true): boolean {
	    //     let argsData: ITooltipRenderEventArgs = {
	    //         cancel: false, name: tooltipRender, text: textCollection,
	    //         point: point.point, series: point.series, textStyle: this.textStyle
	    //     };
	    //     this.chart.trigger(tooltipRender, argsData);
	    //     if (!argsData.cancel) {
	    //         if (point.series.type === 'BoxAndWhisker') {
	    //             this.removeText();
	    //             isFirst = true;
	    //         }
	    //         this.formattedText = this.formattedText.concat(argsData.text);
	    //         this.text = this.formattedText;
	    //     }
	    //     return !argsData.cancel;
	    // }
	    BaseTooltip.prototype.removeText = function () {
	        this.textElements = [];
	        var element = this.getElement(this.element.id + '_tooltip_group');
	        if (element && element.childNodes.length > 0) {
	            while (element.lastChild && element.childNodes.length !== 1) {
	                element.removeChild(element.lastChild);
	            }
	        }
	    };
	    BaseTooltip.prototype.stopAnimation = function () {
	        stopTimer(this.toolTipInterval);
	    };
	    /**
	     * Removes the tooltip on mouse leave.
	     *
	     * @returns {void}
	     * @private
	     */
	    BaseTooltip.prototype.removeTooltip = function (duration) {
	        var _this = this;
	        var tooltipElement = this.getElement(this.element.id + '_tooltip');
	        var tooltipTemplate = tooltipElement ? this.getElement(tooltipElement.id + 'parent_template') : null;
	        tooltipTemplate && tooltipTemplate.innerText !== '<div></div>';
	        this.stopAnimation();
	        if (tooltipElement && this.previousPoints.length > 0) {
	            this.toolTipInterval = +setTimeout(function () {
	                if (_this.svgTooltip) {
	                    _this.svgTooltip.fadeOut();
	                }
	            }, duration);
	        }
	    };
	    return BaseTooltip;
	}(ChartData));

	var __extends$3 = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `Tooltip` module is used to render the tooltip for chart series.
	 */
	var Tooltip = /** @class */ (function (_super) {
	    __extends$3(Tooltip, _super);
	    /**
	     * Constructor for tooltip module.
	     *
	     * @private
	     */
	    function Tooltip(chart) {
	        var _this = _super.call(this, chart) || this;
	        _this.commonXvalues = [];
	        _this.addEventListener();
	        return _this;
	    }
	    /**
	     * @hidden
	     */
	    Tooltip.prototype.addEventListener = function () {
	        if (this.chart.isDestroyed) {
	            return;
	        }
	        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
	        this.chart.on(cancelEvent, this.mouseLeaveHandler, this);
	        this.chart.on('tapHold', this.longPress, this);
	        this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
	        this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);
	    };
	    Tooltip.prototype.mouseUpHandler = function () {
	        var chart = this.control;
	        var data = this.getData();
	        data.lierIndex = this.lierIndex;
	        if (chart.isTouch && !this.isSelected(chart) &&
	            ((withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect) && chart.tooltip.shared)
	                || !chart.tooltip.shared)) {
	            if (!chart.crosshair.enable) {
	                this.tooltip();
	                if (chart.tooltip.fadeOutMode === 'Move') {
	                    this.removeTooltip(chart.tooltip.fadeOutDuration);
	                }
	            }
	            else if (chart.startMove && chart.tooltip.fadeOutMode === 'Move') {
	                this.removeTooltip(2000);
	            }
	        }
	        else if (!this.findData(data, this.previousPoints[0]) && chart.tooltip.fadeOutMode === 'Click') {
	            this.removeTooltip(0);
	        }
	    };
	    Tooltip.prototype.mouseLeaveHandler = function () {
	        this.removeTooltip(this.chart.tooltip.fadeOutDuration);
	    };
	    Tooltip.prototype.mouseMoveHandler = function () {
	        var chart = this.chart;
	        chart.mouseX = chart.mouseX / chart.scaleX;
	        chart.mouseY = chart.mouseY / chart.scaleY;
	        if (chart.stockChart && chart.stockChart.onPanning) {
	            if (chart.mouseY < chart.chartAxisLayoutPanel.seriesClipRect.y) {
	                chart.mouseY = chart.chartAxisLayoutPanel.seriesClipRect.y;
	            }
	            else if (chart.mouseY > chart.chartAxisLayoutPanel.seriesClipRect.y + chart.chartAxisLayoutPanel.seriesClipRect.height) {
	                chart.mouseY = chart.chartAxisLayoutPanel.seriesClipRect.y + chart.chartAxisLayoutPanel.seriesClipRect.height;
	            }
	        }
	        // Tooltip for chart series.
	        if (!chart.disableTrackTooltip && !this.isSelected(chart)) {
	            if (!chart.tooltip.shared && (!chart.isTouch || (chart.startMove))) {
	                this.tooltip();
	            }
	            if (withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
	                if (chart.tooltip.shared && (!chart.isTouch || (chart.startMove))) {
	                    this.tooltip();
	                }
	            }
	            else {
	                if (chart.tooltip.shared && chart.tooltip.fadeOutMode === 'Move') {
	                    this.removeTooltip(this.chart.tooltip.fadeOutDuration);
	                }
	            }
	        }
	    };
	    /**
	     * Handles the long press on chart.
	     *
	     * @returns {boolean} false
	     * @private
	     */
	    Tooltip.prototype.longPress = function () {
	        var chart = this.chart;
	        if (chart.crosshair.enable && withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {
	            this.tooltip();
	            chart.markerRender.markerMove(false);
	        }
	        return false;
	    };
	    /**
	     * Renders the tooltip.
	     *
	     * @returns {void}
	     */
	    Tooltip.prototype.tooltip = function () {
	        var elementId = this.chart.enableCanvas ? this.element.id + '_tooltip_group' : this.element.id + '_tooltip_svg';
	        var svgElement = this.getElement(elementId);
	        // To prevent the disappearance of the tooltip, while resize the stock chart.
	        var isStockSvg = this.chart.stockChart && svgElement && (svgElement.firstChild.childNodes.length > 1);
	        var isTooltip = (svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0 && !isStockSvg);
	        var tooltipDiv = this.getTooltipElement(isTooltip);
	        if (this.chart.enableCanvas && tooltipDiv) {
	            document.getElementById(this.chart.element.id + '_Secondary_Element').appendChild(tooltipDiv);
	            tooltipDiv.appendChild(document.getElementById(this.chart.element.id + '_tooltip_svg'));
	        }
	        if (!this.chart.tooltip.shared) {
	            this.renderSeriesTooltip(this.chart, !isTooltip, tooltipDiv);
	        }
	        else {
	            this.renderGroupedTooltip(this.chart, !isTooltip, tooltipDiv);
	        }
	    };
	    Tooltip.prototype.findHeader = function (data) {
	        if (this.header === '') {
	            return '';
	        }
	        this.header = this.parseTemplate(data.point, data.series, this.header, data.series.xAxis, data.series.yAxis);
	        if (this.header.replace(/<b>/g, '').replace(/<\/b>/g, '').trim() !== '') {
	            return this.header;
	        }
	        return '';
	    };
	    Tooltip.prototype.findShapes = function () {
	        if (!this.chart.tooltip.enableMarker) {
	            return [];
	        }
	        var marker = [];
	        for (var _i = 0, _a = this.currentPoints; _i < _a.length; _i++) {
	            var data = _a[_i];
	            marker.push(data.point.marker.shape || data.series.marker.shape || 'Circle');
	        }
	        return marker;
	    };
	    Tooltip.prototype.renderSeriesTooltip = function (chart, isFirst, tooltipDiv) {
	        var data = this.getData();
	        data.lierIndex = this.lierIndex;
	        this.currentPoints = [];
	        if (this.findData(data, this.previousPoints[0])) {
	            if (!(chart.dataEditingModule && chart.dataEditingModule.isPointDragging) && (this.previousPoints[0] &&
	                data.point.index === this.previousPoints[0].point.index && data.series.index === this.previousPoints[0].series.index)) {
	                return null;
	            }
	            if (this.pushData(data, isFirst, tooltipDiv, true)) {
	                this.triggerTooltipRender(data, isFirst, this.getTooltipText(data), this.findHeader(data));
	            }
	        }
	        else {
	            if (!data.point && this.isRemove && chart.tooltip.fadeOutMode === 'Move') {
	                this.removeTooltip(this.chart.tooltip.fadeOutDuration);
	                this.isRemove = false;
	            }
	            else {
	                var commonXvalues = this.mergeXvalues(this.chart.visibleSeries);
	                for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
	                    var series = _a[_i];
	                    if (series.visible && !(series.category === 'TrendLine')) {
	                        data = this.getClosestX(chart, series, commonXvalues) || data;
	                    }
	                }
	            }
	        }
	        if (data && data.point) {
	            this.findMouseValue(data, chart);
	        }
	    };
	    Tooltip.prototype.triggerTooltipRender = function (point, isFirst, textCollection, headerText) {
	        var _this = this;
	        var tooltipTemplate;
	        var argsData = {
	            cancel: false, name: tooltipRender, text: textCollection, headerText: headerText, template: tooltipTemplate,
	            series: this.chart.isBlazor ? {} : point.series, textStyle: this.textStyle, point: point.point,
	            data: { pointX: point.point.x, pointY: point.point.y, seriesIndex: point.series.index, seriesName: point.series.name,
	                pointIndex: point.point.index, pointText: point.point.text }
	        };
	        var borderWidth = this.chart.border.width;
	        var padding = 3;
	        var chartTooltipSuccess = function (argsData) {
	            if (!argsData.cancel) {
	                if (point.series.type === 'BoxAndWhisker') {
	                    _this.removeText();
	                    isFirst = true;
	                }
	                _this.headerText = argsData.headerText;
	                _this.formattedText = _this.formattedText.concat(argsData.text);
	                _this.text = _this.formattedText;
	                _this.createTooltip(_this.chart, isFirst, _this.getSymbolLocation(point), point.series.clipRect, point.point, _this.findShapes(), _this.findMarkerHeight(_this.currentPoints[0]), new Rect(borderWidth, borderWidth, _this.chart.availableSize.width - padding - borderWidth * 2, _this.chart.availableSize.height - padding - borderWidth * 2), _this.chart.crosshair.enable, null, _this.getTemplateText(point), _this.template ? argsData.template : '');
	            }
	            else {
	                _this.removeHighlight();
	                remove(_this.getElement(_this.element.id + '_tooltip'));
	            }
	            _this.isRemove = true;
	        };
	        chartTooltipSuccess.bind(this, point);
	        this.chart.trigger(tooltipRender, argsData, chartTooltipSuccess);
	    };
	    Tooltip.prototype.findMarkerHeight = function (pointData) {
	        var markerHeight = 0;
	        var series = pointData.series;
	        markerHeight = ((series.marker.visible || (this.chart.tooltip.shared &&
	            (!series.isRectSeries || series.marker.visible)) || series.type === 'Scatter' || series.drawType === 'Scatter')
	            && !(series.type === 'Candle' || series.type === 'Hilo' || series.type === 'HiloOpenClose')) ?
	            ((series.marker.height + 2) / 2 + (2 * series.marker.border.width)) : 0;
	        return markerHeight;
	    };
	    Tooltip.prototype.findData = function (data, previous) {
	        return data.point && ((!previous || (previous.point !== data.point)) ||
	            (previous && previous.lierIndex > 3 && previous.lierIndex !== this.lierIndex) || (previous.point === data.point));
	    };
	    Tooltip.prototype.getSymbolLocation = function (data) {
	        var location;
	        if (data.series.type !== 'BoxAndWhisker') {
	            if (!data.point.symbolLocations[0]) {
	                return null;
	            }
	            location = new ChartLocation(data.point.symbolLocations[0].x, data.point.symbolLocations[0].y);
	        }
	        switch (data.series.type) {
	            case 'BoxAndWhisker':
	                return this.getBoxLocation(data);
	            case 'Waterfall':
	                return this.getWaterfallRegion(data, location);
	            case 'RangeArea':
	            case 'RangeStepArea':
	            case 'SplineRangeArea':
	            case 'RangeColumn':
	                return this.getRangeArea(data, location);
	            default:
	                return location;
	        }
	    };
	    Tooltip.prototype.getRangeArea = function (data, location) {
	        if (data.point.regions[0]) {
	            if (!this.inverted) {
	                location.y = data.point.regions[0].y + data.point.regions[0].height / 2;
	            }
	            else {
	                location.x = data.point.regions[0].x + data.point.regions[0].width / 2;
	            }
	            if (data.series.type === 'RangeStepArea') {
	                location.y = data.point.regions[0].y + data.point.regions[0].height / 2 + data.point.regions[0].width;
	            }
	        }
	        return location;
	    };
	    Tooltip.prototype.getWaterfallRegion = function (data, location) {
	        if (!this.inverted) {
	            location.y = (data.point.y < 0) ?
	                location.y - data.point.regions[0].height : location.y;
	        }
	        else {
	            location.x = (data.point.y < 0) ?
	                location.x + data.point.regions[0].width : location.x;
	        }
	        return location;
	    };
	    Tooltip.prototype.getTooltipText = function (pointData) {
	        var series = pointData.series;
	        return this.parseTemplate(pointData.point, series, this.getFormat(this.chart, series), series.xAxis, series.yAxis);
	    };
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    Tooltip.prototype.getTemplateText = function (data) {
	        if (this.template && this.chart.tooltip.shared) {
	            var point = [];
	            for (var i = 0; i < data.length; i++) {
	                point[i] = extend({}, data[i].point);
	                point[i].x = this.formatPointValue(data[i].point, data[i].series.xAxis, 'x', true, false);
	                if ((data[i].series.seriesType === 'XY')) {
	                    point[i].y = this.formatPointValue(data[i].point, data[i].series.yAxis, 'y', false, true);
	                }
	                else {
	                    point[i].low = this.formatPointValue(data[i].point, data[i].series.yAxis, 'low', false, true);
	                    point[i].high = this.formatPointValue(data[i].point, data[i].series.yAxis, 'high', false, true);
	                }
	            }
	            return point;
	        }
	        else if (this.template) {
	            var point = extend({}, data.point);
	            point.x = this.formatPointValue(data.point, data.series.xAxis, 'x', true, false);
	            if ((data.series.seriesType === 'XY')) {
	                point.y = this.formatPointValue(data.point, data.series.yAxis, 'y', false, true);
	            }
	            else {
	                point.low = this.formatPointValue(data.point, data.series.yAxis, 'low', false, true);
	                point.high = this.formatPointValue(data.point, data.series.yAxis, 'high', false, true);
	            }
	            return point;
	        }
	        else {
	            return data.point;
	        }
	    };
	    Tooltip.prototype.findMouseValue = function (data, chart) {
	        if (!chart.requireInvertedAxis) {
	            if (chart.chartAreaType === 'PolarRadar') {
	                this.valueX = valueToPolarCoefficient(data.point.xValue, data.series.xAxis) * data.series.xAxis.rect.width
	                    + data.series.xAxis.rect.x;
	            }
	            else {
	                this.valueX = (data.series.category === 'TrendLine' && chart.tooltip.shared) ? this.valueX :
	                    valueToCoefficient(data.point.xValue, data.series.xAxis) * data.series.xAxis.rect.width
	                        + data.series.xAxis.rect.x;
	            }
	            this.valueY = chart.mouseY;
	        }
	        else {
	            this.valueY = (1 - valueToCoefficient(data.point.xValue, data.series.xAxis)) * data.series.xAxis.rect.height
	                + data.series.xAxis.rect.y;
	            this.valueX = chart.mouseX;
	        }
	    };
	    Tooltip.prototype.renderGroupedTooltip = function (chart, isFirst, tooltipDiv) {
	        var data;
	        var dataCollection = [];
	        var lastData;
	        var pointData = chart.chartAreaType === 'PolarRadar' ? this.getData() : null;
	        this.stopAnimation();
	        this.removeHighlight();
	        this.currentPoints = [];
	        var extraPoints = [];
	        var closestXValue = Number.MAX_VALUE;
	        var closetYValue = Number.MAX_VALUE;
	        var pointXValue;
	        var pointYValue;
	        var tempData;
	        //let headerContent : string = '';
	        if (isFirst) {
	            if (!chart.stockChart) {
	                if (tooltipDiv) {
	                    document.getElementById(this.element.id + '_Secondary_Element').appendChild(tooltipDiv);
	                }
	            }
	            else {
	                if (tooltipDiv && !getElement$1(tooltipDiv.id)) {
	                    document.getElementById(chart.stockChart.element.id + '_Secondary_Element').appendChild(tooltipDiv);
	                }
	            }
	        }
	        this.removeText();
	        var argument = {
	            text: [], cancel: false, name: sharedTooltipRender, data: [], point: [], series: [], headerText: '', textStyle: this.textStyle, template: ''
	        };
	        var i = 0;
	        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
	            var series = _a[_i];
	            if (!series.enableTooltip || !series.visible) {
	                continue;
	            }
	            if (chart.chartAreaType === 'Cartesian' && series.visible) {
	                data = this.getClosestX(chart, series, this.commonXValue(this.chart.visibleSeries));
	            }
	            else if (chart.chartAreaType === 'PolarRadar' && series.visible && pointData.point !== null) {
	                data = new PointData(series.points[pointData.point.index], series);
	            }
	            // if (data && this.header !== '' && this.currentPoints.length === 0) {
	            //     headerContent = this.findHeader(data);
	            // }
	            if (chart.tooltip.showNearestPoint && !data) {
	                data = this.getClosestX(chart, series, this.commonXValue([series]));
	            }
	            if (data) {
	                argument.data.push({ pointX: data.point.x, pointY: data.point.y, seriesIndex: data.series.index,
	                    seriesName: data.series.name, pointIndex: data.point.index, pointText: data.point.text });
	                argument.series[i] = data.series;
	                argument.point[i] = data.point;
	                argument.headerText = this.findHeader(data);
	                this.currentPoints.push(data);
	                argument.text.push(this.getTooltipText(data));
	                pointXValue = (!chart.requireInvertedAxis) ? chart.mouseX - data.series.clipRect.x : chart.mouseY - data.series.clipRect.y;
	                pointYValue = chart.mouseY - data.series.clipRect.y;
	                if (data.point.symbolLocations && data.point.symbolLocations.length && Math.abs(pointXValue - data.point.symbolLocations[0].x) <= closestXValue &&
	                    Math.abs(data.point.symbolLocations[0].y - pointYValue) < Math.abs(closetYValue - pointYValue)) {
	                    closestXValue = Math.abs(pointXValue - data.point.symbolLocations[0].x);
	                    closetYValue = data.point.symbolLocations[0].y;
	                    tempData = data;
	                }
	                lastData = (data.series.category === 'TrendLine' && chart.tooltip.shared) ? lastData : tempData || data;
	                dataCollection.push(data);
	            }
	            // if (data && this.triggerEvent(data, isFirst, this.getTooltipText(data)), this.findHeader(data)) {
	            //     this.findMouseValue(data, chart);
	            //     (<PointData[]>this.currentPoints).push(data);
	            //     data = null;
	            // } else if (data) {
	            //     extraPoints.push(data);
	            // }
	            i++;
	        }
	        if (!chart.tooltip.showNearestPoint) {
	            var collection = [];
	            this.currentPoints = [];
	            argument.point = [];
	            argument.series = [];
	            argument.data = [];
	            argument.text = [];
	            for (var _b = 0, dataCollection_1 = dataCollection; _b < dataCollection_1.length; _b++) {
	                var data_1 = dataCollection_1[_b];
	                if (data_1.point.symbolLocations[0].x === lastData.point.symbolLocations[0].x) {
	                    argument.point.push(data_1.point);
	                    argument.series.push(data_1.series);
	                    argument.text.push(this.getTooltipText(data_1));
	                    argument.headerText = this.findHeader(data_1);
	                    collection.push(data_1);
	                    argument.data.push({
	                        pointX: data_1.point.x, pointY: data_1.point.y, seriesIndex: data_1.series.index,
	                        seriesName: data_1.series.name, pointIndex: data_1.point.index, pointText: data_1.point.text
	                    });
	                }
	            }
	            dataCollection = collection;
	            this.currentPoints = collection;
	        }
	        if (dataCollection.length > 0 && this.currentPoints.length > 0) { // To avoid console error when we have empty chart with shared tooltip.
	            this.triggerSharedTooltip(argument, lastData, extraPoints, chart, isFirst, dataCollection);
	        }
	        else if (this.getElement(this.element.id + '_tooltip_path')) {
	            this.getElement(this.element.id + '_tooltip_path').setAttribute('d', '');
	        }
	    };
	    Tooltip.prototype.triggerSharedTooltip = function (argument, point, extraPoints, chart, isFirst, dataCollection) {
	        var _this = this;
	        var tooltipTemplate;
	        var argsData = {
	            cancel: false, name: sharedTooltipRender, text: argument.text, headerText: argument.headerText,
	            textStyle: argument.textStyle, template: tooltipTemplate,
	            point: argument.point, series: argument.series,
	            data: argument.data
	        };
	        var borderWidth = this.chart.border.width;
	        var padding = 3;
	        var toolbarHeight;
	        var titleHeight;
	        var currentPoints = [];
	        if (chart.stockChart) {
	            toolbarHeight = chart.stockChart.enablePeriodSelector ? chart.stockChart.toolbarHeight : 0;
	            titleHeight = measureText(this.chart.stockChart.title, this.chart.stockChart.titleStyle, this.chart.themeStyle.tooltipLabelFont).height + 10;
	        }
	        var sharedTooltip = function (argsData) {
	            if (!argsData.cancel) {
	                if (point.series.type === 'BoxAndWhisker') {
	                    _this.removeText();
	                    isFirst = true;
	                }
	                for (var i = 0; i < argsData.text.length; i++) {
	                    if (argsData.text[i]) {
	                        currentPoints.push(_this.currentPoints[i]);
	                    }
	                }
	                _this.currentPoints = currentPoints;
	                _this.formattedText = _this.formattedText.concat(argsData.text);
	                _this.text = argsData.text;
	                _this.headerText = argsData.headerText;
	                _this.findMouseValue(point, _this.chart);
	                _this.createTooltip(chart, isFirst, _this.findSharedLocation(), _this.currentPoints.length === 1 ? _this.currentPoints[0].series.clipRect : null, dataCollection.length === 1 ? dataCollection[0].point : null, _this.findShapes(), _this.findMarkerHeight(_this.currentPoints[0]), new Rect(borderWidth, (chart.stockChart ? (toolbarHeight + titleHeight + borderWidth) : borderWidth), _this.chart.availableSize.width - padding - borderWidth * 2, _this.chart.availableSize.height - padding - borderWidth * 2), _this.chart.crosshair.enable, extraPoints, _this.template ? _this.getTemplateText(dataCollection) : null, _this.template ? argsData.template : '');
	                point = null;
	            }
	            else {
	                extraPoints.push(point);
	            }
	        };
	        sharedTooltip.bind(this, point, extraPoints);
	        this.chart.trigger(sharedTooltipRender, argsData, sharedTooltip);
	    };
	    Tooltip.prototype.findSharedLocation = function () {
	        var stockChart = this.chart.stockChart;
	        if (stockChart) {
	            if (this.text.length === 1) {
	                this.text.push('');
	            }
	            var toolbarHeight = stockChart.enablePeriodSelector ? stockChart.toolbarHeight : 0;
	            var element = document.getElementById(stockChart.element.id + '_ChartTitle');
	            var titleHeight = stockChart.title !== '' ? element.getBoundingClientRect().height + 10 : 0;
	            if (stockChart.tooltip.position === 'Nearest') {
	                return new ChartLocation(this.valueX, this.valueY + toolbarHeight + titleHeight);
	            }
	            return new ChartLocation(this.chart.chartAxisLayoutPanel.seriesClipRect.x + 5, this.chart.chartAxisLayoutPanel.seriesClipRect.y + toolbarHeight + 5 + titleHeight);
	        }
	        else {
	            if (this.currentPoints.length > 1) {
	                return new ChartLocation(this.valueX, this.valueY);
	            }
	            else {
	                return this.getSymbolLocation(this.currentPoints[0]);
	            }
	        }
	    };
	    Tooltip.prototype.getBoxLocation = function (data) {
	        var location = this.lierIndex > 3 ? (data.point.outliers.length > 0 ? data.point.symbolLocations[this.lierIndex - 4] : null) :
	            {
	                x: data.point.regions[0].x + (data.point.regions[0].width / 2),
	                y: data.point.regions[0].y + (data.point.regions[0].height / 2)
	            };
	        return location;
	    };
	    Tooltip.prototype.parseTemplate = function (point, series, format, xAxis, yAxis) {
	        var val;
	        var textValue;
	        for (var _i = 0, _a = Object.keys(point); _i < _a.length; _i++) {
	            var dataValue = _a[_i];
	            val = new RegExp('${point' + '.' + dataValue + '}', 'gm');
	            format = format.replace(val.source, this.formatPointValue(point, val.source === '${point.x}' ? xAxis : yAxis, dataValue, val.source === '${point.x}', (val.source === '${point.high}' ||
	                val.source === '${point.open}' ||
	                val.source === '${point.close}' ||
	                val.source === '${point.low}' ||
	                val.source === '${point.y}' ||
	                val.source === '${point.minimum}' ||
	                val.source === '${point.maximum}' ||
	                val.source === '${point.outliers}' ||
	                val.source === '${point.upperQuartile}' ||
	                val.source === '${point.lowerQuartile}' ||
	                val.source === '${point.median}')));
	        }
	        for (var _b = 0, _c = Object.keys(Object.getPrototypeOf(series)); _b < _c.length; _b++) {
	            var dataValue = _c[_b];
	            val = new RegExp('${series' + '.' + dataValue + '}', 'gm');
	            textValue = series[dataValue];
	            format = format.replace(val.source, textValue);
	        }
	        return format;
	    };
	    Tooltip.prototype.formatPointValue = function (point, axis, dataValue, isXPoint, isYPoint) {
	        var textValue;
	        var customLabelFormat;
	        var value;
	        if (axis.valueType !== 'Category' && isXPoint) {
	            customLabelFormat = axis.labelFormat && axis.labelFormat.match('{value}') !== null;
	            textValue = customLabelFormat ? axis.labelFormat.replace('{value}', axis.format(point[dataValue])) :
	                axis.format(point[dataValue]);
	        }
	        else if (isYPoint && !isNullOrUndefined(point[dataValue])) {
	            customLabelFormat = axis.labelFormat && axis.labelFormat.match('{value}') !== null;
	            value = dataValue === 'outliers' ? axis.format(point[dataValue][this.lierIndex - 4]) :
	                axis.format(point[dataValue]);
	            textValue = customLabelFormat ? axis.labelFormat.replace('{value}', value) : value;
	        }
	        else if (dataValue === 'size') {
	            var format = this.chart.intl.getNumberFormat({ format: '', useGrouping: this.chart.useGroupingSeparator });
	            textValue = typeof point[dataValue] === 'number' ? format(point[dataValue]) : point[dataValue];
	        }
	        else {
	            textValue = point[dataValue];
	        }
	        return textValue;
	    };
	    Tooltip.prototype.getFormat = function (chart, series) {
	        if (series.tooltipFormat) {
	            if (series.seriesType === 'XY' && series.category === 'Indicator') {
	                return this.getIndicatorTooltipFormat(series, chart, chart.tooltip.format);
	            }
	            return series.tooltipFormat;
	        }
	        if (!series.tooltipFormat && chart.tooltip.format) {
	            if (series.seriesType === 'XY' && series.category === 'Indicator') {
	                return this.getIndicatorTooltipFormat(series, chart, chart.tooltip.format);
	            }
	            return chart.tooltip.format;
	        }
	        var textX = (series.type === 'Histogram') ? '${point.minimum}' + '-' + '${point.maximum}' : '${point.x}';
	        var format = !chart.tooltip.shared ? textX : '${series.name}';
	        switch (series.seriesType) {
	            case 'XY':
	                if (series.category === 'Indicator') {
	                    this.getIndicatorTooltipFormat(series, chart, chart.tooltip.format);
	                }
	                return format + ' : ' + ((series.type === 'Bubble') ? '<b>${point.y}</b>  Size : <b>${point.size}</b>' :
	                    '<b>${point.y}</b>');
	            case 'HighLow':
	                return format + ('<br/>High : <b>${point.high}</b><br/>Low : <b>${point.low}</b>');
	            case 'HighLowOpenClose':
	                return format + ('<br/>High : <b>${point.high}</b><br/>Low : <b>${point.low}</b><br/>' +
	                    'Open : <b>${point.open}</b><br/>Close : <b>${point.close}</b>');
	            case 'BoxPlot': {
	                return format + '<br/>' + (this.lierIndex > 3 ? 'Outliers : <b>${point.outliers}</b>' :
	                    'Maximum : <b>${point.maximum}</b><br/>Q3 : <b>${point.upperQuartile}</b><br/>' +
	                        'Median : <b>${point.median}</b><br/>Q1 : <b>${point.lowerQuartile}</b><br/>Minimum : <b>${point.minimum}</b>');
	            }
	            default: return '';
	        }
	    };
	    Tooltip.prototype.getIndicatorTooltipFormat = function (series, chart, format) {
	        var toolTip;
	        if (series.seriesType === 'XY') {
	            toolTip = series.name + ' : <b>${point.y}</b>';
	        }
	        else {
	            toolTip = format;
	        }
	        return toolTip;
	    };
	    /*
	    * @hidden
	    */
	    Tooltip.prototype.removeHighlightedMarker = function (data, fadeOut) {
	        for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {
	            var item = data_2[_i];
	            removeElement(this.element.id + '_Series_' + item.series.index +
	                '_Point_' + item.point.index + '_Trackball');
	            if (this.chart.markerRender) {
	                this.chart.markerRender.removeHighlightedMarker(item.series, item.point, fadeOut);
	            }
	        }
	        this.previousPoints = [];
	    };
	    /**
	     * Get module name.
	     */
	    Tooltip.prototype.getModuleName = function () {
	        /**
	         * Returns the module name
	         */
	        return 'Tooltip';
	    };
	    /**
	     * To destroy the tooltip.
	     *
	     * @returns {void}
	     * @private
	     */
	    Tooltip.prototype.destroy = function () {
	        /**
	         * Destroy method performed here
	         */
	    };
	    return Tooltip;
	}(BaseTooltip));

	/**
	 * Selection src file
	 */
	/**
	 * Selection Module handles the selection for chart.
	 *
	 * @private
	 */
	var BaseSelection = /** @class */ (function () {
	    function BaseSelection(control) {
	        this.control = control;
	    }
	    /**
	     * To create selection styles for series
	     *
	     * @returns {void}
	     */
	    BaseSelection.prototype.seriesStyles = function () {
	        var seriesclass;
	        var style = document.getElementById(this.styleId);
	        var pattern = '{}';
	        var fill;
	        var opacity;
	        var selectionPattern = this.control.selectionPattern;
	        var highlightPattern = this.control.highlightPattern;
	        if ((this.styleId.indexOf('highlight') > 0 && this.control.highlightColor !== '') || isNullOrUndefined(style) || selectionPattern !== 'None' || highlightPattern !== 'None') {
	            style = document.createElement('style');
	            style.setAttribute('id', this.styleId);
	            for (var _i = 0, _a = this.control.visibleSeries; _i < _a.length; _i++) {
	                var series = _a[_i];
	                var visibleSeries = this.control.visibleSeries[series.index] ||
	                    this.control.visibleSeries[series.index];
	                if ((this.styleId.indexOf('highlight') > 0 && this.control.highlightColor !== '') || (!isNullOrUndefined(selectionPattern) || !isNullOrUndefined(highlightPattern)) &&
	                    (selectionPattern !== 'None' || highlightPattern !== 'None')) {
	                    var patternName = this.styleId.indexOf('highlight') > 0 ? highlightPattern : selectionPattern;
	                    if ((visibleSeries.type === 'Pie' || visibleSeries.type === 'Funnel' ||
	                        visibleSeries.type === 'Pyramid') && this.control.highlightColor !== 'transparent') {
	                        for (var i = 0; i < visibleSeries.points.length; i++) {
	                            opacity = visibleSeries.opacity;
	                            fill = this.pattern(this.control, (this.styleId.indexOf('highlight') > 0 && this.control.highlightColor !== '') ? this.control.highlightColor : (visibleSeries.points[i]).color, series.points[i].index, patternName, opacity);
	                            pattern = '{ fill:' + fill + '}';
	                            seriesclass = series.selectionStyle || this.styleId + '_series_' + series.index + '_point_' + series.points[i].index + ',' + '.' +
	                                this.styleId + '_series_' + series.index + '_point_' + series.points[i].index + '> *';
	                            if (this.control.highlightMode === 'None' && this.control.legendSettings.enableHighlight) {
	                                style.innerText += '.' + this.styleId + '_series_' + series.index + '> *' + ' { stroke-width:' + (3) + ';} ';
	                            }
	                            pattern = (pattern.indexOf('None') > -1) ? '{fill:' + this.control.highlightColor + '!important}' : pattern;
	                            style.innerText += series.selectionStyle ? '' : '.' + seriesclass + pattern;
	                        }
	                    }
	                    else if (visibleSeries.type && this.control.highlightColor !== 'transparent') {
	                        opacity = visibleSeries.opacity;
	                        fill = this.pattern(this.control, (this.styleId.indexOf('highlight') > 0 && this.control.highlightColor !== '') ? this.control.highlightColor :
	                            (visibleSeries.pointColorMapping !== '' || (this.control.rangeColorSettings && this.control.rangeColorSettings.length > 1)) ? (visibleSeries.points[0]).color
	                                : visibleSeries.interior, series.index, patternName, opacity);
	                        pattern = '{ fill:' + fill + '}';
	                    }
	                }
	                seriesclass = series.selectionStyle || this.styleId + '_series_' + series.index + ',' + '.' +
	                    this.styleId + '_series_' + series.index + '> *';
	                if (this.control.highlightMode === 'None' && this.control.legendSettings.enableHighlight) {
	                    style.innerText += '.' + this.styleId + '_series_' + series.index + '> *' + ' { stroke-width:' + (parseFloat(series.width.toString()) + 1) + ';} ';
	                }
	                pattern = (pattern.indexOf('None') > -1) ? '{}' : pattern;
	                style.innerText += series.selectionStyle ? '' : '.' + seriesclass + pattern;
	            }
	            var unSelectOpacity = (this.control).highlightColor !== 'transparent' ? 0.3 : opacity;
	            if (isNullOrUndefined(this.control.selectionModule) && this.control.selectionMode === 'None' && this.control.highlightColor !== '') {
	                unSelectOpacity = 1;
	            }
	            style.innerText += '.' + this.unselected + ' { opacity:' + (unSelectOpacity) + ';} ';
	            document.body.appendChild(style);
	        }
	    };
	    /**
	     * To create the pattern for series/points.
	     *
	     * @param chart
	     * @param color
	     * @param index
	     * @param patternName
	     * @param opacity
	     * @param chart
	     * @param color
	     * @param index
	     * @param patternName
	     * @param opacity
	     * @param chart
	     * @param color
	     * @param index
	     * @param patternName
	     * @param opacity
	     * @param chart
	     * @param color
	     * @param index
	     * @param patternName
	     * @param opacity
	     * @param chart
	     * @param color
	     * @param index
	     * @param patternName
	     * @param opacity
	     */
	    BaseSelection.prototype.pattern = function (chart, color, index, patternName, opacity) {
	        var backgroundColor = '#ffffff';
	        var svg = chart.svgObject;
	        var pathOptions = [];
	        var patternGroup = {
	            'id': chart.element.id + '_' + patternName + '_Selection' + '_' + index, 'patternUnits': 'userSpaceOnUse'
	        };
	        var heightStr = 'height';
	        var widthStr = 'width';
	        var width = 10;
	        var height = 12;
	        var patternNum = 6;
	        var turquoiseNum = 17;
	        var turstrokewidth = 1;
	        var starNum = 21;
	        var circleNum = 9;
	        var tileNum = 18;
	        var strokeWidth = 1;
	        var bubNum = 20;
	        switch (patternName) {
	            case 'Dots':
	                patternGroup[heightStr] = patternGroup[widthStr] = patternNum;
	                patternGroup[widthStr] = patternNum;
	                pathOptions[0] = {
	                    'x': 0, 'y': 0, 'width': 7, 'height': 7, 'transform': 'translate(0,0)',
	                    'fill': backgroundColor, 'opacity': opacity, 'name': 'rect'
	                };
	                pathOptions[1] = {
	                    'cx': 3,
	                    'cy': 3,
	                    'r': 2,
	                    'stroke-width': 1,
	                    'fill': color,
	                    'name': 'circle'
	                };
	                break;
	            case 'Pacman':
	                patternGroup[heightStr] = '18.384';
	                patternGroup[widthStr] = '17.917';
	                pathOptions[0] = {
	                    'name': 'rect', 'x': 0, 'y': 0, 'width': 17.917, 'height': 18.384,
	                    'transform': 'translate(0,0)', 'fill': backgroundColor, 'opacity': opacity
	                };
	                pathOptions[1] = {
	                    'name': 'path', 'd': 'M9.081,9.194l5.806-3.08c-0.812-1.496-2.403-3.052-4.291-3.052H8.835C6.138,3.063,3,6.151,3,8.723v1.679   c0,2.572,3.138,5.661,5.835,5.661h1.761c2.085,0,3.835-1.76,4.535-3.514L9.081,9.194z', 'stroke-width': 1, 'stroke': color, 'fill': color
	                };
	                break;
	            case 'Chessboard':
	                patternGroup[heightStr] = patternGroup[widthStr] = width;
	                pathOptions[0] = {
	                    'x': 0, 'y': 0, 'width': width, 'height': width, 'fill': backgroundColor, 'opacity': opacity,
	                    'name': 'rect'
	                };
	                pathOptions[1] = { 'x': 0, 'y': 0, 'width': 5, 'height': 5, 'fill': color, 'opacity': opacity, 'name': 'rect' };
	                pathOptions[2] = { 'x': 5, 'y': 5, 'width': 5, 'height': 5, 'fill': color, 'opacity': opacity, 'name': 'rect' };
	                break;
	            case 'Crosshatch':
	                patternGroup[heightStr] = patternGroup[widthStr] = '8';
	                pathOptions[0] = {
	                    'x': 0, 'y': 0, 'width': 8, 'height': 8, 'transform': 'translate(0,0)',
	                    'fill': backgroundColor, 'opacity': opacity, 'name': 'rect'
	                };
	                pathOptions[1] = {
	                    'd': 'M0 0L8 8ZM8 0L0 8Z',
	                    'stroke-width': 1,
	                    'stroke': color,
	                    'name': 'path'
	                };
	                break;
	            case 'DiagonalForward':
	                patternGroup[heightStr] = patternGroup[widthStr] = patternNum;
	                pathOptions[0] = {
	                    'x': 0, 'y': 0, 'width': patternNum, 'height': patternNum, 'transform': 'translate(0,0)',
	                    'fill': backgroundColor, 'opacity': opacity, 'name': 'rect'
	                };
	                pathOptions[1] = {
	                    'd': 'M 3 -3 L 9 3 M 6 6 L 0 0 M 3 9 L -3 3',
	                    'stroke-width': 2,
	                    'stroke': color,
	                    'name': 'path'
	                };
	                break;
	            case 'DiagonalBackward':
	                patternGroup[heightStr] = patternGroup[widthStr] = patternNum;
	                pathOptions[0] = {
	                    'x': 0, 'y': 0, 'width': patternNum, 'height': patternNum, 'transform': 'translate(0,0)',
	                    'fill': backgroundColor, 'opacity': opacity, 'name': 'rect'
	                };
	                pathOptions[1] = {
	                    'd': 'M 3 -3 L -3 3 M 0 6 L 6 0 M 9 3 L 3 9',
	                    'stroke-width': 2,
	                    'stroke': color,
	                    'name': 'path'
	                };
	                break;
	            case 'Grid':
	                patternGroup[heightStr] = patternGroup[widthStr] = patternNum;
	                pathOptions[0] = {
	                    'name': 'rect', 'x': 0, 'y': 0, 'width': patternNum, 'height': patternNum, 'transform': 'translate(0,0)',
	                    'fill': backgroundColor, 'opacity': opacity
	                };
	                pathOptions[1] = {
	                    'name': 'path',
	                    'd': 'M1 3.5L11 3.5 M0 3.5L11 3.5 M0 7.5L11 7.5 M0 11.5L11 11.5 M5.5 0L5.5 12 M11.5 0L11.5 12Z',
	                    'stroke-width': 1,
	                    'stroke': color
	                };
	                break;
	            case 'Turquoise':
	                patternGroup[heightStr] = patternGroup[widthStr] = turquoiseNum;
	                pathOptions[0] = {
	                    'name': 'rect', 'x': 0, 'y': 0, 'width': turquoiseNum, 'height': turquoiseNum, 'transform': 'translate(0,0)',
	                    'fill': backgroundColor, 'opacity': opacity
	                };
	                pathOptions[1] = {
	                    'name': 'path', 'd': 'M0.5739999999999998,2.643a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0',
	                    'stroke-width': turstrokewidth, 'stroke-miterlimit': width, 'stroke': color, 'fill': color
	                };
	                pathOptions[2] = {
	                    'name': 'path', 'd': 'M11.805,2.643a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0',
	                    'stroke-width': turstrokewidth, 'stroke-miterlimit': width, 'stroke': color, 'fill': color
	                };
	                pathOptions[3] = {
	                    'name': 'path', 'd': 'M6.19,2.643a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0',
	                    'stroke-width': turstrokewidth, 'stroke-miterlimit': width, 'stroke': color, 'fill': color
	                };
	                pathOptions[4] = {
	                    'name': 'path', 'd': 'M11.805,8.217a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0',
	                    'stroke-width': turstrokewidth, 'stroke-miterlimit': width, 'stroke': color, 'fill': color
	                };
	                pathOptions[5] = {
	                    'name': 'path', 'd': 'M6.19,8.217a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0',
	                    'stroke-width': turstrokewidth, 'stroke-miterlimit': width, 'stroke': color, 'fill': color
	                };
	                pathOptions[6] = {
	                    'name': 'path', 'd': 'M11.805,13.899a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0',
	                    'stroke-width': turstrokewidth, 'stroke-miterlimit': width, 'stroke': color, 'fill': color
	                };
	                pathOptions[7] = {
	                    'name': 'path', 'd': 'M6.19,13.899a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0',
	                    'stroke-width': turstrokewidth, 'stroke-miterlimit': width, 'stroke': color, 'fill': color
	                };
	                break;
	            case 'Star':
	                patternGroup[heightStr] = patternGroup[widthStr] = starNum;
	                pathOptions[0] = {
	                    'name': 'rect', 'x': 0, 'y': 0, 'width': starNum, 'height': starNum, 'transform': 'translate(0,0)',
	                    'fill': backgroundColor, 'opacity': opacity
	                };
	                pathOptions[1] = {
	                    'name': 'path',
	                    'd': 'M15.913,18.59L10.762 12.842 5.613 18.75 8.291 11.422 0.325 9.91 8.154 8.33 5.337 0.91 10.488 6.658 15.637 0.75 12.959 8.078 20.925 9.59 13.096 11.17 z',
	                    'stroke-width': 1,
	                    'stroke': color,
	                    'fill': color
	                };
	                break;
	            case 'Triangle':
	                patternGroup[heightStr] = patternGroup[widthStr] = width;
	                pathOptions[0] = {
	                    'name': 'rect', 'x': 0, 'y': 0, 'width': width, 'height': width, 'transform': 'translate(0,0)',
	                    'fill': backgroundColor, 'opacity': opacity
	                };
	                pathOptions[1] = {
	                    'name': 'path',
	                    'd': 'M4.987,0L7.48 4.847 9.974 9.694 4.987 9.694 0 9.694 2.493 4.847 z',
	                    'stroke-width': 1,
	                    'stroke': color,
	                    'fill': color
	                };
	                break;
	            case 'Circle':
	                patternGroup[heightStr] = patternGroup[widthStr] = circleNum;
	                pathOptions[0] = {
	                    'name': 'rect', 'x': 0, 'y': 0, 'width': circleNum, 'height': circleNum, 'transform': 'translate(0,0)',
	                    'fill': backgroundColor, 'opacity': opacity
	                };
	                pathOptions[1] = {
	                    'name': 'circle',
	                    'cx': 5.125,
	                    'cy': 3.875,
	                    'r': 3.625,
	                    'stroke-width': 1,
	                    'fill': color
	                };
	                break;
	            case 'Tile':
	                patternGroup[heightStr] = patternGroup[widthStr] = tileNum;
	                pathOptions[0] = {
	                    'name': 'rect', 'x': 0, 'y': 0, 'width': tileNum, 'height': tileNum, 'transform': 'translate(0,0)',
	                    'fill': backgroundColor, 'opacity': opacity
	                };
	                pathOptions[1] = { 'name': 'path', 'd': 'M0,9L0 0 9 0 z', 'stroke-width': strokeWidth, 'stroke': color, 'fill': color };
	                pathOptions[2] = { 'name': 'path', 'd': 'M9,9L9 0 18 0 z', 'stroke-width': strokeWidth, 'stroke': color, 'fill': color };
	                pathOptions[3] = { 'name': 'path', 'd': 'M0,18L0 9 9 9 z', 'stroke-width': strokeWidth, 'stroke': color, 'fill': color };
	                pathOptions[4] = { 'name': 'path', 'd': 'M9,18L9 9 18 9 z', 'stroke-width': strokeWidth, 'stroke': color, 'fill': color };
	                break;
	            case 'HorizontalDash':
	                patternGroup[heightStr] = patternGroup[widthStr] = height;
	                pathOptions[0] = {
	                    'name': 'rect', 'x': 0, 'y': 0, 'width': height, 'height': height, 'transform': 'translate(0,0)',
	                    'fill': backgroundColor, 'opacity': opacity
	                };
	                pathOptions[1] = {
	                    'name': 'path', 'd': 'M0,1.5 L10 1.5 M0,5.5 L10 5.5 M0,9.5 L10 9.5 z', 'stroke-width': 1,
	                    'stroke': color, 'fill': color
	                };
	                break;
	            case 'VerticalDash':
	                patternGroup[heightStr] = patternGroup[widthStr] = height;
	                pathOptions[0] = {
	                    'name': 'rect', 'x': 0, 'y': 0, 'width': height, 'height': height, 'transform': 'translate(0,0)',
	                    'fill': backgroundColor, 'opacity': opacity
	                };
	                pathOptions[1] = {
	                    'name': 'path', 'd': 'M1.5,0 L1.5 10 M5.5,0 L5.5 10 M9.5,0 L9.5 10 z', 'stroke-width': 1,
	                    'stroke': color, 'fill': color
	                };
	                break;
	            case 'Rectangle':
	                patternGroup[heightStr] = patternGroup[widthStr] = height;
	                pathOptions[0] = { 'name': 'rect', 'width': height, 'height': height, 'fill': backgroundColor, 'opacity': opacity };
	                pathOptions[1] = { 'name': 'rect', 'x': 1, 'y': 2, 'width': 4, 'height': 9, 'fill': color, 'opacity': opacity };
	                pathOptions[2] = { 'name': 'rect', 'x': 7, 'y': 2, 'width': 4, 'height': 9, 'fill': color, 'opacity': opacity };
	                break;
	            case 'Box':
	                patternGroup[heightStr] = patternGroup[widthStr] = width;
	                pathOptions[0] = { 'name': 'rect', 'width': 13, 'height': 13, 'fill': backgroundColor, 'opacity': opacity };
	                pathOptions[1] = {
	                    'name': 'rect', 'x': 1.5, 'y': 1.5, 'width': width, 'height': 9, 'fill': color,
	                    'opacity': opacity
	                };
	                break;
	            case 'HorizontalStripe':
	                patternGroup[heightStr] = height;
	                patternGroup[widthStr] = width;
	                pathOptions[0] = {
	                    'name': 'rect', 'x': 0, 'y': 0, 'width': width, 'height': height,
	                    'transform': 'translate(0,0)', 'fill': backgroundColor, 'opacity': opacity
	                };
	                pathOptions[1] = {
	                    'name': 'path', 'd': 'M0,0.5 L10 0.5 M0,4.5 L10 4.5 M0,8.5 L10 8.5 z', 'stroke-width': 1,
	                    'stroke': color, 'fill': color
	                };
	                break;
	            case 'VerticalStripe':
	                patternGroup[heightStr] = width;
	                patternGroup[widthStr] = height;
	                pathOptions[0] = {
	                    'name': 'rect', 'x': 0, 'y': 0, 'width': height, 'height': width, 'transform': 'translate(0,0)',
	                    'fill': backgroundColor, 'opacity': opacity
	                };
	                pathOptions[1] = {
	                    'name': 'path', 'd': 'M0.5,0 L0.5 10 M4.5,0 L4.5 10 M8.5,0 L8.5 10 z', 'stroke-width': 1,
	                    'stroke': color, 'fill': color
	                };
	                break;
	            case 'Bubble':
	                patternGroup[heightStr] = patternGroup[widthStr] = bubNum;
	                pathOptions[0] = {
	                    'name': 'rect', 'x': 0, 'y': 0, 'width': bubNum, 'height': bubNum, 'transform': 'translate(0,0)',
	                    'fill': backgroundColor, 'opacity': opacity
	                };
	                pathOptions[1] = { 'name': 'circle', 'cx': 5.217, 'cy': 11.325, 'r': 3.429, 'stroke-width': 1, 'fill': '#D0A6D1' };
	                pathOptions[2] = { 'name': 'circle', 'cx': 13.328, 'cy': 6.24, 'r': 4.884, 'stroke-width': 1, 'fill': color };
	                pathOptions[3] = {
	                    'name': 'circle', 'cx': 13.277, 'cy': 14.66, 'r': 3.018, 'stroke-width': 1,
	                    'fill': '#D0A6D1'
	                };
	                break;
	        }
	        var svgRenderer = (chart.svgRenderer || chart.renderer);
	        var pattern = svgRenderer.createPattern(patternGroup, 'pattern');
	        this.loadPattern(chart, pathOptions, pattern, svgRenderer);
	        svg.appendChild(pattern);
	        return 'url(#' + chart.element.id + '_' + patternName + '_' + 'Selection' + '_' + index + ')';
	    };
	    /**
	     * To load the pattern into svg
	     *
	     * @param chart
	     * @param options
	     * @param pattern
	     * @param svgRenderer
	     * @param chart
	     * @param options
	     * @param pattern
	     * @param svgRenderer
	     * @param chart
	     * @param options
	     * @param pattern
	     * @param svgRenderer
	     * @param chart
	     * @param options
	     * @param pattern
	     * @param svgRenderer
	     */
	    BaseSelection.prototype.loadPattern = function (chart, options, pattern, svgRenderer) {
	        var i;
	        for (i = 0; i < options.length; i++) {
	            var path = svgRenderer.createPattern(options[i], options[i].name);
	            pattern.appendChild(path);
	        }
	    };
	    /**
	     * To concat indexes
	     *
	     * @param userIndexes
	     * @param localIndexes
	     * @param userIndexes
	     * @param localIndexes
	     */
	    BaseSelection.prototype.concatIndexes = function (userIndexes, localIndexes) {
	        return userIndexes.concat(localIndexes);
	    };
	    /**
	     * Selected points series visibility checking on legend click
	     *
	     * @param selectedIndexes
	     */
	    BaseSelection.prototype.checkVisibility = function (selectedIndexes, chart) {
	        if (chart === void 0) { chart = null; }
	        if (!selectedIndexes) {
	            return false;
	        }
	        var visible = false;
	        var uniqueSeries = [];
	        for (var _i = 0, selectedIndexes_1 = selectedIndexes; _i < selectedIndexes_1.length; _i++) {
	            var index = selectedIndexes_1[_i];
	            if (uniqueSeries.indexOf(index.series) === -1) {
	                uniqueSeries.push(index.series);
	            }
	        }
	        for (var _a = 0, uniqueSeries_1 = uniqueSeries; _a < uniqueSeries_1.length; _a++) {
	            var index = uniqueSeries_1[_a];
	            if (chart != null && chart.rangeColorSettings && chart.rangeColorSettings.length > 0 &&
	                chart.rangeColorSettings[0].colors.length > 0) {
	                if (this.control.series[0].visible) {
	                    visible = true;
	                    break;
	                }
	            }
	            else {
	                if (this.control.visibleSeries[index].visible) {
	                    visible = true;
	                    break;
	                }
	            }
	        }
	        return visible;
	    };
	    /**
	     * To add svg element style class
	     *
	     * @param element
	     * @param className
	     * @param element
	     * @param className
	     * @private
	     */
	    BaseSelection.prototype.addSvgClass = function (element, className) {
	        var elementClassName = element.getAttribute('class') || '';
	        elementClassName += ((elementClassName !== '') ? ' ' : '');
	        if (elementClassName.indexOf(className) === -1) {
	            element.setAttribute('class', elementClassName + className);
	        }
	    };
	    /**
	     * To remove svg element style class
	     *
	     * @param element
	     * @param className
	     * @param element
	     * @param className
	     * @private
	     */
	    BaseSelection.prototype.removeSvgClass = function (element, className) {
	        var elementClassName = element.getAttribute('class') || '';
	        if (elementClassName.indexOf(className) > -1) {
	            element.setAttribute('class', elementClassName.replace(className, ''));
	        }
	    };
	    /**
	     * To get children from parent element
	     *
	     * @param parent
	     */
	    BaseSelection.prototype.getChildren = function (parent) {
	        var children = [];
	        for (var i = 0; i < parent.childNodes.length; i++) {
	            if (parent.childNodes[i].tagName !== 'defs') {
	                children.push(parent.childNodes[i]);
	            }
	        }
	        return children;
	    };
	    return BaseSelection;
	}());

	var __extends$2 = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `Selection` module handles the selection for chart.
	 *
	 * @private
	 */
	var Selection = /** @class */ (function (_super) {
	    __extends$2(Selection, _super);
	    /**
	     * Constructor for selection module.
	     *
	     * @private
	     */
	    function Selection(chart) {
	        var _this = _super.call(this, chart) || this;
	        _this.isdrawRect = true;
	        _this.multiDataIndexes = [];
	        _this.pathIndex = 0;
	        _this.seriesIndex = 0;
	        _this.count = -1;
	        _this.dragRectArray = [];
	        _this.filterArray = [];
	        _this.totalSelectedPoints = [];
	        _this.chart = chart;
	        _this.renderer = chart.renderer;
	        var mode = chart.selectionMode;
	        _this.isMultiDrag = chart.isMultiSelect && (mode.indexOf('Drag') > -1);
	        _this.addEventListener();
	        return _this;
	    }
	    /**
	     * Binding events for selection module.
	     */
	    Selection.prototype.addEventListener = function () {
	        if (this.chart.isDestroyed || (this.chart.stockChart && this.chart.stockChart.onPanning)) {
	            return;
	        }
	        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
	        this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
	        this.chart.on(cancelEvent, this.mouseLeave, this);
	        this.chart.on('click', this.mouseClick, this);
	        this.chart.on(Browser.touchStartEvent, this.mousedown, this);
	        this.chart.on(Browser.touchEndEvent, this.mouseLeave, this);
	    };
	    /**
	     * Chart mouse down
	     */
	    Selection.prototype.mousedown = function (e) {
	        var chart = this.chart;
	        if (chart.isPointMouseDown || chart.selectionMode === 'None' || chart.isChartDrag) {
	            return;
	        }
	        if (chart.isDoubleTap || !chart.isTouch || this.rectPoints) {
	            this.dragStart(chart, chart.chartAxisLayoutPanel.seriesClipRect, chart.mouseDownX, chart.mouseDownY, e);
	        }
	    };
	    /**
	     * UnBinding events for selection module.
	     */
	    Selection.prototype.removeEventListener = function () {
	        if (this.chart.isDestroyed) {
	            return;
	        }
	        this.chart.off(Browser.touchMoveEvent, this.mouseMove);
	        this.chart.off('pointerleave' , this.mouseLeave);
	        this.chart.off('click', this.mouseClick);
	        this.chart.off(Browser.touchStartEvent, this.mousedown);
	        this.chart.off(Browser.touchEndEvent, this.mouseLeave);
	    };
	    /**
	     * To find private variable values
	     */
	    Selection.prototype.initPrivateVariables = function (chart) {
	        this.styleId = chart.element.id + '_ej2_chart_selection';
	        this.unselected = chart.element.id + '_ej2_deselected';
	        this.closeIconId = chart.element.id + '_ej2_drag_close';
	        this.draggedRectGroup = chart.element.id + '_ej2_drag_group';
	        this.multiRectGroup = chart.element.id + '_ej2_drag_multi_group';
	        this.draggedRect = chart.element.id + '_ej2_drag_rect';
	        this.lassoPath = chart.element.id + '_ej2_drag_path';
	        this.selectedDataIndexes = [];
	        this.rectPoints = null;
	        this.isSeriesMode = chart.selectionMode === 'Series';
	    };
	    /**
	     * Method to select the point and series.
	     *
	     * @returns {void}
	     */
	    Selection.prototype.invokeSelection = function (chart) {
	        this.initPrivateVariables(chart);
	        this.series = extend({}, chart.visibleSeries, null, true);
	        this.seriesStyles();
	        this.currentMode = chart.selectionMode;
	        if (!(chart.selectionMode.indexOf('Drag') > -1)) {
	            this.selectDataIndex(chart, this.concatIndexes(chart.selectedDataIndexes, this.selectedDataIndexes));
	        }
	    };
	    Selection.prototype.generateStyle = function (series) {
	        if (series) {
	            if (this.styleId.indexOf('selection') > 1 && this.chart.selectionMode !== 'None') {
	                this.unselected = series.unSelectedStyle || this.unselected;
	            }
	            if (this.styleId.indexOf('highlight') > 0 && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {
	                this.unselected = series.nonHighlightStyle || this.unselected;
	            }
	            return (series.selectionStyle || this.styleId + '_series_' + series.index);
	        }
	        return 'undefined';
	    };
	    /**
	     *  Method to get the selected data index
	     *
	     * @private
	     */
	    Selection.prototype.selectDataIndex = function (chart, indexes) {
	        for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {
	            var index = indexes_1[_i];
	            this.performSelection(index, chart, this.getElementByIndex(chart, index, '', this.series[index.series].marker.visible)[0]);
	        }
	    };
	    /**
	     *  Method to get the selected index element
	     *
	     * @private
	     */
	    Selection.prototype.getElementByIndex = function (chart, index, suffix, marker) {
	        if (suffix === void 0) { suffix = ''; }
	        var elementId = chart.element.id + '_Series_' + index.series + '_Point' + '_' + index.point;
	        var series = chart.series[index.series];
	        elementId = (series.type !== 'Scatter' && series.type !== 'Bubble' && marker) ? (elementId + '_Symbol' + suffix) : elementId;
	        return [getElement(elementId), ((series.type === 'RangeArea' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea') && series.marker.visible) ?
	                getElement(elementId + '1') : null];
	    };
	    /**
	     *  Method to get the selected cluster element
	     *
	     * @private
	     */
	    Selection.prototype.getClusterElements = function (chart, index) {
	        var clusters = [];
	        var seriesStyle;
	        var selectedElements;
	        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
	            var series = _a[_i];
	            if (series.visible) {
	                index = new Index(series.index, index.point);
	                if (series.isRectSeries) {
	                    clusters.push(this.getElementByIndex(chart, index)[0]);
	                }
	                clusters.push(this.getElementByIndex(chart, index, '', series.marker.visible)[0]);
	                seriesStyle = this.generateStyle(chart.visibleSeries[index.series]);
	                selectedElements = document.querySelectorAll('.' + seriesStyle);
	                this.findTrackballElements(selectedElements, seriesStyle);
	                var clusterIndex = series.marker.visible && series.isRectSeries ? 2 : 1;
	                if (!chart.isMultiSelect && selectedElements.length > 0 &&
	                    selectedElements[0].id !== clusters[clusters.length - clusterIndex].id) {
	                    this.removeSelection(chart, index.series, selectedElements, seriesStyle, true);
	                }
	            }
	        }
	        return clusters;
	    };
	    /**
	     *  Method to get trackball elements
	     *
	     * @private
	     */
	    Selection.prototype.findTrackballElements = function (selectedElements, className) {
	        var trackballElements;
	        var elements;
	        for (var i = 0; i < selectedElements.length; i++) {
	            if (!isNullOrUndefined(selectedElements[i])) {
	                trackballElements = !isNullOrUndefined(selectedElements[i].parentNode) ?
	                    [].slice.call(selectedElements[0].parentNode.querySelectorAll('.' + className)) : [];
	                if (trackballElements.length > 0) {
	                    elements = [];
	                    for (var i_1 = 0; i_1 < trackballElements.length; i_1++) {
	                        if (trackballElements[i_1].id.indexOf('Trackball') > -1) {
	                            elements.push(trackballElements[i_1]);
	                        }
	                    }
	                    this.removeStyles(elements);
	                }
	            }
	        }
	    };
	    /**
	     *  Method to get the selected element
	     *
	     * @private
	     */
	    Selection.prototype.findElements = function (chart, series, index, suffix, marker) {
	        if (suffix === void 0) { suffix = ''; }
	        if (this.isSeriesMode) {
	            return this.getSeriesElements(series);
	        }
	        else if (this.currentMode === 'Cluster') {
	            return this.getClusterElements(chart, index);
	        }
	        else {
	            return this.getElementByIndex(chart, index, suffix, marker);
	        }
	    };
	    /**
	     * To find the selected element.
	     *
	     * @returns {void}
	     * @private
	     */
	    Selection.prototype.isAlreadySelected = function (targetElem, eventType) {
	        if (eventType === 'click') {
	            this.currentMode = this.chart.selectionMode;
	            this.styleId = this.chart.element.id + '_ej2_chart_selection';
	        }
	        else if (eventType === 'mousemove' || eventType === 'pointermove') {
	            this.currentMode = this.chart.highlightMode;
	            this.highlightDataIndexes = [];
	            this.styleId = this.chart.element.id + '_ej2_chart_highlight';
	        }
	        if (this.chart.highlightMode !== 'None' && this.chart.selectionMode === 'None') {
	            if (eventType === 'click') {
	                return false;
	            }
	        }
	        if (((this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight) && this.previousSelectedEle && this.previousSelectedEle[0])) {
	            var parentNodeId = targetElem.parentNode.id;
	            var isElement = void 0;
	            if (targetElem.parentNode) {
	                isElement = (parentNodeId.indexOf('SeriesGroup') > 0 || parentNodeId.indexOf('SymbolGroup') > 0) ? true : false;
	            }
	            for (var i = 0; i < this.previousSelectedEle.length; i++) {
	                if (this.previousSelectedEle[i].hasAttribute('class')) {
	                    if (this.previousSelectedEle[i].getAttribute('class').indexOf('highlight') > -1 &&
	                        (isElement || eventType === 'click')) {
	                        this.previousSelectedEle[i].removeAttribute('class');
	                        if (this.chart.highlightColor !== '' && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightPattern === 'None') {
	                            if (this.previousSelectedEle[i].id.indexOf('Group') > 0) {
	                                for (var j = 0; j < this.previousSelectedEle[i].children.length; j++) {
	                                    this.previousSelectedEle[i].children[j].setAttribute('fill', this.control.visibleSeries[this.indexFinder(this.previousSelectedEle[i].id).series].interior);
	                                }
	                            }
	                            else {
	                                this.previousSelectedEle[i].setAttribute('fill', this.control.visibleSeries[this.indexFinder(this.previousSelectedEle[i].id).series].interior);
	                            }
	                        }
	                        this.addOrRemoveIndex(this.highlightDataIndexes, this.indexFinder(this.previousSelectedEle[i].id));
	                    }
	                    else if (!isElement && this.previousSelectedEle[i].getAttribute('class').indexOf('highlight') > -1) {
	                        this.performSelection(this.indexFinder(this.previousSelectedEle[i].id), this.chart, this.previousSelectedEle[i]);
	                    }
	                }
	            }
	        }
	        return true;
	    };
	    Selection.prototype.mouseClick = function (event) {
	        this.calculateSelectedElements(event.target, event.type);
	    };
	    /**
	     * To find the selected element.
	     *
	     * @returns {void}
	     * @private
	     */
	    Selection.prototype.calculateSelectedElements = function (targetElement, eventType) {
	        if (isNullOrUndefined(targetElement)) {
	            return;
	        }
	        if ((this.chart.selectionMode === 'None' && this.chart.highlightMode === 'None') ||
	            targetElement.id && targetElement.id.indexOf(this.chart.element.id + '_') === -1) {
	            return;
	        }
	        if (eventType === 'mousemove' || eventType === 'pointermove') {
	            if (targetElement.hasAttribute('class') && (targetElement.getAttribute('class').indexOf('highlight') > -1 ||
	                targetElement.getAttribute('class').indexOf('selection') > -1)) {
	                return;
	            }
	            if (!isNullOrUndefined(targetElement.parentNode) && targetElement.parentNode.hasAttribute('class') &&
	                (targetElement.parentNode.getAttribute('class').indexOf('highlight') > 0 ||
	                    targetElement.parentNode.getAttribute('class').indexOf('selection') > 0)) {
	                return;
	            }
	        }
	        this.isAlreadySelected(targetElement, eventType);
	        if (targetElement.id && targetElement.id.indexOf('_Series_') > -1 && targetElement.id.indexOf('_Text_') === -1) {
	            var element = void 0;
	            if (targetElement.id.indexOf('_Trackball_1') > -1) {
	                element = getElement(targetElement.id.split('_Trackball_')[0] + '_Symbol');
	                element = isNullOrUndefined(element) ? getElement(targetElement.id.split('_Trackball_')[0]) : element;
	            }
	            else if (targetElement.id.indexOf('_Trackball_0') > -1) {
	                return null;
	            }
	            this.performSelection(this.indexFinder(targetElement.id), this.chart, element || targetElement);
	        }
	    };
	    /**
	     *  Method to perform the selection
	     *
	     * @private
	     */
	    Selection.prototype.performSelection = function (index, chart, element) {
	        this.isSeriesMode = this.currentMode === 'Series';
	        if (chart.visibleSeries[index.series].type === 'BoxAndWhisker' && element &&
	            element.id === chart.element.id + '_Series_' + index.series + '_Point_' + index.point + '_BoxPath') {
	            element = element.parentNode;
	        }
	        if (chart.visibleSeries[index.series].type === 'Area' && (this.currentMode === 'Point' || this.currentMode === 'Cluster') && element &&
	            (element.id === this.chart.element.id + '_Series_' + index.series)) {
	            var className = this.generateStyle(chart.series[index.series]);
	            var selectionEle = document.querySelectorAll('.' + className);
	            this.findTrackballElements(selectionEle, className);
	            this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);
	        }
	        switch (this.currentMode) {
	            case 'Series':
	                this.selection(chart, index, this.getSeriesElements(chart.series[index.series]));
	                this.selectionComplete(chart, index, this.currentMode);
	                this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);
	                break;
	            case 'Point':
	                if (!isNaN(index.point) && element) {
	                    var pointElements = [];
	                    pointElements.push(element);
	                    if (pointElements[0] !== null && chart.series[index.series].marker.visible &&
	                        (chart.series[index.series].type.indexOf('Column') !== -1 || chart.series[index.series].type.indexOf('Bar') !== -1)) {
	                        if (!(element.id.indexOf('_Symbol') !== -1) && getElement(element.id + '_Symbol')) {
	                            pointElements.push(getElement(element.id + '_Symbol'));
	                        }
	                        else if (element.id.indexOf('_Symbol') !== -1 && getElement(element.id.replace('_Symbol', ''))) {
	                            pointElements.push(getElement(element.id.replace('_Symbol', '')));
	                        }
	                    }
	                    this.selection(chart, index, pointElements);
	                    this.selectionComplete(chart, index, this.currentMode);
	                    this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);
	                }
	                break;
	            case 'Cluster':
	                if (!isNaN(index.point)) {
	                    this.clusterSelection(chart, index);
	                    this.selectionComplete(chart, index, this.currentMode);
	                    this.blurEffect(chart.element.id, chart.visibleSeries, false, index.point);
	                }
	                break;
	        }
	    };
	    /**
	     *  Method to get the selected data index
	     *
	     * @private
	     */
	    Selection.prototype.selectionComplete = function (chart, index, selectionMode) {
	        var points;
	        var pointIndex;
	        var seriesIndex;
	        var selectedPointValues = [];
	        var yValue;
	        var selectedPointX;
	        if (selectionMode === 'Cluster') {
	            for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
	                var series = _a[_i];
	                if (series.visible) {
	                    for (var i = 0; i < this.selectedDataIndexes.length; i++) {
	                        pointIndex = chart.isMultiSelect ? this.selectedDataIndexes[i].point : index.point;
	                        seriesIndex = series.index;
	                        points = series.points;
	                        if (!isNaN(pointIndex)) {
	                            yValue = (series.type !== 'RangeArea' || 'SplineRangeArea' || 'RangeStepArea') ? points[pointIndex].yValue :
	                                points[pointIndex].regions[0].y;
	                            selectedPointX = points[pointIndex].xValue;
	                            if (chart.primaryXAxis.valueType === 'Category') {
	                                selectedPointX = points[pointIndex].x.toLocaleString();
	                            }
	                            else if (chart.primaryXAxis.valueType === 'DateTime') {
	                                selectedPointX = new Date(points[pointIndex].xValue);
	                            }
	                            if (series.category !== 'Indicator') {
	                                selectedPointValues.push({
	                                    x: selectedPointX, y: yValue, seriesIndex: seriesIndex,
	                                    pointIndex: pointIndex
	                                });
	                            }
	                            if (series.type === 'RangeArea' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea') {
	                                selectedPointValues.push({
	                                    x: selectedPointX, y: points[pointIndex].regions[0].y,
	                                    seriesIndex: seriesIndex, pointIndex: pointIndex
	                                });
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        else if (selectionMode === 'Series') {
	            if (chart.isMultiSelect) {
	                for (var i = 0; i < this.selectedDataIndexes.length; i++) {
	                    seriesIndex = this.selectedDataIndexes[i].series;
	                    if (this.selectedDataIndexes.length > 0) {
	                        selectedPointValues.push({
	                            seriesIndex: seriesIndex
	                        });
	                    }
	                }
	            }
	            else {
	                seriesIndex = (this.selectedDataIndexes.length > 0) ? this.selectedDataIndexes[0].series : (this.highlightDataIndexes && this.highlightDataIndexes.length > 0) ? this.highlightDataIndexes[0].series : 0;
	                if (this.selectedDataIndexes.length > 0 || (this.highlightDataIndexes && this.highlightDataIndexes.length > 0)) {
	                    selectedPointValues.push({
	                        seriesIndex: seriesIndex
	                    });
	                }
	            }
	        }
	        else if (selectionMode === 'Point') {
	            var selectedData = [];
	            if (this.styleId.indexOf('highlight') > -1) {
	                selectedData = this.highlightDataIndexes;
	            }
	            else {
	                selectedData = this.selectedDataIndexes;
	            }
	            for (var i = 0; i < selectedData.length; i++) {
	                pointIndex = selectedData[i].point;
	                seriesIndex = selectedData[i].series;
	                var series = chart.series[seriesIndex];
	                points = series.points;
	                if (!isNaN(pointIndex)) {
	                    selectedPointX = points[pointIndex].xValue;
	                    yValue = (series.type !== 'RangeArea' || 'SplineRangeArea' || 'RangeStepArea') ? points[pointIndex].yValue :
	                        points[pointIndex].regions[0].y;
	                    if (chart.primaryXAxis.valueType === 'Category') {
	                        selectedPointX = points[pointIndex].x.toLocaleString();
	                    }
	                    else if (chart.primaryXAxis.valueType === 'DateTime') {
	                        selectedPointX = new Date(points[pointIndex].xValue);
	                    }
	                    selectedPointValues.push({
	                        x: selectedPointX, y: yValue, seriesIndex: seriesIndex,
	                        pointIndex: pointIndex
	                    });
	                }
	            }
	        }
	        var args = {
	            name: selectionComplete,
	            selectedDataValues: selectedPointValues,
	            cancel: false,
	            chart: chart
	        };
	        chart.trigger(selectionComplete, args);
	    };
	    /**
	     *  Method to perform selection
	     *
	     * @private
	     */
	    Selection.prototype.selection = function (chart, index, selectedElements) {
	        if (!(this.currentMode === 'Lasso')) {
	            if (!chart.isMultiSelect && (this.currentMode.indexOf('Drag') === -1 && this.styleId.indexOf('highlight') === -1 &&
	                chart.selectionMode !== 'None')) {
	                this.removeMultiSelectElements(chart, this.selectedDataIndexes, index, chart.series);
	            }
	        }
	        var indexValue = (this.rangeColorMappingEnabled()) ? 0 : index.series;
	        if (!isNullOrUndefined(selectedElements[0])) {
	            if (chart.visibleSeries[indexValue].isRectSeries) {
	                if (selectedElements[0].id) {
	                    if (document.getElementById(selectedElements[0].id + '_Symbol')) {
	                        selectedElements.push(getElement(selectedElements[0].id + '_Symbol'));
	                    }
	                    else if (selectedElements[0].id.indexOf('SeriesGroup') !== -1) {
	                        if (document.getElementById(selectedElements[0].id.replace('SeriesGroup', 'SymbolGroup'))) {
	                            selectedElements.push(getElement(selectedElements[0].id.replace('SeriesGroup', 'SymbolGroup')));
	                        }
	                    }
	                }
	            }
	            var isAdd = void 0;
	            var className = selectedElements[0] && (selectedElements[0].getAttribute('class') || '');
	            var pClassName = selectedElements[0].parentNode &&
	                (selectedElements[0].parentNode.getAttribute('class') || '');
	            if (className !== '' && this.currentMode !== 'Cluster') {
	                this.findTrackballElements(selectedElements, className);
	            }
	            if (selectedElements[0] && className.indexOf(this.getSelectionClass(selectedElements[0].id)) > -1) {
	                this.removeStyles(selectedElements);
	            }
	            else if (selectedElements[0].parentNode && pClassName.indexOf(this.getSelectionClass(selectedElements[0].id)) > -1) {
	                this.removeStyles([selectedElements[0].parentNode]);
	            }
	            else {
	                this.previousSelectedEle = (chart.highlightMode !== 'None' || chart.legendSettings.enableHighlight) ? selectedElements : [];
	                this.applyStyles(selectedElements);
	                isAdd = true;
	            }
	            if (this.styleId.indexOf('highlight') > 0 && (chart.highlightMode !== 'None' || chart.legendSettings.enableHighlight)) {
	                this.addOrRemoveIndex(this.highlightDataIndexes, index, isAdd);
	            }
	            else {
	                this.addOrRemoveIndex(this.selectedDataIndexes, index, isAdd);
	            }
	        }
	    };
	    /**
	     *  Method to get the cluster selection element
	     *
	     * @private
	     */
	    Selection.prototype.clusterSelection = function (chart, index) {
	        this.selection(chart, index, this.getClusterElements(chart, new Index(index.series, index.point)));
	    };
	    /**
	     * Method to remove the multi selected elements
	     *
	     * @private
	     */
	    Selection.prototype.removeMultiSelectElements = function (chart, index, currentIndex, seriesCollection) {
	        var series;
	        for (var i = 0; i < index.length; i++) {
	            series = seriesCollection[index[i].series];
	            if ((this.isSeriesMode && !this.toEquals(index[i], currentIndex, this.isSeriesMode)) ||
	                (this.currentMode === 'Cluster' && !this.toEquals(index[i], currentIndex, false)) ||
	                (!this.isSeriesMode && this.toEquals(index[i], currentIndex, true) &&
	                    !this.toEquals(index[i], currentIndex, false))) {
	                this.removeStyles(this.findElements(chart, series, index[i], '', false));
	                if (series.marker.visible) {
	                    this.removeStyles(this.findElements(chart, series, index[i], '', true));
	                }
	                index.splice(i, 1);
	                i--;
	            }
	        }
	    };
	    /**
	     * Method to remove the selection
	     *
	     * @private
	     */
	    Selection.prototype.blurEffect = function (chartId, visibleSeries, isLegend, index) {
	        if (isLegend === void 0) { isLegend = false; }
	        if (index === void 0) { index = 0; }
	        var visibility = (this.checkVisibility(this.highlightDataIndexes, this.chart) ||
	            this.checkVisibility(this.selectedDataIndexes, this.chart)); // legend click scenario
	        for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
	            var series = visibleSeries_1[_i];
	            var legendIndex = void 0;
	            var legendStrokeColor = void 0;
	            if (this.rangeColorMappingEnabled()) {
	                if (isLegend === false) {
	                    legendIndex = Object.keys(series.rangeColorPoints).indexOf(series.points[index].interior);
	                    legendStrokeColor = series.points[index].interior;
	                }
	                else {
	                    legendIndex = index;
	                    legendStrokeColor = document.getElementById(chartId + '_chart_legend_shape_' + index).getAttribute('fill');
	                }
	            }
	            else {
	                legendIndex = series.index;
	                legendStrokeColor = this.chart.visibleSeries[series.index].interior;
	            }
	            if (series.visible) {
	                this.checkSelectionElements(getElement(chartId + 'SeriesGroup' + series.index), this.generateStyle(series), visibility, isLegend, legendIndex, legendStrokeColor);
	                if (!isNullOrUndefined(getElement(chartId + 'SymbolGroup' + series.index))) {
	                    this.checkSelectionElements(getElement(chartId + 'SymbolGroup' + series.index), this.generateStyle(series), visibility, isLegend, legendIndex, legendStrokeColor);
	                }
	            }
	        }
	    };
	    /**
	     * Method to add the add/remove class to element
	     *
	     * @private
	     */
	    Selection.prototype.checkSelectionElements = function (element, className, visibility, isLegend, series, legendStrokeColor) {
	        if (isLegend === void 0) { isLegend = true; }
	        if (series === void 0) { series = 0; }
	        if (legendStrokeColor === void 0) { legendStrokeColor = '#D3D3D3'; }
	        var children = (this.isSeriesMode ? element.childNodes || [element] : element.childNodes || element);
	        if (this.chart.selectionMode !== 'None' && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            children = (element.childNodes || element);
	        }
	        var elementClassName;
	        var parentClassName;
	        var legendShape;
	        var selectElement = element;
	        for (var i = 0; i < children.length; i++) {
	            elementClassName = children[i].getAttribute('class') || '';
	            parentClassName = children[i].parentNode.getAttribute('class') || '';
	            if (this.chart.selectionMode !== 'None' && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {
	                className = elementClassName.indexOf('selection') > 0 ||
	                    elementClassName.indexOf('highlight') > 0 ? elementClassName : className;
	                className = (parentClassName.indexOf('selection') > 0 ||
	                    parentClassName.indexOf('highlight') > 0) ? parentClassName : className;
	            }
	            if (elementClassName.indexOf(className) === -1 &&
	                parentClassName.indexOf(className) === -1 && visibility) {
	                this.addSvgClass(children[i], this.unselected);
	            }
	            else {
	                selectElement = children[i];
	                this.removeSvgClass(children[i], this.unselected);
	                this.removeSvgClass(children[i].parentNode, this.unselected);
	            }
	            if (children[i].id.indexOf('Trackball') > 0 && selectElement.classList[0] === className) {
	                this.removeSvgClass(children[i], this.unselected);
	                this.removeSvgClass(children[i].parentNode, this.unselected);
	                this.addSvgClass(children[i], className);
	            }
	        }
	        if (element.id.indexOf('Symbol') > -1) {
	            if ((element.querySelectorAll('.' + className)[0]) && element.querySelectorAll('.' + className)[0].getAttribute('class')
	                === className) {
	                var symbolEle = getElement(this.control.element.id + '_Series_' + element.id[element.id.length - 1]);
	                var seriesClassName = symbolEle && symbolEle.hasAttribute('class') ? symbolEle.getAttribute('class') : '';
	                if (seriesClassName.indexOf(this.unselected) > -1) {
	                    this.removeSvgClass(symbolEle, this.unselected);
	                }
	            }
	        }
	        if (this.control.legendModule && this.control.legendSettings.visible) {
	            legendShape = getElement(this.control.element.id + '_chart_legend_shape_' + series);
	            if (legendShape) {
	                if (legendShape.hasAttribute('class')) {
	                    this.removeSvgClass(legendShape, legendShape.getAttribute('class'));
	                    if (!isNullOrUndefined(this.chart.highlightColor && this.chart.highlightColor !== '') && !this.chart.legendSettings.enableHighlight) {
	                        legendShape.setAttribute('stroke', legendStrokeColor);
	                        if (this.chart.highlightPattern === 'None') {
	                            legendShape.setAttribute('fill', legendStrokeColor);
	                        }
	                    }
	                }
	                elementClassName = selectElement.getAttribute('class') || '';
	                parentClassName = selectElement.parentNode.getAttribute('class') || '';
	                if (elementClassName.indexOf(className) === -1 && parentClassName.indexOf(className) === -1 && visibility) {
	                    this.addSvgClass(legendShape, (this.chart.highlightMode === 'None' && this.chart.legendSettings.enableHighlight) ? className : this.unselected);
	                    this.removeSvgClass(legendShape, className);
	                    if (this.chart.highlightColor !== '' && !isNullOrUndefined(this.chart.highlightColor)) {
	                        legendShape.setAttribute('stroke', this.control.visibleSeries[series].interior);
	                        if (this.chart.highlightPattern === 'None') {
	                            legendShape.setAttribute('fill', this.control.visibleSeries[series].interior);
	                        }
	                    }
	                }
	                else {
	                    this.removeSvgClass(legendShape, this.unselected);
	                    if (!isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightColor !== '') {
	                        legendShape.setAttribute('stroke', this.control.visibleSeries[series].interior);
	                        if (this.chart.highlightPattern === 'None') {
	                            legendShape.setAttribute('fill', this.control.visibleSeries[series].interior);
	                        }
	                    }
	                    if ((elementClassName === '' && parentClassName === '') || elementClassName.trim() === 'EJ2-Trackball') {
	                        this.removeSvgClass(legendShape, className);
	                    }
	                    else {
	                        this.addSvgClass(legendShape, className);
	                        if (className.indexOf('highlight') > 0 && this.chart.highlightColor !== '' && this.chart.highlightColor !== 'transparent' && !isNullOrUndefined(this.chart.highlightColor)) {
	                            legendShape.setAttribute('stroke', this.chart.highlightColor);
	                            if (this.styleId.indexOf('highlight') > 0 && this.chart.highlightPattern === 'None') {
	                                legendShape.setAttribute('fill', this.chart.highlightColor);
	                            }
	                        }
	                    }
	                }
	                var legendItemsId = void 0;
	                if (this.rangeColorMappingEnabled()) {
	                    for (var i = 0; i < this.chart.rangeColorSettings.length; i++) {
	                        legendItemsId = document.getElementById(this.chart.element.id + '_chart_legend_shape_' + i);
	                        if (legendShape !== legendItemsId) {
	                            this.addSvgClass(legendItemsId, this.unselected);
	                        }
	                        else if (isLegend === true) {
	                            this.addSvgClass(legendItemsId, className);
	                        }
	                        if (elementClassName.indexOf(className) === -1 && isLegend === false) {
	                            this.removeSvgClass(legendItemsId, this.unselected);
	                        }
	                    }
	                }
	                if (isLegend && parentClassName.indexOf(className) > -1) {
	                    this.addSvgClass(legendShape, className);
	                }
	            }
	        }
	    };
	    /**
	     *  Method to apply the styles
	     *
	     * @private
	     */
	    Selection.prototype.applyStyles = function (elements) {
	        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
	            var element = elements_1[_i];
	            if (element) {
	                this.removeSvgClass(element.parentNode, this.unselected);
	                this.removeSvgClass(element, this.unselected);
	                if (this.chart.series[0].pointColorMapping === 'fill' || this.rangeColorMappingEnabled()) {
	                    var className = this.getSelectionClass(element.id);
	                    var index = className.indexOf('highlight') > -1 ? parseInt(className.split(this.chart.element.id + '_ej2_chart_highlight_series_')[1], 10) : parseInt(className.split(this.chart.element.id + '_ej2_chart_selection_series_')[1], 10);
	                    var patternName = this.styleId.indexOf('highlight') > 0 ? this.chart.highlightPattern : this.chart.selectionPattern;
	                    var pattern = void 0;
	                    if (className.indexOf('highlight') > -1 || className.indexOf('selection') > -1) {
	                        pattern = document.getElementById(this.chart.element.id + '_' + patternName + '_' + 'Selection' + '_' + index);
	                    }
	                    if (element.id.indexOf('legend') === -1 && element.id.indexOf('Group') === -1 && pattern != null) {
	                        for (var i = 1; i < pattern.children.length; i++) {
	                            pattern.children[i].setAttribute('fill', element.getAttribute('fill'));
	                            pattern.children[i].setAttribute('stroke', element.getAttribute('fill'));
	                        }
	                    }
	                }
	                this.addSvgClass(element, this.getSelectionClass(element.id));
	                if (this.styleId.indexOf('highlight') > 0 && this.chart.highlightColor !== '' && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightPattern === 'None' && this.chart.highlightColor !== 'transparent') {
	                    if (element.id.indexOf('Group') > 0) {
	                        for (var i = 0; i < element.children.length; i++) {
	                            element.children[i].setAttribute('fill', this.chart.highlightColor);
	                        }
	                    }
	                    else {
	                        element.setAttribute('fill', this.chart.highlightColor);
	                    }
	                }
	            }
	        }
	    };
	    /**
	     *  Method to get the selection class
	     *
	     * @private
	     */
	    Selection.prototype.getSelectionClass = function (id) {
	        return this.generateStyle(this.control.visibleSeries[this.indexFinder(id).series]);
	    };
	    /**
	     *  Method to remove styles
	     *
	     * @private
	     */
	    Selection.prototype.removeStyles = function (elements) {
	        for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
	            var element = elements_2[_i];
	            if (element) {
	                this.removeSvgClass(element, this.getSelectionClass(element.id));
	                if (this.chart.highlightPattern === 'None' && this.chart.highlightColor !== '' && !isNullOrUndefined(this.chart.highlightColor) && this.chart.highlightColor !== 'transparent') {
	                    if (element.id.indexOf('Group') > 0) {
	                        for (var i = 0; i < element.children.length; i++) {
	                            element.children[i].setAttribute('fill', this.control.visibleSeries[this.indexFinder(element.id).series].interior);
	                        }
	                    }
	                    else {
	                        element.setAttribute('fill', this.control.visibleSeries[this.indexFinder(element.id).series].interior);
	                    }
	                }
	            }
	        }
	    };
	    /**
	     *  Method to remove the selected data index
	     *
	     * @private
	     */
	    Selection.prototype.addOrRemoveIndex = function (indexes, index, isAdd) {
	        for (var i = 0; i < indexes.length; i++) {
	            if (this.toEquals(indexes[i], index, this.isSeriesMode)) {
	                indexes.splice(i, 1);
	                i--;
	            }
	        }
	        if (isAdd) {
	            indexes.push(index);
	        }
	    };
	    /**
	     *  Method to get the equal index
	     *
	     * @private
	     */
	    Selection.prototype.toEquals = function (first, second, checkSeriesOnly) {
	        return ((first.series === second.series || (this.currentMode === 'Cluster' && !checkSeriesOnly))
	            && (checkSeriesOnly || (first.point === second.point)));
	    };
	    /**
	     * To redraw the selected points.
	     *
	     * @returns {void}
	     * @private
	     */
	    Selection.prototype.redrawSelection = function (chart, oldMode, chartRedraw) {
	        this.isSeriesMode = oldMode === 'Series';
	        if (!isNullOrUndefined(oldMode)) {
	            if (oldMode.indexOf('Drag') !== -1 || oldMode === 'Lasso' || chartRedraw) {
	                chart.isRedrawSelection = false;
	            }
	            else {
	                chart.isRedrawSelection = true;
	            }
	        }
	        var selectedDataIndexes = extend([], this.selectedDataIndexes, null, true);
	        var highlightDataIndexes = extend([], this.highlightDataIndexes, null, true);
	        if (this.styleId.indexOf('highlight') > 0 && highlightDataIndexes.length > 0) {
	            this.removeSelectedElements(chart, this.highlightDataIndexes, chart.series);
	            selectedDataIndexes = highlightDataIndexes;
	        }
	        else {
	            this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);
	        }
	        this.blurEffect(chart.element.id, chart.visibleSeries, false);
	        this.selectDataIndex(chart, selectedDataIndexes);
	    };
	    /** @private */
	    Selection.prototype.legendSelection = function (chart, series, targetElement, eventType) {
	        if (eventType === 'mousemove') {
	            if (targetElement.id.indexOf('text') > 1) {
	                targetElement = getElement(targetElement.id.replace('text', 'shape'));
	            }
	            if (targetElement.id.indexOf('marker') > 1) {
	                targetElement = getElement(targetElement.id.replace('_marker', ''));
	            }
	            if (targetElement.id.indexOf('g') > 1) {
	                targetElement = getElement(targetElement.id.replace('_g_', '_shape_'));
	            }
	            if (targetElement.hasAttribute('class') && (targetElement.getAttribute('class').indexOf('highlight') > -1 ||
	                targetElement.getAttribute('class').indexOf('selection') > -1)) {
	                return;
	            }
	            this.currentMode = this.chart.highlightMode;
	        }
	        var isPreSelected = this.isAlreadySelected(targetElement, eventType);
	        if (isPreSelected) {
	            var seriesStyle = this.generateStyle(chart.visibleSeries[series]);
	            var selectedElements = (document.querySelectorAll('.' + seriesStyle));
	            this.isSeriesMode = this.currentMode === 'Series';
	            var isBlurEffectNeeded = true;
	            if (selectedElements.length > 0) {
	                this.removeSelection(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded);
	            }
	            else {
	                for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
	                    var element = _a[_i];
	                    if (element.index !== series && !chart.isMultiSelect) {
	                        seriesStyle = this.generateStyle(chart.visibleSeries[element.index]);
	                        selectedElements = document.querySelectorAll('.' + seriesStyle);
	                        this.removeSelection(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded);
	                    }
	                }
	                var seriesElements = [];
	                if (this.rangeColorMappingEnabled()) {
	                    // eslint-disable-next-line @typescript-eslint/tslint/config
	                    for (var i = 0, a = chart.visibleSeries[0].seriesElement.children; i < a.length; i++) {
	                        var point = a[i];
	                        if (targetElement.getAttribute('fill') === point.getAttribute('fill')) {
	                            seriesElements.push(point);
	                        }
	                    }
	                    for (var _b = 0, seriesElements_1 = seriesElements; _b < seriesElements_1.length; _b++) {
	                        var element = seriesElements_1[_b];
	                        if (isNullOrUndefined(element)) {
	                            return;
	                        }
	                        this.checkSelectionElements(element, seriesStyle, false, true, series);
	                    }
	                }
	                else {
	                    seriesElements = this.getSeriesElements(chart.visibleSeries[series]);
	                    for (var _c = 0, seriesElements_2 = seriesElements; _c < seriesElements_2.length; _c++) {
	                        var seriesElement = seriesElements_2[_c];
	                        if (isNullOrUndefined(seriesElement)) {
	                            return;
	                        }
	                        this.checkSelectionElements(seriesElement, seriesStyle, false, true, series);
	                    }
	                }
	                this.isSeriesMode = true;
	                this.selection(chart, new Index(series, NaN), seriesElements);
	                this.isSeriesMode = chart.selectionMode === 'Series';
	                this.blurEffect(chart.element.id, chart.visibleSeries, true, series);
	            }
	        }
	    };
	    /** @private */
	    Selection.prototype.rangeColorMappingEnabled = function () {
	        if ((this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0 && this.chart.visibleSeries.length === 1 &&
	            this.chart.rangeColorSettings[0].colors.length > 0 &&
	            (this.chart.series[0].type === 'Column' || this.chart.series[0].type === 'Bar' ||
	                this.chart.series[0].type === 'Scatter' || this.chart.series[0].type === 'Bubble'))) {
	            return true;
	        }
	        else {
	            return false;
	        }
	    };
	    Selection.prototype.removeSelection = function (chart, series, selectedElements, seriesStyle, isBlurEffectNeeded) {
	        if (selectedElements.length > 0) {
	            var elements = [];
	            for (var i = 0; i < selectedElements.length; i++) {
	                elements.push(selectedElements[i]);
	            }
	            this.removeStyles(elements);
	            this.isSeriesMode = true;
	            this.addOrRemoveIndex(this.selectedDataIndexes, new Index(series, NaN));
	            for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
	                var value = _a[_i];
	                seriesStyle = this.generateStyle(value);
	                if (document.querySelectorAll('.' + seriesStyle).length > 0) {
	                    for (var _b = 0, elements_3 = elements; _b < elements_3.length; _b++) {
	                        var element = elements_3[_b];
	                        this.checkSelectionElements(element, seriesStyle, true, true, series);
	                    }
	                    isBlurEffectNeeded = false;
	                    break;
	                }
	            }
	            if (isBlurEffectNeeded) {
	                this.isSeriesMode = chart.selectionMode === 'Series';
	                this.blurEffect(chart.element.id, chart.visibleSeries);
	            }
	        }
	    };
	    /** @private */
	    Selection.prototype.getSeriesElements = function (series) {
	        var seriesElements = [series.seriesElement];
	        if (series.marker.visible && series.type !== 'Scatter' && series.type !== 'Bubble' && !series.isRectSeries) {
	            seriesElements.push(series.symbolElement);
	        }
	        else if (series.marker.visible && series.isRectSeries) {
	            seriesElements.push(series.symbolElement);
	        }
	        return seriesElements;
	    };
	    /** @private */
	    Selection.prototype.indexFinder = function (id) {
	        var ids = ['NaN', 'NaN'];
	        if (id.indexOf('SeriesGroup') > -1) {
	            ids = id.split('SeriesGroup');
	            ids[0] = ids[1];
	        }
	        else if (id.indexOf('SymbolGroup') > -1) {
	            ids = id.split('SymbolGroup');
	            ids[0] = ids[1];
	        }
	        else if (id.indexOf('_Point_') > -1) {
	            ids = id.split('_Series_')[1].split('_Point_');
	        }
	        else if (id.indexOf('_border_') > -1) {
	            ids[0] = id.split('_border_')[1];
	        }
	        else if (id.indexOf('_Series_') > -1) {
	            ids[0] = id.split('_Series_')[1];
	        }
	        else if (id.indexOf('_chart_legend_shape_') > -1) {
	            ids = id.split('_chart_legend_shape_');
	            ids[0] = ids[1];
	        }
	        return new Index(parseInt(ids[0], 10), parseInt(ids[1], 10));
	    };
	    /**
	     * Drag selection that returns the selected data.
	     *
	     * @returns {void}
	     * @private
	     */
	    Selection.prototype.calculateDragSelectedElements = function (chart, dragRect, isClose) {
	        this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);
	        var isLasso = chart.selectionMode === 'Lasso';
	        var rect = new Rect(dragRect.x, dragRect.y, dragRect.width, dragRect.height);
	        var axisOffset = new ChartLocation(chart.chartAxisLayoutPanel.seriesClipRect.x, chart.chartAxisLayoutPanel.seriesClipRect.y);
	        this.removeOffset(rect, axisOffset);
	        var points;
	        var index;
	        var selectedPointValues = [];
	        var selectedSeriesValues = [];
	        this.isSeriesMode = false;
	        var isDragResize = (chart.allowMultiSelection) && (this.rectGrabbing || this.resizing);
	        this.rectPoints = this.dragRectArray[isDragResize ? this.targetIndex : this.count] =
	            new Rect(dragRect.x, dragRect.y, dragRect.width, dragRect.height);
	        if (dragRect.width && dragRect.height && !isClose) {
	            var rt = new Rect(dragRect.x, dragRect.y, dragRect.width, dragRect.height);
	            this.removeOffset(rt, axisOffset);
	            this.filterArray[isDragResize ? this.targetIndex : this.count] = rt;
	        }
	        var _loop_1 = function (series) {
	            if (series.visible) {
	                points = series.points;
	                selectedPointValues = [];
	                var xAxisOffset_1;
	                var yAxisOffset_1;
	                if ((chart.isTransposed || series.type.indexOf('Bar') !== -1) &&
	                    !(chart.isTransposed && series.type.indexOf('Bar') !== -1)) {
	                    xAxisOffset_1 = series.xAxis.rect.y - axisOffset.y;
	                    yAxisOffset_1 = series.yAxis.rect.x - axisOffset.x;
	                }
	                else {
	                    xAxisOffset_1 = series.xAxis.rect.x - axisOffset.x;
	                    yAxisOffset_1 = series.yAxis.rect.y - axisOffset.y;
	                }
	                for (var j = 0; j < points.length; j++) {
	                    var yValue = (series.type !== 'RangeArea' || 'SplineRangeArea' || 'RangeStepArea') ? points[j].yValue :
	                        points[j].regions[0].y;
	                    var isCurrentPoint = void 0;
	                    var selectedPointX = points[j].xValue;
	                    if (chart.primaryXAxis.valueType === 'Category') {
	                        selectedPointX = points[j].x.toLocaleString();
	                    }
	                    else if (chart.primaryXAxis.valueType === 'DateTime') {
	                        selectedPointX = new Date(points[j].xValue);
	                    }
	                    if (series.type === 'BoxAndWhisker') {
	                        isCurrentPoint = points[j].regions.some(function (region) {
	                            return withInBounds(region.x + xAxisOffset_1, region.y + yAxisOffset_1, rect);
	                        });
	                    }
	                    else {
	                        if (chart.selectionMode === 'Lasso') {
	                            isCurrentPoint = points[j].isSelect;
	                        }
	                        else {
	                            isCurrentPoint = (chart.allowMultiSelection) ?
	                                this_1.isPointSelect(points[j], xAxisOffset_1, yAxisOffset_1, this_1.filterArray) :
	                                points[j].symbolLocations.some(function (location) {
	                                    return location && withInBounds(location.x + xAxisOffset_1, location.y + yAxisOffset_1, rect);
	                                });
	                        }
	                    }
	                    if (isCurrentPoint && series.category !== 'Indicator') {
	                        index = new Index(series.index, points[j].index);
	                        this_1.selection(chart, index, this_1.findElements(chart, series, index, '', !series.isRectSeries ? series.marker.visible : false));
	                        selectedPointValues.push({ x: selectedPointX, y: yValue });
	                    }
	                    if (isCurrentPoint && (series.type === 'RangeArea' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea')) {
	                        selectedPointValues.push({ x: selectedPointX, y: points[j].regions[0].y });
	                    }
	                }
	                selectedSeriesValues.push(selectedPointValues);
	            }
	        };
	        var this_1 = this;
	        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
	            var series = _a[_i];
	            _loop_1(series);
	        }
	        this.blurEffect(chart.element.id, chart.visibleSeries);
	        var x = isLasso ? chart.mouseDownX : (dragRect.x + dragRect.width);
	        var y = isLasso ? chart.mouseDownY : dragRect.y;
	        if (!isClose) {
	            this.createCloseButton(x, y);
	        }
	        var args = {
	            name: dragComplete,
	            selectedDataValues: selectedSeriesValues,
	            cancel: false
	        };
	        chart.trigger(dragComplete, args);
	    };
	    Selection.prototype.removeOffset = function (rect, clip) {
	        rect.x -= clip.x;
	        rect.y -= clip.y;
	    };
	    Selection.prototype.isPointSelect = function (points, xAxisOffset, yAxisOffset, rectCollection) {
	        var location = points.symbolLocations[0];
	        for (var _i = 0, rectCollection_1 = rectCollection; _i < rectCollection_1.length; _i++) {
	            var rect = rectCollection_1[_i];
	            if (rect && location && withInBounds(location.x + xAxisOffset, location.y + yAxisOffset, rect)) {
	                return true;
	            }
	        }
	        return false;
	    };
	    /**
	     * Method to draw dragging rect.
	     *
	     * @returns {void}
	     * @private
	     */
	    Selection.prototype.drawDraggingRect = function (chart, dragRect) {
	        var cartesianLayout = chart.chartAxisLayoutPanel.seriesClipRect;
	        var border = chart.chartArea.border.width;
	        var rectFill = chart.themeStyle.selectionRectFill;
	        var rectStroke = chart.themeStyle.selectionRectStroke;
	        var isLasso = chart.selectionMode === 'Lasso';
	        if (this.isdrawRect) {
	            cartesianLayout.x = cartesianLayout.x - border / 2;
	            cartesianLayout.y = cartesianLayout.y - border / 2;
	            cartesianLayout.width = cartesianLayout.width + border;
	            cartesianLayout.height = cartesianLayout.height + border;
	            this.isdrawRect = false;
	        }
	        switch (chart.selectionMode) {
	            case 'DragX':
	                dragRect.y = cartesianLayout.y;
	                dragRect.height = cartesianLayout.height;
	                break;
	            case 'DragY':
	                dragRect.x = cartesianLayout.x;
	                dragRect.width = cartesianLayout.width;
	                break;
	        }
	        if ((dragRect.width < 5 || dragRect.height < 5) && !isLasso) {
	            return null;
	        }
	        var isDragMode = chart.selectionMode.indexOf('Drag') > -1 || chart.selectionMode === 'Lasso';
	        if ((chart.allowMultiSelection) && isDragMode) {
	            var element = void 0;
	            var dragGroup = void 0;
	            var multiGroup = getElement(this.multiRectGroup);
	            if (!multiGroup) {
	                multiGroup = chart.svgRenderer.createGroup({ id: this.multiRectGroup });
	                chart.svgObject.appendChild(multiGroup);
	            }
	            if (this.rectGrabbing || this.resizing) {
	                var rectElement = getElement(this.draggedRect + this.targetIndex);
	                if (rectElement.nextSibling) {
	                    remove(rectElement.nextSibling);
	                }
	                this.setAttributes(rectElement, dragRect);
	            }
	            else if (!getElement(this.draggedRectGroup + this.count)) {
	                dragGroup = chart.svgRenderer.createGroup({ id: this.draggedRectGroup + this.count });
	                var svgElement = document.getElementById(chart.element.id + '_series_svg');
	                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
	                chart.enableCanvas ? svgElement.appendChild(dragGroup) : multiGroup.appendChild(dragGroup);
	            }
	            if (!(chart.selectionMode === 'Lasso')) {
	                element = chart.svgRenderer.drawRectangle(new RectOption(this.draggedRect + this.count, rectFill, { color: rectStroke, width: 1 }, 1, dragRect));
	                element.style.cursor = 'move';
	            }
	            else {
	                element = chart.svgRenderer.drawPath(new PathOption(this.lassoPath + this.count, rectFill, 3, rectStroke, 1, '', this.path));
	            }
	            if (!dragGroup && !this.rectGrabbing && !this.resizing) {
	                getElement(this.draggedRectGroup + this.count).appendChild(element);
	            }
	            else if (!this.rectGrabbing && !this.resizing) {
	                dragGroup.appendChild(element);
	            }
	        }
	        else {
	            var element = isLasso ?
	                getElement(this.lassoPath) : getElement(this.draggedRect);
	            if (this.closeIcon) {
	                removeElement(this.closeIconId);
	            }
	            if (element) {
	                if (isLasso) {
	                    element.setAttribute('d', this.path);
	                }
	                else {
	                    this.setAttributes(element, dragRect);
	                }
	            }
	            else {
	                var dragGroup = chart.svgRenderer.createGroup({ id: this.draggedRectGroup });
	                var svgElement = document.getElementById(chart.element.id + '_series_svg');
	                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
	                chart.enableCanvas ? svgElement.appendChild(dragGroup) : chart.svgObject.appendChild(dragGroup);
	                if (!(chart.selectionMode === 'Lasso')) {
	                    element = chart.svgRenderer.drawRectangle(new RectOption(this.draggedRect, rectFill, { color: rectStroke, width: 1 }, 1, dragRect));
	                }
	                else {
	                    element = chart.svgRenderer.drawPath(new PathOption(this.lassoPath, rectFill, 3, rectStroke, 1, '', this.path));
	                }
	                //element.setAttribute('style', 'cursor:move;');
	                dragGroup.appendChild(element);
	            }
	        }
	    };
	    /**
	     * To get drag selected group element index from its id
	     *
	     * @param {string} id element id
	     */
	    Selection.prototype.getIndex = function (id) {
	        var i;
	        for (i = id.length - 1; i > 0; i--) {
	            var x = Number(id[i]);
	            if (!isNaN(x)) {
	                continue;
	            }
	            else {
	                break;
	            }
	        }
	        var index = +id.substr(i + 1, id.length - 1);
	        return index;
	    };
	    Selection.prototype.createCloseButton = function (x, y) {
	        var isMultiDrag = this.chart.allowMultiSelection;
	        var circleStroke = this.chart.themeStyle.selectionCircleStroke;
	        var isDrag = this.rectGrabbing || this.resizing;
	        var closeIcon = this.chart.svgRenderer.createGroup({
	            id: this.closeIconId + (isMultiDrag ? (isDrag ? this.targetIndex : this.count) : ''),
	            style: 'cursor:pointer; visibility: visible;'
	        });
	        closeIcon.appendChild(this.chart.svgRenderer.drawCircle(new CircleOption(this.closeIconId + '_circle' + (isMultiDrag ? (isDrag ? this.targetIndex : this.count) : ''), '#FFFFFF', { color: circleStroke, width: 1 }, 1, x, y, 10)));
	        var direction = 'M ' + (x - 4) + ' ' + (y - 4) + ' L ' + (x + 4) + ' ' + (y + 4) + ' M ' + (x - 4) + ' ' + (y + 4) +
	            ' L ' + (x + 4) + ' ' + (y - 4);
	        closeIcon.appendChild(this.chart.svgRenderer.drawPath({
	            id: this.closeIconId + '_cross' +
	                (isMultiDrag ? (isDrag ? this.targetIndex : this.count) : ''), d: direction,
	            stroke: circleStroke, 'stroke-width': 2, fill: circleStroke
	        }));
	        this.closeIcon = closeIcon;
	        var pathElement = getElement(this.draggedRectGroup + (isMultiDrag ? (isDrag ? this.targetIndex : this.count) : ''));
	        if (pathElement) {
	            pathElement.appendChild(closeIcon);
	        }
	    };
	    /**
	     * Method to remove dragged element.
	     *
	     * @returns {void}
	     * @private
	     */
	    Selection.prototype.removeDraggedElements = function (chart, targetElement, eventType) {
	        if ((targetElement.id && targetElement.id.indexOf(this.closeIconId) > -1) && (eventType.indexOf('move') === -1)) {
	            var isSelectedvalues = true;
	            if ((chart.allowMultiSelection)) {
	                var index = this.getIndex(targetElement.id);
	                var multiRectGroupElement = getElement(this.multiRectGroup);
	                remove(getElement(this.draggedRectGroup + index));
	                this.dragRectArray[index] = null;
	                this.filterArray[index] = null;
	                this.totalSelectedPoints[index] = null;
	                if (multiRectGroupElement && multiRectGroupElement.childElementCount === 0) {
	                    removeElement(multiRectGroupElement);
	                    this.dragRectArray = [];
	                    this.filterArray = [];
	                    this.totalSelectedPoints = [];
	                }
	                if (this.currentMode === 'Lasso') {
	                    if (this.multiDataIndexes[index] != null) {
	                        for (var i = 0; i < this.multiDataIndexes[index].length; i++) {
	                            this.multiDataIndexes[index][i].isSelect = false;
	                        }
	                    }
	                    this.multiDataIndexes[index] = null;
	                    for (var j = 0; j < this.multiDataIndexes.length; j++) {
	                        if (this.multiDataIndexes[j] != null) {
	                            isSelectedvalues = false;
	                            for (var k = 0; k < this.multiDataIndexes[j].length; k++) {
	                                this.multiDataIndexes[j][k].isSelect = true;
	                            }
	                        }
	                    }
	                    this.calculateDragSelectedElements(chart, this.dragRect, true);
	                }
	                else if (this.filterArray.length) {
	                    for (var i = 0; i < this.filterArray.length; i++) {
	                        if (this.filterArray[i]) {
	                            isSelectedvalues = false;
	                            this.calculateDragSelectedElements(chart, this.filterArray[i], true);
	                        }
	                    }
	                }
	                else {
	                    this.calculateDragSelectedElements(chart, new Rect(0, 0, 0, 0), true);
	                }
	            }
	            else {
	                remove(getElement(this.draggedRectGroup));
	                this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);
	            }
	            this.blurEffect(chart.element.id, chart.visibleSeries);
	            this.changeCursorStyle(false, chart.svgObject, 'auto');
	            if (!(chart.allowMultiSelection) || isSelectedvalues) {
	                this.rectPoints = null;
	            }
	        }
	    };
	    /**
	     * Method to resize the drag rect.
	     *
	     * @returns {void}
	     * @private
	     */
	    Selection.prototype.resizingSelectionRect = function (chart, location, tapped, target) {
	        var rect;
	        if (((chart.allowMultiSelection) && (target.id.indexOf('_ej2_drag_rect') > -1)) ||
	            this.dragRectArray[this.targetIndex]) {
	            if (target.id.indexOf('_ej2_drag_rect') > -1) {
	                this.targetIndex = this.getIndex(target.id);
	            }
	            var r = this.dragRectArray[this.targetIndex];
	            rect = new Rect(r.x, r.y, r.width, r.height);
	        }
	        if (!(chart.allowMultiSelection)) {
	            rect = new Rect(this.rectPoints.x, this.rectPoints.y, this.rectPoints.width, this.rectPoints.height);
	        }
	        if (rect) {
	            var resize = this.findResizeMode(chart.svgObject, rect, location);
	            if (this.resizing) {
	                rect = getDraggedRectLocation(rect.x, rect.y, (rect.x + rect.width), (rect.y + rect.height), chart.chartAxisLayoutPanel.seriesClipRect);
	                this.drawDraggingRect(chart, rect);
	                this.dragRect = rect;
	            }
	            if (tapped) {
	                this.resizing = resize;
	            }
	        }
	        else {
	            return;
	        }
	    };
	    Selection.prototype.findResizeMode = function (chartSvgObject, rect, location) {
	        var cursorStyle = 'se-resize';
	        var resize = false;
	        if (!this.resizing) {
	            var resizeEdges = [new Rect(rect.x, (rect.y), rect.width - 5, 5),
	                new Rect((rect.x), rect.y, 5, rect.height),
	                new Rect(rect.x, (rect.y + rect.height - 5), rect.width - 5, 5),
	                new Rect((rect.x + rect.width - 5), rect.y + 5, 5, rect.height - 15),
	                new Rect((rect.x + rect.width - 10), (rect.y + rect.height - 10), 10, 10)]; //corner
	            for (var i = 0; i < resizeEdges.length; i++) {
	                if (withInBounds(location.x, location.y, resizeEdges[i])) {
	                    cursorStyle = (i === 4) ? cursorStyle : (i % 2 === 0) ? 'ns-resize' : 'ew-resize';
	                    resize = true;
	                    this.resizeMode = i;
	                    break;
	                }
	            }
	        }
	        else {
	            var x = rect.x;
	            var y = rect.y;
	            var width = (location.x - x);
	            var height = (location.y - y);
	            switch (this.resizeMode) {
	                case 0:
	                    height = Math.abs((rect.height + rect.y) - location.y);
	                    rect.y = Math.min((rect.height + rect.y), location.y);
	                    rect.height = height;
	                    break;
	                case 1:
	                    width = Math.abs((rect.width + rect.x) - location.x);
	                    rect.x = Math.min((rect.width + rect.x), location.x);
	                    rect.width = width;
	                    break;
	                case 2:
	                    rect.height = Math.abs(height);
	                    rect.y = Math.min(location.y, y);
	                    break;
	                case 3:
	                    rect.width = Math.abs(width);
	                    rect.x = Math.min(location.x, x);
	                    break;
	                case 4:
	                    rect.width = Math.abs(width);
	                    rect.height = Math.abs(height);
	                    rect.x = Math.min(location.x, x);
	                    rect.y = Math.min(location.y, y);
	                    break;
	            }
	        }
	        if (this.currentMode !== 'Lasso') {
	            this.changeCursorStyle(resize, getElement((this.chart.allowMultiSelection) ? this.draggedRect +
	                this.targetIndex : this.draggedRect), cursorStyle);
	        }
	        this.changeCursorStyle(resize, chartSvgObject, cursorStyle);
	        return resize;
	    };
	    Selection.prototype.changeCursorStyle = function (isResize, rectelement, cursorStyle) {
	        cursorStyle = isResize ? cursorStyle : (this.control.svgObject === rectelement) ? 'auto' : 'move';
	        if (rectelement) {
	            rectelement.style.cursor = cursorStyle;
	        }
	    };
	    Selection.prototype.removeSelectedElements = function (chart, index, seriesCollection) {
	        index = chart.isRedrawSelection ? index : index.splice(0, index.length); // No need to remove selected indexes while redrawing
	        var seriesElements;
	        for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
	            var series = seriesCollection_1[_i];
	            if (series.visible) {
	                seriesElements = this.getSeriesElements(series);
	                this.removeStyles(seriesElements);
	                for (var _a = 0, seriesElements_3 = seriesElements; _a < seriesElements_3.length; _a++) {
	                    var seriesElement = seriesElements_3[_a];
	                    this.removeStyles(this.getChildren(seriesElement));
	                }
	            }
	        }
	    };
	    Selection.prototype.setAttributes = function (ele, object) {
	        var keys = Object.keys(object);
	        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
	            var key = keys_1[_i];
	            ele.setAttribute(key, object[key]);
	        }
	    };
	    /**
	     * Method to move the dragged rect.
	     *
	     * @returns {void}
	     * @private
	     */
	    Selection.prototype.draggedRectMoved = function (chart, grabbedPoint, doDrawing, target) {
	        var rect;
	        if ((this.resizing || this.rectGrabbing) && (chart.allowMultiSelection)) {
	            var r = this.dragRectArray[this.targetIndex];
	            rect = new Rect(r.x, r.y, r.width, r.height);
	        }
	        else {
	            rect = new Rect(this.rectPoints.x, this.rectPoints.y, this.rectPoints.width, this.rectPoints.height);
	        }
	        rect.x -= (grabbedPoint.x - chart.mouseX);
	        rect.y -= (grabbedPoint.y - chart.mouseY);
	        rect = getDraggedRectLocation(rect.x, rect.y, rect.x + rect.width, rect.height + rect.y, chart.chartAxisLayoutPanel.seriesClipRect);
	        if (doDrawing) {
	            this.drawDraggingRect(chart, rect);
	        }
	        else {
	            this.calculateDragSelectedElements(chart, rect);
	        }
	    };
	    Selection.prototype.mouseLeave = function (event) {
	        this.completeSelection(event.target, event.type);
	    };
	    /**
	     * To complete the selection.
	     *
	     * @returns {void}
	     * @private
	     */
	    Selection.prototype.completeSelection = function (target, eventType) {
	        var chart = this.chart;
	        if (chart.selectionMode === 'None') {
	            return;
	        }
	        this.currentMode = chart.selectionMode;
	        if ((this.dragging || this.resizing) && this.dragRect.width > 5 && this.dragRect.height > 5) {
	            this.calculateDragSelectedElements(chart, this.dragRect);
	        }
	        else if (!(chart.allowMultiSelection) && this.rectGrabbing &&
	            this.rectPoints.width && this.rectPoints.height) {
	            this.draggedRectMoved(chart, this.dragRect);
	        }
	        else if (this.rectGrabbing && this.dragRectArray[this.targetIndex].width && this.dragRectArray[this.targetIndex].height) {
	            this.draggedRectMoved(chart, this.dragRect);
	        }
	        if (chart.selectionMode === 'Lasso' && this.dragging && this.path) {
	            if (this.path.indexOf('L') !== -1) {
	                if (!(chart.allowMultiSelection)) {
	                    getElement(this.lassoPath).setAttribute('d', this.path + 'Z');
	                    this.pointChecking(getElement(this.lassoPath));
	                }
	                else if (getElement(this.lassoPath + this.count)) {
	                    getElement(this.lassoPath + this.count).setAttribute('d', this.path + 'Z');
	                    this.pointChecking(getElement(this.lassoPath + this.count));
	                }
	                if (this.dragging || this.resizing) {
	                    this.calculateDragSelectedElements(chart, this.dragRect);
	                }
	            }
	        }
	        this.dragging = false;
	        this.rectGrabbing = false;
	        this.resizing = false;
	        this.removeDraggedElements(chart, target, eventType);
	    };
	    Selection.prototype.getDragRect = function (chart, seriesClipRect) {
	        return getDraggedRectLocation(chart.mouseDownX, chart.mouseDownY, chart.mouseX, chart.mouseY, seriesClipRect);
	    };
	    /** @private */
	    Selection.prototype.dragStart = function (chart, seriesClipRect, mouseDownX, mouseDownY, event) {
	        var mode = chart.selectionMode;
	        this.currentMode = chart.selectionMode;
	        this.dragging = (mode.indexOf('Drag') > -1 || mode === 'Lasso') && (chart.isDoubleTap || !chart.isTouch) &&
	            chart.chartAreaType !== 'PolarRadar';
	        var target = event.target;
	        this.path = undefined;
	        if (this.dragging) {
	            this.count = getElement(this.multiRectGroup) ? (this.count + 1) : 0;
	            this.dragRect = new Rect(chart.mouseDownX, chart.mouseDownY, 0, 0);
	            if (chart.mouseDownX < seriesClipRect.x || chart.mouseDownX > (seriesClipRect.x + seriesClipRect.width) ||
	                chart.mouseDownY < seriesClipRect.y || chart.mouseDownY > (seriesClipRect.y + seriesClipRect.height)) {
	                this.dragging = false;
	            }
	        }
	        if (mode === 'Lasso') {
	            for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
	                var series = _a[_i];
	                if (series.visible) {
	                    for (var _b = 0, _c = series.points; _b < _c.length; _b++) {
	                        var point = _c[_b];
	                        if (!(chart.allowMultiSelection)) {
	                            point.isSelect = false;
	                        }
	                    }
	                }
	            }
	        }
	        if (!(mode === 'Lasso')) {
	            if (this.rectPoints && !(chart.allowMultiSelection)) {
	                this.dragRect = new Rect(chart.mouseDownX, chart.mouseDownY, 0, 0);
	                this.resizingSelectionRect(chart, new ChartLocation(mouseDownX, mouseDownY), true);
	                this.rectGrabbing = withInBounds(mouseDownX, mouseDownY, this.rectPoints);
	            }
	            if ((chart.allowMultiSelection)) {
	                var index = this.getIndex(target.id);
	                this.targetIndex = this.isDragRect(target.id) ? index : undefined;
	                if (this.dragRectArray.length && this.isDragRect(target.id)) {
	                    this.resizingSelectionRect(chart, new ChartLocation(mouseDownX, mouseDownY), true, target);
	                    this.rectGrabbing = withInBounds(mouseDownX, mouseDownY, this.dragRectArray[index]);
	                }
	            }
	        }
	    };
	    Selection.prototype.isDragRect = function (id) {
	        return id.indexOf('_ej2_drag_rect') > -1;
	    };
	    /** @private */
	    Selection.prototype.mouseMove = function (event) {
	        var chart = this.chart;
	        var target = event.target;
	        var eventType = event.type;
	        this.highlightChart(target, eventType);
	        if (chart.selectionMode === 'None') {
	            return;
	        }
	        if (eventType === 'touchmove' && (Browser.isIos || Browser.isIos7) && this.dragging && event.preventDefault) {
	            event.preventDefault();
	        }
	        this.selectionAndDrag(chart, target, eventType);
	    };
	    /**
	     * highlight parts
	     *
	     * @private
	     */
	    Selection.prototype.highlightChart = function (target, eventType) {
	        if (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight) {
	            if (!isNullOrUndefined(target)) {
	                if (target.id.indexOf('_legend_text') > 1) {
	                    target = getElement(target.id.replace('text', 'shape'));
	                }
	                if ((target).hasAttribute('class') && ((target).getAttribute('class').indexOf('highlight') > -1 ||
	                    target.getAttribute('class').indexOf('selection') > -1)) {
	                    return;
	                }
	                this.calculateSelectedElements(target, eventType);
	                if (this.chart.highlightModule.highlightDataIndexes && this.chart.highlightModule.highlightDataIndexes.length > 0 &&
	                    target.id.indexOf('_chart_legend_') === -1 && target.id.indexOf('_Series_') === -1) {
	                    this.removeLegendHighlightStyles();
	                }
	            }
	            return;
	        }
	    };
	    /**
	     * selection and drag selection
	     *
	     * @private
	     */
	    Selection.prototype.selectionAndDrag = function (chart, target, eventType) {
	        var insideMoving = withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect);
	        if (insideMoving) {
	            if (this.rectGrabbing && !this.resizing) {
	                this.draggedRectMoved(chart, this.dragRect, true, target);
	            }
	            else if (this.dragging && !this.resizing) {
	                if (chart.selectionMode === 'Lasso') {
	                    this.getPath(chart.mouseDownX, chart.mouseDownY, chart.mouseX, chart.mouseY);
	                    this.drawDraggingRect(chart, this.dragRect);
	                }
	                else {
	                    this.dragRect = this.getDragRect(chart, chart.chartAxisLayoutPanel.seriesClipRect);
	                    this.drawDraggingRect(chart, this.dragRect);
	                }
	            }
	            if (this.rectPoints && !(chart.allowMultiSelection)) {
	                this.resizingSelectionRect(chart, new ChartLocation(chart.mouseX, chart.mouseY), null, target);
	            }
	            else if (((chart.allowMultiSelection) && !this.dragging) || this.resizing) {
	                this.resizingSelectionRect(chart, new ChartLocation(chart.mouseX, chart.mouseY), null, target);
	            }
	        }
	        else {
	            this.completeSelection(target, eventType);
	        }
	    };
	    /**
	     * remove highlighted legend when not focused.
	     *
	     * @private
	     */
	    Selection.prototype.removeLegendHighlightStyles = function () {
	        this.chart.highlightModule.highlightDataIndexes = [];
	        var elementCollection;
	        for (var i = 0; i < this.chart.visibleSeries.length; i++) {
	            elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));
	            if (this.selectedDataIndexes.length === 0) {
	                elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));
	                while (elementCollection.length > 0) {
	                    var element = elementCollection[0];
	                    if (element) {
	                        this.removeSvgClass(element, element.getAttribute('class'));
	                    }
	                }
	                elementCollection = document.getElementsByClassName(this.unselected);
	                while (elementCollection.length > 0) {
	                    var element = elementCollection[0];
	                    if (element) {
	                        this.removeSvgClass(element, element.getAttribute('class'));
	                    }
	                }
	            }
	            else {
	                elementCollection = document.getElementsByClassName(this.generateStyle(this.chart.visibleSeries[i]));
	                while (elementCollection.length > 0) {
	                    var element = elementCollection[0];
	                    if (element) {
	                        this.removeSvgClass(element, element.getAttribute('class'));
	                        this.addSvgClass(element, this.unselected);
	                    }
	                }
	            }
	        }
	    };
	    Selection.prototype.getPath = function (startX, startY, endX, endY) {
	        if (this.dragging) {
	            if (this.path) {
	                this.path = this.path + ' L' + endX + ' ' + endY;
	            }
	            else {
	                this.path = 'M ' + startX + ' ' + startY;
	            }
	        }
	    };
	    Selection.prototype.pointChecking = function (path) {
	        var _this = this;
	        var chart = this.chart;
	        var element;
	        var svgRect = getElement(chart.svgId).getBoundingClientRect();
	        var offsetX = chart.chartAxisLayoutPanel.seriesClipRect.x + Math.max(svgRect.left, 0);
	        var offsetY = chart.chartAxisLayoutPanel.seriesClipRect.y + Math.max(svgRect.top, 0);
	        this.multiDataIndexes[this.count] = [];
	        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
	            var series = _a[_i];
	            series.points.filter(function (point) {
	                // To check whether the point have symbol location value or not.
	                if (point.symbolLocations && point.symbolLocations.length) {
	                    element = document.elementFromPoint(point.symbolLocations[0].x + offsetX, point.symbolLocations[0].y + offsetY);
	                }
	                if (element === path) {
	                    point.isSelect = true;
	                    if ((_this.chart.allowMultiSelection) && _this.currentMode === 'Lasso') {
	                        _this.multiDataIndexes[_this.count][_this.seriesIndex] = point;
	                        _this.seriesIndex++;
	                    }
	                }
	                else if (!(chart.allowMultiSelection)) {
	                    point.isSelect = false;
	                }
	            });
	        }
	        this.seriesIndex = 0;
	    };
	    /**
	     * Get module name.
	     *
	     * @private
	     */
	    Selection.prototype.getModuleName = function () {
	        return 'Selection';
	    };
	    /**
	     * To destroy the selection.
	     *
	     * @returns {void}
	     * @private
	     */
	    Selection.prototype.destroy = function () {
	        this.removeEventListener();
	        // Destroy method performed here
	    };
	    return Selection;
	}(BaseSelection));

	var __extends$1 = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `Highlight` module handles the selection for chart.
	 *
	 * @private
	 */
	var Highlight = /** @class */ (function (_super) {
	    __extends$1(Highlight, _super);
	    /**
	     * Constructor for selection module.
	     *
	     * @private
	     */
	    function Highlight(chart) {
	        var _this = _super.call(this, chart) || this;
	        _this.chart = chart;
	        _this.renderer = chart.renderer;
	        _this.wireEvents();
	        return _this;
	    }
	    /**
	     * Binding events for selection module.
	     */
	    Highlight.prototype.wireEvents = function () {
	        if (this.chart.isDestroyed || (this.chart.stockChart && this.chart.stockChart.onPanning)) {
	            return;
	        }
	        this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
	    };
	    /**
	     * UnBinding events for selection module.
	     */
	    Highlight.prototype.unWireEvents = function () {
	        if (this.chart.isDestroyed) {
	            return;
	        }
	        this.chart.off(Browser.touchMoveEvent, this.mouseMove);
	    };
	    /**
	     * To find private variable values
	     */
	    Highlight.prototype.declarePrivateVariables = function (chart) {
	        this.styleId = chart.element.id + '_ej2_chart_highlight';
	        this.unselected = chart.element.id + '_ej2_deselected';
	        this.selectedDataIndexes = [];
	        this.highlightDataIndexes = [];
	        this.isSeriesMode = chart.highlightMode === 'Series';
	    };
	    /**
	     * Method to select the point and series.
	     *
	     * @returns {void}
	     */
	    Highlight.prototype.invokeHighlight = function (chart) {
	        this.declarePrivateVariables(chart);
	        this.series = extend({}, chart.visibleSeries, null, true);
	        this.seriesStyles();
	        this.currentMode = chart.highlightMode;
	    };
	    /**
	     * Get module name.
	     *
	     * @private
	     */
	    Highlight.prototype.getModuleName = function () {
	        return 'Highlight';
	    };
	    /**
	     * To destroy the highlight.
	     *
	     * @returns {void}
	     * @private
	     */
	    Highlight.prototype.destroy = function () {
	        this.unWireEvents();
	        // Destroy method performed here
	    };
	    return Highlight;
	}(Selection));

	/* eslint-disable jsdoc/require-returns */
	/* eslint-disable valid-jsdoc */
	/* eslint-disable jsdoc/require-param */
	/**
	 * `DataLabel` module is used to render data label for the data point.
	 */
	var DataLabel = /** @class */ (function () {
	    /**
	     * Constructor for the data label module.
	     *
	     * @private
	     */
	    function DataLabel(chart) {
	        this.errorHeight = 0;
	        this.chart = chart;
	    }
	    DataLabel.prototype.initPrivateVariables = function (series, marker) {
	        var transform = '';
	        var clipPath = '';
	        var render = series.chart.renderer;
	        var index = (series.index === undefined) ? series.category : series.index;
	        if (series.chart.chartAreaType === 'Cartesian') {
	            transform = 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')';
	            clipPath = 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')';
	        }
	        if (marker.dataLabel.visible) {
	            series.shapeElement = render.createGroup({
	                'id': this.chart.element.id + 'ShapeGroup' + index,
	                'transform': transform,
	                'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'
	            });
	            series.textElement = render.createGroup({
	                'id': this.chart.element.id + 'TextGroup' + index,
	                'transform': transform,
	                'clip-path': clipPath
	            });
	            series.textElement.setAttribute('aria-hidden', 'true');
	        }
	        this.markerHeight = ((series.type === 'Scatter' || marker.visible)) ? (marker.height / 2) : 0;
	        this.commonId = this.chart.element.id + '_Series_' + index + '_Point_';
	        this.calculateErrorHeight(series, series.marker.dataLabel.position);
	        this.chartBackground = this.chart.chartArea.background === 'transparent' ?
	            this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;
	    };
	    DataLabel.prototype.calculateErrorHeight = function (series, position) {
	        if (!series.errorBar.visible) {
	            return null;
	        }
	        else if (series.errorBar.visible && this.chart.chartAreaType !== 'PolarRadar') {
	            var direction = series.errorBar.direction;
	            var positiveHeight = this.chart.errorBarModule.positiveHeight;
	            var negativeHeight = this.chart.errorBarModule.negativeHeight;
	            if (this.isRectSeries(series)) {
	                if (position === 'Top' || position === 'Auto') {
	                    if (direction === 'Both' || direction === 'Minus') {
	                        this.errorHeight = negativeHeight;
	                    }
	                    else {
	                        this.errorHeight = 0;
	                    }
	                }
	                if (position === 'Outer' || position === 'Auto') {
	                    if (direction === 'Both' || direction === 'Plus') {
	                        this.errorHeight = positiveHeight;
	                    }
	                    else {
	                        this.errorHeight = 0;
	                    }
	                }
	            }
	            else {
	                if (position === 'Top' || position === 'Outer' || position === 'Auto') {
	                    if ((direction === 'Both' || direction === 'Plus') && (!series.chart.isTransposed)) {
	                        this.errorHeight = positiveHeight;
	                    }
	                    else {
	                        this.errorHeight = 0;
	                    }
	                }
	                if (position === 'Bottom' || position === 'Auto') {
	                    if (direction === 'Both' || direction === 'Minus') {
	                        this.errorHeight = negativeHeight;
	                    }
	                    else {
	                        this.errorHeight = 0;
	                    }
	                }
	            }
	        }
	        else {
	            this.errorHeight = 0;
	        }
	    };
	    DataLabel.prototype.isRectSeries = function (series) {
	        return series.isRectSeries || series.type === 'RangeArea' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea';
	    };
	    /**
	     * Render the data label for series.
	     *
	     * @returns {void}
	     */
	    DataLabel.prototype.render = function (series, chart, dataLabel) {
	        // initialize the private variable
	        this.initPrivateVariables(series, series.marker);
	        var rect;
	        var labelLocation = { x: 0, y: 0 };
	        var rgbValue;
	        var contrast;
	        var argsData;
	        var border;
	        var textSize;
	        var angle;
	        var degree;
	        this.inverted = chart.requireInvertedAxis;
	        this.yAxisInversed = series.yAxis.isAxisInverse;
	        var redraw = chart.redraw;
	        var isDataLabelOverlap = false;
	        var coordinatesAfterRotation = [];
	        var templateId = chart.element.id + '_Series_' +
	            (series.index === undefined ? series.category : series.index) + '_DataLabelCollections';
	        var element = createElement('div', {
	            id: templateId
	        });
	        var visiblePoints = getVisiblePoints(series);
	        var point;
	        var rectCenterX;
	        var rectCenterY;
	        // Data label point iteration started
	        for (var i = 0; i < visiblePoints.length; i++) {
	            point = visiblePoints[i];
	            if (!dataLabel.showZero && ((point.y !== 0) || (point.y === 0 && series.emptyPointSettings.mode === 'Zero'))) {
	                return null;
	            }
	            this.margin = dataLabel.margin;
	            var labelText = [];
	            var labelLength = void 0;
	            var xPos = void 0;
	            var yPos = void 0;
	            var xValue = void 0;
	            var yValue = void 0;
	            var isRender = true;
	            var clip = series.clipRect;
	            var shapeRect = void 0;
	            isDataLabelOverlap = false;
	            dataLabel.angle = dataLabel.labelIntersectAction === 'Rotate90' ? 90 : dataLabel.angle;
	            dataLabel.enableRotation = dataLabel.labelIntersectAction === 'Rotate90' ? true : dataLabel.enableRotation;
	            angle = degree = dataLabel.angle;
	            border = { width: dataLabel.border.width, color: dataLabel.border.color };
	            var argsFont = (extend({}, getValue('properties', dataLabel.font), null, true));
	            if ((point.symbolLocations.length && point.symbolLocations[0]) ||
	                (series.type === 'BoxAndWhisker' && point.regions.length)) {
	                labelText = getLabelText(point, series, chart);
	                labelLength = labelText.length;
	                for (var i_1 = 0; i_1 < labelLength; i_1++) {
	                    argsData = {
	                        cancel: false, name: textRender, series: series,
	                        point: point, text: labelText[i_1], border: border,
	                        color: dataLabel.fill, template: dataLabel.template, font: argsFont, location: labelLocation,
	                        textSize: measureText(labelText[i_1], dataLabel.font, this.chart.themeStyle.datalabelFont)
	                    };
	                    chart.trigger(textRender, argsData);
	                    if (!argsData.cancel) {
	                        this.fontBackground = argsData.color;
	                        this.isDataLabelShape(argsData);
	                        this.markerHeight = series.type === 'Bubble' ? (point.regions[0].height / 2) : this.markerHeight;
	                        if (argsData.template !== null) {
	                            this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i_1, redraw);
	                        }
	                        else {
	                            textSize = measureText(argsData.text, dataLabel.font, this.chart.themeStyle.datalabelFont);
	                            rect = this.calculateTextPosition(point, series, textSize, dataLabel, i_1);
	                            // To check whether the polar radar chart datalabel intersects the axis label or not
	                            if (chart.chartAreaType === 'PolarRadar') {
	                                for (var _i = 0, _a = chart.chartAxisLayoutPanel.visibleAxisLabelRect; _i < _a.length; _i++) {
	                                    var rectRegion = _a[_i];
	                                    if (isOverlap(new Rect(rect.x, rect.y, rect.width, rect.height), rectRegion)) {
	                                        isRender = false;
	                                        break;
	                                    }
	                                }
	                            }
	                            var actualRect = new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height);
	                            //let notOverlapping: boolean;
	                            if (dataLabel.enableRotation) {
	                                var rectCoordinates = this.getRectanglePoints(rect);
	                                rectCenterX = rect.x + (rect.width / 2);
	                                rectCenterY = (rect.y + (rect.height / 2));
	                                coordinatesAfterRotation = getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle);
	                                isDataLabelOverlap = (dataLabel.labelIntersectAction === 'Rotate90' || angle == -90) ? false : this.isDataLabelOverlapWithChartBound(coordinatesAfterRotation, chart, clip);
	                                if (!isDataLabelOverlap) {
	                                    this.chart.rotatedDataLabelCollections.push(coordinatesAfterRotation);
	                                    var currentPointIndex = this.chart.rotatedDataLabelCollections.length - 1;
	                                    for (var index = currentPointIndex; index >= 0; index--) {
	                                        if (this.chart.rotatedDataLabelCollections[currentPointIndex] &&
	                                            this.chart.rotatedDataLabelCollections[index - 1] &&
	                                            isRotatedRectIntersect(this.chart.rotatedDataLabelCollections[currentPointIndex], this.chart.rotatedDataLabelCollections[index - 1])) {
	                                            isDataLabelOverlap = true;
	                                            this.chart.rotatedDataLabelCollections[currentPointIndex] = null;
	                                            break;
	                                        }
	                                    }
	                                }
	                            }
	                            else {
	                                isDataLabelOverlap = isCollide(rect, chart.dataLabelCollections, clip);
	                            }
	                            if ((!isDataLabelOverlap || dataLabel.labelIntersectAction === 'None') && isRender) {
	                                chart.dataLabelCollections.push(actualRect);
	                                if (this.isShape) {
	                                    shapeRect = chart.renderer.drawRectangle(new RectOption(this.commonId + point.index + '_TextShape_' + i_1, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry), new Int32Array([clip.x, clip.y]));
	                                    if (series.shapeElement) {
	                                        series.shapeElement.appendChild(shapeRect);
	                                    }
	                                }
	                                // Checking the font color
	                                var backgroundColor = this.fontBackground === 'transparent' ? ((this.chart.theme.indexOf('Dark') > -1 || this.chart.theme === 'HighContrast') ? 'black' : 'white') : this.fontBackground;
	                                rgbValue = convertHexToColor(colorNameToHex(backgroundColor));
	                                contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);
	                                xPos = (rect.x + this.margin.left + textSize.width / 2) + labelLocation.x;
	                                yPos = (rect.y + this.margin.top + textSize.height * 3 / 4) + labelLocation.y;
	                                labelLocation = { x: 0, y: 0 };
	                                if (angle !== 0 && dataLabel.enableRotation) {
	                                    // xValue = xPos - (dataLabel.margin.left) / 2 + (dataLabel.margin.right / 2);
	                                    xValue = rectCenterX;
	                                    //yValue = yPos - (dataLabel.margin.top) / 2 - (textSize.height / dataLabel.margin.top) +
	                                    // (dataLabel.margin.bottom) / 2;
	                                    yValue = rectCenterY;
	                                    degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;
	                                }
	                                else {
	                                    degree = 0;
	                                    xValue = rect.x;
	                                    yValue = rect.y;
	                                    xPos -= chart.chartAreaType == 'Cartesian' && xPos + (textSize.width / 2) > clip.width ? (xPos + textSize.width / 2) - clip.width : 0;
	                                    yPos -= (yPos + textSize.height > clip.y + clip.height && !(series.type.indexOf('Bar') > -1)) ? (yPos + textSize.height) - (clip.y + clip.height) : 0;
	                                }
	                                var textAnchor = dataLabel.labelIntersectAction === 'Rotate90' ? (dataLabel.position == 'Top' ? 'start' : (dataLabel.position == 'Middle' ? 'middle' : 'end')) :
	                                    ((angle == -90 && dataLabel.enableRotation) ? (dataLabel.position == 'Top' ? 'end' : (dataLabel.position == 'Middle' ? 'middle' : 'start')) : 'middle');
	                                textElement(chart.renderer, new TextOption(this.commonId + point.index + '_Text_' + i_1, xPos, yPos, textAnchor, argsData.text, 'rotate(' + degree + ',' + (xValue) + ',' + (yValue) + ')', 'auto', degree), argsData.font, argsData.font.color ||
	                                    ((contrast >= 128 || series.type === 'Hilo' || series.type === 'HiloOpenClose') ? 'black' : 'white'), series.textElement, false, redraw, true, false, series.chart.duration, series.clipRect, null, null, chart.enableCanvas, null, this.chart.themeStyle.datalabelFont);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        if (element.childElementCount) {
	            if (!chart.enableCanvas) {
	                appendChildElement(chart.enableCanvas, getElement(chart.element.id + '_Secondary_Element'), element, chart.redraw, 
	                // eslint-disable-next-line @typescript-eslint/indent
	                false, 'x', 'y', null, '', false, false, null, chart.duration);
	            }
	            else {
	                getElement(chart.element.id + '_Secondary_Element').appendChild(element);
	            }
	        }
	    };
	    /**
	     * Get rect coordinates
	     */
	    DataLabel.prototype.getRectanglePoints = function (rect) {
	        var loc1 = new ChartLocation(rect.x, rect.y);
	        var loc2 = new ChartLocation(rect.x + rect.width, rect.y);
	        var loc3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);
	        var loc4 = new ChartLocation(rect.x, rect.y + rect.height);
	        return [loc1, loc2, loc3, loc4];
	    };
	    DataLabel.prototype.isDataLabelOverlapWithChartBound = function (rectCoordinates, chart, clip) {
	        for (var index = 0; index < rectCoordinates.length; index++) {
	            if (!withInBounds(rectCoordinates[index].x + clip.x, rectCoordinates[index].y + clip.y, chart.initialClipRect)) {
	                return true;
	            }
	        }
	        return false;
	    };
	    /**
	     * Render the data label template.
	     *
	     * @returns {void}
	     * @private
	     */
	    DataLabel.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw) {
	        this.margin = { left: 0, right: 0, bottom: 0, top: 0 };
	        var clip = series.clipRect;
	        var childElement = createTemplate(createElement('div', {
	            id: this.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabel_'
	                + point.index + (labelIndex ? ('_' + labelIndex) : ''),
	            styles: 'position: absolute;background-color:' + data.color + ';' +
	                getFontStyle(dataLabel.font) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'
	        }), point.index, data.template, this.chart, point, series, this.chart.element.id + '_DataLabel', labelIndex);
	        this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw);
	    };
	    DataLabel.prototype.calculateTemplateLabelSize = function (parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw, isReactCallback) {
	        var elementRect = measureElementRect(childElement, redraw, isReactCallback);
	        var rect = this.calculateTextPosition(point, series, { width: elementRect.width, height: elementRect.height }, dataLabel, labelIndex);
	        var clipWidth = 0;
	        var clipHeight = 0;
	        var isOverlap = false;
	        if (isReactCallback) {
	            isOverlap = (elementRect.width === 0 || elementRect.height === 0); // To check the data label already overlap before react callback call
	            // clipWidth = ((series.clipRect.x + rect.x) + elementRect.width) > parentElement.clientWidth ?
	            //     (parentElement.clientWidth - (series.clipRect.x + rect.x)) : 0;
	            // clipHeight = (series.points.length - 1 === point.index) ? elementRect.height / 2 : 0;
	        }
	        childElement.style.left = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.x) + rect.x - clipWidth) + 'px';
	        childElement.style.top = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.y) + rect.y + clipHeight) + 'px';
	        var backgroundColor = this.fontBackground === 'transparent' ? (this.chart.theme.indexOf('Dark') > -1 ? 'black' : 'white') : this.fontBackground;
	        var rgbValue = convertHexToColor(colorNameToHex(backgroundColor));
	        var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;
	        var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;
	        childElement.style.color = dataLabel.font.color ||
	            ((Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000)) >= 128 ? 'black' : 'white');
	        if (childElement.childElementCount && !isOverlap && (!isCollide(rect, this.chart.dataLabelCollections, clip) ||
	            dataLabel.labelIntersectAction === 'None') && (series.seriesType !== 'XY' || point.yValue === undefined ||
	            withIn(point.yValue, series.yAxis.visibleRange) || (series.type.indexOf('Stacking') > -1) ||
	            (series.type.indexOf('100') > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange))) &&
	            withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y &&
	            parseFloat(childElement.style.left) >= hAxis.rect.x &&
	            parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height &&
	            parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {
	            this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));
	            appendChildElement(this.chart.enableCanvas, parentElement, childElement, redraw, true, 'left', 'top');
	            if (series.animation.enable && this.chart.animateSeries && !this.chart.enableCanvas) {
	                this.doDataLabelAnimation(series, childElement);
	            }
	            else if (this.chart.enableCanvas) {
	                parentElement.appendChild(childElement);
	            }
	        }
	    };
	    DataLabel.prototype.calculateTextPosition = function (point, series, textSize, dataLabel, labelIndex) {
	        var labelRegion = labelIndex > 1 ? (series.type === 'Candle') ? point.regions[1] : point.regions[0] : point.regions[0];
	        if (labelIndex > 1 && series.type === 'HiloOpenClose') {
	            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];
	        }
	        var location;
	        location = this.getLabelLocation(point, series, textSize, labelIndex);
	        var padding = 5;
	        var clipRect = series.clipRect;
	        // calculating alignment
	        if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === 'BoxAndWhisker') {
	            this.locationX = location.x;
	            var alignmentValue = textSize.height + (this.borderWidth * 2) + this.markerHeight +
	                this.margin.bottom + this.margin.top + padding;
	            location.x = (dataLabel.position === 'Auto') ? location.x :
	                this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false);
	            // calculating position
	            location.y = (!this.isRectSeries(series) || series.type === 'BoxAndWhisker') ?
	                this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) :
	                this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);
	            if (this.isRectSeries(series) && this.chart.chartAreaType === 'PolarRadar') {
	                location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex, dataLabel.alignment, alignmentValue);
	            }
	        }
	        else {
	            this.locationY = location.y;
	            var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;
	            location.x = dataLabel.position === 'Auto' ? location.x :
	                this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);
	            location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);
	        }
	        var rect = calculateRect(location, textSize, this.margin);
	        // Checking the condition whether data Label has been exist the clip rect
	        if (!(dataLabel.enableRotation === true && dataLabel.angle !== 0) &&
	            !((rect.y > (clipRect.y + clipRect.height)) || (rect.x > (clipRect.x + clipRect.width)) ||
	                (rect.x + rect.width < 0) || (rect.y + rect.height < 0))) {
	            rect.x = rect.x < 0 ? padding : rect.x;
	            rect.y = (rect.y < 0) && !(dataLabel.labelIntersectAction === 'None') ? padding : rect.y;
	            rect.x -= (rect.x + rect.width) > (clipRect.x + clipRect.width) ? (rect.x + rect.width)
	                - (clipRect.x + clipRect.width) + padding : 0;
	            rect.y -= (rect.y + rect.height) > (clipRect.y + clipRect.height) ? (rect.y + rect.height)
	                - (clipRect.y + clipRect.height) + padding : 0;
	            this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;
	        }
	        var dataLabelOutRegion;
	        if (this.inverted && series.isRectSeries && (rect.x + rect.width > labelRegion.x + labelRegion.width)) {
	            dataLabelOutRegion = true;
	        }
	        this.fontBackground = dataLabelOutRegion ? this.chartBackground : this.fontBackground;
	        return rect;
	    };
	    // Calculation label location for polar column draw types
	    DataLabel.prototype.calculatePolarRectPosition = function (location, position, series, point, size, labelIndex, alignment, alignmentValue) {
	        var padding = 5;
	        var columnRadius;
	        var chartWidth = this.chart.availableSize.width;
	        var alignmentSign = (alignment === 'Center') ? 0 : (alignment === 'Far' ? 1 : -1);
	        var angle = (point.regionData.startAngle - 0.5 * Math.PI) + (point.regionData.endAngle - point.regionData.startAngle) / 2;
	        if (labelIndex === 0) {
	            columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius
	                : point.regionData.radius;
	        }
	        else {
	            columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius
	                : point.regionData.radius;
	        }
	        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;
	        if (series.drawType.indexOf('Stacking') > -1) {
	            position = position === 'Outer' ? 'Top' : position;
	        }
	        else if (series.drawType.indexOf('Range') > -1) {
	            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';
	        }
	        if (position === 'Outer') {
	            columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight :
	                columnRadius - 2 * padding - this.markerHeight;
	        }
	        else if (position === 'Middle') {
	            columnRadius = columnRadius / 2 + padding;
	            if (series.drawType === 'StackingColumn') {
	                columnRadius = point.regionData.innerRadius + ((point.regionData.radius - point.regionData.innerRadius) / 2)
	                    + padding - (size.height / 2);
	            }
	        }
	        else if (position === 'Top') {
	            columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight :
	                columnRadius + 2 * padding + this.markerHeight;
	        }
	        else if (position === 'Bottom') {
	            columnRadius = 2 * padding;
	            columnRadius += (series.drawType === 'StackingColumn') ? (point.regionData.innerRadius + this.markerHeight) : 0;
	        }
	        else {
	            if (labelIndex === 0) {
	                columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding :
	                    series.drawType === 'StackingColumn' ? columnRadius - 2 * padding : columnRadius + 2 * padding;
	            }
	            else {
	                columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;
	            }
	        }
	        columnRadius += (alignmentValue * alignmentSign);
	        location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle);
	        // To change x location based on text anchor for column and stackingcolumn chart
	        if (series.drawType === 'StackingColumn') {
	            location.x = location.x < chartWidth / 2 ? location.x + size.width / 2 :
	                (location.x > chartWidth / 2 ? location.x - size.width / 2 : location.x);
	        }
	        else if (series.drawType === 'Column') {
	            location.x = location.x < chartWidth / 2 ? location.x - size.width / 2 :
	                (location.x > chartWidth / 2 ? location.x + size.width / 2 : location.x);
	        }
	        location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);
	        return location;
	    };
	    /**
	     * Get the label location
	     */
	    DataLabel.prototype.getLabelLocation = function (point, series, textSize, labelIndex) {
	        var location = new ChartLocation(0, 0);
	        var labelRegion = (series.type === 'Candle' && labelIndex > 1) ? point.regions[1] : point.regions[0];
	        if (series.type === 'HiloOpenClose') {
	            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];
	        }
	        var xAxis = series.xAxis;
	        var yAxis = series.yAxis;
	        var isInverted = series.chart.requireInvertedAxis;
	        if (series.type === 'BoxAndWhisker') {
	            this.markerHeight = 0;
	            switch (labelIndex) {
	                case 0:
	                    location = getPoint(point.xValue, point.median, xAxis, yAxis, isInverted);
	                    break;
	                case 1:
	                    location = getPoint(point.xValue, point.maximum, xAxis, yAxis, isInverted);
	                    break;
	                case 2:
	                    location = getPoint(point.xValue, point.minimum, xAxis, yAxis, isInverted);
	                    break;
	                case 3:
	                    location = getPoint(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);
	                    break;
	                case 4:
	                    location = getPoint(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);
	                    break;
	                default: {
	                    location = getPoint(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);
	                    this.markerHeight = series.marker.height / 2;
	                    break;
	                }
	            }
	            if (isInverted) {
	                location.y = point.regions[0].y + (point.regions[0].height / 2);
	            }
	            else {
	                location.x = point.regions[0].x + (point.regions[0].width / 2);
	            }
	        }
	        else if (labelIndex === 0 || labelIndex === 1) {
	            location = new ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);
	        }
	        else if ((labelIndex === 2 || labelIndex === 3) && series.type === 'Candle') {
	            location = new ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);
	        }
	        else if (isInverted) {
	            location = { x: labelRegion.x + (labelRegion.width) / 2, y: labelRegion.y };
	        }
	        else {
	            location = { x: labelRegion.x + labelRegion.width, y: labelRegion.y + (labelRegion.height) / 2 };
	        }
	        //Aligning the label at the beginning of the tick, when tick size is less than text size
	        if (labelIndex > 1 && series.type === 'HiloOpenClose') {
	            if (series.chart.requireInvertedAxis) {
	                var height = labelRegion.height;
	                location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);
	            }
	            else {
	                var width = labelRegion.width;
	                location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);
	            }
	        }
	        return location;
	    };
	    DataLabel.prototype.calculateRectPosition = function (labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {
	        if (series.chart.chartAreaType === 'PolarRadar') {
	            return null;
	        }
	        var padding = 5;
	        var margin = this.margin;
	        var textLength = !this.inverted ? textSize.height : textSize.width;
	        var extraSpace = this.borderWidth + textLength / 2 + (position !== 'Outer' && series.type.indexOf('Column') > -1 &&
	            (Math.abs(rect.height - textSize.height) < padding) ? 0 : padding);
	        if (series.type === 'StackingColumn100' || series.type === 'StackingBar100') {
	            position = (position === 'Outer') ? 'Top' : position;
	        }
	        else if (series.type.indexOf('Range') > -1) {
	            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';
	        }
	        else if (series.type === 'Waterfall') {
	            position = position === 'Auto' ? 'Middle' : position;
	        }
	        switch (position) {
	            case 'Bottom':
	                labelLocation = !this.inverted ?
	                    isMinus ? (labelLocation - rect.height + extraSpace + margin.top) :
	                        (labelLocation + rect.height - extraSpace - margin.bottom) :
	                    isMinus ? (labelLocation + rect.width - extraSpace - margin.left) :
	                        (labelLocation - rect.width + extraSpace + margin.right);
	                break;
	            case 'Middle':
	                labelLocation = labelLocation = !this.inverted ?
	                    (isMinus ? labelLocation - (rect.height / 2) : labelLocation + (rect.height / 2)) :
	                    (isMinus ? labelLocation + (rect.width / 2) : labelLocation - (rect.width / 2));
	                break;
	            case 'Auto':
	                labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);
	                break;
	            default:
	                extraSpace += this.errorHeight;
	                labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, extraSpace, isMinus);
	                break;
	        }
	        var check = !this.inverted ? (labelLocation < rect.y || labelLocation > rect.y + rect.height) :
	            (labelLocation < rect.x || labelLocation > rect.x + rect.width);
	        this.fontBackground = check ?
	            (this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground)
	            : this.fontBackground === 'transparent' ? (point.color || series.interior) : this.fontBackground;
	        var seriesLength = series.chart.series.length;
	        if (position === 'Outer' && (series.type.indexOf('Stacking') > -1) && ((seriesLength - 1) > series.index)) {
	            var nextSeries = void 0;
	            var nextSeriesPoint = void 0;
	            for (var i = series.index + 1; i < seriesLength; i++) {
	                nextSeries = series.chart.series[i];
	                nextSeriesPoint = nextSeries.points[point.index];
	                if ((nextSeries.type.indexOf('Stacking') > -1) && (nextSeries.type.indexOf('100') === -1)) {
	                    this.fontBackground = (nextSeriesPoint && ((nextSeriesPoint.yValue < 0 && point.yValue < 0) ||
	                        (nextSeriesPoint.yValue > 0 && point.yValue > 0))) ? (nextSeriesPoint ? nextSeriesPoint.color :
	                        nextSeries.interior) : this.fontBackground;
	                    break;
	                }
	            }
	        }
	        return labelLocation;
	    };
	    DataLabel.prototype.calculatePathPosition = function (labelLocation, position, series, point, size, labelIndex) {
	        var padding = 5;
	        if ((series.type.indexOf('Area') > -1 && series.type !== 'RangeArea' && series.type !== 'SplineRangeArea' && series.type !== 'RangeStepArea')
	            && this.yAxisInversed && series.marker.dataLabel.position !== 'Auto') {
	            position = position === 'Top' ? 'Bottom' : position === 'Bottom' ? 'Top' : position;
	        }
	        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;
	        switch (position) {
	            case 'Top':
	            case 'Outer':
	                labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding -
	                    this.errorHeight;
	                break;
	            case 'Bottom':
	                labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding +
	                    this.errorHeight;
	                break;
	            case 'Auto':
	                labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);
	                break;
	        }
	        return labelLocation;
	    };
	    DataLabel.prototype.isDataLabelShape = function (style) {
	        this.isShape = (style.color !== 'transparent' || style.border.width > 0);
	        this.borderWidth = style.border.width;
	        if (!this.isShape) {
	            this.margin = { left: 0, right: 0, bottom: 0, top: 0 };
	        }
	    };
	    DataLabel.prototype.calculateRectActualPosition = function (labelLocation, rect, isMinus, series, size, labelIndex, point) {
	        var location;
	        var labelRect;
	        var isOverLap = true;
	        var position = 0;
	        var collection = this.chart.dataLabelCollections;
	        var finalPosition = series.type.indexOf('Range') !== -1 || series.type === 'Hilo' ? 2 : 4;
	        while (isOverLap && position < finalPosition) {
	            var actualPosition = this.getPosition(position);
	            if (series.type.indexOf('Stacking') > -1 && actualPosition === 'Outer') {
	                actualPosition = 'Top';
	                position++;
	            }
	            location = this.calculateRectPosition(labelLocation, rect, isMinus, actualPosition, series, size, labelIndex, point);
	            if (!this.inverted) {
	                labelRect = calculateRect(new ChartLocation(this.locationX, location), size, this.margin);
	                isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;
	            }
	            else {
	                labelRect = calculateRect(new ChartLocation(location, this.locationY), size, this.margin);
	                isOverLap = labelRect.x < 0 || isCollide(labelRect, collection, series.clipRect) ||
	                    labelRect.x + labelRect.width > series.clipRect.width;
	            }
	            position++;
	        }
	        return location;
	    };
	    // alignment calculation assigned here
	    DataLabel.prototype.calculateAlignment = function (value, labelLocation, alignment, isMinus) {
	        switch (alignment) {
	            case 'Far':
	                labelLocation = !this.inverted ? (isMinus ? labelLocation + value : labelLocation - value) :
	                    (isMinus ? labelLocation - value : labelLocation + value);
	                break;
	            case 'Near':
	                labelLocation = !this.inverted ? (isMinus ? labelLocation - value : labelLocation + value) :
	                    (isMinus ? labelLocation + value : labelLocation - value);
	                break;
	            // eslint-disable-next-line no-self-assign
	            case 'Center':
	                labelLocation = labelLocation;
	                break;
	        }
	        return labelLocation;
	    };
	    //calculation for top and outer position of datalabel for rect series
	    DataLabel.prototype.calculateTopAndOuterPosition = function (location, rect, position, series, index, extraSpace, isMinus) {
	        var margin = this.margin;
	        var top;
	        switch (series.type) {
	            case 'RangeColumn':
	            case 'RangeArea':
	            case 'RangeStepArea':
	            case 'SplineRangeArea':
	            case 'Hilo':
	                top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);
	                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);
	                break;
	            case 'Candle':
	                top = (index === 0 || index === 2) && !this.yAxisInversed
	                    || (index === 1 || index === 3) && this.yAxisInversed;
	                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);
	                break;
	            case 'HiloOpenClose':
	                if (index <= 1) {
	                    top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);
	                    location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);
	                }
	                else {
	                    if (this.yAxisInversed) {
	                        location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;
	                    }
	                    else {
	                        location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;
	                    }
	                }
	                break;
	            default:
	                if ((isMinus && position === 'Top') || (!isMinus && position === 'Outer')) {
	                    location = !this.inverted ? location - extraSpace - margin.bottom - this.markerHeight :
	                        location + extraSpace + margin.left + this.markerHeight;
	                }
	                else {
	                    location = !this.inverted ? location + extraSpace + margin.top + this.markerHeight :
	                        location - extraSpace - margin.right - this.markerHeight;
	                }
	                break;
	        }
	        return location;
	    };
	    /**
	     * Updates the label location
	     */
	    DataLabel.prototype.updateLabelLocation = function (position, location, extraSpace, margin, rect, top, inside) {
	        if (inside === void 0) { inside = false; }
	        if (!this.inverted) {
	            if (top) {
	                location = (position === 'Outer' && !inside) ? location - extraSpace - margin.bottom - this.markerHeight :
	                    location + extraSpace + margin.top + this.markerHeight;
	            }
	            else {
	                location = (position === 'Outer' && !inside) ? location + rect.height + extraSpace + margin.top + this.markerHeight :
	                    location + rect.height - extraSpace - margin.bottom - this.markerHeight;
	            }
	        }
	        else {
	            if (top) {
	                location = (position === 'Outer' && !inside) ? location + extraSpace + margin.left + this.markerHeight :
	                    location - extraSpace - margin.right - this.markerHeight;
	            }
	            else {
	                location = (position === 'Outer' && !inside) ? location - rect.width - extraSpace - margin.right - this.markerHeight :
	                    location - rect.width + extraSpace + margin.left + this.markerHeight;
	            }
	        }
	        return location;
	    };
	    DataLabel.prototype.calculatePathActualPosition = function (y, markerSize, series, point, size, labelIndex) {
	        var points = series.points;
	        var index = point.index;
	        var yValue = points[index].yValue;
	        var position;
	        var nextPoint = points.length - 1 > index ? points[index + 1] : null;
	        var previousPoint = index > 0 ? points[index - 1] : null;
	        var yLocation;
	        var isOverLap = true;
	        var labelRect;
	        var isBottom;
	        var positionIndex;
	        var collection = this.chart.dataLabelCollections;
	        if (series.type === 'Bubble') {
	            position = 'Top';
	        }
	        else if (series.type.indexOf('Step') > -1) {
	            position = 'Top';
	            if (index) {
	                position = (!previousPoint || !previousPoint.visible || (yValue > previousPoint.yValue !== this.yAxisInversed)
	                    || yValue === previousPoint.yValue) ? 'Top' : 'Bottom';
	            }
	        }
	        else if (series.type === 'BoxAndWhisker') {
	            if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {
	                position = series.yAxis.isAxisInverse ? 'Bottom' : 'Top';
	            }
	            else if (labelIndex === 2 || labelIndex === 4) {
	                position = series.yAxis.isAxisInverse ? 'Top' : 'Bottom';
	            }
	            else {
	                isOverLap = false;
	                position = 'Middle';
	                yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);
	            }
	        }
	        else {
	            if (index === 0) {
	                position = (!nextPoint || !nextPoint.visible || yValue > nextPoint.yValue ||
	                    (yValue < nextPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';
	            }
	            else if (index === points.length - 1) {
	                position = (!previousPoint || !previousPoint.visible || yValue > previousPoint.yValue ||
	                    (yValue < previousPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';
	            }
	            else {
	                if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {
	                    position = 'Top';
	                }
	                else if (!nextPoint.visible || !previousPoint) {
	                    position = (nextPoint.yValue > yValue || (previousPoint && previousPoint.yValue > yValue)) ?
	                        'Bottom' : 'Top';
	                }
	                else {
	                    var slope = (nextPoint.yValue - previousPoint.yValue) / 2;
	                    var intersectY = (slope * index) + (nextPoint.yValue - (slope * (index + 1)));
	                    position = !this.yAxisInversed ? intersectY < yValue ? 'Top' : 'Bottom' :
	                        intersectY < yValue ? 'Bottom' : 'Top';
	                }
	            }
	        }
	        isBottom = position === 'Bottom';
	        positionIndex = ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'].indexOf(position);
	        while (isOverLap && positionIndex < 4) {
	            yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);
	            labelRect = calculateRect(new ChartLocation(this.locationX, yLocation), size, this.margin);
	            isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect)
	                || (labelRect.y + labelRect.height) > series.clipRect.height;
	            positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;
	            isBottom = false;
	        }
	        return yLocation;
	    };
	    /**
	     * Animates the data label.
	     *
	     * @param  {Series} series - Data label of the series gets animated.
	     * @returns {void}
	     */
	    DataLabel.prototype.doDataLabelAnimation = function (series, element) {
	        var shapeElements = series.shapeElement.childNodes;
	        var textNode = series.textElement.childNodes;
	        var delay = series.animation.delay + series.animation.duration;
	        var duration = series.chart.animated ? series.chart.duration : 200;
	        var location;
	        var length = element ? 1 : textNode.length;
	        var tempElement;
	        for (var i = 0; i < length; i++) {
	            tempElement = textNode[i];
	            if (element) {
	                element.style.visibility = 'hidden';
	                templateAnimate(element, delay, duration, 'ZoomIn');
	            }
	            else {
	                location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));
	                markerAnimate(tempElement, delay, duration, series, null, location, true);
	                if (shapeElements[i]) {
	                    tempElement = shapeElements[i];
	                    location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));
	                    markerAnimate(tempElement, delay, duration, series, null, location, true);
	                }
	            }
	        }
	    };
	    DataLabel.prototype.getPosition = function (index) {
	        return (['Outer', 'Top', 'Bottom', 'Middle', 'Auto'][index]);
	    };
	    /**
	     * Get module name.
	     */
	    DataLabel.prototype.getModuleName = function () {
	        // Returns the module name
	        return 'DataLabel';
	    };
	    /**
	     * To destroy the dataLabel for series.
	     *
	     * @returns {void}
	     * @private
	     */
	    DataLabel.prototype.destroy = function () {
	        // Destroy method performed here
	    };
	    return DataLabel;
	}());

	var __extends = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * `Legend` module is used to render legend for the chart.
	 */
	var Legend = /** @class */ (function (_super) {
	    __extends(Legend, _super);
	    function Legend(chart) {
	        var _this = _super.call(this, chart) || this;
	        _this.library = _this;
	        _this.addEventListener();
	        return _this;
	    }
	    /**
	     * Binding events for legend module.
	     */
	    Legend.prototype.addEventListener = function () {
	        if (this.chart.isDestroyed) {
	            return;
	        }
	        this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);
	        this.chart.on('click', this.click, this);
	        this.chart.on(Browser.touchEndEvent, this.mouseEnd, this);
	    };
	    /**
	     * UnBinding events for legend module.
	     */
	    Legend.prototype.removeEventListener = function () {
	        if (this.chart.isDestroyed) {
	            return;
	        }
	        this.chart.off(Browser.touchMoveEvent, this.mouseMove);
	        this.chart.off('click', this.click);
	        this.chart.off(Browser.touchEndEvent, this.mouseEnd);
	    };
	    /**
	     * To handle mosue move for legend module
	     */
	    Legend.prototype.mouseMove = function (e) {
	        if (this.chart.legendSettings.visible && !this.chart.isTouch) {
	            this.move(e);
	            if (this.chart.highlightModule && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {
	                var legendItemsId = [this.legendID + '_text_', this.legendID + '_shape_marker_',
	                    this.legendID + '_shape_', this.legendID + '_g_'];
	                var targetId = e.target.id;
	                var index = void 0;
	                for (var _i = 0, legendItemsId_1 = legendItemsId; _i < legendItemsId_1.length; _i++) {
	                    var id = legendItemsId_1[_i];
	                    if (targetId.indexOf(id) > -1) {
	                        index = parseInt(targetId.split(id)[1], 10);
	                        this.chart.highlightModule.legendSelection(this.chart, index, e.target, e.type);
	                        break;
	                    }
	                }
	                // this.click(e);
	            }
	        }
	    };
	    /**
	     * To handle mosue end for legend module
	     */
	    Legend.prototype.mouseEnd = function (e) {
	        if (this.chart.legendSettings.visible && this.chart.isTouch) {
	            this.move(e);
	        }
	    };
	    /**
	     * Get the legend options.
	     *
	     * @returns {void}
	     * @private
	     */
	    Legend.prototype.getLegendOptions = function (visibleSeriesCollection, chart) {
	        this.legendCollections = [];
	        var seriesType;
	        var fill;
	        var dashArray;
	        var colors = [];
	        this.isRtlEnable = chart.enableRtl;
	        this.isReverse = !this.isRtlEnable && chart.legendSettings.reverse;
	        if (visibleSeriesCollection.length > 1) {
	            this.legend.mode = 'Series';
	        }
	        for (var _i = 0, visibleSeriesCollection_1 = visibleSeriesCollection; _i < visibleSeriesCollection_1.length; _i++) {
	            var series = visibleSeriesCollection_1[_i];
	            if (this.legend.mode === 'Series') {
	                if (series.category !== 'Indicator') {
	                    seriesType = (chart.chartAreaType === 'PolarRadar') ? series.drawType :
	                        series.type;
	                    dashArray = !series.marker.visible && (seriesType.indexOf('Line') > -1 && seriesType.indexOf('Area') === -1) ? series.dashArray : '';
	                    // To set legend color when use pointColorMapping
	                    fill = (series.pointColorMapping && series.points.length > 0) ?
	                        (series.points[0].interior ? series.points[0].interior : series.interior) : series.interior;
	                    this.legendCollections.push(new LegendOptions(series.name, fill, series.legendShape, (series.category === 'TrendLine' ?
	                        this.chart.series[series.sourceIndex].trendlines[series.index].visible : series.visible), seriesType, series.legendImageUrl ? series.legendImageUrl : (series.type === 'Scatter' && series.marker.shape === 'Image' ?
	                        series.marker.imageUrl : ''), series.marker.shape, series.marker.visible, null, null, dashArray));
	                }
	            }
	            else if (this.legend.mode === 'Point') {
	                var _loop_1 = function (points) {
	                    seriesType = (chart.chartAreaType === 'PolarRadar') ? series.drawType :
	                        series.type;
	                    fill = points.interior ? points.interior : series.interior;
	                    if (this_1.legendCollections.filter(function (i) { return i.text === points.x.toString(); }).length === 0) {
	                        this_1.legendCollections.push(new LegendOptions(points.x.toString(), fill, series.legendShape, (series.category === 'TrendLine' ?
	                            this_1.chart.series[series.sourceIndex].trendlines[series.index].visible : points.visible), seriesType, (series.type === 'Scatter' && series.marker.shape === 'Image') ? series.marker.imageUrl : '', series.marker.shape, series.marker.visible));
	                    }
	                };
	                var this_1 = this;
	                for (var _a = 0, _b = series.points; _a < _b.length; _a++) {
	                    var points = _b[_a];
	                    _loop_1(points);
	                }
	            }
	            else if (this.legend.mode === 'Range') {
	                for (var _c = 0, _d = series.points; _c < _d.length; _c++) {
	                    var points = _d[_c];
	                    seriesType = (chart.chartAreaType === 'PolarRadar') ? series.drawType :
	                        series.type;
	                    fill = points.interior ? points.interior : series.interior;
	                    var legendLabel = 'Others';
	                    if (colors.indexOf(fill) < 0) {
	                        colors.push(fill);
	                        if (chart.rangeColorSettings.length >= 1 && chart.rangeColorSettings[0].colors.length === 1) {
	                            for (var _e = 0, _f = chart.rangeColorSettings; _e < _f.length; _e++) {
	                                var rangeMap = _f[_e];
	                                if (rangeMap.colors[0] === fill) {
	                                    legendLabel = rangeMap.label;
	                                }
	                            }
	                            this.legendCollections.push(new LegendOptions(legendLabel, fill, series.legendShape, (series.category === 'TrendLine' ?
	                                this.chart.series[series.sourceIndex].trendlines[series.index].visible : points.visible), seriesType, (series.type === 'Scatter' && series.marker.shape === 'Image') ? series.marker.imageUrl : '', series.marker.shape, series.marker.visible));
	                        }
	                    }
	                }
	            }
	            else {
	                if (this.legendCollections.length === 0 && chart.rangeColorSettings.length > 0) {
	                    var startLabel = chart.rangeColorSettings[0].start.toString();
	                    var endLabel = chart.rangeColorSettings[chart.rangeColorSettings.length - 1].end.toString();
	                    this.legendCollections.push(new LegendOptions(startLabel, series.interior, 'Rectangle', true, seriesType, '', series.marker.shape, series.marker.visible));
	                    this.legendCollections.push(new LegendOptions(endLabel, series.interior, 'Rectangle', true, seriesType, '', series.marker.shape, series.marker.visible));
	                }
	            }
	        }
	        if (this.isReverse && chart.legendSettings.mode !== 'Gradient') {
	            this.legendCollections.reverse();
	        }
	    };
	    /** @private */
	    Legend.prototype.getLegendBounds = function (availableSize, legendBounds, legend) {
	        this.calculateLegendTitle(legend, legendBounds);
	        this.isTitle = legend.title ? true : false;
	        this.chartRowCount = 1;
	        this.rowHeights = [];
	        this.columnHeights = [];
	        this.pageHeights = [];
	        var padding = legend.padding;
	        var titlePosition = legend.titlePosition;
	        var extraHeight = 0;
	        var legendOption;
	        var extraWidth = 0;
	        var arrowWidth = this.arrowWidth;
	        var arrowHeight = this.arrowHeight;
	        var verticalArrowSpace = this.isVertical && !legend.enablePages ? arrowHeight : 0;
	        var titleSpace = this.isTitle && titlePosition === 'Top' ? this.legendTitleSize.height + this.fivePixel : 0;
	        titleSpace = this.isTitle && this.isVertical && titlePosition !== 'Top' ? this.legendTitleSize.height + this.fivePixel : titleSpace;
	        if (!this.isVertical) {
	            extraHeight = !legend.height ? ((availableSize.height / 100) * 5) : 0;
	        }
	        else {
	            extraWidth = !legend.width ? ((availableSize.width / 100) * 5) : 0;
	        }
	        legendBounds.height += (extraHeight);
	        legendBounds.width += extraWidth;
	        var shapeWidth = legend.shapeWidth;
	        var shapePadding = legend.shapePadding;
	        var maximumWidth = 0;
	        var rowWidth = 0;
	        var legendWidth = 0;
	        var columnHeight = 0;
	        var columnCount = 0;
	        var rowCount = 0;
	        var titlePlusArrowSpace = 0;
	        var legendEventArgs;
	        var render = false;
	        this.maxItemHeight = Math.max(measureText('MeasureText', legend.textStyle, this.chart.themeStyle.legendLabelFont).height, legend.shapeHeight);
	        for (var i = 0; i < this.legendCollections.length; i++) {
	            legendOption = this.legendCollections[i];
	            if (regSub.test(legendOption.text)) {
	                legendOption.text = getUnicodeText(legendOption.text, regSub);
	            }
	            if (regSup.test(legendOption.text)) {
	                legendOption.text = getUnicodeText(legendOption.text, regSup);
	            }
	            legendEventArgs = {
	                fill: legendOption.fill, text: legendOption.text, shape: legendOption.shape,
	                markerShape: legendOption.markerShape, name: legendRender, cancel: false
	            };
	            this.chart.trigger(legendRender, legendEventArgs);
	            legendOption.render = !legendEventArgs.cancel;
	            legendOption.text = legendEventArgs.text;
	            legendOption.fill = legendEventArgs.fill;
	            legendOption.shape = legendEventArgs.shape;
	            legendOption.markerShape = legendEventArgs.markerShape;
	            legendOption.textSize = measureText(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);
	            shapeWidth = legendOption.text ? legend.shapeWidth : 0;
	            shapePadding = legendOption.text ? legend.shapePadding : 0;
	            if (legendOption.render && legendOption.text) {
	                render = true;
	                legendWidth = shapeWidth + shapePadding + (legend.maximumLabelWidth ? legend.maximumLabelWidth : legendOption.textSize.width) + (!this.isVertical ? (i === 0) ? padding : this.itemPadding : padding);
	                rowWidth = rowWidth + legendWidth;
	                if (!legend.enablePages && !this.isVertical) {
	                    titlePlusArrowSpace = this.isTitle && titlePosition !== 'Top' ? this.legendTitleSize.width + this.fivePixel : 0;
	                    titlePlusArrowSpace += arrowWidth;
	                }
	                this.getLegendHeight(legendOption, legend, legendBounds, rowWidth, this.maxItemHeight, padding);
	                if (legendBounds.width < (padding + rowWidth + titlePlusArrowSpace) || this.isVertical) {
	                    maximumWidth = Math.max(maximumWidth, (rowWidth + padding + titlePlusArrowSpace - (this.isVertical ? 0 : legendWidth)));
	                    if (rowCount === 0 && (legendWidth !== rowWidth)) {
	                        rowCount = 1;
	                    }
	                    rowWidth = this.isVertical ? 0 : legendWidth;
	                    rowCount++;
	                    columnCount = 0;
	                    columnHeight = verticalArrowSpace;
	                    //columnHeight = (rowCount * (this.maxItemHeight + padding)) + padding + titleSpace + verticalArrowSpace;
	                }
	                var len = (rowCount > 0 ? (rowCount - 1) : 0);
	                this.rowHeights[len] = Math.max((this.rowHeights[len] ? this.rowHeights[len] : 0), legendOption.textSize.height);
	                // this.maxItemHeight = Math.max(this.maxItemHeight, legendOption.textSize.height);
	                this.columnHeights[columnCount] = (this.columnHeights[columnCount] ? this.columnHeights[columnCount] : 0) + legendOption.textSize.height + (this.isVertical ? (i === 0) ? padding : this.itemPadding : padding);
	                columnCount++;
	            }
	        }
	        columnHeight = Math.max.apply(null, this.columnHeights) + padding + titleSpace;
	        columnHeight = Math.max(columnHeight, (this.maxItemHeight + padding) + padding + titleSpace);
	        this.isPaging = legendBounds.height < columnHeight;
	        if (this.isPaging && !legend.enablePages) {
	            if (this.isVertical) {
	                // eslint-disable-next-line no-self-assign
	                columnHeight = columnHeight;
	            }
	            else {
	                columnHeight = (this.maxItemHeight + padding) + padding + (titlePosition === 'Top' ? titleSpace : 0);
	            }
	        }
	        this.totalPages = rowCount;
	        if (!this.isPaging && !this.isVertical) {
	            rowWidth += this.isTitle && titlePosition !== 'Top' ? (this.fivePixel + this.legendTitleSize.width + this.fivePixel) : 0;
	        }
	        if (render) {
	            this.setBounds(Math.max((rowWidth + padding), maximumWidth), columnHeight, legend, legendBounds);
	        }
	        else {
	            this.setBounds(0, 0, legend, legendBounds);
	        }
	    };
	    /** @private */
	    Legend.prototype.getLegendHeight = function (legendOption, legend, legendBounds, rowWidth, legendHeight, padding) {
	        var legendWidth = legendOption.textSize.width;
	        var textPadding = legend.shapePadding + (padding * 2) + legend.shapeWidth;
	        switch (legend.textWrap) {
	            case 'Wrap':
	            case 'AnyWhere':
	                if (legendWidth > legend.maximumLabelWidth || legendWidth + rowWidth > legendBounds.width) {
	                    legendOption.textCollection = textWrap(legendOption.text, (legend.maximumLabelWidth ? Math.min(legend.maximumLabelWidth, (legendBounds.width - textPadding)) : (legendBounds.width - textPadding)), legend.textStyle, null, null, this.chart.themeStyle.legendLabelFont);
	                }
	                else {
	                    legendOption.textCollection.push(legendOption.text);
	                }
	                legendOption.textSize.height = (legendHeight * legendOption.textCollection.length);
	                break;
	        }
	    };
	    /** @private */
	    Legend.prototype.getRenderPoint = function (legendOption, start, textPadding, prevLegend, rect, count, firstLegend, rowCount) {
	        var padding = this.legend.padding;
	        var textWidth = textPadding + (this.legend.maximumLabelWidth ? this.legend.maximumLabelWidth : prevLegend.textSize.width);
	        var previousBound = prevLegend.location.x + ((!this.isRtlEnable) ? textWidth : -textWidth);
	        if (this.isWithinBounds(previousBound, (this.legend.maximumLabelWidth ? this.legend.maximumLabelWidth : legendOption.textSize.width) + textPadding - this.itemPadding, rect) || this.isVertical) {
	            legendOption.location.x = start.x;
	            if (count !== firstLegend)
	                this.chartRowCount++;
	            legendOption.location.y = (count === firstLegend) ? prevLegend.location.y :
	                prevLegend.location.y + (this.isVertical ? prevLegend.textSize.height : this.rowHeights[(this.chartRowCount - 2)]) + (this.isVertical ? this.itemPadding : padding);
	        }
	        else {
	            legendOption.location.x = (count === firstLegend) ? prevLegend.location.x : previousBound;
	            legendOption.location.y = prevLegend.location.y;
	        }
	        var availwidth = (!this.isRtlEnable) ? (this.legendBounds.x + this.legendBounds.width) - (legendOption.location.x +
	            textPadding - this.itemPadding - this.legend.shapeWidth / 2) : (legendOption.location.x - textPadding + this.itemPadding + (this.legend.shapeWidth / 2)) - this.legendBounds.x;
	        if (!this.isVertical && this.isPaging && !this.legend.enablePages) {
	            availwidth = this.legendBounds.width - legendOption.location.x - this.fivePixel;
	        }
	        availwidth = this.legend.maximumLabelWidth ? Math.min(this.legend.maximumLabelWidth, availwidth) : availwidth;
	        if (this.legend.textOverflow === 'Ellipsis' && this.legend.textWrap === 'Normal') {
	            legendOption.text = textTrim(+availwidth.toFixed(4), legendOption.text, this.legend.textStyle, this.chart.themeStyle.legendLabelFont);
	        }
	    };
	    Legend.prototype.isWithinBounds = function (previousBound, textWidth, rect) {
	        if (!this.isRtlEnable) {
	            return (previousBound + textWidth) > (rect.x + rect.width + (this.legend.shapeWidth / 2));
	        }
	        else {
	            return (previousBound - textWidth) < (rect.x - (this.legend.shapeWidth / 2));
	        }
	    };
	    /** @private */
	    Legend.prototype.LegendClick = function (index, event) {
	        var chart = this.chart;
	        var seriesIndex = chart.legendSettings.mode === 'Series' ? index : 0;
	        var legendIndex = !this.isReverse ? index : (this.legendCollections.length - 1) - index;
	        var series = chart.visibleSeries[seriesIndex];
	        var legend = this.legendCollections[legendIndex];
	        var changeDetection = 'isProtectedOnChange';
	        if (chart.legendSettings.mode === 'Series') {
	            var legendClickArgs = {
	                legendText: legend.text, legendShape: legend.shape,
	                chart: chart.isBlazor ? {} : chart, series: series, points: series.points, name: legendClick, cancel: false
	            };
	            this.chart.trigger(legendClick, legendClickArgs);
	            series.legendShape = legendClickArgs.legendShape;
	            if (!legendClickArgs.cancel) {
	                if (series.fill !== null) {
	                    chart.visibleSeries[index].interior = series.fill;
	                }
	                if (chart.legendSettings.toggleVisibility) {
	                    series.chart[changeDetection] = true;
	                    if (series.category === 'TrendLine') {
	                        if (!chart.series[series.sourceIndex].trendlines[series.index].visible && chart.series[series.sourceIndex].visible) {
	                            chart.series[series.sourceIndex].trendlines[series.index].visible = true;
	                        }
	                        else {
	                            chart.series[series.sourceIndex].trendlines[series.index].visible = false;
	                        }
	                    }
	                    else {
	                        this.changeSeriesVisiblity(series, series.visible);
	                    }
	                    legend.visible = series.category === 'TrendLine' ? chart.series[series.sourceIndex].trendlines[series.index].visible :
	                        (series.visible);
	                    this.refreshLegendToggle(chart, series);
	                }
	                else if (chart.highlightModule) {
	                    chart.highlightModule.legendSelection(chart, index, event.target, event.type);
	                }
	                else if (chart.selectionModule) {
	                    chart.selectionModule.legendSelection(chart, index, event.target, event.type);
	                }
	                series.chart[changeDetection] = false;
	            }
	        }
	        else if (chart.legendSettings.mode === 'Point') {
	            var point = series.points[index];
	            var legendClickArgs = {
	                legendText: legend.text, legendShape: legend.shape,
	                chart: chart.isBlazor ? {} : chart, series: series, points: [point], name: legendClick, cancel: false
	            };
	            this.chart.trigger(legendClick, legendClickArgs);
	            if (chart.legendSettings.toggleVisibility && !legendClickArgs.cancel) {
	                point.visible = !point.visible;
	                var legendOption = this.legendCollections[index];
	                legendOption.visible = point.visible;
	                this.refreshLegendToggle(chart, series);
	            }
	        }
	        else if (chart.legendSettings.mode === 'Range') {
	            var points = [];
	            var legendOption = this.legendCollections[index];
	            for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
	                var point = _a[_i];
	                if (legendOption.fill === (point.interior || series.interior)) {
	                    points.push(point);
	                }
	            }
	            var legendClickArgs = {
	                legendText: legend.text, legendShape: legend.shape,
	                chart: chart.isBlazor ? {} : chart, series: series, points: points, name: legendClick, cancel: false
	            };
	            this.chart.trigger(legendClick, legendClickArgs);
	            if (chart.legendSettings.toggleVisibility && !legendClickArgs.cancel) {
	                legendOption.visible = !legendOption.visible;
	                for (var _b = 0, points_1 = points; _b < points_1.length; _b++) {
	                    var point = points_1[_b];
	                    point.visible = !point.visible;
	                }
	                this.refreshLegendToggle(chart, series);
	            }
	        }
	    };
	    Legend.prototype.refreshLegendToggle = function (chart, series) {
	        var selectedDataIndexes = [];
	        if (chart.selectionModule) {
	            selectedDataIndexes = extend([], chart.selectionModule.selectedDataIndexes, null, true);
	        }
	        if ((chart.svgObject.childNodes.length > 0) && !chart.enableAnimation && !chart.enableCanvas) {
	            while (chart.svgObject.lastChild) {
	                chart.svgObject.removeChild(chart.svgObject.lastChild);
	            }
	            remove(chart.svgObject);
	        }
	        chart.animateSeries = false;
	        chart.redraw = chart.enableAnimation;
	        chart.rotatedDataLabelCollections = [];
	        removeElement(getElement$1(chart.element.id + '_Secondary_Element').querySelectorAll('.ejSVGTooltip')[0]);
	        blazorTemplatesReset(chart);
	        this.redrawSeriesElements(series, chart);
	        chart.removeSvg();
	        chart.refreshAxis();
	        series.refreshAxisLabel();
	        this.refreshSeries(chart.visibleSeries);
	        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {
	            var series_1 = _a[_i];
	            if (!isNullOrUndefined(series_1)) {
	                chart.markerRender.removeHighlightedMarker(series_1, null, true);
	            }
	        }
	        chart.refreshBound();
	        chart.trigger('loaded', { chart: chart });
	        if (selectedDataIndexes.length > 0) {
	            chart.selectionModule.selectedDataIndexes = selectedDataIndexes;
	            chart.selectionModule.redrawSelection(chart, chart.selectionMode);
	        }
	        if (chart.highlightModule && chart.highlightMode !== 'None' || chart.legendSettings.enableHighlight) {
	            chart.highlightModule.redrawSelection(chart, chart.highlightMode);
	        }
	        chart.redraw = false;
	    };
	    Legend.prototype.changeSeriesVisiblity = function (series, visibility) {
	        series.visible = !visibility;
	        if (this.isSecondaryAxis(series.xAxis)) {
	            series.xAxis.internalVisibility = series.xAxis.series.some(function (value) { return (value.visible); });
	        }
	        if (this.isSecondaryAxis(series.yAxis) || (series.category == 'Pareto' && series.type == 'Line')) {
	            series.yAxis.internalVisibility = series.yAxis.series.some(function (value) { return (value.visible); });
	        }
	        if (series.trendlines.length && series.visible) {
	            series.trendlines.forEach(function (trendline) {
	                trendline.visible = true;
	            });
	        }
	    };
	    Legend.prototype.isSecondaryAxis = function (axis) {
	        return (this.chart.axes.indexOf(axis) > -1);
	    };
	    Legend.prototype.redrawSeriesElements = function (series, chart) {
	        if (!chart.redraw) {
	            return null;
	        }
	        removeElement(chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) +
	            '_DataLabelCollections');
	    };
	    Legend.prototype.refreshSeries = function (seriesCollection) {
	        for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {
	            var series = seriesCollection_1[_i];
	            if (series.type.indexOf('Spline') > -1) {
	                var isArea = (series.type.indexOf('Area') > -1 || series.drawType.indexOf('Area') > -1);
	                var isRange = series.type.indexOf('Range') > -1;
	                this.chart['spline' + (isArea ? isRange ? 'RangeArea' : 'Area' : '') + 'SeriesModule'].findSplinePoint(series);
	            }
	            series.position = undefined;
	        }
	    };
	    /**
	     * To show the tooltip for the trimmed text in legend.
	     *
	     * @returns {void}
	     */
	    Legend.prototype.click = function (event) {
	        var _this = this;
	        if (!this.chart.legendSettings.visible) {
	            return;
	        }
	        var pageX = this.chart.mouseX;
	        var pageY = this.chart.mouseY;
	        var legendRegion = [];
	        var targetId = event.target.id.indexOf('_chart_legend_g_') > -1 ?
	            event.target.firstChild['id'] : event.target.id;
	        var legendItemsId = [this.legendID + '_text_', this.legendID + '_shape_marker_',
	            this.legendID + '_shape_'];
	        var seriesIndex;
	        for (var _i = 0, legendItemsId_2 = legendItemsId; _i < legendItemsId_2.length; _i++) {
	            var id = legendItemsId_2[_i];
	            if (targetId.indexOf(id) > -1) {
	                seriesIndex = parseInt(targetId.split(id)[1], 10);
	                this.LegendClick(seriesIndex, event);
	                break;
	            }
	        }
	        if (targetId.indexOf(this.legendID + '_pageup') > -1) {
	            this.changePage(event, true);
	        }
	        else if (targetId.indexOf(this.legendID + '_pagedown') > -1) {
	            this.changePage(event, false);
	        }
	        if (this.chart.enableCanvas && this.pagingRegions.length) {
	            this.checkWithinBounds(pageX, pageY);
	        }
	        legendRegion = this.legendRegions.filter(function (region) {
	            return (withInBounds(pageX, (pageY + (_this.isPaging ? (_this.currentPageNumber - 1) * _this.translatePage(_this.chart.enableCanvas, null, 1, 2) : 0)), region.rect));
	        });
	        if (legendRegion.length && this.chart.enableCanvas) {
	            this.LegendClick(legendRegion[0].index, event);
	        }
	    };
	    /**
	     * To check click position is within legend bounds
	     */
	    Legend.prototype.checkWithinBounds = function (pageX, pageY) {
	        var cRender = this.chart.renderer;
	        var bounds = this.legendBounds;
	        var borderWidth = this.chart.legendSettings.border.width;
	        var canvasRect = new Rect(bounds.x, bounds.y, bounds.width, bounds.height);
	        canvasRect.x = canvasRect.x - borderWidth / 2;
	        canvasRect.y = canvasRect.y - borderWidth / 2;
	        canvasRect.width = canvasRect.width + borderWidth;
	        canvasRect.height = canvasRect.height + borderWidth;
	        if (withInBounds(pageX, pageY, this.pagingRegions[0])) {
	            // pageDown calculations are performing here
	            if (!this.isRtlEnable) {
	                this.canvasPageDown(cRender, canvasRect, bounds);
	            }
	            else {
	                this.canvasPageUp(cRender, canvasRect, bounds);
	            }
	            return null;
	        }
	        if (withInBounds(pageX, pageY, this.pagingRegions[1])) {
	            // pageUp calculations are performing here
	            if (!this.isRtlEnable) {
	                this.canvasPageUp(cRender, canvasRect, bounds);
	            }
	            else {
	                this.canvasPageDown(cRender, canvasRect, bounds);
	            }
	            return null;
	        }
	    };
	    Legend.prototype.canvasPageDown = function (cRender, canvasRect, bounds) {
	        if (--this.currentPageNumber > 0) {
	            this.legendRegions = [];
	            cRender.clearRect(canvasRect);
	            cRender.canvasClip(new RectOption('legendClipPath', 'transparent', { width: 0, color: '' }, null, canvasRect));
	            this.renderLegend(this.chart, this.legend, bounds);
	            cRender.canvasRestore();
	        }
	        else {
	            ++this.currentPageNumber;
	        }
	    };
	    Legend.prototype.canvasPageUp = function (cRender, canvasRect, bounds) {
	        if (++this.currentPageNumber > 0 && this.currentPageNumber <= this.totalNoOfPages) {
	            this.legendRegions = [];
	            cRender.clearRect(canvasRect);
	            cRender.canvasClip(new RectOption('legendClipPath', 'transpaent', { width: 0, color: '' }, null, canvasRect));
	            this.renderLegend(this.chart, this.legend, bounds);
	            cRender.canvasRestore();
	        }
	        else {
	            --this.currentPageNumber;
	        }
	    };
	    /**
	     * Get module name
	     */
	    Legend.prototype.getModuleName = function () {
	        return 'Legend';
	    };
	    /**
	     * To destroy the Legend.
	     *
	     * @returns {void}
	     * @private
	     */
	    Legend.prototype.destroy = function () {
	        this.removeEventListener();
	    };
	    return Legend;
	}(BaseLegend));

	/* src\time.svelte generated by Svelte v4.2.1 */

	const { console: console_1$2 } = globals;
	const file$3 = "src\\time.svelte";

	function create_fragment$3(ctx) {
		let div1;
		let h1;
		let t1;
		let div0;

		const block = {
			c: function create() {
				div1 = element$1("div");
				h1 = element$1("h1");
				h1.textContent = "Time to fill";
				t1 = space();
				div0 = element$1("div");
				attr_dev(h1, "class", "h1 svelte-gcz5op");
				add_location(h1, file$3, 191, 4, 6493);
				attr_dev(div0, "id", "container2");
				add_location(div0, file$3, 192, 0, 6527);
				attr_dev(div1, "class", "Container1 svelte-gcz5op");
				add_location(div1, file$3, 190, 0, 6463);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, h1);
				append_dev(div1, t1);
				append_dev(div1, div0);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$3.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$3($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Time', slots, []);
		Chart.Inject(ColumnSeries, SplineSeries, Category, DateTime, Tooltip, Legend);
		let chartData2 = [];
		let splineData = [];
		const currentDate = new Date();
		const currentYear = currentDate.getFullYear();
		const monthNames = Array.from({ length: 12 }, (_, i) => `${currentYear} ${new Date(currentYear, i, 1).toLocaleString('en-US', { month: 'short' })}`);
		let startDate = '';
		let endDate = '';

		function getDatesFromLocalStorage() {
			const storedStartDate = localStorage.getItem('startDate');
			const storedEndDate = localStorage.getItem('endDate');

			if (storedStartDate && storedEndDate) {
				startDate = storedStartDate;
				endDate = storedEndDate;
			}
		}

		// Subscribe to the dateStore
		dateStore.subscribe(value => {
			startDate = value.startDate;
			endDate = value.endDate;
			fetchData(startDate, endDate); // Fetch data whenever the date changes
		});

		async function fetchData(startDate, endDate) {
			try {
				const apiUrl = "https://api.recruitly.io/api/dashboard/ats/data/placementmonthlymetrics";
				const apiKey = "TEST45684CB2A93F41FC40869DC739BD4D126D77";
				const response = await fetch(`${apiUrl}?start=${startDate}&end=${endDate}&apiKey=${apiKey}`);

				if (response.ok) {
					const jsonData = await response.json();
					console.log(jsonData);
					const dataMap = new Map(jsonData.map(item => [monthNames[item.month - 1], item]));

					chartData2 = monthNames.map(month => ({
						x: month,
						y: dataMap.has(month) ? dataMap.get(month).placements : 0
					}));

					splineData = monthNames.map(month => ({
						x: month,
						y: dataMap.has(month) ? dataMap.get(month).days : 0
					}));

					updateChart();
				} else {
					console.error('Failed to fetch data from the API');
				}
			} catch(error) {
				console.error('An error occurred:', error);
			}
		}

		function updateChart() {
			const chart = new Chart({
					primaryXAxis: {
						valueType: 'Category',
						majorGridLines: { width: 0 },
						labelStyle: { size: '17px', fontWeight: "normal" }
					},
					primaryYAxis: {
						edgeLabelPlacement: 'Shift',
						majorTickLines: { width: 0 },
						minorTickLines: { width: 0 },
						lineStyle: { width: 0 },
						title: "Placements",
						titleStyle: {
							fontFamily: "'Segoe UI', 'Helvetica Neue', 'Trebuchet MS', Verdana, sans-serif",
							fontWeight: '360',
							color: "#767676;",
							size: '18px'
						},
						labelStyle: { size: '15px', fontWeight: "normal" }
					},
					width: '1390px',
					height: '400px',
					series: [
						{
							type: 'Column',
							dataSource: chartData2,
							xName: 'x',
							yName: 'y',
							fill: 'DodgerBlue',
							name: 'Placements',
							columnWidth: 0.5
						},
						{
							type: 'Spline',
							dataSource: splineData,
							xName: 'x',
							yName: 'y',
							yAxisName: 'splineAxis',
							width: 2,
							fill: 'blue',
							marker: { visible: true, width: 10, height: 10 },
							name: 'Avg.Days to fill'
						}
					],
					axes: [
						{
							name: 'splineAxis',
							opposedPosition: true,
							title: 'Total time to fill days',
							titleStyle: {
								fontFamily: "'Segoe UI', 'Helvetica Neue', 'Trebuchet MS', Verdana, sans-serif",
								fontWeight: '360',
								color: "#767676;",
								size: '18px'
							},
							labelStyle: { size: '15px', fontWeight: "normal" }
						}
					],
					tooltip: {
						enable: true,
						shared: true,
						format: ' ${series.name} :${point.y}',
						fill: 'white', // Change the background color of the tooltip
						textStyle: {
							color: 'black', // Change the text (content) color of the tooltip
							fontWeight: "bold"
						},
						border: {
							width: 4, // Set the border width
							color: 'whitesmoke', // Set the border color
							
						}
					},
					legendSettings: {
						visible: true,
						//Legend position as top
						position: 'Bottom'
					}
				});

			chart.appendTo('#container2');
		}

		onMount(() => {
			getDatesFromLocalStorage(); // Try to get dates from local storage
			fetchData(startDate, endDate); // Fetch data on component mount
		});

		afterUpdate(() => {
			fetchData(startDate, endDate); // Fetch data after updates
			updateChart(); // Update the chart immediately

			// Store the dates in local storage for future use
			localStorage.setItem('startDate', startDate);

			localStorage.setItem('endDate', endDate);
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<Time> was created with unknown prop '${key}'`);
		});

		$$self.$capture_state = () => ({
			onMount,
			afterUpdate,
			dateStore,
			Chart,
			ColumnSeries,
			SplineSeries,
			Category,
			DateTime,
			Tooltip,
			Legend,
			Browser,
			chartData2,
			splineData,
			currentDate,
			currentYear,
			monthNames,
			startDate,
			endDate,
			getDatesFromLocalStorage,
			fetchData,
			updateChart
		});

		$$self.$inject_state = $$props => {
			if ('chartData2' in $$props) chartData2 = $$props.chartData2;
			if ('splineData' in $$props) splineData = $$props.splineData;
			if ('startDate' in $$props) startDate = $$props.startDate;
			if ('endDate' in $$props) endDate = $$props.endDate;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [];
	}

	class Time extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Time",
				options,
				id: create_fragment$3.name
			});
		}
	}

	/* src\placement.svelte generated by Svelte v4.2.1 */

	const { console: console_1$1 } = globals;
	const file$2 = "src\\placement.svelte";

	function create_fragment$2(ctx) {
		let div1;
		let h1;
		let t1;
		let div0;

		const block = {
			c: function create() {
				div1 = element$1("div");
				h1 = element$1("h1");
				h1.textContent = "Placement Value by User";
				t1 = space();
				div0 = element$1("div");
				attr_dev(h1, "class", "h1 svelte-127769");
				add_location(h1, file$2, 196, 4, 7299);
				attr_dev(div0, "id", "container3");
				add_location(div0, file$2, 197, 0, 7344);
				attr_dev(div1, "class", "container1 svelte-127769");
				add_location(div1, file$2, 195, 0, 7269);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, h1);
				append_dev(div1, t1);
				append_dev(div1, div0);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$2.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$2($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Placement', slots, []);
		Chart.Inject(StackingColumnSeries, Category, DataLabel, Tooltip, Legend, Highlight);
		let chartData = []; // Initialize with an empty array
		let startDate = '';
		let endDate = '';

		// Function to check if local storage has date information
		function getDatesFromLocalStorage() {
			const storedStartDate = localStorage.getItem('startDate');
			const storedEndDate = localStorage.getItem('endDate');

			if (storedStartDate && storedEndDate) {
				startDate = storedStartDate;
				endDate = storedEndDate;
			}
		}

		// Subscribe to the dateStore
		dateStore.subscribe(value => {
			startDate = value.startDate;
			endDate = value.endDate;
			fetchData(startDate, endDate); // Fetch data whenever the date changes
		});

		async function fetchData(startDate, endDate) {
			try {
				const apiUrl = "https://api.recruitly.io/api/dashboard/ats/data/placementmonthlyusermetrics";
				const apiKey = "TEST45684CB2A93F41FC40869DC739BD4D126D77";
				const response = await fetch(`${apiUrl}?start=${startDate}&end=${endDate}&apiKey=${apiKey}`);

				if (response.ok) {
					const jsonData = await response.json();
					console.log(jsonData);

					// Create an array of unique month names dynamically
					const monthNames = [...new Set(jsonData.map(item => item.monthLabel))];

					monthNames.sort((a, b) => {
						const [aMonth, aYear] = a.split('/');
						const [bMonth, bYear] = b.split('/');

						if (+aYear !== +bYear) {
							return +aYear - +bYear;
						} else {
							return +aMonth - +bMonth;
						}
					});

					// Transform API data into the format suitable for the chart
					chartData = monthNames.map(monthName => {
						const monthData = jsonData.filter(item => item.monthLabel === monthName);

						return {
							x: monthName,
							'Andy Barnes': monthData.reduce((total, item) => total + item['Andy Barnes'], 0) / 1000000,
							'Gary Williams': monthData.reduce((total, item) => total + item['Gary Williams'], 0) / 1000000,
							'Bob Shaw': monthData.reduce((total, item) => total + item['Bob Shaw'], 0) / 1000000
						};
					});

					// Refresh the chart with the updated data
					updateChart();
				} else {
					console.error('Failed to fetch data from the API. HTTP status:', response.status);
				}
			} catch(error) {
				console.error('An error occurred while fetching data:', error);
			}
		}

		// Function to create or update the chart
		function updateChart() {
			chartData = chartData.map(item => {
				const dateParts = item.x.split('/');
				const month = parseInt(dateParts[0]);
				const year = parseInt(dateParts[1]);

				// Convert the month number to a three-letter month abbreviation (e.g., Jan, Feb)
				const monthAbbreviation = new Date(year, month - 1, 1).toLocaleString('default', { month: 'short' });

				return {
					x: `${monthAbbreviation} ${year}`,
					'Andy Barnes': item['Andy Barnes'],
					'Gary Williams': item['Gary Williams'],
					'Bob Shaw': item['Bob Shaw']
				};
			});

			// Create and append the chart with the updated data source
			const chart = new Chart({
					primaryXAxis: {
						valueType: 'Category',
						majorGridLines: { width: 0 },
						labelStyle: { size: '15px', fontWeight: "normal" }
					},
					primaryYAxis: {
						edgeLabelPlacement: 'Shift',
						majorTickLines: { width: 0 },
						minorTickLines: { width: 0 },
						lineStyle: { width: 0 },
						labelFormat: '{value}M',
						labelPlacement: 'OnTicks',
						minimum: 0,
						maximum: 5,
						interval: 1,
						title: 'Placement value',
						titleStyle: {
							fontFamily: "'Segoe UI', 'Helvetica Neue', 'Trebuchet MS', Verdana, sans-serif",
							fontWeight: 'Normal',
							color: "#767676;",
							size: '18px'
						},
						labelStyle: { size: '15px', fontWeight: "normal" }
					},
					width: '1350px', // Set the width of the chart
					height: '400px', // Set the height of the chart
					series: [
						{
							type: 'StackingColumn',
							dataSource: chartData,
							xName: 'x',
							width: 2,
							yName: 'Bob Shaw',
							columnSpacing: 0.2,
							name: 'Bob Shaw',
							fill: 'DodgerBlue',
							columnWidth: 0.5
						},
						{
							type: 'StackingColumn',
							dataSource: chartData,
							xName: 'x',
							width: 2,
							yName: 'Andy Barnes',
							columnSpacing: 0.2,
							name: 'Andy Barnes',
							fill: 'Tomato',
							columnWidth: 0.5
						},
						{
							type: 'StackingColumn',
							dataSource: chartData,
							xName: 'x',
							width: 2,
							yName: 'Gary Williams',
							columnSpacing: 0.2,
							name: 'Gary Williams',
							fill: 'MediumSeaGreen',
							columnWidth: 0.5
						}
					],
					tooltip: {
						enable: true,
						format: 'GDP ${point.y}', // Customize tooltip format
						template: '#Female-Material'
					},
					legendSettings: { enableHighlight: true }
				});

			chart.appendTo('#container3');
		}

		onMount(() => {
			getDatesFromLocalStorage(); // Try to get dates from local storage
			fetchData(startDate, endDate); // Fetch data on component mount
		});

		afterUpdate(() => {
			fetchData(startDate, endDate); // Fetch data after updates
			updateChart(); // Update the chart immediately

			// Store the dates in local storage for future use
			localStorage.setItem('startDate', startDate);

			localStorage.setItem('endDate', endDate);
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Placement> was created with unknown prop '${key}'`);
		});

		$$self.$capture_state = () => ({
			onMount,
			afterUpdate,
			Chart,
			StackingColumnSeries,
			Category,
			DataLabel,
			Tooltip,
			Legend,
			Highlight,
			Browser,
			chartData,
			dateStore,
			startDate,
			endDate,
			getDatesFromLocalStorage,
			fetchData,
			updateChart
		});

		$$self.$inject_state = $$props => {
			if ('chartData' in $$props) chartData = $$props.chartData;
			if ('startDate' in $$props) startDate = $$props.startDate;
			if ('endDate' in $$props) endDate = $$props.endDate;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [];
	}

	class Placement extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Placement",
				options,
				id: create_fragment$2.name
			});
		}
	}

	/* src\rejectedreasons.svelte generated by Svelte v4.2.1 */

	const { console: console_1 } = globals;
	const file$1 = "src\\rejectedreasons.svelte";

	function create_fragment$1(ctx) {
		let div1;
		let h1;
		let t1;
		let div0;

		const block = {
			c: function create() {
				div1 = element$1("div");
				h1 = element$1("h1");
				h1.textContent = "Reject Reasons";
				t1 = space();
				div0 = element$1("div");
				attr_dev(h1, "class", "h1 svelte-1k96ako");
				add_location(h1, file$1, 137, 2, 3844);
				attr_dev(div0, "id", "container");
				attr_dev(div0, "class", "svelte-1k96ako");
				add_location(div0, file$1, 138, 0, 3880);
				attr_dev(div1, "class", "container1 svelte-1k96ako");
				add_location(div1, file$1, 136, 0, 3816);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, h1);
				append_dev(div1, t1);
				append_dev(div1, div0);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Rejectedreasons', slots, []);
		Chart.Inject(BarSeries, Category, DataLabel);
		let chartData = [];
		let chart = null; // Initialize chart with null
		let startDate = '';
		let endDate = '';

		// Function to check if local storage has date information
		function getDatesFromLocalStorage() {
			const storedStartDate = localStorage.getItem('startDate');
			const storedEndDate = localStorage.getItem('endDate');

			if (storedStartDate && storedEndDate) {
				startDate = storedStartDate;
				endDate = storedEndDate;
			}
		}

		// Subscribe to the dateStore
		dateStore.subscribe(value => {
			startDate = value.startDate;
			endDate = value.endDate;
			fetchData(startDate, endDate); // Fetch data whenever the date changes
		});

		async function fetchData(startDate, endDate) {
			try {
				const apiUrl = "https://api.recruitly.io/api/dashboard/ats/data/rejectreasons";
				const apiKey = "TEST45684CB2A93F41FC40869DC739BD4D126D77";
				const response = await fetch(`${apiUrl}?start=${startDate}&end=${endDate}&apiKey=${apiKey}`);

				if (response.ok) {
					const jsonData = await response.json();
					console.log("Data fetched:", jsonData);

					chartData = jsonData.slice(0, 6).map((item, index) => ({
						x: item.reason || 'Unknown',
						y: item.count
					}));

					chartData.sort((a, b) => a.y - b.y);
					updateChart();
				} else {
					const errorText = await response.text();
					console.error("Failed to fetch data. Error:", errorText);
				}
			} catch(error) {
				console.error("Error:", error);
			}
		}

		function updateChart() {
			chartData.map(item => ({ ...item }));

			if (chart) {
				chart.destroy();
			}

			chart = new Chart({
					primaryXAxis: {
						valueType: 'Category',
						majorGridLines: { width: 0 },
						labelStyle: {
							size: '1rem',
							fontWeight: "510",
							fontFamily: 'sans-serif'
						}
					},
					primaryYAxis: {
						majorTickLines: { width: 0 },
						minorTickLines: { width: 0 },
						lineStyle: { width: 0 },
						interval: 5,
						labelStyle: {
							size: '1rem',
							fontWeight: "400",
							fontFamily: 'sans-serif'
						}
					},
					width: '1350px',
					height: "390px",
					series: [
						{
							type: 'Bar',
							dataSource: chartData,
							xName: 'x',
							width: 2,
							yName: 'y',
							columnSpacing: 0.1,
							animation: { enable: true, duration: 1000, delay: 200 },
							cornerRadius: { topRight: 5, bottomRight: 5 },
							marker: {
								dataLabel: {
									visible: true,
									position: "Bottom",
									font: {
										fontWeight: 'bold',
										color: 'white',
										size: '17px'
									}
								}
							}
						}
					]
				});

			chart.appendTo('#container');
		}

		onMount(() => {
			getDatesFromLocalStorage(); // Try to get dates from local storage
			fetchData(startDate, endDate); // Fetch data on component mount
		});

		afterUpdate(() => {
			fetchData(startDate, endDate); // Fetch data after updates
			updateChart(); // Update the chart immediately

			// Store the dates in local storage for future use
			localStorage.setItem('startDate', startDate);

			localStorage.setItem('endDate', endDate);
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Rejectedreasons> was created with unknown prop '${key}'`);
		});

		$$self.$capture_state = () => ({
			onMount,
			afterUpdate,
			dateStore,
			Chart,
			BarSeries,
			Category,
			DataLabel,
			chartData,
			chart,
			startDate,
			endDate,
			getDatesFromLocalStorage,
			fetchData,
			updateChart
		});

		$$self.$inject_state = $$props => {
			if ('chartData' in $$props) chartData = $$props.chartData;
			if ('chart' in $$props) chart = $$props.chart;
			if ('startDate' in $$props) startDate = $$props.startDate;
			if ('endDate' in $$props) endDate = $$props.endDate;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [];
	}

	class Rejectedreasons extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Rejectedreasons",
				options,
				id: create_fragment$1.name
			});
		}
	}

	/* src\App.svelte generated by Svelte v4.2.1 */
	const file = "src\\App.svelte";

	function create_fragment(ctx) {
		let div;
		let calendar;
		let t0;
		let metric;
		let t1;
		let time;
		let t2;
		let placement;
		let t3;
		let reject;
		let current;
		calendar = new Calendar({ $$inline: true });
		metric = new Metric({ $$inline: true });
		time = new Time({ $$inline: true });
		placement = new Placement({ $$inline: true });
		reject = new Rejectedreasons({ $$inline: true });

		const block = {
			c: function create() {
				div = element$1("div");
				create_component(calendar.$$.fragment);
				t0 = space();
				create_component(metric.$$.fragment);
				t1 = space();
				create_component(time.$$.fragment);
				t2 = space();
				create_component(placement.$$.fragment);
				t3 = space();
				create_component(reject.$$.fragment);
				attr_dev(div, "class", "main-container svelte-ps73m");
				add_location(div, file, 10, 2, 250);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				mount_component(calendar, div, null);
				append_dev(div, t0);
				mount_component(metric, div, null);
				append_dev(div, t1);
				mount_component(time, div, null);
				append_dev(div, t2);
				mount_component(placement, div, null);
				append_dev(div, t3);
				mount_component(reject, div, null);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(calendar.$$.fragment, local);
				transition_in(metric.$$.fragment, local);
				transition_in(time.$$.fragment, local);
				transition_in(placement.$$.fragment, local);
				transition_in(reject.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(calendar.$$.fragment, local);
				transition_out(metric.$$.fragment, local);
				transition_out(time.$$.fragment, local);
				transition_out(placement.$$.fragment, local);
				transition_out(reject.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(calendar);
				destroy_component(metric);
				destroy_component(time);
				destroy_component(placement);
				destroy_component(reject);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('App', slots, []);
		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
		});

		$$self.$capture_state = () => ({
			Calendar,
			Metric,
			Time,
			Placement,
			Reject: Rejectedreasons
		});

		return [];
	}

	class App extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance, create_fragment, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "App",
				options,
				id: create_fragment.name
			});
		}
	}

	const app = new App({
	  target: document.body,
	  props: {
	    name: "world",
	  },
	});

	return app;

})();
//# sourceMappingURL=bundle.js.map
